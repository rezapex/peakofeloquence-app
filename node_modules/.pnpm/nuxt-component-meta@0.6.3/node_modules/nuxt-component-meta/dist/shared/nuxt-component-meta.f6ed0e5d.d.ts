import * as typescript from 'typescript';
import * as vue_component_meta from 'vue-component-meta';
import { ComponentMeta, MetaCheckerOptions } from 'vue-component-meta';
import { Component, ComponentsDir, ComponentsOptions } from '@nuxt/schema';

type ComponentData = Omit<Component, 'filePath' | 'shortPath'> & { 
  meta: ComponentMeta
  fullPath?: string
  filePath?: string,
  shortPath?: string,
}

type NuxtComponentMeta = Record<string, ComponentData>

interface TransformersHookData {
  meta: NuxtComponentMeta
  path: string
  source: string
}

type ExtendHookData = ComponentMetaParserOptions

interface ModuleOptions {
    /**
     * Directory where files metas are outputed upon parsing.
     *
     * It will create `component-meta.d.ts` and `component-meta.mjs` files.
     */
    outputDir?: string;
    /**
     * Nuxt root directory.
     *
     * Should be auto-filled by the module/process.
     */
    rootDir?: string;
    /**
     * Debug level: true, false or 2.
     *
     * 2 will log every timings for components parsing.
     */
    debug?: boolean | 2;
    /**
     * Components directories pushed in the include list.
     */
    componentDirs: (string | ComponentsDir)[];
    /**
     * Components options pushed in include list.
     */
    components?: ComponentsOptions[];
    /**
     * Component paths and/or path regexps to be excluded.
     */
    exclude?: (string | RegExp | ((component: any) => boolean))[];
    /**
     * vue-component-meta checker options.
     */
    checkerOptions?: MetaCheckerOptions;
    /**
     * Extra transformers to be run on top of each component code.
     *
     * `component` will be the Nuxt component options for this component and `code` the code of the component.
     */
    transformers?: ((component: any, code: string) => ({
        component: any;
        code: string;
    }))[];
    /**
     * Filter all components that are not global.
     */
    globalsOnly?: boolean;
    /**
     * Filter meta properties to be included in the output.
     */
    metaFields: {
        type: boolean;
        props: boolean;
        slots: boolean;
        events: boolean;
        exposed: boolean;
    };
    /**
     * Allow to load external components definitions.
     *
     * It can be a path to a file exporting a default object of components definitions or an object of components definitions.
     */
    metaSources?: (string | Partial<NuxtComponentMeta>)[];
}
interface ModuleHooks {
    'component-meta:transformers'(data: TransformersHookData): void;
    'component-meta:extend'(data: ExtendHookData): void;
}

type ComponentMetaParserOptions = Omit<ModuleOptions, 'components' | 'metaSources'> & {
    components: Component[];
    metaSources?: NuxtComponentMeta;
};
declare function useComponentMetaParser({ outputDir, rootDir, components: _components, componentDirs, checkerOptions, exclude, transformers, debug, metaFields, metaSources }: ComponentMetaParserOptions): {
    readonly checker: {
        updateFile(fileName: string, text: string): void;
        deleteFile(fileName: string): void;
        reload(): void;
        clearCache(): void;
        getExportNames: (componentPath: string) => string[];
        getComponentMeta: (componentPath: string, exportName?: string | undefined) => vue_component_meta.ComponentMeta;
        __internal__: {
            tsLs: typescript.LanguageService;
        };
    };
    readonly components: NuxtComponentMeta;
    refreshChecker: () => void;
    stubOutput: () => Promise<void>;
    outputPath: string;
    updateOutput: (content?: string) => Promise<void>;
    fetchComponent: (component: string | any) => Promise<void>;
    fetchComponents: () => Promise<void>;
    getStringifiedComponents: () => string;
    getVirtualModuleContent: () => string;
};
type ComponentMetaParser = ReturnType<typeof useComponentMetaParser>;

export { type ComponentMetaParserOptions as C, type ModuleOptions as M, type ModuleHooks as a, type ComponentMetaParser as b, useComponentMetaParser as u };
