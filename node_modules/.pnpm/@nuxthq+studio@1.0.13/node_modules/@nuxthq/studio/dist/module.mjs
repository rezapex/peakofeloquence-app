import { existsSync } from 'node:fs';
import path from 'path';
import { defu } from 'defu';
import { logger, defineNuxtModule, resolveAlias, createResolver, extendViteConfig, addVitePlugin, addPlugin, addComponentsDir, addServerHandler, addPrerenderRoutes, installModule } from '@nuxt/kit';
import { findNearestFile } from 'pkg-types';
import gitUrlParse from 'git-url-parse';



// -- Unbuild CommonJS Shims --
import __cjs_url__ from 'url';
import __cjs_path__ from 'path';
import __cjs_mod__ from 'module';
const __filename = __cjs_url__.fileURLToPath(import.meta.url);
const __dirname = __cjs_path__.dirname(__filename);
const require = __cjs_mod__.createRequire(import.meta.url);
const version = "1.0.13";

const log = logger.withTag("@nuxt/studio");
const module = defineNuxtModule({
  meta: {
    name: "studio",
    configKey: "studio"
  },
  defaults: {
    enabled: "production",
    project: ""
  },
  async setup(options, nuxt) {
    nuxt.hook("schema:resolved", (schema) => {
      nuxt.options.runtimeConfig.appConfigSchema = {
        properties: schema.properties?.appConfig,
        default: schema.default?.appConfig
      };
      nuxt.options.runtimeConfig.contentSchema = schema.properties?.content || {};
    });
    nuxt.hook("app:resolve", (appCtx) => {
      const studioAppConfigPath = resolveAlias("~/.studio/app.config.json");
      if (existsSync(studioAppConfigPath)) {
        appCtx.configs.unshift(studioAppConfigPath);
      }
    });
    if (options.enabled === "production" && nuxt.options.dev === true) {
      return;
    }
    const contentModule = "@nuxt/content";
    if (!nuxt.options.runtimeConfig.content && !nuxt.options.modules.includes(contentModule)) {
      log.warn("Could not find `@nuxt/content` module. Please install it to enable preview mode.");
      return;
    }
    const contentModuleVersion = await import(contentModule).then((m) => m.default || m).then((m) => m.getMeta()).then((m) => m.version).catch(() => "0");
    if (contentModuleVersion < "2.1.1") {
      log.warn("Please update `@nuxt/content` to version 2.1.1 or higher to enable preview mode.");
      return;
    }
    nuxt.hook("pinceau:options", (options2) => {
      options2.studio = true;
    });
    const { resolve } = createResolver(import.meta.url);
    const apiURL = process.env.NUXT_PUBLIC_STUDIO_API_URL || process.env.STUDIO_API || "https://api.nuxt.studio";
    const publicToken = process.env.NUXT_PUBLIC_STUDIO_TOKENS;
    const iframeMessagingAllowedOrigins = process.env.IFRAME_MESSAGING_ALLOWED_ORIGINS;
    const gitInfo = await _getLocalGitInfo(nuxt.options.rootDir) || _getGitEnv() || {};
    nuxt.options.runtimeConfig.studio = defu(nuxt.options.runtimeConfig.studio, {
      version,
      publicToken,
      project: options.project,
      gitInfo
    });
    nuxt.options.runtimeConfig.public.studio = defu(nuxt.options.runtimeConfig.public.studio, { apiURL, iframeMessagingAllowedOrigins });
    extendViteConfig((config) => {
      config.optimizeDeps = config.optimizeDeps || {};
      config.optimizeDeps.include = config.optimizeDeps.include || [];
      config.optimizeDeps.include.push(
        "socket.io-client",
        "slugify"
      );
    });
    if (contentModuleVersion === "2.10.0") {
      addVitePlugin({
        name: "content-resolver",
        enforce: "pre",
        resolveId(id, importer) {
          if (id.endsWith(".mjs") && ((importer || "").includes("@nuxt/content/dist") || id.includes("@nuxt/content/dist"))) {
            id = id.replace(".mjs", ".js").replace(/^\/node_modules/, "./node_modules/");
            return path.resolve(path.dirname(importer || __dirname), id.replace(".mjs", ".js"));
          }
        }
      });
    }
    addPlugin(resolve("./runtime/plugins/preview.client"));
    addComponentsDir({ path: resolve("./runtime/components") });
    addServerHandler({
      method: "get",
      route: "/__studio.json",
      handler: resolve("./runtime/server/routes/studio")
    });
    addPrerenderRoutes("/__studio.json");
    await installModule("nuxt-component-meta", {
      globalsOnly: true
    });
  }
});
async function _getLocalGitInfo(rootDir) {
  const remote = await _getLocalGitRemote(rootDir);
  if (!remote) {
    return;
  }
  const { name, owner, source } = gitUrlParse(remote);
  const url = `https://${source}/${owner}/${name}`;
  return {
    name,
    owner,
    url
  };
}
async function _getLocalGitRemote(dir) {
  try {
    const parseGitConfig = await import('parse-git-config').then(
      (m) => m.promise || m.default || m
    );
    const gitDir = await findNearestFile(".git/config", { startingFrom: dir });
    const parsed = await parseGitConfig({ path: gitDir });
    if (!parsed) {
      return;
    }
    const gitRemote = parsed['remote "origin"'].url;
    return gitRemote;
  } catch (err) {
  }
}
function _getGitEnv() {
  const envInfo = {
    // Provider
    provider: process.env.VERCEL_GIT_PROVIDER || // vercel
    (process.env.GITHUB_SERVER_URL ? "github" : void 0) || // github
    "",
    // Owner
    owner: process.env.VERCEL_GIT_REPO_OWNER || // vercel
    process.env.GITHUB_REPOSITORY_OWNER || // github
    process.env.CI_PROJECT_PATH?.split("/").shift() || // gitlab
    "",
    // Name
    name: process.env.VERCEL_GIT_REPO_SLUG || process.env.GITHUB_REPOSITORY?.split("/").pop() || // github
    process.env.CI_PROJECT_PATH?.split("/").splice(1).join("/") || // gitlab
    "",
    // Url
    url: process.env.REPOSITORY_URL || ""
    // netlify
  };
  if (!envInfo.url && envInfo.provider && envInfo.owner && envInfo.name) {
    envInfo.url = `https://${envInfo.provider}.com/${envInfo.owner}/${envInfo.name}`;
  }
  if (!envInfo.name && !envInfo.owner && envInfo.url) {
    try {
      const { name, owner } = gitUrlParse(envInfo.url);
      envInfo.name = name;
      envInfo.owner = owner;
    } catch {
    }
  }
  return {
    name: envInfo.name,
    owner: envInfo.owner,
    url: envInfo.url
  };
}

export { module as default };
