import { html as convertHtmlToSatori } from "satori-html";
import { loadFont, walkSatoriTree } from "./utils.mjs";
import imageSrc from "./plugins/imageSrc.mjs";
import twClasses from "./plugins/twClasses.mjs";
import flex from "./plugins/flex.mjs";
import emojis from "./plugins/emojis.mjs";
import encoding from "./plugins/encoding.mjs";
import loadPngCreator from "#nuxt-og-image/png";
import loadSatori from "#nuxt-og-image/satori";
import { useRuntimeConfig } from "#imports";
const satoriFonts = [];
let fontLoadPromise = null;
function loadFonts(baseURL, fonts) {
  if (fontLoadPromise)
    return fontLoadPromise;
  return fontLoadPromise = Promise.all(fonts.map((font) => loadFont(baseURL, font)));
}
const SatoriRenderer = {
  name: "satori",
  createPng: async function createPng(options) {
    const svg = await this.createSvg(options);
    const pngCreator = await loadPngCreator();
    return pngCreator(svg, options);
  },
  createVNode: async function createVNode(options) {
    const html = options.html || await globalThis.$fetch("/api/og-image-html", {
      params: {
        path: options.path,
        options: JSON.stringify(options)
      }
    });
    const body = html.match(/<body[^>]*>([\s\S]*)<\/body>/)?.[1] || html;
    const satoriTree = convertHtmlToSatori(body);
    await walkSatoriTree(satoriTree, [
      emojis,
      twClasses,
      imageSrc,
      flex,
      encoding
    ], options);
    return satoriTree;
  },
  createSvg: async function createSvg(options) {
    const { fonts, satoriOptions } = useRuntimeConfig()["nuxt-og-image"];
    const vnodes = await this.createVNode(options);
    if (!satoriFonts.length)
      satoriFonts.push(...await loadFonts(options.requestOrigin, fonts));
    const satori = await loadSatori();
    return await satori(vnodes, {
      ...satoriOptions,
      fonts: satoriFonts,
      embedFont: true,
      width: options.width,
      height: options.height
    });
  }
};
export default SatoriRenderer;
