import { existsSync, promises as fsp } from "node:fs";
import { Buffer } from "node:buffer";
import { getQuery } from "h3";
import { join } from "pathe";
import sizeOf from "image-size";
import { defu } from "defu";
import { withoutLeadingSlash } from "ufo";
import { useNitroCache } from "../cache.mjs";
import { useNitroOrigin, useRuntimeConfig } from "#imports";
export function wasmLoader(asyncModuleLoad, fallback) {
  let promise;
  let wasm;
  return {
    async load(options) {
      if (typeof promise !== "undefined")
        return promise;
      if (wasm)
        return wasm;
      promise = promise || new Promise(async (resolve) => {
        try {
          wasm = await asyncModuleLoad;
          if (typeof wasm === "string")
            wasm = void 0;
        } catch (e) {
        }
        if (!wasm) {
          wasm = await readPublicAsset(fallback, "base64");
          if (wasm)
            wasm = Buffer.from(wasm, "base64");
        }
        if (!wasm) {
          wasm = await (await globalThis.$fetch(fallback, { baseURL: options.requestOrigin })).arrayBuffer();
          wasm = Buffer.from(wasm);
        }
        resolve(wasm);
      });
      return promise;
    }
  };
}
export async function fetchOptionsCached(e, path) {
  const key = [
    withoutLeadingSlash(path === "/" || !path ? "index" : path).replaceAll("/", "-"),
    "options"
  ].join(":");
  const { cachedItem, update } = await useNitroCache(e, "nuxt-og-image", {
    key,
    // allow internal requests to be cached for 5 seconds
    cacheTtl: 5 * 1e3,
    cache: !process.dev,
    headers: false
  });
  if (cachedItem)
    return cachedItem;
  const options = await fetchOptions(e, path);
  await update(options);
  return options;
}
export async function fetchOptions(e, path) {
  const options = await globalThis.$fetch("/api/og-image-options", {
    query: {
      path
    },
    responseType: "json"
  });
  return defu(
    { requestOrigin: useNitroOrigin(e) },
    options,
    // use query data
    getQuery(e)
  );
}
export function base64ToArrayBuffer(base64) {
  const buffer = Buffer.from(base64, "base64");
  return new Uint8Array(buffer).buffer;
}
function r(base, key) {
  return join(base, key.replace(/:/g, "/"));
}
export async function readPublicAsset(file, encoding) {
  const { assetDirs } = useRuntimeConfig()["nuxt-og-image"];
  for (const assetDir of assetDirs) {
    const path = r(assetDir, file);
    if (existsSync(path))
      return await fsp.readFile(path, { encoding });
  }
}
export async function readPublicAssetBase64(file) {
  const base64 = await readPublicAsset(file, "base64");
  if (base64) {
    const dimensions = await sizeOf(Buffer.from(base64, "base64"));
    return {
      src: toBase64Image(file, base64),
      ...dimensions
    };
  }
}
export function toBase64Image(fileName, data) {
  const base64 = typeof data === "string" ? data : Buffer.from(data).toString("base64");
  let type = "image/jpeg";
  const ext = fileName.split(".").pop();
  if (ext === "svg")
    type = "image/svg+xml";
  else if (ext === "png")
    type = "image/png";
  return `data:${type};base64,${base64}`;
}
export * from "./utils-pure.mjs";
