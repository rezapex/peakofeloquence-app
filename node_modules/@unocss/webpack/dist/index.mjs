import process$1 from 'node:process';
import { resolve, isAbsolute, normalize } from 'node:path';
import { createUnplugin } from 'unplugin';
import WebpackSources from 'webpack-sources';
import { createFilter } from '@rollup/pluginutils';
import { loadConfig } from '@unocss/config';
import { cssIdRE, createGenerator, BetterMap } from '@unocss/core';
import fs from 'node:fs/promises';
import fg from 'fast-glob';
import MagicString from 'magic-string';
import remapping from '@ampproject/remapping';
import { createHash } from 'node:crypto';

const INCLUDE_COMMENT = "@unocss-include";
const IGNORE_COMMENT = "@unocss-ignore";
const CSS_PLACEHOLDER = "@unocss-placeholder";
const SKIP_START_COMMENT = "@unocss-skip-start";
const SKIP_END_COMMENT = "@unocss-skip-end";
const SKIP_COMMENT_RE = new RegExp(`(//\\s*?${SKIP_START_COMMENT}\\s*?|\\/\\*\\s*?${SKIP_START_COMMENT}\\s*?\\*\\/|<!--\\s*?${SKIP_START_COMMENT}\\s*?-->)[\\s\\S]*?(//\\s*?${SKIP_END_COMMENT}\\s*?|\\/\\*\\s*?${SKIP_END_COMMENT}\\s*?\\*\\/|<!--\\s*?${SKIP_END_COMMENT}\\s*?-->)`, "g");

const defaultPipelineExclude = [cssIdRE];
const defaultPipelineInclude = [/\.(vue|svelte|[jt]sx|mdx?|astro|elm|php|phtml|html)($|\?)/];

function deprecationCheck(config) {
  let warned = false;
  function warn(msg) {
    warned = true;
    console.warn(`[unocss] ${msg}`);
  }
  if (config.include)
    warn("`include` option is deprecated, use `content.pipeline.include` instead.");
  if (config.exclude)
    warn("`exclude` option is deprecated, use `content.pipeline.exclude` instead.");
  if (config.extraContent)
    warn("`extraContent` option is deprecated, use `content` instead.");
  if (config.content?.plain)
    warn("`content.plain` option is renamed to `content.inline`.");
  if (warned && typeof process !== "undefined" && process.env.CI)
    throw new Error("deprecation warning");
}

function createContext(configOrPath, defaults = {}, extraConfigSources = [], resolveConfigResult = () => {
}) {
  let root = process$1.cwd();
  let rawConfig = {};
  let configFileList = [];
  const uno = createGenerator(rawConfig, defaults);
  let rollupFilter = createFilter(
    defaultPipelineInclude,
    defaultPipelineExclude,
    { resolve: typeof configOrPath === "string" ? configOrPath : root }
  );
  const invalidations = [];
  const reloadListeners = [];
  const modules = new BetterMap();
  const tokens = /* @__PURE__ */ new Set();
  const tasks = [];
  const affectedModules = /* @__PURE__ */ new Set();
  let ready = reloadConfig();
  async function reloadConfig() {
    const result = await loadConfig(root, configOrPath, extraConfigSources, defaults);
    resolveConfigResult(result);
    deprecationCheck(result.config);
    rawConfig = result.config;
    configFileList = result.sources;
    uno.setConfig(rawConfig);
    uno.config.envMode = "dev";
    rollupFilter = rawConfig.content?.pipeline === false ? () => false : createFilter(
      rawConfig.content?.pipeline?.include || rawConfig.include || defaultPipelineInclude,
      rawConfig.content?.pipeline?.exclude || rawConfig.exclude || defaultPipelineExclude,
      { resolve: typeof configOrPath === "string" ? configOrPath : root }
    );
    tokens.clear();
    await Promise.all(modules.map((code, id) => uno.applyExtractors(code.replace(SKIP_COMMENT_RE, ""), id, tokens)));
    invalidate();
    dispatchReload();
    const presets = /* @__PURE__ */ new Set();
    uno.config.presets.forEach((i) => {
      if (!i.name)
        return;
      if (presets.has(i.name))
        console.warn(`[unocss] duplication of preset ${i.name} found, there might be something wrong with your config.`);
      else
        presets.add(i.name);
    });
    return result;
  }
  async function updateRoot(newRoot) {
    if (newRoot !== root) {
      root = newRoot;
      ready = reloadConfig();
    }
    return await ready;
  }
  function invalidate() {
    invalidations.forEach((cb) => cb());
  }
  function dispatchReload() {
    reloadListeners.forEach((cb) => cb());
  }
  async function extract(code, id) {
    if (id)
      modules.set(id, code);
    const len = tokens.size;
    await uno.applyExtractors(code.replace(SKIP_COMMENT_RE, ""), id, tokens);
    if (tokens.size > len)
      invalidate();
  }
  function filter(code, id) {
    if (code.includes(IGNORE_COMMENT))
      return false;
    return code.includes(INCLUDE_COMMENT) || code.includes(CSS_PLACEHOLDER) || rollupFilter(id.replace(/\?v=\w+$/, ""));
  }
  async function getConfig() {
    await ready;
    return rawConfig;
  }
  async function flushTasks() {
    const _tasks = [...tasks];
    await Promise.all(_tasks);
    tasks.splice(0, _tasks.length);
  }
  return {
    get ready() {
      return ready;
    },
    tokens,
    modules,
    affectedModules,
    tasks,
    flushTasks,
    invalidate,
    onInvalidate(fn) {
      invalidations.push(fn);
    },
    filter,
    reloadConfig,
    onReload(fn) {
      reloadListeners.push(fn);
    },
    uno,
    extract,
    getConfig,
    get root() {
      return root;
    },
    updateRoot,
    getConfigFileList: () => configFileList
  };
}

function getHash(input, length = 8) {
  return createHash("sha256").update(input).digest("hex").slice(0, length);
}
function hash(str) {
  let i;
  let l;
  let hval = 2166136261;
  for (i = 0, l = str.length; i < l; i++) {
    hval ^= str.charCodeAt(i);
    hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
  }
  return `00000${(hval >>> 0).toString(36)}`.slice(-6);
}

async function applyTransformers(ctx, original, id, enforce = "default") {
  if (original.includes(IGNORE_COMMENT))
    return;
  const transformers = (ctx.uno.config.transformers || []).filter((i) => (i.enforce || "default") === enforce);
  if (!transformers.length)
    return;
  const skipMap = /* @__PURE__ */ new Map();
  let code = original;
  let s = new MagicString(transformSkipCode(code, skipMap));
  const maps = [];
  for (const t of transformers) {
    if (t.idFilter) {
      if (!t.idFilter(id))
        continue;
    } else if (!ctx.filter(code, id)) {
      continue;
    }
    await t.transform(s, id, ctx);
    if (s.hasChanged()) {
      code = restoreSkipCode(s.toString(), skipMap);
      maps.push(s.generateMap({ hires: true, source: id }));
      s = new MagicString(code);
    }
  }
  if (code !== original) {
    ctx.affectedModules.add(id);
    return {
      code,
      map: remapping(maps, (_, ctx2) => {
        ctx2.content = code;
        return null;
      })
    };
  }
}
function transformSkipCode(code, map) {
  for (const item of Array.from(code.matchAll(SKIP_COMMENT_RE))) {
    if (item != null) {
      const matched = item[0];
      const withHashKey = `@unocss-skip-placeholder-${hash(matched)}`;
      map.set(withHashKey, matched);
      code = code.replace(matched, withHashKey);
    }
  }
  return code;
}
function restoreSkipCode(code, map) {
  for (const [withHashKey, matched] of map.entries())
    code = code.replace(withHashKey, matched);
  return code;
}

async function setupContentExtractor(ctx, shouldWatch = false) {
  const { content } = await ctx.getConfig();
  const { extract, tasks, root, filter } = ctx;
  if (content?.inline) {
    await Promise.all(
      content.inline.map(async (c, idx) => {
        if (typeof c === "function")
          c = await c();
        if (typeof c === "string")
          c = { code: c };
        return extract(c.code, c.id ?? `__plain_content_${idx}__`);
      })
    );
  }
  if (content?.filesystem) {
    const files = await fg(content.filesystem, { cwd: root });
    async function extractFile(file) {
      file = isAbsolute(file) ? file : resolve(root, file);
      const code = await fs.readFile(file, "utf-8");
      if (!filter(code, file))
        return;
      const preTransform = await applyTransformers(ctx, code, file, "pre");
      const defaultTransform = await applyTransformers(ctx, preTransform?.code || code, file);
      await applyTransformers(ctx, defaultTransform?.code || preTransform?.code || code, file, "post");
      return await extract(preTransform?.code || code, file);
    }
    if (shouldWatch) {
      const { watch } = await import('chokidar');
      const ignored = ["**/{.git,node_modules}/**"];
      const watcher = watch(files, {
        ignorePermissionErrors: true,
        ignored,
        cwd: root,
        ignoreInitial: true
      });
      watcher.on("all", (type, file) => {
        if (type === "add" || type === "change") {
          const absolutePath = resolve(root, file);
          tasks.push(extractFile(absolutePath));
        }
      });
    }
    await Promise.all(files.map(extractFile));
  }
}

const VIRTUAL_ENTRY_ALIAS = [
  /^(?:virtual:)?uno(?::(.+))?\.css(\?.*)?$/
];
const LAYER_MARK_ALL = "__ALL__";
const RESOLVED_ID_WITH_QUERY_RE = /[\/\\]__uno(?:(_.*?))?\.css(\?.*)?$/;
const RESOLVED_ID_RE = /[\/\\]__uno(?:_(.*?))?\.css$/;
function resolveId(id) {
  if (id.match(RESOLVED_ID_WITH_QUERY_RE))
    return id;
  for (const alias of VIRTUAL_ENTRY_ALIAS) {
    const match = id.match(alias);
    if (match) {
      return match[1] ? `/__uno_${match[1]}.css` : "/__uno.css";
    }
  }
}
function resolveLayer(id) {
  const match = id.match(RESOLVED_ID_RE);
  if (match)
    return match[1] || LAYER_MARK_ALL;
}
const LAYER_PLACEHOLDER_RE = /#--unocss--\s*{\s*layer\s*:\s*(.+?)\s*(?:;\s*escape-view\s*:\s*(.+?)\s*)?;?\s*}/g;
function getLayerPlaceholder(layer) {
  return `#--unocss--{layer:${layer};escape-view:\\"\\'\\\`\\\\}`;
}
function getCssEscaperForJsContent(view) {
  if (!view)
    return (css) => css;
  const prefix = {};
  const escapeViewRe = /(\\*)\\(["'`\\])/g;
  view.trim().replace(escapeViewRe, (_, bs, char) => {
    prefix[char] = bs;
    return "";
  });
  return (css) => css.replace(/["'`\\]/g, (v) => {
    return (prefix[v] || "") + v;
  });
}
const HASH_PLACEHOLDER_RE = /#--unocss-hash--\s*{\s*content\s*:\s*\\*"(.+?)\\*";?\s*}/g;
function getHashPlaceholder(hash) {
  return `#--unocss-hash--{content:"${hash}"}`;
}

function getPath(id) {
  return id.replace(/\?.*$/, "");
}
function isCssId(id) {
  return cssIdRE.test(id);
}

const PLUGIN_NAME = "unocss:webpack";
const UPDATE_DEBOUNCE = 10;
function defineConfig(config) {
  return config;
}
function WebpackPlugin(configOrPath, defaults) {
  return createUnplugin(() => {
    const ctx = createContext(configOrPath, {
      envMode: process$1.env.NODE_ENV === "development" ? "dev" : "build",
      ...defaults
    });
    const { uno, tokens, filter, extract, onInvalidate, tasks, flushTasks } = ctx;
    let timer;
    onInvalidate(() => {
      clearTimeout(timer);
      timer = setTimeout(updateModules, UPDATE_DEBOUNCE);
    });
    const nonPreTransformers = ctx.uno.config.transformers?.filter((i) => i.enforce !== "pre");
    if (nonPreTransformers?.length) {
      console.warn(
        // eslint-disable-next-line prefer-template
        '[unocss] webpack integration only supports "pre" enforce transformers currently.the following transformers will be ignored\n' + nonPreTransformers.map((i) => ` - ${i.name}`).join("\n")
      );
    }
    tasks.push(setupContentExtractor(ctx, typeof configOrPath === "object" && configOrPath?.watch));
    const entries = /* @__PURE__ */ new Set();
    const hashes = /* @__PURE__ */ new Map();
    const plugin = {
      name: "unocss:webpack",
      enforce: "pre",
      transformInclude(id) {
        return filter("", id) && !id.endsWith(".html") && !RESOLVED_ID_RE.test(id);
      },
      async transform(code, id) {
        const result = await applyTransformers(ctx, code, id, "pre");
        if (isCssId(id))
          return result;
        if (result == null)
          tasks.push(extract(code, id));
        else
          tasks.push(extract(result.code, id));
        return result;
      },
      resolveId(id) {
        const entry = resolveId(id);
        if (entry === id)
          return;
        if (entry) {
          let query = "";
          const queryIndex = id.indexOf("?");
          if (queryIndex >= 0)
            query = id.slice(queryIndex);
          entries.add(entry);
          return entry + query;
        }
      },
      loadInclude(id) {
        const layer = getLayer(id);
        return !!layer;
      },
      // serve the placeholders in virtual module
      load(id) {
        const layer = getLayer(id);
        const hash = hashes.get(id);
        if (layer)
          return (hash ? getHashPlaceholder(hash) : "") + getLayerPlaceholder(layer);
      },
      webpack(compiler) {
        compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation) => {
          const optimizeAssetsHook = (
            /* webpack 5 & 6 */
            compilation.hooks.processAssets || /* webpack 4 */
            compilation.hooks.optimizeAssets
          );
          optimizeAssetsHook.tapPromise(PLUGIN_NAME, async () => {
            const files = Object.keys(compilation.assets);
            await flushTasks();
            const result = await uno.generate(tokens, { minify: true });
            for (const file of files) {
              if (file === "*")
                return;
              let code = compilation.assets[file].source().toString();
              let replaced = false;
              code = code.replace(HASH_PLACEHOLDER_RE, "");
              code = code.replace(LAYER_PLACEHOLDER_RE, (_, layer, escapeView) => {
                replaced = true;
                const css = layer === LAYER_MARK_ALL ? result.getLayers(void 0, Array.from(entries).map((i) => resolveLayer(i)).filter((i) => !!i)) : result.getLayer(layer) || "";
                const escapeCss = getCssEscaperForJsContent(escapeView);
                return escapeCss(css);
              });
              if (replaced)
                compilation.assets[file] = new WebpackSources.RawSource(code);
            }
          });
        });
      }
    };
    let lastTokenSize = tokens.size;
    async function updateModules() {
      if (!plugin.__vfsModules)
        return;
      await flushTasks();
      const result = await uno.generate(tokens);
      if (lastTokenSize === tokens.size)
        return;
      lastTokenSize = tokens.size;
      Array.from(plugin.__vfsModules).forEach((id) => {
        let path = decodeURIComponent(id.slice(plugin.__virtualModulePrefix.length));
        path = normalizeAbsolutePath(path);
        const layer = resolveLayer(path);
        if (!layer)
          return;
        const code = layer === LAYER_MARK_ALL ? result.getLayers(void 0, Array.from(entries).map((i) => resolveLayer(i)).filter((i) => !!i)) : result.getLayer(layer) || "";
        const hash = getHash(code);
        hashes.set(path, hash);
        plugin.__vfs.writeModule(id, code);
      });
    }
    return plugin;
  }).webpack();
}
function getLayer(id) {
  let layer = resolveLayer(getPath(id));
  if (!layer) {
    const entry = resolveId(id);
    if (entry)
      layer = resolveLayer(entry);
  }
  return layer;
}
function normalizeAbsolutePath(path) {
  if (isAbsolute(path))
    return normalize(path);
  else
    return path;
}

export { WebpackPlugin as default, defineConfig };
