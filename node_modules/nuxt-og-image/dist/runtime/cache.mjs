import { prefixStorage } from "unstorage";
import { getQuery, setHeader } from "h3";
import { useRuntimeConfig, useStorage } from "#imports";
export async function useNitroCache(e, module, options) {
  const { runtimeCacheStorage, version } = useRuntimeConfig()[module];
  const enabled = options.cache && runtimeCacheStorage && options.cacheTtl && options.cacheTtl > 0;
  const baseCacheKey = runtimeCacheStorage === "default" ? `/cache/${module}@${version}` : `/${module}@${version}`;
  const cache = prefixStorage(useStorage(), `${baseCacheKey}/`);
  const key = options.key;
  let xCacheHeader = "DISABLED";
  let xCacheExpires = 0;
  const newExpires = Date.now() + (options.cacheTtl || 0);
  const purge = typeof getQuery(e).purge !== "undefined";
  let cachedItem = false;
  if (!options.skipRestore && enabled && await cache.hasItem(key).catch(() => false)) {
    const { value, expiresAt } = await cache.getItem(key).catch(() => ({ value: null, expiresAt: Date.now() }));
    if (purge) {
      xCacheHeader = "PURGE";
      xCacheExpires = newExpires;
      await cache.removeItem(key).catch(() => {
      });
    } else if (expiresAt > Date.now()) {
      xCacheHeader = "HIT";
      xCacheExpires = newExpires;
      cachedItem = value;
    } else {
      xCacheHeader = "MISS";
      xCacheExpires = expiresAt;
      await cache.removeItem(key).catch(() => {
      });
    }
  }
  if (options.headers) {
    setHeader(e, `x-${module}-cache`, xCacheHeader);
    setHeader(e, `x-${module}-expires`, xCacheExpires.toString());
  }
  return {
    enabled,
    cachedItem,
    async update(item) {
      enabled && await cache.setItem(key, { value: item, expiresAt: Date.now() + (options.cacheTtl || 0) });
    }
  };
}
