import { Buffer } from "node:buffer";
import { base64ToArrayBuffer, readPublicAsset } from "../../utils.mjs";
import { useStorage } from "#imports";
const cachedFonts = {};
export async function loadFont(requestOrigin, font) {
  const fontKey = `${font.name}:${font.weight}`;
  const storageKey = `assets:nuxt-og-image:font:${fontKey}`;
  if (cachedFonts[fontKey])
    return cachedFonts[fontKey];
  const [name, weight] = fontKey.split(":");
  let data;
  if (await useStorage().hasItem(storageKey))
    data = base64ToArrayBuffer(await useStorage().getItem(storageKey));
  if (!data && name === "Inter" && ["400", "700"].includes(weight)) {
    data = await readPublicAsset(`/inter-latin-ext-${weight}-normal.woff`);
  }
  if (font.path) {
    data = await readPublicAsset(font.path);
    if (!data) {
      try {
        data = await globalThis.$fetch(font.path, {
          responseType: "arrayBuffer",
          baseURL: requestOrigin
        });
      } catch {
      }
    }
  }
  if (!data) {
    const fontUrl = await globalThis.$fetch("/api/og-image-font", {
      query: { name, weight }
    });
    data = await globalThis.$fetch(fontUrl, {
      responseType: "arrayBuffer"
    });
  }
  cachedFonts[fontKey] = { name, weight: Number(weight), data, style: "normal" };
  await useStorage().setItem(storageKey, Buffer.from(data).toString("base64"));
  return cachedFonts[fontKey];
}
export async function walkSatoriTree(node, plugins, props) {
  if (!node.props?.children)
    return;
  if (Array.isArray(node.props.children) && node.props.children.length === 0) {
    delete node.props.children;
    return;
  }
  for (const child of node.props.children || []) {
    if (child) {
      for (const plugin of plugins.flat()) {
        if (plugin.filter(child))
          await plugin.transform(child, props);
      }
      await walkSatoriTree(child, plugins, props);
    }
  }
}
export function defineSatoriTransformer(transformer) {
  return transformer;
}
