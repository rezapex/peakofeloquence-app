import { Buffer } from "node:buffer";
import { withBase } from "ufo";
import sizeOf from "image-size";
import { defineSatoriTransformer } from "../utils.mjs";
import { readPublicAssetBase64, toBase64Image } from "../../../utils.mjs";
export default defineSatoriTransformer({
  filter: (node) => node.type === "img",
  transform: async (node, options) => {
    const src = node.props?.src;
    if (src && src.startsWith("/")) {
      let updated = false;
      const file = await readPublicAssetBase64(src);
      let dimensions;
      if (file) {
        node.props.src = file.src;
        dimensions = { width: file.width, height: file.height };
        updated = true;
      }
      if (!updated) {
        let valid = true;
        const response = await globalThis.$fetch(src, {
          responseType: "arrayBuffer",
          baseURL: options.requestOrigin
        }).catch(() => {
          valid = false;
        });
        if (valid) {
          node.props.src = toBase64Image(src, response);
          const imageSize = await sizeOf(Buffer.from(response));
          dimensions = { width: imageSize.width, height: imageSize.height };
          updated = true;
        }
      }
      if (dimensions?.width && dimensions?.height) {
        const naturalAspectRatio = dimensions.width / dimensions.height;
        if (node.props.width && !node.props.height) {
          node.props.height = Math.round(node.props.width / naturalAspectRatio);
        } else if (node.props.height && !node.props.width) {
          node.props.width = Math.round(node.props.height * naturalAspectRatio);
        } else if (!node.props.width && !node.props.height) {
          node.props.width = dimensions.width;
          node.props.height = dimensions.height;
        }
      }
      if (!updated) {
        node.props.src = `${withBase(src, `${options.requestOrigin}`)}?${Date.now()}`;
      }
    }
  }
});
