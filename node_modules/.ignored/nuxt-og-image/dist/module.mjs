import { readFile, writeFile } from 'node:fs/promises';
import * as fs from 'node:fs';
import { existsSync } from 'node:fs';
import { useNuxt, createResolver, addTemplate, defineNuxtModule, useLogger, addServerHandler, addImports, addComponent, hasNuxtModule, addServerPlugin } from '@nuxt/kit';
import { execa } from 'execa';
import chalk from 'chalk';
import defu$1, { defu } from 'defu';
import { toRouteMatcher, createRouter } from 'radix3';
import { withBase, parsePath, joinURL } from 'ufo';
import { resolve, relative, dirname } from 'pathe';
import { tinyws } from 'tinyws';
import sirv from 'sirv';
import { pathExists, copy, mkdirp } from 'fs-extra';
import { globby } from 'globby';
import { installNuxtSiteConfig, updateSiteConfig } from 'nuxt-site-config-kit';
import { provider } from 'std-env';
import { hash } from 'ohash';
import terminate from 'terminate';
import playwrightCore from 'playwright-core';
import { createBirpcGroup } from 'birpc';
import { stringify, parse } from 'flatted';
import { addDependency } from 'nypm';

const version = "2.2.4";

async function createBrowser() {
  if (process.dev || process.env.prerender) {
    try {
      const { Launcher } = await import(String("chrome-launcher"));
      const chromePath = Launcher.getFirstInstallation();
      return await playwrightCore.chromium.launch({
        headless: true,
        executablePath: chromePath
      });
    } catch (e) {
    }
  }
  try {
    return await playwrightCore.chromium.launch({
      headless: true
    });
  } catch (e) {
  }
  try {
    const playwright = await import(String("playwright"));
    return await playwright.chromium.launch({
      headless: true
    });
  } catch (e) {
    if (process.dev) {
      console.warn("Failed to load chromium instance. Ensure you have chrome installed, otherwise add the dependency: `npm add -D playwright`.");
    } else {
      console.error("Failed to load browser instance. Please open an issue with the exception: https://github.com/harlan-zw/nuxt-og-image/issues.");
      throw e;
    }
  }
}

async function screenshot(browser, options) {
  const page = await browser.newPage({
    colorScheme: options.colorScheme
  });
  await page.setViewportSize({
    width: options.width || 1200,
    height: options.height || 630
  });
  const isHtml = options.html || options.path?.startsWith("html:");
  if (isHtml) {
    const html = options.html || options.path?.substring(5);
    await page.evaluate((html2) => {
      document.open("text/html");
      document.write(html2);
      document.close();
    }, html);
    await page.waitForLoadState("networkidle");
  } else {
    await page.goto(withBase(options.path, options.host), {
      timeout: 1e4,
      waitUntil: "networkidle"
    });
  }
  const screenshotOptions = {
    timeout: 1e4
  };
  if (options.delay)
    await page.waitForTimeout(options.delay);
  if (options.mask) {
    await page.evaluate((mask) => {
      for (const el of document.querySelectorAll(mask))
        el.style.display = "none";
    }, options.mask);
  }
  if (options.selector)
    return await page.locator(options.selector).screenshot(screenshotOptions);
  const screenshot2 = await page.screenshot(screenshotOptions);
  await page.close();
  return screenshot2;
}

function setupPlaygroundRPC(nuxt, config) {
  const serverFunctions = {
    getConfig() {
      return config;
    },
    async openInEditor(input) {
      if (input.startsWith("./"))
        input = resolve(process.cwd(), input);
      const match = input.match(/^(.*?)([:\d]*)$/);
      let suffix = "";
      if (match) {
        input = match[1];
        suffix = match[2];
      }
      const file = [
        input,
        `${input}.js`,
        `${input}.mjs`,
        `${input}.ts`
      ].find((i) => existsSync(i));
      if (file) {
        await import('launch-editor').then((r) => (r.default || r)(file + suffix));
      } else {
        console.error("File not found:", input);
      }
    }
  };
  const clients = /* @__PURE__ */ new Set();
  const birpc = createBirpcGroup(serverFunctions, []);
  nuxt.hook("builder:watch", (e, path) => {
    if (e === "change")
      birpc.broadcast.refresh.asEvent(path);
  });
  const middleware = async (req, res) => {
    if (req.ws) {
      const ws = await req.ws();
      clients.add(ws);
      const channel = {
        post: (d) => ws.send(d),
        on: (fn) => ws.on("message", fn),
        serialize: stringify,
        deserialize: parse
      };
      birpc.updateChannels((c) => {
        c.push(channel);
      });
      ws.on("close", () => {
        clients.delete(ws);
        birpc.updateChannels((c) => {
          const index = c.indexOf(channel);
          if (index >= 0)
            c.splice(index, 1);
        });
      });
    } else if (req.method === "POST") {
      const body = await getBodyJson(req);
      if (body.method === "setPayload") ; else {
        res.statusCode = 400;
      }
      res.end();
    }
  };
  return {
    middleware,
    birpc
  };
}
function getBodyJson(req) {
  return new Promise((resolve2, reject) => {
    let body = "";
    req.on("data", (chunk) => body += chunk);
    req.on("error", reject);
    req.on("end", () => {
      try {
        resolve2(JSON.parse(body) || {});
      } catch (e) {
        reject(e);
      }
    });
  });
}

function decodeHtml(html) {
  return html.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&").replace(/&cent;/g, "\xA2").replace(/&pound;/g, "\xA3").replace(/&yen;/g, "\xA5").replace(/&euro;/g, "\u20AC").replace(/&copy;/g, "\xA9").replace(/&reg;/g, "\xAE").replace(/&quot;/g, '"').replace(/&#39;/g, "'").replace(/&#x27;/g, "'").replace(/&#x2F;/g, "/").replace(/&#([0-9]+);/g, (full, int) => {
    return String.fromCharCode(Number.parseInt(int));
  });
}
function decodeObjectHtmlEntities(obj) {
  Object.entries(obj).forEach(([key, value]) => {
    if (typeof value === "string")
      obj[key] = decodeHtml(value);
  });
  return obj;
}
function extractAndNormaliseOgImageOptions(path, html, routeRules, defaults) {
  const htmlPayload = html.match(/<script.+id="nuxt-og-image-options"[^>]*>(.+?)<\/script>/)?.[1];
  if (!htmlPayload)
    return false;
  let options;
  try {
    const payload = JSON.parse(htmlPayload);
    Object.entries(payload).forEach(([key, value]) => {
      if (!value)
        delete payload[key];
    });
    options = defu(payload, routeRules);
  } catch (e) {
    options = routeRules;
    if (process.dev)
      console.warn("Failed to parse #nuxt-og-image-options", e, options);
  }
  if (!options)
    return false;
  if (!options.description) {
    const description = html.match(/<meta property="og:description" content="(.*?)">/)?.[1];
    if (description)
      options.description = description;
    else
      options.description = html.match(/<meta name="description" content="(.*?)">/)?.[1];
  }
  const decoded = decodeObjectHtmlEntities(options);
  return defu(
    decoded,
    // runtime options
    { path },
    defaults
  );
}

const SVG2PNGWasmPlaceholder = '"/* NUXT_OG_IMAGE_SVG2PNG_WASM */"';
const YogaWasmPlaceholder = '"/* NUXT_OG_IMAGE_YOGA_WASM */"';
const ReSVGWasmPlaceholder = '"/* NUXT_OG_IMAGE_RESVG_WASM */"';
const Wasms = [
  {
    placeholder: SVG2PNGWasmPlaceholder,
    path: "svg2png/svg2png.wasm",
    file: "svg2png.wasm"
  },
  {
    placeholder: ReSVGWasmPlaceholder,
    path: "resvg/resvg.wasm",
    file: "resvg.wasm"
  },
  {
    placeholder: YogaWasmPlaceholder,
    path: "yoga/yoga.wasm",
    file: "yoga.wasm"
  }
];
const DefaultRuntimeCompatibility = {
  // node-server runtime
  browser: "playwright",
  satori: "default",
  wasm: "fetch",
  png: "resvg-node",
  node: true,
  cssInline: true
};
const cloudflare = {
  browser: false,
  wasm: "import",
  png: "resvg-wasm",
  node: false,
  cssInline: false
};
const awsLambda = {
  browser: false,
  // too difficult to support
  wasm: "inline",
  cssInline: false
};
const RuntimeCompatibility = {
  "nitro-dev": {
    wasm: "fetch",
    browser: "universal"
  },
  "stackblitz": {
    browser: false,
    satori: "yoga-wasm",
    wasm: "inline",
    png: "resvg-wasm",
    cssInline: false
  },
  "aws-lambda": awsLambda,
  "netlify": awsLambda,
  "netlify-edge": {
    wasm: "inline",
    png: "resvg-wasm",
    node: false,
    cssInline: false
  },
  "vercel": {
    // exceeds 50mb limit
    browser: false
  },
  "vercel-edge": {
    browser: false,
    wasm: "import",
    wasmImportQuery: "?module",
    png: "resvg-wasm",
    node: false,
    cssInline: false
  },
  "cloudflare-pages": cloudflare,
  "cloudflare": cloudflare
};

const autodetectableProviders = {
  azure_static: "azure",
  cloudflare_pages: "cloudflare-pages",
  netlify: "netlify",
  stormkit: "stormkit",
  vercel: "vercel",
  cleavr: "cleavr",
  stackblitz: "stackblitz"
};
const autodetectableStaticProviders = {
  netlify: "netlify-static",
  vercel: "vercel-static"
};
function detectTarget(options = {}) {
  return options?.static ? autodetectableStaticProviders[provider] : autodetectableProviders[provider];
}
function getNitroPreset(nuxt = useNuxt()) {
  return process.env.NITRO_PRESET || nuxt.options.nitro.preset || detectTarget() || "node-server";
}
function getNitroProviderCompatibility(overrides, nuxt = useNuxt()) {
  let compatibility;
  if (provider === "stackblitz") {
    compatibility = RuntimeCompatibility.stackblitz;
  } else if (nuxt.options.dev || nuxt.options._prepare || nuxt.options._generate) {
    compatibility = {
      wasm: "fetch",
      browser: "universal"
    };
  } else {
    const target = getNitroPreset(nuxt);
    const lookup = RuntimeCompatibility[target];
    if (lookup === false)
      return false;
    compatibility = lookup || {};
  }
  compatibility = defu$1(overrides, compatibility, DefaultRuntimeCompatibility);
  return compatibility;
}
function ensureDependencies(nuxt, dep) {
  return Promise.all(dep.map((d) => {
    return addDependency(d, { cwd: nuxt.options.rootDir });
  }));
}

function extendTypes(module, template) {
  const nuxt = useNuxt();
  const { resolve } = createResolver(import.meta.url);
  addTemplate({
    filename: `module/${module}.d.ts`,
    getContents: async () => {
      const typesPath = relative(resolve(nuxt.options.rootDir, nuxt.options.buildDir, "module"), resolve("runtime/types"));
      const s = await template({ typesPath });
      return `// Generated by ${module}
${s}
export {}
`;
    }
  });
  nuxt.hooks.hook("prepare:types", ({ references }) => {
    references.push({ path: resolve(nuxt.options.buildDir, `module/${module}.d.ts`) });
  });
}

const PATH = "/__nuxt_og_image__";
const PATH_ENTRY = `${PATH}/entry`;
const PATH_PLAYGROUND = `${PATH}/client`;
const module = defineNuxtModule({
  meta: {
    name: "nuxt-og-image",
    compatibility: {
      nuxt: "^3.7.0",
      bridge: false
    },
    configKey: "ogImage"
  },
  defaults(nuxt) {
    return {
      enabled: true,
      defaults: {
        provider: "satori",
        component: "OgImageTemplateFallback",
        width: 1200,
        height: 630,
        cache: true,
        // default is to cache the image for 1 day (24 hours)
        cacheTtl: 24 * 60 * 60 * 1e3
      },
      componentDirs: ["OgImage", "OgImageTemplate"],
      runtimeSatori: true,
      runtimeBrowser: nuxt.options.dev,
      fonts: [],
      runtimeCacheStorage: true,
      satoriOptions: {},
      playground: process.env.NODE_ENV === "development" || nuxt.options.dev,
      debug: false
    };
  },
  async setup(config, nuxt) {
    const logger = useLogger("nuxt-og-image");
    logger.level = config.debug || nuxt.options.debug ? 4 : 3;
    if (config.enabled === false) {
      logger.debug("The module is disabled, skipping setup.");
      return;
    }
    const { resolve } = createResolver(import.meta.url);
    logger.debug("Using Nitro preset", getNitroPreset());
    const nitroCompatibility = getNitroProviderCompatibility(config.runtimeCompatibility || {});
    logger.debug("Nitro compatibility", nitroCompatibility);
    const nitroTarget = process.env.NITRO_PRESET || nuxt.options.nitro.preset || provider;
    if (!nitroCompatibility) {
      logger.warn(`\`nuxt-og-image\` does not support the nitro preset \`${nitroTarget}\`. Please make an issue. `);
      return;
    }
    if (!nitroCompatibility.browser && config.runtimeBrowser) {
      config.runtimeBrowser = false;
      logger.warn(`\`nuxt-og-image\` does not support the nitro target \`${nitroTarget}\` with the runtime browser. Set runtimeBrowser: false to stop seeing this.`);
    }
    if (config.runtimeBrowser && nitroCompatibility.browser === "lambda") {
      logger.info(`\`nuxt-og-image\` is deploying to nitro target \`${nitroTarget}\` that installs extra dependencies.`);
      await ensureDependencies(nuxt, ["puppeteer-core@14.1.1", "@sparticuz/chrome-aws-lambda@14.1.1"]);
    }
    await installNuxtSiteConfig();
    updateSiteConfig({
      _context: "nuxt-og-image:config",
      url: config.siteUrl || config.host
    });
    nuxt.options.nitro.storage = nuxt.options.nitro.storage || {};
    if (nuxt.options._generate) {
      nuxt.options.nitro.storage["og-image"] = {
        driver: "memory"
      };
    } else if (config.runtimeCacheStorage && !nuxt.options.dev && typeof config.runtimeCacheStorage === "object") {
      nuxt.options.nitro.storage["og-image"] = config.runtimeCacheStorage;
    }
    if (!config.fonts.length)
      config.fonts = ["Inter:400", "Inter:700"];
    const distResolve = (p) => {
      const cwd = resolve(".");
      if (cwd.endsWith("/dist"))
        return resolve(p);
      return resolve(`../dist/${p}`);
    };
    nuxt.options.experimental.componentIslands = true;
    extendTypes("nuxt-og-image", ({ typesPath }) => {
      return `
declare module 'nitropack' {
  interface NitroRouteRules {
    ogImage?: false | import('${typesPath}').OgImageOptions
  }
  interface NitroRouteConfig {
    ogImage?: false | import('${typesPath}').OgImageOptions
  }
}`;
    });
    addServerHandler({
      lazy: true,
      handler: resolve("./runtime/nitro/middleware/og.png")
    });
    ["html", "options", "svg", "vnode", "font", "debug"].forEach((type) => {
      if (type !== "debug" || config.debug) {
        addServerHandler({
          lazy: true,
          route: `/api/og-image-${type}`,
          handler: resolve(`./runtime/nitro/routes/${type}`)
        });
      }
    });
    nuxt.hook("devtools:customTabs", (iframeTabs) => {
      iframeTabs.push({
        name: "ogimage",
        title: "OG Image",
        icon: "carbon:image-search",
        view: {
          type: "iframe",
          src: "/__nuxt_og_image__/client/"
        }
      });
    });
    if (config.playground) {
      const playgroundDir = distResolve("./client");
      const {
        middleware: rpcMiddleware
      } = setupPlaygroundRPC(nuxt, config);
      nuxt.hook("vite:serverCreated", async (server) => {
        server.middlewares.use(PATH_ENTRY, tinyws());
        server.middlewares.use(PATH_ENTRY, rpcMiddleware);
        if (await pathExists(playgroundDir))
          server.middlewares.use(PATH_PLAYGROUND, sirv(playgroundDir, { single: true, dev: true }));
      });
      addServerHandler({
        handler: resolve("./runtime/nitro/middleware/playground")
      });
    }
    nuxt.options.optimization.treeShake.composables.client["nuxt-og-image"] = [];
    [
      // deprecated
      "Dynamic",
      "Static",
      // new
      "index",
      "Cached",
      "WithoutCache",
      "Screenshot"
    ].forEach((name) => {
      name = name === "index" ? "defineOgImage" : `defineOgImage${name}`;
      addImports({
        name,
        from: resolve("./runtime/composables/defineOgImage")
      });
      nuxt.options.optimization.treeShake.composables.client["nuxt-og-image"].push(name);
    });
    await addComponent({
      name: "OgImageTemplateFallback",
      filePath: resolve("./runtime/components/OgImageTemplate/Fallback.vue"),
      island: true
    });
    [
      // deprecated
      "Static",
      "Dynamic",
      // new
      "index",
      "Cached",
      "WithoutCache",
      "Screenshot"
    ].forEach((name) => {
      addComponent({
        global: hasNuxtModule("@nuxt/content"),
        name: name === "index" ? "OgImage" : `OgImage${name}`,
        filePath: resolve(`./runtime/components/OgImage/${name}`)
      });
    });
    const ogImageComponents = [];
    nuxt.hook("components:extend", (components) => {
      components.forEach((component) => {
        let valid = false;
        config.componentDirs.forEach((dir) => {
          if (component.pascalName.startsWith(dir) || component.kebabName.startsWith(dir) || component.shortPath.includes(`/${dir}/`))
            valid = true;
        });
        if (valid || component.pascalName === "OgImageTemplateFoo") {
          component.island = true;
          component.mode = "server";
          ogImageComponents.push({
            // purge cache when component changes
            hash: hash(fs.readFileSync(component.filePath, "utf-8")),
            pascalName: component.pascalName,
            kebabName: component.kebabName
          });
        }
      });
    });
    addTemplate({
      filename: "og-image-component-names.mjs",
      getContents() {
        return `export const componentNames = ${JSON.stringify(ogImageComponents)}`;
      },
      options: { mode: "server" }
    });
    const runtimeDir = resolve("./runtime");
    nuxt.options.build.transpile.push(runtimeDir);
    addServerPlugin(resolve("./runtime/nitro/plugins/prerender"));
    const customAssetDirs = [
      // allows us to show custom error images
      resolve("./runtime/public-assets")
    ];
    if (config.runtimeSatori) {
      if (config.fonts.includes("Inter:400"))
        customAssetDirs.push(resolve("./runtime/public-assets-optional/inter-font"));
      if (nitroCompatibility.png === "resvg-wasm" && nitroCompatibility.wasm === "fetch")
        customAssetDirs.push(resolve("./runtime/public-assets-optional/resvg"));
      else if (nitroCompatibility.png === "svg2png" && nitroCompatibility.wasm === "fetch")
        customAssetDirs.push(resolve("./runtime/public-assets-optional/svg2png"));
      if (nitroCompatibility.satori === "yoga-wasm")
        customAssetDirs.push(resolve("./runtime/public-assets-optional/yoga"));
    }
    nuxt.hooks.hook("modules:done", async () => {
      nuxt.hooks.callHook("og-image:config", config);
      nuxt.options.runtimeConfig["nuxt-og-image"] = {
        version,
        satoriOptions: config.satoriOptions,
        runtimeSatori: config.runtimeSatori,
        runtimeBrowser: config.runtimeBrowser,
        // @ts-expect-error runtime type
        defaults: config.defaults,
        // avoid adding credentials
        runtimeCacheStorage: typeof config.runtimeCacheStorage === "boolean" ? "default" : config.runtimeCacheStorage.driver,
        // convert the fonts to uniform type to fix ts issue
        fonts: config.fonts.map((f) => {
          if (typeof f === "string") {
            const [name, weight] = f.split(":");
            return {
              name,
              weight
            };
          }
          return f;
        }),
        assetDirs: [
          resolve(nuxt.options.srcDir, nuxt.options.dir.public),
          ...customAssetDirs,
          // always add runtime dirs for prerendering to work, these are just used as scan roots
          resolve("./runtime/public-assets-optional/inter-font"),
          resolve("./runtime/public-assets-optional/resvg"),
          resolve("./runtime/public-assets-optional/yoga"),
          resolve("./runtime/public-assets-optional/svg2png")
        ]
      };
    });
    nuxt.hooks.hook("nitro:config", async (nitroConfig) => {
      nitroConfig.externals = defu$1(nitroConfig.externals || {}, {
        inline: [runtimeDir]
      });
      if (!nitroCompatibility.node) {
        nitroConfig.alias = nitroConfig.alias || {};
        if (config.runtimeBrowser) {
          nitroConfig.alias.electron = "unenv/runtime/mock/proxy-cjs";
          nitroConfig.alias.bufferutil = "unenv/runtime/mock/proxy-cjs";
          nitroConfig.alias["utf-8-validate"] = "unenv/runtime/mock/proxy-cjs";
        }
        nitroConfig.alias.queue = "unenv/runtime/mock/proxy-cjs";
      }
      if (nitroCompatibility.png === "resvg-wasm")
        nitroConfig.alias["@resvg/resvg-js"] = "unenv/runtime/mock/proxy-cjs";
      nitroConfig.publicAssets = nitroConfig.publicAssets || [];
      customAssetDirs.forEach((dir) => {
        nitroConfig.publicAssets.push({ dir, maxAge: 31536e3 });
      });
      const providerPath = `${runtimeDir}/nitro/providers`;
      nitroConfig.virtual["#nuxt-og-image/css-inline"] = `import cssInline from '${providerPath}/css-inline/${nitroCompatibility.cssInline ? "css-inline" : "mock"}'
export default function() {
 return cssInline
}
`;
      if (config.runtimeBrowser) {
        nitroConfig.virtual["#nuxt-og-image/browser"] = `
let browser
export default async function() {
  browser = browser || await import('${providerPath}/browser/${nitroCompatibility.browser}').then((m) => m.default || m)
  return browser
}
`;
      }
      if (config.runtimeSatori) {
        nitroConfig.virtual["#nuxt-og-image/satori"] = `import satori from '${providerPath}/satori/${nitroCompatibility.satori}'
export default function() {
  return satori
}`;
        nitroConfig.virtual["#nuxt-og-image/png"] = `import png from '${providerPath}/png/${nitroCompatibility.png}'
export default function() {
 return png
}
`;
      }
      const rendererPath = `${runtimeDir}/nitro/renderers`;
      nitroConfig.virtual["#nuxt-og-image/provider"] = `
${config.runtimeSatori ? `import satori from '${rendererPath}/satori'` : ""}
${config.runtimeBrowser ? `import browser from '${rendererPath}/browser'` : ""}

export async function useProvider(provider) {
  if (provider === 'satori')
    return ${config.runtimeSatori ? "satori" : "null"}
  if (provider === 'browser')
    return ${config.runtimeBrowser ? "browser" : "null"}
  return null
}
      `;
    });
    nuxt.hooks.hook("nitro:init", async (nitro) => {
      let screenshotQueue = [];
      nitro.hooks.hook("compiled", async (_nitro) => {
        if (!config.runtimeSatori || nuxt.options.dev)
          return;
        if (config.fonts.includes("Inter:400"))
          await copy(resolve("./runtime/public-assets-optional/inter-font/inter-latin-ext-400-normal.woff"), resolve(_nitro.options.output.publicDir, "inter-latin-ext-400-normal.woff"));
        if (config.fonts.includes("Inter:700"))
          await copy(resolve("./runtime/public-assets-optional/inter-font/inter-latin-ext-700-normal.woff"), resolve(_nitro.options.output.publicDir, "inter-latin-ext-700-normal.woff"));
        const configuredEntry = nitro.options.rollupConfig?.output.entryFileNames;
        const wasmProviderPath = resolve(_nitro.options.output.serverDir, typeof configuredEntry === "string" ? configuredEntry : "index.mjs");
        const paths = [wasmProviderPath];
        const chunks = await globby([`${_nitro.options.output.serverDir}/chunks/**/*.mjs`], { absolute: true });
        paths.push(...chunks);
        for (const path of paths) {
          if (!await pathExists(path))
            continue;
          let contents = await readFile(path, "utf-8");
          let updated = false;
          for (const wasm of Wasms) {
            if (contents.includes(wasm.placeholder)) {
              if (nitroCompatibility.wasm === "import") {
                contents = contents.replace(wasm.placeholder, `import("./${wasm.file}${nitroCompatibility.wasmImportQuery || ""}").then(m => m.default || m)`);
                await copy(resolve(`./runtime/public-assets-optional/${wasm.path}`), resolve(dirname(path), wasm.file));
              } else if (nitroCompatibility.wasm === "inline") {
                const wasmBuffer = await readFile(resolve(`./runtime/public-assets-optional/${wasm.path}`));
                contents = contents.replace(wasm.placeholder, `Buffer.from("${wasmBuffer}", "base64")`);
              }
              updated = true;
            }
          }
          if (updated)
            await writeFile(path, contents, { encoding: "utf-8" });
        }
      });
      const _routeRulesMatcher = toRouteMatcher(
        createRouter({ routes: nitro.options.routeRules })
      );
      nitro.hooks.hook("prerender:generate", async (ctx) => {
        if (ctx.route.includes("."))
          return;
        const html = ctx.contents;
        if (!html)
          return;
        const routeRules = defu$1({}, ..._routeRulesMatcher.matchAll(ctx.route).reverse());
        const extractedOptions = extractAndNormaliseOgImageOptions(ctx.route, html, routeRules.ogImage || {}, config.defaults);
        if (!extractedOptions || routeRules.ogImage === false)
          return;
        const isPageScreenshot = extractedOptions.component === "PageScreenshot";
        const entry = {
          route: parsePath(ctx.route).pathname,
          // drop hash and query
          path: !isPageScreenshot ? `/api/og-image-html?path=${ctx.route}` : ctx.route,
          ...extractedOptions
        };
        if (screenshotQueue.some((r) => r.route === entry.route))
          return;
        if ((nuxt.options._generate || entry.cache) && entry.provider === "browser")
          screenshotQueue.push(entry);
      });
      if (nuxt.options.dev)
        return;
      const captureScreenshots = async () => {
        await nuxt.callHook("og-image:prerenderScreenshots", screenshotQueue);
        if (screenshotQueue.length === 0)
          return;
        nitro.logger.info("Ensuring chromium install for og:image generation...");
        const installChromeProcess = execa("npx", ["playwright", "install", "chromium"], {
          stdio: "inherit"
        });
        installChromeProcess.stderr?.pipe(process.stderr);
        await new Promise((resolve2) => {
          installChromeProcess.on("exit", (e) => {
            if (e !== 0)
              nitro.logger.error("Failed to install Playwright dependency for og:image generation. Trying anyway...");
            resolve2(true);
          });
        });
        installChromeProcess.pid && terminate(installChromeProcess.pid);
        const browser = await createBrowser();
        if (!browser) {
          nitro.logger.log(chalk.red("Failed to create a browser to create og:images."));
          return;
        }
        nitro.logger.info("Creating server for og:image generation...");
        const previewProcess = execa("npx", ["serve", nitro.options.output.publicDir]);
        try {
          const host = (await new Promise((resolve2) => {
            previewProcess.stdout?.on("data", (data) => {
              if (data.includes("Accepting connections at")) {
                resolve2(data.toString().split("Accepting connections at ")[1]);
              }
            });
          })).trim();
          previewProcess.removeAllListeners("data");
          nitro.logger.info(`Prerendering ${screenshotQueue.length} og:image screenshots...`);
          for (const k in screenshotQueue) {
            let entry = screenshotQueue[k];
            if (entry.route && Object.keys(entry).length === 1) {
              const html = await $fetch(entry.route, { baseURL: withBase(nuxt.options.app.baseURL, host) });
              const routeRules = defu$1({}, ..._routeRulesMatcher.matchAll(entry.route).reverse());
              const extractedOptions = extractAndNormaliseOgImageOptions(entry.route, html, routeRules.ogImage || {}, {
                ...config.defaults,
                component: "PageScreenshot"
              });
              if (!extractedOptions || routeRules.ogImage === false) {
                entry.skip = true;
                continue;
              }
              screenshotQueue[k] = entry = defu$1(
                { path: extractedOptions.component !== "PageScreenshot" ? `/api/og-image-html?path=${entry.route}` : entry.route },
                entry,
                extractedOptions
              );
            }
            if (!entry.skip && entry.component !== "PageScreenshot")
              entry.html = await globalThis.$fetch(entry.path);
          }
          for (const k in screenshotQueue) {
            const entry = screenshotQueue[k];
            if (entry.skip)
              continue;
            const start = Date.now();
            let hasError = false;
            const dirname2 = joinURL(nitro.options.output.publicDir, entry.route, "/__og_image__/");
            const filename = joinURL(dirname2, "/og.png");
            try {
              const imgBuffer = await screenshot(browser, {
                ...config.defaults || {},
                ...entry || {},
                host
              });
              try {
                await mkdirp(dirname2);
              } catch (e) {
              }
              await writeFile(filename, imgBuffer);
            } catch (e) {
              hasError = true;
              console.error(e);
            }
            const generateTimeMS = Date.now() - start;
            nitro.logger.log(chalk[hasError ? "red" : "gray"](
              `  ${Number(k) === screenshotQueue.length - 1 ? "\u2514\u2500" : "\u251C\u2500"} /${relative(nitro.options.output.publicDir, filename)} (${generateTimeMS}ms) ${Math.round((Number(k) + 1) / screenshotQueue.length * 100)}%`
            ));
          }
        } catch (e) {
          console.error(e);
        } finally {
          await browser?.close();
          previewProcess.pid && terminate(previewProcess.pid);
        }
        screenshotQueue = [];
      };
      nitro.hooks.hook("rollup:before", async () => {
        await captureScreenshots();
      });
      nitro.hooks.hook("close", async () => {
        await captureScreenshots();
      });
    });
  }
});

export { module as default };
