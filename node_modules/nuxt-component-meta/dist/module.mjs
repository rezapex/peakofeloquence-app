import { readFileSync } from 'fs';
import { createResolver, resolveAlias, logger, defineNuxtModule, resolveModule, addImportsDir, addTemplate, addServerHandler } from '@nuxt/kit';
import { join } from 'pathe';
import { createUnplugin } from 'unplugin';
import { useComponentMetaParser } from './parser.mjs';
import 'fs/promises';
import 'perf_hooks';
import 'vue-component-meta';

const metaPlugin = createUnplugin(
  ({ parser, parserOptions }) => {
    const instance = parser || useComponentMetaParser(parserOptions);
    let _configResolved;
    return {
      name: "vite-plugin-nuxt-component-meta",
      enforce: "post",
      async buildStart() {
        if (_configResolved?.build.ssr) {
          return;
        }
        await instance.fetchComponents();
        await instance.updateOutput();
      },
      vite: {
        configResolved(config) {
          _configResolved = config;
        },
        async handleHotUpdate({ file }) {
          if (Object.entries(instance.components).some(([, comp]) => comp.fullPath === file)) {
            await instance.fetchComponent(file);
            await instance.updateOutput();
          }
        }
      }
    };
  }
);

async function loadExternalSources(sources = []) {
  const resolver = createResolver(import.meta.url);
  const components = {};
  for (const src of sources) {
    if (typeof src === "string") {
      try {
        let modulePath = "";
        const alias = resolveAlias(src);
        if (alias !== src) {
          modulePath = alias;
        } else {
          modulePath = await resolver.resolvePath(src);
        }
        const definition = await import(modulePath).then((m) => m.default || m);
        for (const [name, meta] of Object.entries(definition)) {
          components[name] = meta;
        }
      } catch (error) {
        logger.error(`Unable to load static components definitions from "${src}"`, error);
      }
    } else {
      for (const [name, meta] of Object.entries(src)) {
        if (meta) {
          components[name] = meta;
        }
      }
    }
  }
  return components;
}

const module = defineNuxtModule({
  meta: {
    name: "nuxt-component-meta",
    configKey: "componentMeta"
  },
  defaults: (nuxt) => ({
    outputDir: nuxt.options.buildDir,
    rootDir: nuxt.options.rootDir,
    componentDirs: [],
    components: [],
    metaSources: [],
    silent: true,
    exclude: ["nuxt/dist/app/components/client-only", "nuxt/dist/app/components/dev-only", "@nuxtjs/mdc/dist/runtime/components/MDC"],
    metaFields: {
      type: true,
      props: true,
      slots: true,
      events: true,
      exposed: true
    },
    transformers: [
      // @nuxt/content support
      (component, code) => {
        code = code.replace(
          /<ContentSlot\s*([^>]*)?:use="\$slots\.([a-zA-Z0-9_]+)"/gm,
          (_, _before, slotName, _rest) => {
            return `<slot ${_before || ""}${slotName === "default" ? "" : `name="${slotName}"`}`;
          }
        );
        code = code.replace(
          /<ContentSlot\s*([^>]*)?name="([a-zA-Z0-9_]+)"/gm,
          (_, _before, slotName, _rest) => {
            return `<slot ${_before || ""}${slotName === "default" ? "" : `name="${slotName}"`}`;
          }
        );
        code = code.replace(/<\/ContentSlot>/gm, "</slot>");
        const name = code.match(/(const|let|var) ([a-zA-Z][a-zA-Z-_0-9]*) = useSlots\(\)/)?.[2] || "$slots";
        const _slots = code.match(new RegExp(`${name}\\.[a-zA-Z]+`, "gm"));
        if (_slots) {
          const slots = _slots.map((s) => s.replace(name + ".", "")).map((s) => `<slot name="${s}" />`);
          code = code.replace(/<template>/, `<template>
${slots.join("\n")}
`);
        }
        const slotNames = code.match(/(const|let|var) {([^}]+)}\s*=\s*useSlots\(\)/)?.[2];
        if (slotNames) {
          const slots = slotNames.trim().split(",").map((s) => s.trim().split(":")[0].trim()).map((s) => `<slot name="${s}" />`);
          code = code.replace(/<template>/, `<template>
${slots.join("\n")}
`);
        }
        return { component, code };
      }
    ],
    checkerOptions: {
      forceUseTs: true,
      schema: {
        ignore: [
          "NuxtComponentMetaNames",
          // avoid loop
          "RouteLocationRaw",
          // vue router
          "RouteLocationPathRaw",
          // vue router
          "RouteLocationNamedRaw"
          // vue router
        ]
      }
    },
    globalsOnly: false
  }),
  async setup(options, nuxt) {
    const resolver = createResolver(import.meta.url);
    let parser;
    const parserOptions = {
      ...options,
      components: [],
      metaSources: {}
    };
    let transformers = options?.transformers || [];
    transformers = await nuxt.callHook("component-meta:transformers", transformers);
    let componentDirs = [...options?.componentDirs || []];
    let components = [];
    let metaSources = {};
    nuxt.hook("components:dirs", (dirs) => {
      componentDirs = [
        ...componentDirs,
        ...dirs,
        { path: resolveModule("nuxt").replace("/index.mjs", "/app") },
        { path: resolveModule("@nuxt/ui-templates").replace("/index.mjs", "/templates") }
      ];
      parserOptions.componentDirs = componentDirs;
    });
    nuxt.hook("components:extend", (_components) => {
      _components.forEach((c) => {
        if (c.global) {
          parserOptions.componentDirs.push(c.filePath);
        }
      });
    });
    nuxt.hook("components:extend", async (_components) => {
      components = _components;
      if (options?.globalsOnly) {
        components = components.filter((c) => c.global);
      }
      metaSources = await loadExternalSources(options.metaSources);
      parserOptions.components = components;
      parserOptions.metaSources = metaSources;
      await nuxt.callHook("component-meta:extend", parserOptions);
      parser = useComponentMetaParser(parserOptions);
      await parser.stubOutput();
    });
    addImportsDir(resolver.resolve("./runtime/composables"));
    addTemplate({
      filename: "component-meta.mjs",
      getContents: () => "export default {}",
      write: true
    });
    addTemplate({
      filename: "component-meta.d.ts",
      getContents: () => [
        "import type { ComponentData } from 'nuxt-component-meta'",
        `export type NuxtComponentMetaNames = ${[...components, ...Object.values(metaSources)].map((c) => `'${c.pascalName}'`).join(" | ")}`,
        "export type NuxtComponentMeta = Record<NuxtComponentMetaNames, ComponentData>",
        "declare const components: NuxtComponentMeta",
        "export { components as default, components }"
      ].join("\n"),
      write: true
    });
    nuxt.hook("vite:extend", (vite) => {
      vite.config.plugins = vite.config.plugins || [];
      vite.config.plugins.push(metaPlugin.vite({ parser, parserOptions }));
    });
    nuxt.options.alias = nuxt.options.alias || {};
    nuxt.options.alias["#nuxt-component-meta"] = join(nuxt.options.buildDir, "component-meta.mjs");
    nuxt.options.alias["#nuxt-component-meta/types"] = join(nuxt.options.buildDir, "component-meta.d.ts");
    nuxt.hook("prepare:types", ({ tsConfig, references }) => {
      references.push({
        path: join(nuxt.options.buildDir, "component-meta.d.ts")
      });
    });
    nuxt.hook("nitro:config", (nitroConfig) => {
      nitroConfig.handlers = nitroConfig.handlers || [];
      nitroConfig.virtual = nitroConfig.virtual || {};
      nitroConfig.virtual["#nuxt-component-meta/nitro"] = () => readFileSync(join(nuxt.options.buildDir, "/component-meta.mjs"), "utf-8");
    });
    addServerHandler({
      method: "get",
      route: "/api/component-meta",
      handler: resolver.resolve("./runtime/server/api/component-meta.get")
    });
    addServerHandler({
      method: "get",
      route: "/api/component-meta.json",
      handler: resolver.resolve("./runtime/server/api/component-meta.get")
    });
    addServerHandler({
      method: "get",
      route: "/api/component-meta/:component?",
      handler: resolver.resolve("./runtime/server/api/component-meta.get")
    });
  }
});

export { module as default };
