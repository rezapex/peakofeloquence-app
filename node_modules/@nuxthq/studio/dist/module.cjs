'use strict';

const node_fs = require('node:fs');
const path = require('path');
const defu = require('defu');
const kit = require('@nuxt/kit');
const pkgTypes = require('pkg-types');
const gitUrlParse = require('git-url-parse');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const path__default = /*#__PURE__*/_interopDefaultCompat(path);
const gitUrlParse__default = /*#__PURE__*/_interopDefaultCompat(gitUrlParse);

const version = "1.0.13";

const log = kit.logger.withTag("@nuxt/studio");
const module$1 = kit.defineNuxtModule({
  meta: {
    name: "studio",
    configKey: "studio"
  },
  defaults: {
    enabled: "production",
    project: ""
  },
  async setup(options, nuxt) {
    nuxt.hook("schema:resolved", (schema) => {
      nuxt.options.runtimeConfig.appConfigSchema = {
        properties: schema.properties?.appConfig,
        default: schema.default?.appConfig
      };
      nuxt.options.runtimeConfig.contentSchema = schema.properties?.content || {};
    });
    nuxt.hook("app:resolve", (appCtx) => {
      const studioAppConfigPath = kit.resolveAlias("~/.studio/app.config.json");
      if (node_fs.existsSync(studioAppConfigPath)) {
        appCtx.configs.unshift(studioAppConfigPath);
      }
    });
    if (options.enabled === "production" && nuxt.options.dev === true) {
      return;
    }
    const contentModule = "@nuxt/content";
    if (!nuxt.options.runtimeConfig.content && !nuxt.options.modules.includes(contentModule)) {
      log.warn("Could not find `@nuxt/content` module. Please install it to enable preview mode.");
      return;
    }
    const contentModuleVersion = await import(contentModule).then((m) => m.default || m).then((m) => m.getMeta()).then((m) => m.version).catch(() => "0");
    if (contentModuleVersion < "2.1.1") {
      log.warn("Please update `@nuxt/content` to version 2.1.1 or higher to enable preview mode.");
      return;
    }
    nuxt.hook("pinceau:options", (options2) => {
      options2.studio = true;
    });
    const { resolve } = kit.createResolver((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.src || new URL('module.cjs', document.baseURI).href)));
    const apiURL = process.env.NUXT_PUBLIC_STUDIO_API_URL || process.env.STUDIO_API || "https://api.nuxt.studio";
    const publicToken = process.env.NUXT_PUBLIC_STUDIO_TOKENS;
    const iframeMessagingAllowedOrigins = process.env.IFRAME_MESSAGING_ALLOWED_ORIGINS;
    const gitInfo = await _getLocalGitInfo(nuxt.options.rootDir) || _getGitEnv() || {};
    nuxt.options.runtimeConfig.studio = defu.defu(nuxt.options.runtimeConfig.studio, {
      version,
      publicToken,
      project: options.project,
      gitInfo
    });
    nuxt.options.runtimeConfig.public.studio = defu.defu(nuxt.options.runtimeConfig.public.studio, { apiURL, iframeMessagingAllowedOrigins });
    kit.extendViteConfig((config) => {
      config.optimizeDeps = config.optimizeDeps || {};
      config.optimizeDeps.include = config.optimizeDeps.include || [];
      config.optimizeDeps.include.push(
        "socket.io-client",
        "slugify"
      );
    });
    if (contentModuleVersion === "2.10.0") {
      kit.addVitePlugin({
        name: "content-resolver",
        enforce: "pre",
        resolveId(id, importer) {
          if (id.endsWith(".mjs") && ((importer || "").includes("@nuxt/content/dist") || id.includes("@nuxt/content/dist"))) {
            id = id.replace(".mjs", ".js").replace(/^\/node_modules/, "./node_modules/");
            return path__default.resolve(path__default.dirname(importer || __dirname), id.replace(".mjs", ".js"));
          }
        }
      });
    }
    kit.addPlugin(resolve("./runtime/plugins/preview.client"));
    kit.addComponentsDir({ path: resolve("./runtime/components") });
    kit.addServerHandler({
      method: "get",
      route: "/__studio.json",
      handler: resolve("./runtime/server/routes/studio")
    });
    kit.addPrerenderRoutes("/__studio.json");
    await kit.installModule("nuxt-component-meta", {
      globalsOnly: true
    });
  }
});
async function _getLocalGitInfo(rootDir) {
  const remote = await _getLocalGitRemote(rootDir);
  if (!remote) {
    return;
  }
  const { name, owner, source } = gitUrlParse__default(remote);
  const url = `https://${source}/${owner}/${name}`;
  return {
    name,
    owner,
    url
  };
}
async function _getLocalGitRemote(dir) {
  try {
    const parseGitConfig = await import('parse-git-config').then(
      (m) => m.promise || m.default || m
    );
    const gitDir = await pkgTypes.findNearestFile(".git/config", { startingFrom: dir });
    const parsed = await parseGitConfig({ path: gitDir });
    if (!parsed) {
      return;
    }
    const gitRemote = parsed['remote "origin"'].url;
    return gitRemote;
  } catch (err) {
  }
}
function _getGitEnv() {
  const envInfo = {
    // Provider
    provider: process.env.VERCEL_GIT_PROVIDER || // vercel
    (process.env.GITHUB_SERVER_URL ? "github" : void 0) || // github
    "",
    // Owner
    owner: process.env.VERCEL_GIT_REPO_OWNER || // vercel
    process.env.GITHUB_REPOSITORY_OWNER || // github
    process.env.CI_PROJECT_PATH?.split("/").shift() || // gitlab
    "",
    // Name
    name: process.env.VERCEL_GIT_REPO_SLUG || process.env.GITHUB_REPOSITORY?.split("/").pop() || // github
    process.env.CI_PROJECT_PATH?.split("/").splice(1).join("/") || // gitlab
    "",
    // Url
    url: process.env.REPOSITORY_URL || ""
    // netlify
  };
  if (!envInfo.url && envInfo.provider && envInfo.owner && envInfo.name) {
    envInfo.url = `https://${envInfo.provider}.com/${envInfo.owner}/${envInfo.name}`;
  }
  if (!envInfo.name && !envInfo.owner && envInfo.url) {
    try {
      const { name, owner } = gitUrlParse__default(envInfo.url);
      envInfo.name = name;
      envInfo.owner = owner;
    } catch {
    }
  }
  return {
    name: envInfo.name,
    owner: envInfo.owner,
    url: envInfo.url
  };
}

module.exports = module$1;
