import { createApp } from "vue";
import { createDefu } from "defu";
import { callWithNuxt } from "#app";
import ContentPreviewMode from "../components/ContentPreviewMode.vue";
import { createSingleton, deepAssign, deepDelete, mergeDraft, StudioConfigFiles } from "../utils/index.mjs";
import { useAppConfig, useNuxtApp, useRuntimeConfig, useState, useContentState, queryContent, ref, toRaw, useRoute, useRouter } from "#imports";
const useDefaultAppConfig = createSingleton(() => JSON.parse(JSON.stringify(useAppConfig())));
const defu = createDefu((obj, key, value) => {
  if (Array.isArray(obj[key]) && Array.isArray(value)) {
    obj[key] = value;
    return true;
  }
});
export const useStudio = () => {
  const nuxtApp = useNuxtApp();
  const { studio: studioConfig, content: contentConfig } = useRuntimeConfig().public;
  const contentPathMap = {};
  const apiURL = window.sessionStorage.getItem("previewAPI") || studioConfig?.apiURL;
  const initialAppConfig = useDefaultAppConfig();
  let initialTokensConfig;
  const storage = useState("studio-client-db", () => null);
  const dbFiles = useState("studio-preview-db-files", () => []);
  if (!storage.value) {
    nuxtApp.hook("content:storage", (_storage) => {
      storage.value = _storage;
    });
    queryContent("/non-existing-path").findOne();
  }
  const syncPreviewFiles = async (contentStorage, files) => {
    const previewToken = window.sessionStorage.getItem("previewToken");
    const keys = await contentStorage.getKeys(`${previewToken}:`);
    await Promise.all(keys.map((key) => contentStorage.removeItem(key)));
    const sources = new Set(files.map((file) => file.parsed._id.split(":").shift()));
    await contentStorage.setItem(`${previewToken}$`, JSON.stringify({ ignoreSources: Array.from(sources) }));
    await Promise.all(
      files.map((item) => {
        contentPathMap[item.parsed._path] = item.parsed;
        return contentStorage.setItem(`${previewToken}:${item.parsed._id}`, JSON.stringify(item.parsed));
      })
    );
  };
  const syncPreviewAppConfig = (appConfig) => {
    const _appConfig = callWithNuxt(nuxtApp, useAppConfig);
    if (_appConfig?.ui) {
      _appConfig.ui.icons = { ..._appConfig.ui.icons, dynamic: true };
    }
    deepAssign(_appConfig, defu(appConfig, initialAppConfig));
    if (!appConfig) {
      deepDelete(_appConfig, initialAppConfig);
    }
  };
  const syncPreviewTokensConfig = (tokensConfig) => {
    const themeSheet = nuxtApp?.vueApp?._context?.config?.globalProperties?.$pinceauTheme;
    if (!themeSheet || !themeSheet?.updateTheme) {
      return;
    }
    if (!initialTokensConfig) {
      initialTokensConfig = JSON.parse(JSON.stringify(themeSheet?.theme.value || {}));
    }
    callWithNuxt(
      nuxtApp,
      themeSheet.updateTheme,
      [
        // Using `defu` to merge with initial tokens
        // This is important to revert to default values for missing properties
        defu(tokensConfig, initialTokensConfig)
      ]
    );
  };
  const syncPreview = async (data) => {
    dbFiles.value = data.files = data.files || dbFiles.value || [];
    if (!storage.value) {
      return false;
    }
    const mergedFiles = mergeDraft(data.files, data.additions, data.deletions);
    const contentFiles = mergedFiles.filter((item) => ![StudioConfigFiles.appConfig, StudioConfigFiles.nuxtConfig, StudioConfigFiles.tokensConfig].includes(item.path));
    await syncPreviewFiles(storage.value, contentFiles);
    const appConfig = mergedFiles.find((item) => item.path === StudioConfigFiles.appConfig);
    syncPreviewAppConfig(appConfig?.parsed);
    const tokensConfig = mergedFiles.find((item) => item.path === StudioConfigFiles.tokensConfig);
    syncPreviewTokensConfig(tokensConfig?.parsed);
    requestRerender();
    return true;
  };
  const requestPreviewSynchronization = async () => {
    const previewToken = window.sessionStorage.getItem("previewToken");
    await $fetch("api/projects/preview/sync", {
      baseURL: apiURL,
      method: "POST",
      params: {
        token: previewToken
      }
    });
  };
  const mountPreviewUI = () => {
    const previewToken = window.sessionStorage.getItem("previewToken");
    const el = document.createElement("div");
    el.id = "__nuxt_preview_wrapper";
    document.body.appendChild(el);
    createApp(ContentPreviewMode, {
      previewToken,
      apiURL,
      syncPreview,
      requestPreviewSyncAPI: requestPreviewSynchronization
    }).mount(el);
  };
  const findContentWithId = async (path) => {
    const previewToken = window.sessionStorage.getItem("previewToken");
    if (!path) {
      return null;
    }
    path = path.replace(/\/$/, "");
    let content = await storage.value?.getItem(`${previewToken}:${path}`);
    if (!content) {
      content = await storage.value?.getItem(`cached:${path}`);
    }
    if (!content) {
      content = content = await storage.value?.getItem(path);
    }
    if (!content) {
      content = contentPathMap[path || "/"];
    }
    return content;
  };
  const updateContent = (content) => {
    const previewToken = window.sessionStorage.getItem("previewToken");
    if (!storage.value) {
      return;
    }
    contentPathMap[content.parsed._path] = content.parsed;
    storage.value.setItem(`${previewToken}:${content.parsed?._id}`, JSON.stringify(content.parsed));
  };
  const removeContentWithId = async (path) => {
    const previewToken = window.sessionStorage.getItem("previewToken");
    const content = await findContentWithId(path);
    await storage.value?.removeItem(`${previewToken}:${path}`);
    if (content) {
      delete contentPathMap[content._path];
      const nonDraftContent = await findContentWithId(content._id);
      if (nonDraftContent) {
        contentPathMap[nonDraftContent._path] = nonDraftContent;
      }
    }
  };
  const requestRerender = async () => {
    if (contentConfig?.documentDriven) {
      const { pages } = callWithNuxt(nuxtApp, useContentState);
      const contents = await Promise.all(Object.keys(pages.value).map(async (key) => {
        return await findContentWithId(pages.value[key]?._id ?? key);
      }));
      pages.value = contents.reduce((acc, item, index) => {
        if (item) {
          acc[Object.keys(pages.value)[index]] = item;
        }
        return acc;
      }, {});
    }
    await nuxtApp.hooks.callHookParallel("app:data:refresh");
  };
  return {
    apiURL,
    contentStorage: storage,
    syncPreviewFiles,
    syncPreviewAppConfig,
    syncPreviewTokensConfig,
    requestPreviewSynchronization,
    findContentWithId,
    updateContent,
    removeContentWithId,
    requestRerender,
    mountPreviewUI,
    initiateIframeCommunication
  };
  function initiateIframeCommunication() {
    if (!window.parent || window.self === window.parent) {
      return;
    }
    const router = useRouter();
    const route = useRoute();
    const editorSelectedPath = ref("");
    const routePayload = (route2) => ({
      path: route2.path,
      query: toRaw(route2.query),
      params: toRaw(route2.params),
      fullPath: route2.fullPath,
      meta: toRaw(route2.meta)
    });
    window.addEventListener("keydown", (e) => {
      if (e.metaKey || e.ctrlKey || e.altKey || e.shiftKey) {
        window.parent.postMessage({
          type: "nuxt-studio:preview:keydown",
          payload: {
            key: e.key,
            metaKey: e.metaKey,
            ctrlKey: e.ctrlKey,
            shiftKey: e.shiftKey,
            altKey: e.altKey
          }
        }, "*");
      }
    });
    window.addEventListener("message", async (e) => {
      const allowedOrigins = studioConfig?.iframeMessagingAllowedOrigins?.split(",").map((origin) => origin.trim()) || [];
      if (!["https://nuxt.studio", "https://new.nuxt.studio", "https://new.dev.nuxt.studio", "https://dev.nuxt.studio", "http://localhost:3000", ...allowedOrigins].includes(e.origin)) {
        return;
      }
      const { type, payload = {} } = e.data || {};
      switch (type) {
        case "nuxt-studio:editor:file-selected": {
          const content = await findContentWithId(payload.path);
          if (!content) {
          } else if (content._partial) {
          } else if (content._path !== useRoute().path) {
            editorSelectedPath.value = content._path;
            router.push(content._path);
          }
          break;
        }
        case "nuxt-studio:editor:file-changed": {
          const { additions = [], deletions = [] } = payload;
          for (const addition of additions) {
            await updateContent(addition);
          }
          for (const deletion of deletions) {
            await removeContentWithId(deletion.path);
          }
          requestRerender();
          break;
        }
        case "nuxt-studio:preview:sync": {
          syncPreview(payload);
          break;
        }
        case "nuxt-studio:config:file-changed": {
          const { additions = [], deletions = [] } = payload;
          const appConfig = additions.find((item) => item.path === StudioConfigFiles.appConfig);
          if (appConfig) {
            syncPreviewAppConfig(appConfig?.parsed);
          }
          const shouldRemoveAppConfig = deletions.find((item) => item.path === StudioConfigFiles.appConfig);
          if (shouldRemoveAppConfig) {
            syncPreviewAppConfig(void 0);
          }
          const tokensConfig = additions.find((item) => item.path === StudioConfigFiles.tokensConfig);
          if (tokensConfig) {
            syncPreviewTokensConfig(tokensConfig?.parsed);
          }
          const shouldRemoveTokensConfig = deletions.find((item) => item.path === StudioConfigFiles.tokensConfig);
          if (shouldRemoveTokensConfig) {
            syncPreviewTokensConfig(void 0);
          }
          break;
        }
      }
    });
    nuxtApp.hook("page:finish", () => {
      detectRenderedContents();
      if (nuxtApp.payload.prerenderedAt) {
        requestRerender();
      }
    });
    nuxtApp.hook("content:document-driven:finish", ({ route: route2, page }) => {
      route2.meta.studio_page_contentId = page?._id;
    });
    nuxtApp.hook("nuxt-studio:preview:ready", () => {
      window.parent.postMessage({
        type: "nuxt-studio:preview:ready",
        payload: routePayload(useRoute())
      }, "*");
      setTimeout(() => {
        detectRenderedContents();
      }, 100);
    });
    function detectRenderedContents() {
      const renderedContents = Array.from(window.document.querySelectorAll("[data-content-id]")).map((el) => el.getAttribute("data-content-id"));
      const contentIds = Array.from(/* @__PURE__ */ new Set([route.meta.studio_page_contentId, ...renderedContents])).filter(Boolean);
      if (editorSelectedPath.value === contentIds[0]) {
        editorSelectedPath.value = "";
        return;
      }
      window.openContentInStudioEditor(contentIds, { navigate: true, pageContentId: route.meta.studio_page_contentId });
    }
    window.openContentInStudioEditor = (contentIds, data = {}) => {
      window.parent.postMessage({
        type: "nuxt-studio:preview:navigate",
        payload: {
          ...routePayload(route),
          contentIds,
          ...data
        }
      }, "*");
    };
  }
};
