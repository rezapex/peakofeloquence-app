{
  "resolvedId": "/Users/rezajafar/peakofeloquence-app/node_modules/@nuxt/ui-pro/modules/pro/runtime/components/content/ContentSearch.vue",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "<template>\n  <UModal v-model=\"isOpen\" :overlay=\"!smallerThanSm\" :transition=\"!smallerThanSm\" :ui=\"ui\">\n    <UCommandPalette\n      ref=\"commandPaletteRef\"\n      :model-value=\"[]\"\n      :groups=\"groups\"\n      :ui=\"ui.commandPalette\"\n      :close-button=\"ui.default.closeButton\"\n      :fuse=\"fuse\"\n      multiple\n      v-bind=\"attrs\"\n      @update:model-value=\"onSelect\"\n      @close=\"isOpen = false\"\n    />\n  </UModal>\n</template>\n\n<script setup lang=\"ts\">\nimport type { PropType } from 'vue'\nimport { defu } from 'defu'\nimport { useBreakpoints, breakpointsTailwind } from '@vueuse/core'\nimport type { ParsedContent, NavItem, MarkdownNode } from '@nuxt/content/dist/runtime/types'\nimport type { Group, Command } from '#ui/types'\nimport type { ContentSearchLink } from '#ui-pro/types'\nimport type { UseFuseOptions } from '@vueuse/integrations/useFuse'\n\ndefineOptions({\n  inheritAttrs: false\n})\n\nconst appConfig = useAppConfig()\n\nconst config = computed(() => ({\n  padding: 'p-0 sm:p-4',\n  rounded: 'rounded-none sm:rounded-lg',\n  width: 'sm:max-w-3xl',\n  height: 'h-dvh sm:h-[28rem]',\n  commandPalette: {\n    input: {\n      height: 'h-[--header-height] sm:h-12',\n      icon: {\n        size: 'h-5 w-5',\n        padding: 'ps-11'\n      }\n    },\n    group: {\n      command: {\n        // eslint-disable-next-line quotes\n        prefix: `!text-foreground after:content-['_>']`\n      }\n    },\n    container: 'scroll-py-10'\n  },\n  fileIcon: {\n    name: 'i-heroicons-document-text'\n  },\n  default: {\n    closeButton: {\n      icon: appConfig.ui.icons.close,\n      color: 'gray' as const,\n      variant: 'ghost' as const,\n      size: 'sm' as const\n    }\n  }\n}))\n\nconst props = defineProps({\n  modelValue: {\n    type: Boolean,\n    default: undefined\n  },\n  files: {\n    type: Array as PropType<ParsedContent[]>,\n    default: () => []\n  },\n  navigation: {\n    type: Array as PropType<NavItem[]>,\n    default: () => []\n  },\n  links: {\n    type: Array as PropType<ContentSearchLink[]>,\n    default: () => []\n  },\n  groups: {\n    type: Array as PropType<Group[]>,\n    default: () => []\n  },\n  fuse: {\n    type: Object as PropType<UseFuseOptions<Command>>,\n    default: () => ({})\n  },\n  hideColorMode: {\n    type: Boolean,\n    default: false\n  },\n  ui: {\n    type: Object as PropType<Partial<typeof config.value>>,\n    default: () => ({})\n  }\n})\n\nconst emit = defineEmits(['update:modelValue'])\n\nconst router = useRouter()\nconst { navKeyFromPath } = useContentHelpers()\nconst { usingInput } = useShortcuts()\nconst { isContentSearchModalOpen } = useUIState()\nconst breakpoints = useBreakpoints(breakpointsTailwind)\nconst colorMode = useColorMode()\nconst { ui, attrs } = useUI('content.search', toRef(props, 'ui'), config, undefined, true)\n\nconst smallerThanSm = breakpoints.smaller('sm')\n\nconst commandPaletteRef = ref<HTMLElement & { query: Ref<string>, results: { item: Command }[] }>()\n\nfunction fileIcon (file: ParsedContent) {\n  if (file.icon) return file.icon\n  if (file.navigation?.icon) return file.navigation.icon\n  if (props.navigation) {\n    file.icon = navKeyFromPath(file._path as string, 'icon', props.navigation)\n  }\n  return file.icon || ui.value.fileIcon.name\n}\n\n// Computed\n\nconst isOpen = computed({\n  get () {\n    return props.modelValue !== undefined ? props.modelValue : isContentSearchModalOpen.value\n  },\n  set (value) {\n    props.modelValue !== undefined ? emit('update:modelValue', value) : (isContentSearchModalOpen.value = value)\n  }\n})\n\nconst fuse: ComputedRef<Partial<UseFuseOptions<Command>>> = computed(() => defu({}, props.fuse, {\n  fuseOptions: {\n    ignoreLocation: true,\n    includeMatches: true,\n    threshold: 0.1,\n    keys: [\n      { name: 'title', weight: 5 },\n      { name: 'label', weight: 5 },\n      { name: 'suffix', weight: 3 },\n      'children.children.value',\n      'children.children.children.value',\n      'children.children.children.children.value',\n      'children.children.children.children.children.value'\n    ]\n  },\n  resultLimit: 12\n}))\n\nfunction filter (query: string, commands: Command[]) {\n  if (!query) {\n    return commands?.filter(command => !command.child)\n  }\n\n  return commands\n}\n\nconst groups = computed(() => {\n  let navigationGroups: Group[] = []\n  if (props.navigation?.length) {\n    if (props.navigation.some(link => !!link.children?.length)) {\n      navigationGroups = (props.navigation || []).map(link => {\n        return {\n          key: link._path,\n          label: link.title,\n          commands: (props.files || []).filter(file => file._path?.startsWith(link._path)).flatMap(file => mapFile(file, link)),\n          filter\n        }\n      })\n    } else {\n      navigationGroups = [{\n        key: 'docs',\n        commands: (props.files || []).flatMap(file => mapFile(file)),\n        filter\n      }]\n    }\n  }\n\n  return [props.links?.length && {\n    key: 'links',\n    label: 'Links',\n    commands: props.links.flatMap(link => {\n      return [link.to && {\n        id: router.resolve(link.to).fullPath,\n        ...link,\n        icon: link.icon || ui.value.fileIcon.name\n      }, ...(link.children || []).map((child: { to: string; description: any; icon: any }) => {\n        return {\n          id: router.resolve(child.to as string).fullPath,\n          prefix: link.label,\n          suffix: child.description,\n          ...child,\n          icon: child.icon || link.icon || ui.value.fileIcon.name\n        }\n      })]\n    }).filter(Boolean)\n  }, ...navigationGroups, ...(props.groups || []), !colorMode?.forced && !props.hideColorMode && {\n    key: 'theme',\n    label: 'Theme',\n    commands: [{\n      id: 'theme-light',\n      label: 'Light',\n      icon: appConfig.ui.icons.light,\n      disabled: colorMode.preference === 'light',\n      click: () => {\n        colorMode.preference = 'light'\n      }\n    }, {\n      id: 'theme-dark',\n      label: 'Dark',\n      icon: appConfig.ui.icons.dark,\n      disabled: colorMode.preference === 'dark',\n      click: () => {\n        colorMode.preference = 'dark'\n      }\n    }]\n  }].filter(Boolean) as Group[]\n})\n\n// avoid conflicts between multiple meta_k shortcuts\nconst canToggleModal = computed(() => isOpen.value || !usingInput.value)\n\n// Methods\n\nfunction mapFile (file: ParsedContent, link?: NavItem): Command[] {\n  const prefix = findPageBreadcrumb(link?.children || [], file)?.map(({ title }) => title).join(' > ')\n\n  return [{\n    id: file._id,\n    label: file.navigation?.title || file.title,\n    title: file.navigation?.title || file.title,\n    prefix,\n    to: file._path,\n    suffix: file.description,\n    children: concatChildren(extractUntilFirstTitle(file?.body?.children || [])),\n    icon: fileIcon(file)\n  }, ...Object.entries(groupByHeading(file?.body?.children || [])).map(([hash, { title, children }]) => {\n    if (!title) {\n      return\n    }\n\n    return {\n      id: `${file._path}${hash}`,\n      label: title,\n      prefix: (prefix ? `${prefix} > ` : '') + `${file.navigation?.title || file.title}`,\n      to: `${file._path}${hash}`,\n      children: concatChildren(children),\n      icon: fileIcon(file),\n      child: true\n    }\n  })].filter(Boolean) as Command[]\n}\n\nfunction remapChildren (children: MarkdownNode[]) {\n  return children?.map((grandChild) => {\n    if (['code', 'code-inline', 'em', 'a', 'strong'].includes(grandChild.tag as string)) {\n      return { type: 'text', value: grandChild.children?.find(child => child.type === 'text')?.value || '' }\n    } else if (grandChild.type === 'text') {\n      return grandChild\n    }\n  }).filter(Boolean) as MarkdownNode[] || []\n}\n\nfunction concatChildren (children: MarkdownNode[]): any[] {\n  return children.map((child) => {\n    if (['pre', 'style', 'video'].includes(child.tag as string)) {\n      return\n    }\n\n    let grandChildren = [...(child.children || [])]\n\n    if (['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'td', 'th'].includes(child.tag as string) && grandChildren.length) {\n      grandChildren = remapChildren(grandChildren).reduce((acc: MarkdownNode[], grandChild) => {\n        if (acc.length && acc[acc.length - 1].type === 'text') {\n          acc[acc.length - 1].value += grandChild.value || ''\n        } else {\n          acc.push({ ...grandChild })\n        }\n        return acc\n      }, [])\n\n      return {\n        ...child,\n        children: grandChildren\n      }\n    }\n\n    return {\n      ...child,\n      children: concatChildren(grandChildren)\n    }\n  }).filter(Boolean) as MarkdownNode[]\n}\n\nfunction extractUntilFirstTitle (children: MarkdownNode[]) {\n  const extracted: MarkdownNode[] = []\n  for (const child of children) {\n    if (['h1', 'h2', 'h3'].includes(child.tag as string)) {\n      break\n    }\n    extracted.push(child)\n  }\n  return extracted\n}\n\nfunction groupByHeading (children: MarkdownNode[]) {\n  const groups: Record<string, { title?: string, children: MarkdownNode[] }> = {} // grouped by path\n  let hash = '' // file.page with potential `#anchor` concat\n  let title: string = ''\n  for (const node of children) {\n    // if heading found, udpate current path\n    if (['h1', 'h2', 'h3'].includes(node.tag as string)) {\n      // find heading text value\n      title = node.children?.map(child => {\n        if (child.type === 'text') {\n          return child.value\n        }\n\n        if (['code', 'code-inline', 'em', 'a', 'strong'].includes(child.tag as string)) {\n          return child.children?.find(child => child.type === 'text')?.value\n        }\n      })?.filter(Boolean)?.join(' ') || ''\n\n      if (title && node.props?.id) {\n        hash = `#${encodeURIComponent(node.props.id)}`\n      }\n    }\n    // push to existing/new group based on path\n    if (groups[hash]) {\n      groups[hash].children.push(node)\n    } else {\n      // @ts-ignore\n      groups[hash] = { children: [node], title }\n    }\n  }\n  return groups\n}\n\nfunction onSelect (options: Command[]) {\n  isOpen.value = false\n\n  const option = options[0]\n  if (!option) {\n    return\n  }\n\n  if (option.click) {\n    option.click()\n  } else if (option.to) {\n    if (option.target === '_blank' || option.to.startsWith('http')) {\n      window.open(option.to, option.target || '_blank')\n    } else {\n      router.push(option.to)\n    }\n  } else if (option.href) {\n    window.open(option.href, '_blank')\n  }\n}\n\n// Shortcuts\n\ndefineShortcuts({\n  meta_k: {\n    usingInput: true,\n    whenever: [canToggleModal],\n    handler: () => {\n      isOpen.value = !isOpen.value\n    }\n  },\n  escape: {\n    usingInput: true,\n    whenever: [isOpen],\n    handler: () => { isOpen.value = false }\n  }\n})\n\n// Expose\n\ndefineExpose({\n  commandPaletteRef\n})\n</script>\n",
      "start": 1714180700586,
      "end": 1714180700604,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1714180700604,
      "end": 1714180700604,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1714180700604,
      "end": 1714180700604,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1714180700604,
      "end": 1714180700604,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1714180700604,
      "end": 1714180700604,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1714180700604,
      "end": 1714180700604,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1714180700604,
      "end": 1714180700604,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1714180700604,
      "end": 1714180700604,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1714180700604,
      "end": 1714180700604,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "result": "import _sfc_main from \"/Users/rezajafar/peakofeloquence-app/node_modules/@nuxt/ui-pro/modules/pro/runtime/components/content/ContentSearch.vue?vue&type=script&setup=true&lang.ts\";\nexport * from \"/Users/rezajafar/peakofeloquence-app/node_modules/@nuxt/ui-pro/modules/pro/runtime/components/content/ContentSearch.vue?vue&type=script&setup=true&lang.ts\";\nexport default _sfc_main;\n",
      "start": 1714180700604,
      "end": 1714180700850,
      "order": "normal",
      "sourcemaps": {
        "mappings": ""
      }
    },
    {
      "name": "vite:vue-jsx",
      "start": 1714180700850,
      "end": 1714180700850,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1714180700850,
      "end": 1714180700850,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1714180700850,
      "end": 1714180700850,
      "order": "normal"
    },
    {
      "name": "nuxt:fonts:font-family-injection",
      "start": 1714180700850,
      "end": 1714180700850,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1714180700850,
      "end": 1714180700850,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1714180700850,
      "end": 1714180700850,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1714180700850,
      "end": 1714180700850,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1714180700850,
      "end": 1714180700850,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1714180700850,
      "end": 1714180700850,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1714180700850,
      "end": 1714180700850,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1714180700850,
      "end": 1714180700850,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1714180700850,
      "end": 1714180700850,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1714180700850,
      "end": 1714180700850,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1714180700850,
      "end": 1714180700850,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1714180700851,
      "end": 1714180700851,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1714180700851,
      "end": 1714180700851,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1714180700851,
      "end": 1714180700851,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1714180700851,
      "end": 1714180700851,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1714180700851,
      "end": 1714180700851,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1714180700851,
      "end": 1714180700851,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1714180700851,
      "end": 1714180700851,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1714180700851,
      "end": 1714180700851,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1714180700851,
      "end": 1714180700851,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1714180700851,
      "end": 1714180700851,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1714180700852,
      "end": 1714180700852,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1714180700852,
      "end": 1714180700852,
      "order": "normal"
    }
  ]
}
