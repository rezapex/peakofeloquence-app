{
  "resolvedId": "/Users/rezajafar/peakofeloquence-site/node_modules/parse-entities/lib/index.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/**\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\nimport {characterEntitiesLegacy} from 'character-entities-legacy'\nimport {characterReferenceInvalid} from 'character-reference-invalid'\nimport {isDecimal} from 'is-decimal'\nimport {isHexadecimal} from 'is-hexadecimal'\nimport {isAlphanumerical} from 'is-alphanumerical'\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\n\nconst fromCharCode = String.fromCharCode\n\n// Warning messages.\nconst messages = [\n  '',\n  /* 1: Non terminated (named) */\n  'Named character references must be terminated by a semicolon',\n  /* 2: Non terminated (numeric) */\n  'Numeric character references must be terminated by a semicolon',\n  /* 3: Empty (named) */\n  'Named character references cannot be empty',\n  /* 4: Empty (numeric) */\n  'Numeric character references cannot be empty',\n  /* 5: Unknown (named) */\n  'Named character references must be known',\n  /* 6: Disallowed (numeric) */\n  'Numeric character references cannot be disallowed',\n  /* 7: Prohibited (numeric) */\n  'Numeric character references cannot be outside the permissible Unicode range'\n]\n\n/**\n * Parse HTML character references.\n *\n * @param {string} value\n * @param {import('../index.js').Options} [options={}]\n */\nexport function parseEntities(value, options = {}) {\n  const additional =\n    typeof options.additional === 'string'\n      ? options.additional.charCodeAt(0)\n      : options.additional\n  /** @type {Array<string>} */\n  const result = []\n  let index = 0\n  let lines = -1\n  let queue = ''\n  /** @type {Point|undefined} */\n  let point\n  /** @type {Array<number>|undefined} */\n  let indent\n\n  if (options.position) {\n    if ('start' in options.position || 'indent' in options.position) {\n      // @ts-expect-error: points don’t have indent.\n      indent = options.position.indent\n      // @ts-expect-error: points don’t have indent.\n      point = options.position.start\n    } else {\n      point = options.position\n    }\n  }\n\n  let line = (point ? point.line : 0) || 1\n  let column = (point ? point.column : 0) || 1\n\n  // Cache the current point.\n  let previous = now()\n  /** @type {number|undefined} */\n  let character\n\n  // Ensure the algorithm walks over the first character (inclusive).\n  index--\n\n  while (++index <= value.length) {\n    // If the previous character was a newline.\n    if (character === 10 /* `\\n` */) {\n      column = (indent ? indent[lines] : 0) || 1\n    }\n\n    character = value.charCodeAt(index)\n\n    if (character === 38 /* `&` */) {\n      const following = value.charCodeAt(index + 1)\n\n      // The behavior depends on the identity of the next character.\n      if (\n        following === 9 /* `\\t` */ ||\n        following === 10 /* `\\n` */ ||\n        following === 12 /* `\\f` */ ||\n        following === 32 /* ` ` */ ||\n        following === 38 /* `&` */ ||\n        following === 60 /* `<` */ ||\n        Number.isNaN(following) ||\n        (additional && following === additional)\n      ) {\n        // Not a character reference.\n        // No characters are consumed, and nothing is returned.\n        // This is not an error, either.\n        queue += fromCharCode(character)\n        column++\n        continue\n      }\n\n      const start = index + 1\n      let begin = start\n      let end = start\n      /** @type {string} */\n      let type\n\n      if (following === 35 /* `#` */) {\n        // Numerical reference.\n        end = ++begin\n\n        // The behavior further depends on the next character.\n        const following = value.charCodeAt(end)\n\n        if (following === 88 /* `X` */ || following === 120 /* `x` */) {\n          // ASCII hexadecimal digits.\n          type = 'hexadecimal'\n          end = ++begin\n        } else {\n          // ASCII decimal digits.\n          type = 'decimal'\n        }\n      } else {\n        // Named reference.\n        type = 'named'\n      }\n\n      let characterReferenceCharacters = ''\n      let characterReference = ''\n      let characters = ''\n      // Each type of character reference accepts different characters.\n      // This test is used to detect whether a reference has ended (as the semicolon\n      // is not strictly needed).\n      const test =\n        type === 'named'\n          ? isAlphanumerical\n          : type === 'decimal'\n          ? isDecimal\n          : isHexadecimal\n\n      end--\n\n      while (++end <= value.length) {\n        const following = value.charCodeAt(end)\n\n        if (!test(following)) {\n          break\n        }\n\n        characters += fromCharCode(following)\n\n        // Check if we can match a legacy named reference.\n        // If so, we cache that as the last viable named reference.\n        // This ensures we do not need to walk backwards later.\n        if (type === 'named' && characterEntitiesLegacy.includes(characters)) {\n          characterReferenceCharacters = characters\n          // @ts-expect-error: always able to decode.\n          characterReference = decodeNamedCharacterReference(characters)\n        }\n      }\n\n      let terminated = value.charCodeAt(end) === 59 /* `;` */\n\n      if (terminated) {\n        end++\n\n        const namedReference =\n          type === 'named' ? decodeNamedCharacterReference(characters) : false\n\n        if (namedReference) {\n          characterReferenceCharacters = characters\n          characterReference = namedReference\n        }\n      }\n\n      let diff = 1 + end - start\n      let reference = ''\n\n      if (!terminated && options.nonTerminated === false) {\n        // Empty.\n      } else if (!characters) {\n        // An empty (possible) reference is valid, unless it’s numeric (thus an\n        // ampersand followed by an octothorp).\n        if (type !== 'named') {\n          warning(4 /* Empty (numeric) */, diff)\n        }\n      } else if (type === 'named') {\n        // An ampersand followed by anything unknown, and not terminated, is\n        // invalid.\n        if (terminated && !characterReference) {\n          warning(5 /* Unknown (named) */, 1)\n        } else {\n          // If there’s something after an named reference which is not known,\n          // cap the reference.\n          if (characterReferenceCharacters !== characters) {\n            end = begin + characterReferenceCharacters.length\n            diff = 1 + end - begin\n            terminated = false\n          }\n\n          // If the reference is not terminated, warn.\n          if (!terminated) {\n            const reason = characterReferenceCharacters\n              ? 1 /* Non terminated (named) */\n              : 3 /* Empty (named) */\n\n            if (options.attribute) {\n              const following = value.charCodeAt(end)\n\n              if (following === 61 /* `=` */) {\n                warning(reason, diff)\n                characterReference = ''\n              } else if (isAlphanumerical(following)) {\n                characterReference = ''\n              } else {\n                warning(reason, diff)\n              }\n            } else {\n              warning(reason, diff)\n            }\n          }\n        }\n\n        reference = characterReference\n      } else {\n        if (!terminated) {\n          // All nonterminated numeric references are not rendered, and emit a\n          // warning.\n          warning(2 /* Non terminated (numeric) */, diff)\n        }\n\n        // When terminated and numerical, parse as either hexadecimal or\n        // decimal.\n        let referenceCode = Number.parseInt(\n          characters,\n          type === 'hexadecimal' ? 16 : 10\n        )\n\n        // Emit a warning when the parsed number is prohibited, and replace with\n        // replacement character.\n        if (prohibited(referenceCode)) {\n          warning(7 /* Prohibited (numeric) */, diff)\n          reference = fromCharCode(65533 /* `�` */)\n        } else if (referenceCode in characterReferenceInvalid) {\n          // Emit a warning when the parsed number is disallowed, and replace by\n          // an alternative.\n          warning(6 /* Disallowed (numeric) */, diff)\n          reference = characterReferenceInvalid[referenceCode]\n        } else {\n          // Parse the number.\n          let output = ''\n\n          // Emit a warning when the parsed number should not be used.\n          if (disallowed(referenceCode)) {\n            warning(6 /* Disallowed (numeric) */, diff)\n          }\n\n          // Serialize the number.\n          if (referenceCode > 0xffff) {\n            referenceCode -= 0x10000\n            output += fromCharCode((referenceCode >>> (10 & 0x3ff)) | 0xd800)\n            referenceCode = 0xdc00 | (referenceCode & 0x3ff)\n          }\n\n          reference = output + fromCharCode(referenceCode)\n        }\n      }\n\n      // Found it!\n      // First eat the queued characters as normal text, then eat a reference.\n      if (reference) {\n        flush()\n\n        previous = now()\n        index = end - 1\n        column += end - start + 1\n        result.push(reference)\n        const next = now()\n        next.offset++\n\n        if (options.reference) {\n          options.reference.call(\n            options.referenceContext,\n            reference,\n            {start: previous, end: next},\n            value.slice(start - 1, end)\n          )\n        }\n\n        previous = next\n      } else {\n        // If we could not find a reference, queue the checked characters (as\n        // normal characters), and move the pointer to their end.\n        // This is possible because we can be certain neither newlines nor\n        // ampersands are included.\n        characters = value.slice(start - 1, end)\n        queue += characters\n        column += characters.length\n        index = end - 1\n      }\n    } else {\n      // Handle anything other than an ampersand, including newlines and EOF.\n      if (character === 10 /* `\\n` */) {\n        line++\n        lines++\n        column = 0\n      }\n\n      if (Number.isNaN(character)) {\n        flush()\n      } else {\n        queue += fromCharCode(character)\n        column++\n      }\n    }\n  }\n\n  // Return the reduced nodes.\n  return result.join('')\n\n  // Get current position.\n  function now() {\n    return {\n      line,\n      column,\n      offset: index + ((point ? point.offset : 0) || 0)\n    }\n  }\n\n  /**\n   * Handle the warning.\n   *\n   * @param {1|2|3|4|5|6|7} code\n   * @param {number} offset\n   */\n  function warning(code, offset) {\n    /** @type {ReturnType<now>} */\n    let position\n\n    if (options.warning) {\n      position = now()\n      position.column += offset\n      position.offset += offset\n\n      options.warning.call(\n        options.warningContext,\n        messages[code],\n        position,\n        code\n      )\n    }\n  }\n\n  /**\n   * Flush `queue` (normal text).\n   * Macro invoked before each reference and at the end of `value`.\n   * Does nothing when `queue` is empty.\n   */\n  function flush() {\n    if (queue) {\n      result.push(queue)\n\n      if (options.text) {\n        options.text.call(options.textContext, queue, {\n          start: previous,\n          end: now()\n        })\n      }\n\n      queue = ''\n    }\n  }\n}\n\n/**\n * Check if `character` is outside the permissible unicode range.\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction prohibited(code) {\n  return (code >= 0xd800 && code <= 0xdfff) || code > 0x10ffff\n}\n\n/**\n * Check if `character` is disallowed.\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction disallowed(code) {\n  return (\n    (code >= 0x0001 && code <= 0x0008) ||\n    code === 0x000b ||\n    (code >= 0x000d && code <= 0x001f) ||\n    (code >= 0x007f && code <= 0x009f) ||\n    (code >= 0xfdd0 && code <= 0xfdef) ||\n    (code & 0xffff) === 0xffff ||\n    (code & 0xffff) === 0xfffe\n  )\n}\n",
      "start": 1712268127555,
      "end": 1712268127580,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1712268127580,
      "end": 1712268127580,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1712268127580,
      "end": 1712268127580,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1712268127580,
      "end": 1712268127580,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1712268127580,
      "end": 1712268127580,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1712268127580,
      "end": 1712268127580,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1712268127580,
      "end": 1712268127580,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1712268127580,
      "end": 1712268127580,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1712268127580,
      "end": 1712268127580,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1712268127580,
      "end": 1712268127580,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1712268127580,
      "end": 1712268127580,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1712268127580,
      "end": 1712268127580,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1712268127580,
      "end": 1712268127580,
      "order": "normal"
    },
    {
      "name": "nuxt:fonts:font-family-injection",
      "start": 1712268127580,
      "end": 1712268127580,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1712268127580,
      "end": 1712268127580,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1712268127580,
      "end": 1712268127580,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1712268127580,
      "end": 1712268127580,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1712268127580,
      "end": 1712268127580,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1712268127580,
      "end": 1712268127580,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1712268127580,
      "end": 1712268127580,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1712268127580,
      "end": 1712268127580,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1712268127580,
      "end": 1712268127580,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1712268127580,
      "end": 1712268127581,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1712268127581,
      "end": 1712268127581,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1712268127581,
      "end": 1712268127581,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1712268127581,
      "end": 1712268127581,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1712268127581,
      "end": 1712268127581,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1712268127581,
      "end": 1712268127581,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1712268127581,
      "end": 1712268127581,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1712268127581,
      "end": 1712268127581,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1712268127581,
      "end": 1712268127581,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1712268127581,
      "end": 1712268127581,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1712268127581,
      "end": 1712268127581,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1712268127581,
      "end": 1712268127581,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1712268127581,
      "end": 1712268127581,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1712268127581,
      "end": 1712268127581,
      "order": "normal"
    }
  ]
}
