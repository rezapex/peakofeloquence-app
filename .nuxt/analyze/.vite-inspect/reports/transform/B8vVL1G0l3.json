{
  "resolvedId": "/Users/rezajafar/peakofeloquence-site/node_modules/hast-util-from-parse5/lib/index.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementData} ElementData\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n *\n * @typedef {import('parse5').DefaultTreeAdapterMap} DefaultTreeAdapterMap\n * @typedef {import('parse5').Token.ElementLocation} P5ElementLocation\n * @typedef {import('parse5').Token.Location} P5Location\n *\n * @typedef {import('property-information').Schema} Schema\n *\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n *\n * @typedef {import('vfile').VFile} VFile\n */\n\n/**\n * @typedef {DefaultTreeAdapterMap['document']} P5Document\n * @typedef {DefaultTreeAdapterMap['documentFragment']} P5DocumentFragment\n * @typedef {DefaultTreeAdapterMap['documentType']} P5DocumentType\n * @typedef {DefaultTreeAdapterMap['commentNode']} P5Comment\n * @typedef {DefaultTreeAdapterMap['textNode']} P5Text\n * @typedef {DefaultTreeAdapterMap['element']} P5Element\n * @typedef {DefaultTreeAdapterMap['node']} P5Node\n * @typedef {DefaultTreeAdapterMap['template']} P5Template\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {Space | null | undefined} [space='html']\n *   Which space the document is in (default: `'html'`).\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n * @property {VFile | null | undefined} [file]\n *   File used to add positional info to nodes (optional).\n *\n *   If given, the file should represent the original HTML source.\n * @property {boolean | null | undefined} [verbose=false]\n *   Whether to add extra positional info about starting tags, closing tags,\n *   and attributes to elements (default: `false`).\n *\n *   > ðŸ‘‰ **Note**: only used when `file` is given.\n *\n * @typedef {'html' | 'svg'} Space\n *   Namespace.\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {VFile | undefined} file\n *   Corresponding file.\n * @property {boolean} location\n *   Whether location info was found.\n * @property {Schema} schema\n *   Current schema.\n * @property {boolean | undefined} verbose\n *   Add extra positional info.\n */\n\nimport {ok as assert} from 'devlop'\nimport {h, s} from 'hastscript'\nimport {find, html, svg} from 'property-information'\nimport {location} from 'vfile-location'\nimport {webNamespaces} from 'web-namespaces'\n\nconst own = {}.hasOwnProperty\n/** @type {unknown} */\n// type-coverage:ignore-next-line\nconst proto = Object.prototype\n\n/**\n * Transform a `parse5` AST to hast.\n *\n * @param {P5Node} tree\n *   `parse5` tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Nodes}\n *   hast tree.\n */\nexport function fromParse5(tree, options) {\n  const settings = options || {}\n\n  return one(\n    {\n      file: settings.file || undefined,\n      location: false,\n      schema: settings.space === 'svg' ? svg : html,\n      verbose: settings.verbose || false\n    },\n    tree\n  )\n}\n\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Node} node\n *   p5 node.\n * @returns {Nodes}\n *   hast node.\n */\nfunction one(state, node) {\n  /** @type {Nodes} */\n  let result\n\n  switch (node.nodeName) {\n    case '#comment': {\n      const reference = /** @type {P5Comment} */ (node)\n      result = {type: 'comment', value: reference.data}\n      patch(state, reference, result)\n      return result\n    }\n\n    case '#document':\n    case '#document-fragment': {\n      const reference = /** @type {P5Document | P5DocumentFragment} */ (node)\n      const quirksMode =\n        'mode' in reference\n          ? reference.mode === 'quirks' || reference.mode === 'limited-quirks'\n          : false\n\n      result = {\n        type: 'root',\n        children: all(state, node.childNodes),\n        data: {quirksMode}\n      }\n\n      if (state.file && state.location) {\n        const doc = String(state.file)\n        const loc = location(doc)\n        const start = loc.toPoint(0)\n        const end = loc.toPoint(doc.length)\n        // Always defined as we give valid input.\n        assert(start, 'expected `start`')\n        assert(end, 'expected `end`')\n        result.position = {start, end}\n      }\n\n      return result\n    }\n\n    case '#documentType': {\n      const reference = /** @type {P5DocumentType} */ (node)\n      result = {type: 'doctype'}\n      patch(state, reference, result)\n      return result\n    }\n\n    case '#text': {\n      const reference = /** @type {P5Text} */ (node)\n      result = {type: 'text', value: reference.value}\n      patch(state, reference, result)\n      return result\n    }\n\n    // Element.\n    default: {\n      const reference = /** @type {P5Element} */ (node)\n      result = element(state, reference)\n      return result\n    }\n  }\n}\n\n/**\n * Transform children.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Array<P5Node>} nodes\n *   Nodes.\n * @returns {Array<RootContent>}\n *   hast nodes.\n */\nfunction all(state, nodes) {\n  let index = -1\n  /** @type {Array<RootContent>} */\n  const results = []\n\n  while (++index < nodes.length) {\n    // Assume no roots in `nodes`.\n    const result = /** @type {RootContent} */ (one(state, nodes[index]))\n    results.push(result)\n  }\n\n  return results\n}\n\n/**\n * Transform an element.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Element} node\n *   `parse5` node to transform.\n * @returns {Element}\n *   hast node.\n */\nfunction element(state, node) {\n  const schema = state.schema\n\n  state.schema = node.namespaceURI === webNamespaces.svg ? svg : html\n\n  // Props.\n  let index = -1\n  /** @type {Record<string, string>} */\n  const props = {}\n\n  while (++index < node.attrs.length) {\n    const attribute = node.attrs[index]\n    const name =\n      (attribute.prefix ? attribute.prefix + ':' : '') + attribute.name\n    if (!own.call(proto, name)) {\n      props[name] = attribute.value\n    }\n  }\n\n  // Build.\n  const fn = state.schema.space === 'svg' ? s : h\n  const result = fn(node.tagName, props, all(state, node.childNodes))\n  patch(state, node, result)\n\n  // Switch content.\n  if (result.tagName === 'template') {\n    const reference = /** @type {P5Template} */ (node)\n    const pos = reference.sourceCodeLocation\n    const startTag = pos && pos.startTag && position(pos.startTag)\n    const endTag = pos && pos.endTag && position(pos.endTag)\n\n    // Root in, root out.\n    const content = /** @type {Root} */ (one(state, reference.content))\n\n    if (startTag && endTag && state.file) {\n      content.position = {start: startTag.end, end: endTag.start}\n    }\n\n    result.content = content\n  }\n\n  state.schema = schema\n\n  return result\n}\n\n/**\n * Patch positional info from `from` onto `to`.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Node} from\n *   p5 node.\n * @param {Nodes} to\n *   hast node.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(state, from, to) {\n  if ('sourceCodeLocation' in from && from.sourceCodeLocation && state.file) {\n    const position = createLocation(state, to, from.sourceCodeLocation)\n\n    if (position) {\n      state.location = true\n      to.position = position\n    }\n  }\n}\n\n/**\n * Create clean positional information.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Nodes} node\n *   hast node.\n * @param {P5ElementLocation} location\n *   p5 location info.\n * @returns {Position | undefined}\n *   Position, or nothing.\n */\nfunction createLocation(state, node, location) {\n  const result = position(location)\n\n  if (node.type === 'element') {\n    const tail = node.children[node.children.length - 1]\n\n    // Bug for unclosed with children.\n    // See: <https://github.com/inikulin/parse5/issues/109>.\n    if (\n      result &&\n      !location.endTag &&\n      tail &&\n      tail.position &&\n      tail.position.end\n    ) {\n      result.end = Object.assign({}, tail.position.end)\n    }\n\n    if (state.verbose) {\n      /** @type {Record<string, Position | undefined>} */\n      const props = {}\n      /** @type {string} */\n      let key\n\n      if (location.attrs) {\n        for (key in location.attrs) {\n          if (own.call(location.attrs, key)) {\n            props[find(state.schema, key).property] = position(\n              location.attrs[key]\n            )\n          }\n        }\n      }\n\n      assert(location.startTag, 'a start tag should exist')\n      const opening = position(location.startTag)\n      const closing = location.endTag ? position(location.endTag) : undefined\n      /** @type {ElementData['position']} */\n      const data = {opening}\n      if (closing) data.closing = closing\n      data.properties = props\n\n      node.data = {position: data}\n    }\n  }\n\n  return result\n}\n\n/**\n * Turn a p5 location into a position.\n *\n * @param {P5Location} loc\n *   Location.\n * @returns {Position | undefined}\n *   Position or nothing.\n */\nfunction position(loc) {\n  const start = point({\n    line: loc.startLine,\n    column: loc.startCol,\n    offset: loc.startOffset\n  })\n  const end = point({\n    line: loc.endLine,\n    column: loc.endCol,\n    offset: loc.endOffset\n  })\n\n  // @ts-expect-error: we do use `undefined` for points if one or the other\n  // exists.\n  return start || end ? {start, end} : undefined\n}\n\n/**\n * Filter out invalid points.\n *\n * @param {Point} point\n *   Point with potentially `undefined` values.\n * @returns {Point | undefined}\n *   Point or nothing.\n */\nfunction point(point) {\n  return point.line && point.column ? point : undefined\n}\n",
      "start": 1712268127880,
      "end": 1712268127896,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    },
    {
      "name": "nuxt:fonts:font-family-injection",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1712268127896,
      "end": 1712268127896,
      "order": "normal"
    }
  ]
}
