{
  "resolvedId": "/Users/rezajafar/peakofeloquence-site/node_modules/remark-mdc/dist/index.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { kebabCase } from 'scule';\nimport { visit } from 'unist-util-visit';\nimport yaml from 'js-yaml';\nimport * as flat from 'flat';\nimport { stringifyEntitiesLight } from 'stringify-entities';\nimport { defaultHandlers } from 'mdast-util-to-markdown';\nimport { parseEntities } from 'parse-entities';\nimport { markdownLineEnding, markdownSpace, asciiAlpha, markdownLineEndingOrSpace, asciiAlphanumeric } from 'micromark-util-character';\nimport { factorySpace } from 'micromark-factory-space';\nimport { factoryWhitespace } from 'micromark-factory-whitespace';\nimport { codeFenced } from 'micromark-core-commonmark';\n\nconst FRONTMATTER_DELIMITER = \"---\";\nfunction stringifyFrontMatter(data, content = \"\") {\n  if (!Object.keys(data).length) {\n    return \"\";\n  }\n  data = flat.unflatten(data || {}, {});\n  return [\n    FRONTMATTER_DELIMITER,\n    yaml.dump(data, { lineWidth: -1 }).trim(),\n    FRONTMATTER_DELIMITER,\n    content\n  ].join(\"\\n\");\n}\nfunction parseFrontMatter(content) {\n  let data = {};\n  if (content.startsWith(FRONTMATTER_DELIMITER)) {\n    const idx = content.indexOf(\"\\n\" + FRONTMATTER_DELIMITER);\n    if (idx !== -1) {\n      const frontmatter = content.slice(4, idx);\n      if (frontmatter) {\n        data = yaml.load(frontmatter);\n        content = content.slice(idx + 4);\n      }\n    }\n  }\n  return {\n    content,\n    // unflatten frontmatter data. convert `parent.child` keys into `parent: { child: ... }`\n    data: flat.unflatten(data || {}, {})\n  };\n}\n\nfunction track(options_) {\n  const options = options_ || {};\n  const now = options.now || {};\n  let lineShift = options.lineShift || 0;\n  let line = now.line || 1;\n  let column = now.column || 1;\n  return { move, current, shift };\n  function current() {\n    return { now: { line, column }, lineShift };\n  }\n  function shift(value) {\n    lineShift += value;\n  }\n  function move(value = \"\") {\n    const chunks = value.split(/\\r?\\n|\\r/g);\n    const tail = chunks[chunks.length - 1];\n    line += chunks.length - 1;\n    column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;\n    return value;\n  }\n}\nfunction inlineContainerFlow(parent, context, safeOptions = {}) {\n  const indexStack = context.indexStack;\n  const children = parent.children || [];\n  const tracker = track(safeOptions);\n  const results = [];\n  let index = -1;\n  indexStack.push(-1);\n  while (++index < children.length) {\n    const child = children[index];\n    indexStack[indexStack.length - 1] = index;\n    results.push(\n      tracker.move(\n        context.handle(child, parent, context, {\n          before: \"\",\n          after: \"\",\n          ...tracker.current()\n        })\n      )\n    );\n  }\n  indexStack.pop();\n  return results.join(\"\");\n}\nfunction containerFlow(parent, context, safeOptions = {}) {\n  const indexStack = context.indexStack;\n  const children = parent.children || [];\n  const tracker = track(safeOptions);\n  const results = [];\n  let index = -1;\n  indexStack.push(-1);\n  while (++index < children.length) {\n    const child = children[index];\n    indexStack[indexStack.length - 1] = index;\n    results.push(\n      tracker.move(\n        context.handle(child, parent, context, {\n          before: \"\\n\",\n          after: \"\\n\",\n          ...tracker.current()\n        })\n      )\n    );\n    if (child.type !== \"list\") {\n      context.bulletLastUsed = void 0;\n    }\n    if (index < children.length - 1) {\n      results.push(tracker.move(between(child, children[index + 1])));\n    }\n  }\n  indexStack.pop();\n  return results.join(\"\");\n  function between(left, right) {\n    let index2 = context.join.length;\n    while (index2--) {\n      const result = context.join[index2](left, right, parent, context);\n      if (result === true || result === 1) {\n        break;\n      }\n      if (typeof result === \"number\") {\n        return \"\\n\".repeat(1 + result);\n      }\n      if (result === false) {\n        return \"\\n\\n<!---->\\n\\n\";\n      }\n    }\n    return \"\\n\\n\";\n  }\n}\nfunction containerPhrasing(parent, context, safeOptions) {\n  const indexStack = context.indexStack;\n  const children = parent.children || [];\n  const results = [];\n  let index = -1;\n  let before = safeOptions.before;\n  indexStack.push(-1);\n  let tracker = track(safeOptions);\n  while (++index < children.length) {\n    const child = children[index];\n    let after;\n    indexStack[indexStack.length - 1] = index;\n    if (index + 1 < children.length) {\n      let handle = context.handle.handlers[children[index + 1].type];\n      if (handle && handle.peek) {\n        handle = handle.peek;\n      }\n      after = handle ? handle(children[index + 1], parent, context, {\n        before: \"\",\n        after: \"\",\n        ...tracker.current()\n      }).charAt(0) : \"\";\n    } else {\n      after = safeOptions.after;\n    }\n    if (results.length > 0 && (before === \"\\r\" || before === \"\\n\") && child.type === \"html\") {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        \" \"\n      );\n      before = \" \";\n      tracker = track(safeOptions);\n      tracker.move(results.join(\"\"));\n    }\n    results.push(\n      tracker.move(\n        context.handle(child, parent, context, {\n          ...tracker.current(),\n          before,\n          after\n        })\n      )\n    );\n    before = results[results.length - 1].slice(-1);\n  }\n  indexStack.pop();\n  return results.join(\"\");\n}\nfunction checkQuote(context) {\n  const marker = context.options.quote || '\"';\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      \"Cannot serialize title with `\" + marker + \"` for `options.quote`, expected `\\\"`, or `'`\"\n    );\n  }\n  return marker;\n}\n\nconst NON_UNWRAPPABLE_TYPES = [\n  \"componentContainerSection\",\n  \"componentContainerDataSection\",\n  \"containerComponent\",\n  \"leafComponent\"\n];\n\nconst own = {}.hasOwnProperty;\nconst shortcut = /^[^\\t\\n\\r \"#'.<=>`}]+$/;\nconst baseFence = 2;\nfunction compilePattern(pattern) {\n  if (!pattern._compiled) {\n    const before = (pattern.atBreak ? \"[\\\\r\\\\n][\\\\t ]*\" : \"\") + (pattern.before ? \"(?:\" + pattern.before + \")\" : \"\");\n    pattern._compiled = new RegExp(\n      (before ? \"(\" + before + \")\" : \"\") + (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? \"\\\\\" : \"\") + pattern.character + (pattern.after ? \"(?:\" + pattern.after + \")\" : \"\"),\n      \"g\"\n    );\n  }\n  return pattern._compiled;\n}\nconst toMarkdown = (opts = {}) => {\n  const experimentalAutoUnwrap = (node) => {\n    if (opts?.experimental?.autoUnwrap) {\n      if (node.mdc?.unwrapped) {\n        node.children = [\n          {\n            type: node.mdc.unwrapped,\n            children: node.children.filter((child) => !NON_UNWRAPPABLE_TYPES.includes(child.type))\n          },\n          ...node.children.filter((child) => NON_UNWRAPPABLE_TYPES.includes(child.type))\n        ];\n      }\n    }\n  };\n  function componentContainerSection(node, _, context) {\n    context.indexStack = context.stack;\n    experimentalAutoUnwrap(node);\n    return `#${node.name}\n${content(node, context)}`.trim();\n  }\n  function textComponent(node, _, context) {\n    let value;\n    context.indexStack = context.stack;\n    const exit = context.enter(node.type);\n    if (node.name === \"span\") {\n      value = `[${content(node, context)}]${attributes(node, context)}`;\n    } else if (node.name === \"binding\") {\n      const attrs = node.attributes || {};\n      value = attrs.defaultValue ? `{{ ${attrs.value} || '${attrs.defaultValue}' }}` : `{{ ${attrs.value} }}`;\n    } else {\n      value = \":\" + (node.name || \"\") + label(node, context) + attributes(node, context);\n    }\n    exit();\n    return value;\n  }\n  let nest = 0;\n  function containerComponent(node, _, context) {\n    context.indexStack = context.stack;\n    const prefix = \":\".repeat(baseFence + nest);\n    nest += 1;\n    const exit = context.enter(node.type);\n    let value = prefix + (node.name || \"\") + label(node, context);\n    const attributesText = attributes(node, context);\n    const fmAttributes = node.fmAttributes || {};\n    if ((value + attributesText).length > 80 || Object.keys(fmAttributes).length > 0 || node.children?.some((child) => child.type === \"componentContainerSection\")) {\n      Object.assign(fmAttributes, node.attributes);\n    } else {\n      value += attributesText;\n    }\n    let subvalue;\n    if (Object.keys(fmAttributes).length > 0) {\n      const attrs = Object.entries(fmAttributes).sort(([key1], [key2]) => key1.localeCompare(key2)).reduce((acc, [key, value2]) => {\n        if (key?.startsWith(\":\")) {\n          try {\n            value2 = JSON.parse(value2);\n          } catch {\n          }\n          key = key.slice(1);\n        }\n        acc[key] = value2;\n        return acc;\n      }, {});\n      value += \"\\n\" + stringifyFrontMatter(attrs).trim();\n    }\n    const defaultSlotChildren = node.children.filter((child) => child.type !== \"componentContainerSection\");\n    const slots = node.children.filter((child) => child.type === \"componentContainerSection\");\n    node.children = [\n      ...defaultSlotChildren,\n      ...slots\n    ];\n    experimentalAutoUnwrap(node);\n    if (node.type === \"containerComponent\") {\n      subvalue = content(node, context);\n      if (subvalue) {\n        value += \"\\n\" + subvalue;\n      }\n      value += \"\\n\" + prefix;\n      if (nest > 1) {\n        value = value.split(\"\\n\").map((line) => \"  \" + line).join(\"\\n\");\n      }\n    }\n    nest -= 1;\n    exit();\n    return value;\n  }\n  containerComponent.peek = function peekComponent() {\n    return \":\";\n  };\n  function label(node, context) {\n    let label2 = node;\n    if (node.type === \"containerComponent\") {\n      if (!inlineComponentLabel(node)) {\n        return \"\";\n      }\n      label2 = node.children[0];\n    }\n    const exit = context.enter(\"label\");\n    const subexit = context.enter(node.type + \"Label\");\n    const value = containerPhrasing(label2, context, { before: \"[\", after: \"]\" });\n    subexit();\n    exit();\n    return value ? \"[\" + value + \"]\" : \"\";\n  }\n  function attributes(node, context) {\n    const quote = checkQuote(context);\n    const subset = node.type === \"textComponent\" ? [quote] : [quote, \"\\n\", \"\\r\"];\n    const attrs = Object.fromEntries(\n      Object.entries(node.attributes || {}).sort(([key1], [key2]) => key1.localeCompare(key2))\n    );\n    const values = [];\n    let id;\n    let classesFull = \"\";\n    let classes = \"\";\n    let value;\n    let key;\n    let index;\n    for (key in attrs) {\n      if (own.call(attrs, key) && attrs[key] != null) {\n        value = String(attrs[key]);\n        if (key === \"id\") {\n          id = shortcut.test(value) ? \"#\" + value : quoted(\"id\", value);\n        } else if (key === \"class\") {\n          value = value.split(/[\\t\\n\\r ]+/g);\n          classesFull = [];\n          classes = [];\n          index = -1;\n          while (++index < value.length) {\n            (shortcut.test(value[index]) ? classes : classesFull).push(value[index]);\n          }\n          classesFull = classesFull.length ? quoted(\"class\", classesFull.join(\" \")) : \"\";\n          classes = classes.length ? \".\" + classes.join(\".\") : \"\";\n        } else if (key.startsWith(\":\") && value === \"true\") {\n          values.push(key.slice(1));\n        } else {\n          values.push(quoted(key, value));\n        }\n      }\n    }\n    if (classesFull) {\n      values.unshift(classesFull);\n    }\n    if (classes) {\n      values.unshift(classes);\n    }\n    if (id) {\n      values.unshift(id);\n    }\n    return values.length ? \"{\" + values.join(\" \") + \"}\" : \"\";\n    function quoted(key2, value2) {\n      return key2 + \"=\" + quote + stringifyEntitiesLight(value2, { subset }) + quote;\n    }\n  }\n  function content(node, context) {\n    const content2 = inlineComponentLabel(node) ? Object.assign({}, node, { children: node.children.slice(1) }) : node;\n    return node.type === \"textComponent\" ? inlineContainerFlow(content2, context) : containerFlow(content2, context);\n  }\n  function inlineComponentLabel(node) {\n    return node.children && node.children[0] && node.children[0].data && node.children[0].data.componentLabel;\n  }\n  return {\n    compilePattern,\n    unsafe: [\n      {\n        character: \"\\r\",\n        inConstruct: [\"leafComponentLabel\", \"containerComponentLabel\"]\n      },\n      {\n        character: \"\\n\",\n        inConstruct: [\"leafComponentLabel\", \"containerComponentLabel\"]\n      },\n      {\n        before: \"[^:]\",\n        character: \":\",\n        after: \"[A-Za-z]\",\n        inConstruct: [\"phrasing\"]\n      },\n      { atBreak: true, character: \":\", after: \":\" }\n    ],\n    handlers: {\n      containerComponent,\n      textComponent,\n      componentContainerSection,\n      image: (node, _, state, info) => {\n        return defaultHandlers.image(node, _, state, info) + attributes(node, state);\n      },\n      link: (node, _, state, info) => {\n        return defaultHandlers.link(node, _, state, info) + attributes(node, state);\n      },\n      strong: (node, _, state, info) => {\n        return defaultHandlers.strong(node, _, state, info) + attributes(node, state);\n      },\n      inlineCode: (node, _, state) => {\n        state.compilePattern = state.compilePattern || compilePattern;\n        return defaultHandlers.inlineCode(node, _, state) + attributes(node, state);\n      },\n      emphasis: (node, _, state, info) => {\n        return defaultHandlers.emphasis(node, _, state, info) + attributes(node, state);\n      }\n    }\n  };\n};\n\nconst fromMarkdown = (opts = {}) => {\n  const canContainEols = [\"textComponent\"];\n  const experimentalAutoUnwrap = (node) => {\n    if (opts.experimental?.autoUnwrap && NON_UNWRAPPABLE_TYPES.includes(node.type)) {\n      const nonSlotChildren = node.children.filter((child) => child.type !== \"componentContainerSection\");\n      if (nonSlotChildren.length === 1 && !NON_UNWRAPPABLE_TYPES.includes(nonSlotChildren[0].type)) {\n        const nonSlotChildIndex = node.children.indexOf(nonSlotChildren[0]);\n        node.children.splice(nonSlotChildIndex, 1, ...nonSlotChildren[0].children);\n        node.mdc = node.mdc || {};\n        node.mdc.unwrapped = nonSlotChildren[0].type;\n      }\n    }\n  };\n  const enter = {\n    componentContainer: enterContainer,\n    componentContainerSection: enterContainerSection,\n    componentContainerDataSection: enterContainerDataSection,\n    componentContainerAttributes: enterAttributes,\n    componentContainerLabel: enterContainerLabel,\n    bindingContent: enterBindingContent,\n    componentLeaf: enterLeaf,\n    componentLeafAttributes: enterAttributes,\n    componentText: enterText,\n    textSpan: enterTextSpan,\n    componentTextAttributes: enterAttributes\n  };\n  const exit = {\n    bindingContent: exitBindingContent,\n    componentContainerSectionTitle: exitContainerSectionTitle,\n    listUnordered: conditionalExit,\n    listOrdered: conditionalExit,\n    listItem: conditionalExit,\n    componentContainerSection: exitContainerSection,\n    componentContainerDataSection: exitContainerDataSection,\n    componentContainer: exitContainer,\n    componentContainerAttributeClassValue: exitAttributeClassValue,\n    componentContainerAttributeIdValue: exitAttributeIdValue,\n    componentContainerAttributeName: exitAttributeName,\n    componentContainerAttributeValue: exitAttributeValue,\n    componentContainerAttributes: exitAttributes,\n    componentContainerLabel: exitContainerLabel,\n    componentContainerName,\n    componentContainerAttributeInitializerMarker() {\n      const attributes = this.data.componentAttributes;\n      attributes[attributes.length - 1][1] = \"\";\n    },\n    componentLeaf: exitToken,\n    componentLeafAttributeClassValue: exitAttributeClassValue,\n    componentLeafAttributeIdValue: exitAttributeIdValue,\n    componentLeafAttributeName: exitAttributeName,\n    componentLeafAttributeValue: exitAttributeValue,\n    componentLeafAttributes: exitAttributes,\n    componentLeafName: exitName,\n    componentText: exitToken,\n    textSpan: exitToken,\n    componentTextAttributeClassValue: exitAttributeClassValue,\n    componentTextAttributeIdValue: exitAttributeIdValue,\n    componentTextAttributeName: exitAttributeName,\n    componentTextAttributeValue: exitAttributeValue,\n    componentTextAttributes: exitAttributes,\n    componentTextName: componentContainerName\n  };\n  function enterBindingContent(token) {\n    const regex = /([^|]*)(?:\\|\\|\\s*'(.*)')?/;\n    const values = regex.exec(this.sliceSerialize(token));\n    this.enter({\n      type: \"textComponent\",\n      name: \"binding\",\n      attributes: {\n        value: values?.[1]?.trim(),\n        defaultValue: values?.[2]\n      }\n    }, token);\n  }\n  function exitBindingContent(token) {\n    this.exit(token);\n  }\n  function enterContainer(token) {\n    enterToken.call(this, \"containerComponent\", token);\n  }\n  function exitContainer(token) {\n    const container = this.stack[this.stack.length - 1];\n    if (container.children.length > 1) {\n      const dataSection = container.children.find((child) => child.rawData);\n      container.rawData = dataSection?.rawData;\n    }\n    experimentalAutoUnwrap(container);\n    container.children = container.children.flatMap((child) => {\n      if (child.rawData) {\n        return [];\n      }\n      if (child.name === \"default\" || !child.name) {\n        if (child.mdc?.unwrapped) {\n          container.mdc = container.mdc || {};\n          container.mdc.unwrapped = child.mdc?.unwrapped;\n        }\n        return child.children;\n      }\n      child.data = {\n        hName: \"component-slot\",\n        hProperties: {\n          ...child.attributes,\n          [`v-slot:${child.name}`]: \"\"\n        }\n      };\n      return child;\n    });\n    this.exit(token);\n  }\n  function enterContainerSection(token) {\n    enterToken.call(this, \"componentContainerSection\", token);\n  }\n  function enterContainerDataSection(token) {\n    enterToken.call(this, \"componentContainerDataSection\", token);\n  }\n  function exitContainerSection(token) {\n    const section = this.stack[this.stack.length - 1];\n    attemptClosingOpenListSection.call(this, section);\n    experimentalAutoUnwrap(section);\n    this.exit(token);\n  }\n  function exitContainerDataSection(token) {\n    let section = this.stack[this.stack.length - 1];\n    section = attemptClosingOpenListSection.call(this, section);\n    if (section.type === \"componentContainerDataSection\") {\n      section.rawData = this.sliceSerialize(token);\n      this.exit(token);\n    }\n  }\n  function exitContainerSectionTitle(token) {\n    this.stack[this.stack.length - 1].name = this.sliceSerialize(token)?.trim();\n  }\n  function enterLeaf(token) {\n    enterToken.call(this, \"leafComponent\", token);\n  }\n  function enterTextSpan(token) {\n    this.enter({ type: \"textComponent\", name: \"span\", attributes: {}, children: [] }, token);\n  }\n  function enterText(token) {\n    enterToken.call(this, \"textComponent\", token);\n  }\n  function enterToken(type, token) {\n    this.enter({ type, name: \"\", attributes: {}, children: [] }, token);\n  }\n  function componentContainerName(token) {\n    this.stack[this.stack.length - 1].name = kebabCase(this.sliceSerialize(token));\n  }\n  function exitName(token) {\n    this.stack[this.stack.length - 1].name = this.sliceSerialize(token);\n  }\n  function enterContainerLabel(token) {\n    this.enter({ type: \"paragraph\", data: { componentLabel: true }, children: [] }, token);\n  }\n  function exitContainerLabel(token) {\n    this.exit(token);\n  }\n  function enterAttributes() {\n    this.data.componentAttributes = [];\n    this.buffer();\n  }\n  function exitAttributeIdValue(token) {\n    this.data.componentAttributes.push([\"id\", parseEntities(this.sliceSerialize(token))]);\n  }\n  function exitAttributeClassValue(token) {\n    this.data.componentAttributes.push([\"class\", parseEntities(this.sliceSerialize(token))]);\n  }\n  function exitAttributeValue(token) {\n    const attributes = this.data.componentAttributes;\n    attributes[attributes.length - 1][1] = parseEntities(this.sliceSerialize(token));\n  }\n  function exitAttributeName(token) {\n    this.data.componentAttributes.push([this.sliceSerialize(token), true]);\n  }\n  function exitAttributes() {\n    const attributes = this.data.componentAttributes;\n    const cleaned = {};\n    let index = -1;\n    let attribute;\n    while (++index < attributes.length) {\n      attribute = attributes[index];\n      const name = kebabCase(attribute[0]);\n      if (name === \"class\" && cleaned.class) {\n        cleaned.class += \" \" + attribute[1];\n      } else {\n        cleaned[name] = attribute[1];\n      }\n    }\n    this.data.componentAttributes = attributes;\n    this.resume();\n    let stackTop = this.stack[this.stack.length - 1];\n    if (stackTop.type !== \"textComponent\" || stackTop.name === \"span\") {\n      while (!stackTop.position?.end && stackTop.children?.length > 0) {\n        stackTop = stackTop.children[stackTop.children.length - 1];\n      }\n    }\n    stackTop.attributes = cleaned;\n  }\n  function exitToken(token) {\n    this.exit(token);\n  }\n  function conditionalExit(token) {\n    const [section] = this.tokenStack[this.tokenStack.length - 1];\n    if (section.type === token.type) {\n      this.exit(token);\n    }\n  }\n  function attemptClosingOpenListSection(section) {\n    while (section.type === \"listItem\" || section.type === \"list\") {\n      const [stackToken] = this.tokenStack[this.tokenStack.length - 1];\n      this.exit(stackToken);\n      section = this.stack[this.stack.length - 1];\n    }\n    return section;\n  }\n  return {\n    canContainEols,\n    enter,\n    exit\n  };\n};\n\nconst ContainerSequenceSize = 2;\nconst SectionSequenceSize = 3;\nconst slotSeparatorCode = 35;\nconst slotSeparatorLength = 1;\nconst Codes = {\n  /**\n   * null\n   */\n  EOF: null,\n  /**\n   * ' '\n   */\n  space: 32,\n  /**\n   * '\"'\n   */\n  quotationMark: 34,\n  /**\n   * '#'\n   */\n  hash: 35,\n  /**\n   * ' ' '\n   */\n  apostrophe: 39,\n  /**\n   * '('\n   */\n  openingParentheses: 40,\n  /**\n   * ')'\n   */\n  closingParentheses: 41,\n  /**\n   * '*'\n   */\n  star: 42,\n  /**\n   * ','\n   **/\n  comma: 44,\n  /**\n   * '-'\n   */\n  dash: 45,\n  /**\n   * '.'\n   */\n  dot: 46,\n  /**\n   * ':'\n   */\n  colon: 58,\n  /**\n   * '<'\n   */\n  LessThan: 60,\n  /**\n   * '='\n   */\n  equals: 61,\n  /**\n   * '>'\n   */\n  greaterThan: 62,\n  /**\n   * 'X'\n   */\n  uppercaseX: 88,\n  /**\n   * '['\n   */\n  openingSquareBracket: 91,\n  /**\n   * '\\'\n   */\n  backSlash: 92,\n  /**\n   * ']'\n   */\n  closingSquareBracket: 93,\n  /**\n   * '_'\n   */\n  underscore: 95,\n  /**\n   * '`'\n   */\n  backTick: 96,\n  /**\n   * 'x'\n   */\n  lowercaseX: 120,\n  /**\n   * '{'\n   */\n  openingCurlyBracket: 123,\n  /**\n   * '}'\n   */\n  closingCurlyBracket: 125\n};\n\nfunction createLabel(effects, ok, nok, type, markerType, stringType, disallowEol) {\n  let size = 0;\n  let balance = 0;\n  return start;\n  function start(code) {\n    if (code !== Codes.openingSquareBracket) {\n      throw new Error(\"expected `[`\");\n    }\n    effects.enter(type);\n    effects.enter(markerType);\n    effects.consume(code);\n    effects.exit(markerType);\n    return afterStart;\n  }\n  function afterStart(code) {\n    if (code === Codes.closingSquareBracket) {\n      effects.enter(markerType);\n      effects.consume(code);\n      effects.exit(markerType);\n      effects.exit(type);\n      return ok;\n    }\n    effects.enter(stringType);\n    return atBreak(code);\n  }\n  function atBreak(code) {\n    if (code === Codes.EOF || /* <https://github.com/micromark/micromark/blob/bf53bf9/lib/constant/constants.js#L34> */\n    size > 999) {\n      return nok(code);\n    }\n    if (code === Codes.closingSquareBracket && !balance--) {\n      return atClosingBrace(code);\n    }\n    if (markdownLineEnding(code)) {\n      if (disallowEol) {\n        return nok(code);\n      }\n      effects.enter(\"lineEnding\");\n      effects.consume(code);\n      effects.exit(\"lineEnding\");\n      return atBreak;\n    }\n    effects.enter(\"chunkText\", { contentType: \"text\" });\n    return label(code);\n  }\n  function label(code) {\n    if (code === Codes.EOF || markdownLineEnding(code) || /* <https://github.com/micromark/micromark/blob/bf53bf9/lib/constant/constants.js#L34> */\n    size > 999) {\n      effects.exit(\"chunkText\");\n      return atBreak(code);\n    }\n    if (code === Codes.openingSquareBracket && ++balance > 3) {\n      return nok(code);\n    }\n    if (code === Codes.closingSquareBracket && !balance--) {\n      effects.exit(\"chunkText\");\n      return atClosingBrace(code);\n    }\n    effects.consume(code);\n    return code === Codes.backSlash ? labelEscape : label;\n  }\n  function atClosingBrace(code) {\n    effects.exit(stringType);\n    effects.enter(markerType);\n    effects.consume(code);\n    effects.exit(markerType);\n    effects.exit(type);\n    return ok;\n  }\n  function labelEscape(code) {\n    if (code === Codes.openingSquareBracket || code === Codes.backSlash || code === Codes.closingSquareBracket) {\n      effects.consume(code);\n      size++;\n      return label;\n    }\n    return label(code);\n  }\n}\n\nconst label$2 = { tokenize: tokenizeLabel$2, partial: true };\nconst gfmCheck = { tokenize: checkGfmTaskCheckbox, partial: true };\nconst doubleBracketCheck = { tokenize: checkDoubleBracket, partial: true };\nfunction tokenize$6(effects, ok, nok) {\n  const self = this;\n  return start;\n  function start(code) {\n    if (code !== Codes.openingSquareBracket) {\n      throw new Error(\"expected `[`\");\n    }\n    if (self.previous === Codes.EOF && self._gfmTasklistFirstContentOfListItem) {\n      return effects.check(gfmCheck, nok, attemptLabel)(code);\n    }\n    if (self.previous === Codes.openingSquareBracket) {\n      return nok(code);\n    }\n    return effects.check(doubleBracketCheck, nok, attemptLabel)(code);\n  }\n  function attemptLabel(code) {\n    effects.enter(\"textSpan\");\n    return effects.attempt(label$2, exit, nok)(code);\n  }\n  function exit(code) {\n    if (code === Codes.openingParentheses || code === Codes.openingSquareBracket) {\n      return nok(code);\n    }\n    return exitOK(code);\n  }\n  function exitOK(code) {\n    effects.exit(\"textSpan\");\n    return ok(code);\n  }\n}\nfunction tokenizeLabel$2(effects, ok, nok) {\n  return createLabel(effects, ok, nok, \"componentTextLabel\", \"componentTextLabelMarker\", \"componentTextLabelString\");\n}\nconst tokenizeSpan = {\n  tokenize: tokenize$6\n};\nfunction checkGfmTaskCheckbox(effects, ok, nok) {\n  return enter;\n  function enter(code) {\n    effects.enter(\"formGfmTaskCheckbox\");\n    effects.consume(code);\n    return check;\n  }\n  function check(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return check;\n    }\n    if (code === Codes.uppercaseX || code === Codes.lowercaseX) {\n      effects.consume(code);\n      return check;\n    }\n    if (code === Codes.closingSquareBracket) {\n      effects.exit(\"formGfmTaskCheckbox\");\n      return ok(code);\n    }\n    return nok(code);\n  }\n}\nfunction checkDoubleBracket(effects, ok, nok) {\n  return enter;\n  function enter(code) {\n    effects.enter(\"doubleBracket\");\n    effects.consume(code);\n    return check;\n  }\n  function check(code) {\n    if (code !== Codes.openingSquareBracket) {\n      return nok(code);\n    }\n    effects.exit(\"doubleBracket\");\n    return ok(code);\n  }\n}\n\nfunction createAttributes(effects, ok, nok, attributesType, attributesMarkerType, attributeType, attributeIdType, attributeClassType, attributeNameType, attributeInitializerType, attributeValueLiteralType, attributeValueType, attributeValueMarker, attributeValueData, disallowEol) {\n  let type;\n  let marker;\n  return start;\n  function start(code) {\n    effects.enter(attributesType);\n    effects.enter(attributesMarkerType);\n    effects.consume(code);\n    effects.exit(attributesMarkerType);\n    return between;\n  }\n  function between(code) {\n    if (code === Codes.hash) {\n      type = attributeIdType;\n      return shortcutStart(code);\n    }\n    if (code === Codes.dot) {\n      type = attributeClassType;\n      return shortcutStart(code);\n    }\n    if (code === Codes.colon || code === Codes.underscore || asciiAlpha(code)) {\n      effects.enter(attributeType);\n      effects.enter(attributeNameType);\n      effects.consume(code);\n      return code === Codes.colon ? bindAttributeName : name;\n    }\n    if (disallowEol && markdownSpace(code)) {\n      return factorySpace(effects, between, \"whitespace\")(code);\n    }\n    if (!disallowEol && markdownLineEndingOrSpace(code)) {\n      return factoryWhitespace(effects, between)(code);\n    }\n    return end(code);\n  }\n  function shortcutStart(code) {\n    effects.enter(attributeType);\n    effects.enter(type);\n    effects.enter(type + \"Marker\");\n    effects.consume(code);\n    effects.exit(type + \"Marker\");\n    return shortcutStartAfter;\n  }\n  function shortcutStartAfter(code) {\n    if (code === Codes.EOF || code === Codes.quotationMark || code === Codes.hash || code === Codes.apostrophe || code === Codes.dot || code === Codes.LessThan || code === Codes.equals || code === Codes.greaterThan || code === Codes.backTick || code === Codes.closingCurlyBracket || markdownLineEndingOrSpace(code)) {\n      return nok(code);\n    }\n    effects.enter(type + \"Value\");\n    effects.consume(code);\n    return shortcut;\n  }\n  function shortcut(code) {\n    if (code === Codes.EOF || code === Codes.quotationMark || code === Codes.apostrophe || code === Codes.LessThan || code === Codes.equals || code === Codes.greaterThan || code === Codes.backTick) {\n      return nok(code);\n    }\n    if (code === Codes.hash || code === Codes.dot || code === Codes.closingCurlyBracket || markdownLineEndingOrSpace(code)) {\n      effects.exit(type + \"Value\");\n      effects.exit(type);\n      effects.exit(attributeType);\n      return between(code);\n    }\n    effects.consume(code);\n    return shortcut;\n  }\n  function bindAttributeName(code) {\n    if (code === Codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return bindAttributeName;\n    }\n    effects.exit(attributeNameType);\n    if (disallowEol && markdownSpace(code)) {\n      return factorySpace(effects, bindAttributeNameAfter, \"whitespace\")(code);\n    }\n    if (!disallowEol && markdownLineEndingOrSpace(code)) {\n      return factoryWhitespace(effects, bindAttributeNameAfter)(code);\n    }\n    return bindAttributeNameAfter(code);\n  }\n  function bindAttributeNameAfter(code) {\n    if (code === Codes.equals) {\n      effects.enter(attributeInitializerType);\n      effects.consume(code);\n      effects.exit(attributeInitializerType);\n      return valueBefore;\n    }\n    effects.exit(attributeType);\n    return nok(code);\n  }\n  function name(code) {\n    if (code === Codes.dash || code === Codes.dot || code === Codes.colon || code === Codes.underscore || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return name;\n    }\n    effects.exit(attributeNameType);\n    if (disallowEol && markdownSpace(code)) {\n      return factorySpace(effects, nameAfter, \"whitespace\")(code);\n    }\n    if (!disallowEol && markdownLineEndingOrSpace(code)) {\n      return factoryWhitespace(effects, nameAfter)(code);\n    }\n    return nameAfter(code);\n  }\n  function nameAfter(code) {\n    if (code === Codes.equals) {\n      effects.enter(attributeInitializerType);\n      effects.consume(code);\n      effects.exit(attributeInitializerType);\n      return valueBefore;\n    }\n    effects.exit(attributeType);\n    return between(code);\n  }\n  function valueBefore(code) {\n    if (code === Codes.EOF || code === Codes.LessThan || code === Codes.equals || code === Codes.greaterThan || code === Codes.backTick || code === Codes.closingCurlyBracket || disallowEol && markdownLineEnding(code)) {\n      return nok(code);\n    }\n    if (code === Codes.quotationMark || code === Codes.apostrophe) {\n      effects.enter(attributeValueLiteralType);\n      effects.enter(attributeValueMarker);\n      effects.consume(code);\n      effects.exit(attributeValueMarker);\n      marker = code;\n      return valueQuotedStart;\n    }\n    if (disallowEol && markdownSpace(code)) {\n      return factorySpace(effects, valueBefore, \"whitespace\")(code);\n    }\n    if (!disallowEol && markdownLineEndingOrSpace(code)) {\n      return factoryWhitespace(effects, valueBefore)(code);\n    }\n    effects.enter(attributeValueType);\n    effects.enter(attributeValueData);\n    effects.consume(code);\n    marker = void 0;\n    return valueUnquoted;\n  }\n  function valueUnquoted(code) {\n    if (code === Codes.EOF || code === Codes.quotationMark || code === Codes.apostrophe || code === Codes.LessThan || code === Codes.equals || code === Codes.greaterThan || code === Codes.backTick) {\n      return nok(code);\n    }\n    if (code === Codes.closingCurlyBracket || markdownLineEndingOrSpace(code)) {\n      effects.exit(attributeValueData);\n      effects.exit(attributeValueType);\n      effects.exit(attributeType);\n      return between(code);\n    }\n    effects.consume(code);\n    return valueUnquoted;\n  }\n  function valueQuotedStart(code) {\n    if (code === marker) {\n      effects.enter(attributeValueMarker);\n      effects.consume(code);\n      effects.exit(attributeValueMarker);\n      effects.exit(attributeValueLiteralType);\n      effects.exit(attributeType);\n      return valueQuotedAfter;\n    }\n    effects.enter(attributeValueType);\n    return valueQuotedBetween(code);\n  }\n  function valueQuotedBetween(code) {\n    if (code === marker) {\n      effects.exit(attributeValueType);\n      return valueQuotedStart(code);\n    }\n    if (code === Codes.EOF) {\n      return nok(code);\n    }\n    if (markdownLineEnding(code)) {\n      return disallowEol ? nok(code) : factoryWhitespace(effects, valueQuotedBetween)(code);\n    }\n    effects.enter(attributeValueData);\n    effects.consume(code);\n    return valueQuoted;\n  }\n  function valueQuoted(code) {\n    if (code === marker || code === Codes.EOF || markdownLineEnding(code)) {\n      effects.exit(attributeValueData);\n      return valueQuotedBetween(code);\n    }\n    effects.consume(code);\n    return valueQuoted;\n  }\n  function valueQuotedAfter(code) {\n    return code === Codes.closingCurlyBracket || markdownLineEndingOrSpace(code) ? between(code) : end(code);\n  }\n  function end(code) {\n    if (code === Codes.closingCurlyBracket) {\n      effects.enter(attributesMarkerType);\n      effects.consume(code);\n      effects.exit(attributesMarkerType);\n      effects.exit(attributesType);\n      return ok;\n    }\n    return nok(code);\n  }\n}\n\nconst attributes$2 = { tokenize: tokenizeAttributes$2, partial: true };\nconst validEvents = [\n  /**\n   * Span\n   */\n  \"textSpan\",\n  /**\n   * Bold & Italic\n   */\n  \"attentionSequence\",\n  /**\n   * Inline Code\n   */\n  \"codeText\",\n  /**\n   * Link\n   */\n  \"link\",\n  /**\n   * Image\n   */\n  \"image\"\n];\nfunction tokenize$5(effects, ok, nok) {\n  const self = this;\n  return start;\n  function start(code) {\n    if (code !== Codes.openingCurlyBracket) {\n      throw new Error(\"expected `{`\");\n    }\n    const event = self.events[self.events.length - 1];\n    if (markdownLineEnding(self.previous) || !event || !validEvents.includes(event[1].type)) {\n      return nok(code);\n    }\n    return effects.attempt(attributes$2, ok, nok)(code);\n  }\n}\nfunction tokenizeAttributes$2(effects, ok, nok) {\n  return createAttributes(\n    effects,\n    ok,\n    nok,\n    \"componentTextAttributes\",\n    \"componentTextAttributesMarker\",\n    \"componentTextAttribute\",\n    \"componentTextAttributeId\",\n    \"componentTextAttributeClass\",\n    \"componentTextAttributeName\",\n    \"componentTextAttributeInitializerMarker\",\n    \"componentTextAttributeValueLiteral\",\n    \"componentTextAttributeValue\",\n    \"componentTextAttributeValueMarker\",\n    \"componentTextAttributeValueData\"\n  );\n}\nconst tokenizeAttribute = {\n  tokenize: tokenize$5\n};\n\nfunction attempClose(effects, ok, nok) {\n  return start;\n  function start(code) {\n    if (code !== Codes.closingCurlyBracket) {\n      return nok(code);\n    }\n    effects.exit(\"bindingContent\");\n    effects.enter(\"bindingFence\");\n    effects.consume(code);\n    return secondBracket;\n  }\n  function secondBracket(code) {\n    if (code !== Codes.closingCurlyBracket) {\n      return nok(code);\n    }\n    effects.consume(code);\n    effects.exit(\"bindingFence\");\n    return ok;\n  }\n}\nfunction tokenize$4(effects, ok, nok) {\n  return start;\n  function start(code) {\n    if (code !== Codes.openingCurlyBracket) {\n      throw new Error(\"expected `{`\");\n    }\n    effects.enter(\"bindingFence\");\n    effects.consume(code);\n    return secondBracket;\n  }\n  function secondBracket(code) {\n    if (code !== Codes.openingCurlyBracket) {\n      return nok(code);\n    }\n    effects.consume(code);\n    effects.exit(\"bindingFence\");\n    effects.enter(\"bindingContent\");\n    return content;\n  }\n  function content(code) {\n    if (code === Codes.closingCurlyBracket) {\n      return effects.attempt({ tokenize: attempClose, partial: true }, close, (code2) => {\n        effects.consume(code2);\n        return content;\n      })(code);\n    }\n    effects.consume(code);\n    return content;\n  }\n  function close(code) {\n    return ok(code);\n  }\n}\nconst tokenizeBinding = {\n  tokenize: tokenize$4\n};\n\nfunction createName(effects, ok, nok, nameType) {\n  const self = this;\n  return start;\n  function start(code) {\n    if (asciiAlpha(code)) {\n      effects.enter(nameType);\n      effects.consume(code);\n      return name;\n    }\n    return nok(code);\n  }\n  function name(code) {\n    if (code === Codes.dash || code === Codes.underscore || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return name;\n    }\n    effects.exit(nameType);\n    return self.previous === Codes.underscore ? nok(code) : ok(code);\n  }\n}\n\nconst label$1 = { tokenize: tokenizeLabel$1, partial: true };\nconst attributes$1 = { tokenize: tokenizeAttributes$1, partial: true };\nfunction previous(code) {\n  return code !== Codes.colon || this.events[this.events.length - 1][1].type === \"characterEscape\";\n}\nfunction tokenize$3(effects, ok, nok) {\n  const self = this;\n  return start;\n  function start(code) {\n    if (code !== Codes.colon) {\n      throw new Error(\"expected `:`\");\n    }\n    if (self.previous !== null && !markdownLineEndingOrSpace(self.previous) && ![Codes.openingSquareBracket, Codes.star, Codes.underscore].includes(self.previous)) {\n      return nok(code);\n    }\n    if (!previous.call(self, self.previous)) {\n      throw new Error(\"expected correct previous\");\n    }\n    effects.enter(\"componentText\");\n    effects.enter(\"componentTextMarker\");\n    effects.consume(code);\n    effects.exit(\"componentTextMarker\");\n    return createName.call(self, effects, afterName, nok, \"componentTextName\");\n  }\n  function afterName(code) {\n    if (code === Codes.colon) {\n      return nok(code);\n    }\n    if (code === Codes.openingSquareBracket) {\n      return effects.attempt(label$1, afterLabel, afterLabel)(code);\n    }\n    if (code === Codes.openingCurlyBracket) {\n      return effects.attempt(attributes$1, afterAttributes, afterAttributes)(code);\n    }\n    return exit(code);\n  }\n  function afterAttributes(code) {\n    if (code === Codes.openingSquareBracket) {\n      return effects.attempt(label$1, afterLabel, afterLabel)(code);\n    }\n    return exit(code);\n  }\n  function afterLabel(code) {\n    if (code === Codes.openingCurlyBracket) {\n      return effects.attempt(attributes$1, exit, exit)(code);\n    }\n    return exit(code);\n  }\n  function exit(code) {\n    effects.exit(\"componentText\");\n    return ok(code);\n  }\n}\nfunction tokenizeLabel$1(effects, ok, nok) {\n  return createLabel(effects, ok, nok, \"componentTextLabel\", \"componentTextLabelMarker\", \"componentTextLabelString\");\n}\nfunction tokenizeAttributes$1(effects, ok, nok) {\n  return createAttributes(\n    effects,\n    ok,\n    nok,\n    \"componentTextAttributes\",\n    \"componentTextAttributesMarker\",\n    \"componentTextAttribute\",\n    \"componentTextAttributeId\",\n    \"componentTextAttributeClass\",\n    \"componentTextAttributeName\",\n    \"componentTextAttributeInitializerMarker\",\n    \"componentTextAttributeValueLiteral\",\n    \"componentTextAttributeValue\",\n    \"componentTextAttributeValueMarker\",\n    \"componentTextAttributeValueData\"\n  );\n}\nconst tokenizeInline = {\n  tokenize: tokenize$3,\n  previous\n};\n\nfunction sizeChunks(chunks) {\n  let index = -1;\n  let size = 0;\n  while (++index < chunks.length) {\n    size += typeof chunks[index] === \"string\" ? chunks[index].length : 1;\n  }\n  return size;\n}\nfunction prefixSize(events, type) {\n  const tail = events[events.length - 1];\n  if (!tail || tail[1].type !== type) {\n    return 0;\n  }\n  return sizeChunks(tail[2].sliceStream(tail[1]));\n}\nfunction linePrefixSize(events) {\n  let size = 0;\n  let index = events.length - 1;\n  let tail = events[index];\n  while (index >= 0 && tail && tail[1].type === \"linePrefix\" && tail[0] === \"exit\") {\n    size += sizeChunks(tail[2].sliceStream(tail[1]));\n    index -= 1;\n    tail = events[index];\n  }\n  return size;\n}\nconst useTokenState = (tokenName) => {\n  const token = {\n    isOpen: false,\n    /**\n     * Enter into token, close previous open token if any\n     */\n    enter: (effects) => {\n      const initialState = token.isOpen;\n      token.exit(effects);\n      effects.enter(tokenName);\n      token.isOpen = true;\n      return () => {\n        token.isOpen = initialState;\n      };\n    },\n    /**\n     * Enter into token only once, if token is already open, do nothing\n     */\n    enterOnce: (effects) => {\n      const initialState = token.isOpen;\n      if (!token.isOpen) {\n        effects.enter(tokenName);\n        token.isOpen = true;\n      }\n      return () => {\n        token.isOpen = initialState;\n      };\n    },\n    /**\n     * Exit from token if it is open\n     */\n    exit: (effects) => {\n      const initialState = token.isOpen;\n      if (token.isOpen) {\n        effects.exit(tokenName);\n        token.isOpen = false;\n      }\n      return () => {\n        token.isOpen = initialState;\n      };\n    }\n  };\n  return token;\n};\nconst tokenizeCodeFence = { tokenize: checkCodeFenced, partial: true };\nfunction checkCodeFenced(effects, ok, nok) {\n  let backTickCount = 0;\n  return start;\n  function start(code) {\n    effects.enter(\"codeFenced\");\n    return after(code);\n  }\n  function after(code) {\n    if (code === Codes.backTick) {\n      backTickCount++;\n      effects.consume(code);\n      return after;\n    }\n    effects.exit(\"codeFenced\");\n    if (backTickCount >= 3) {\n      return ok(code);\n    }\n    return nok(code);\n  }\n}\n\nfunction tokenizeFrontMatter(effects, ok, _nok, next, initialPrefix) {\n  let previous;\n  return effects.attempt({\n    tokenize: tokenizeDataSection,\n    partial: true\n  }, dataSectionOpen, next);\n  function tokenizeDataSection(effects2, ok2, nok) {\n    const self = this;\n    let size = 0;\n    let sectionIndentSize = 0;\n    return closingPrefixAfter;\n    function dataLineFirstSpaces(code) {\n      if (markdownSpace(code)) {\n        effects2.consume(code);\n        sectionIndentSize += 1;\n        return dataLineFirstSpaces;\n      }\n      effects2.exit(\"space\");\n      return closingPrefixAfter(code);\n    }\n    function closingPrefixAfter(code) {\n      if (markdownSpace(code)) {\n        effects2.enter(\"space\");\n        return dataLineFirstSpaces(code);\n      }\n      if (sectionIndentSize === 0) {\n        sectionIndentSize = linePrefixSize(self.events);\n      }\n      effects2.enter(\"componentContainerSectionSequence\");\n      return closingSectionSequence(code);\n    }\n    function closingSectionSequence(code) {\n      if (code === Codes.dash || markdownSpace(code)) {\n        effects2.consume(code);\n        size++;\n        return closingSectionSequence;\n      }\n      if (size < SectionSequenceSize) {\n        return nok(code);\n      }\n      if (sectionIndentSize !== initialPrefix) {\n        return nok(code);\n      }\n      if (!markdownLineEnding(code)) {\n        return nok(code);\n      }\n      effects2.exit(\"componentContainerSectionSequence\");\n      return factorySpace(effects2, ok2, \"whitespace\")(code);\n    }\n  }\n  function dataSectionOpen(code) {\n    effects.enter(\"componentContainerDataSection\");\n    return effects.attempt({\n      tokenize: tokenizeDataSection,\n      partial: true\n    }, dataSectionClose, dataChunkStart)(code);\n  }\n  function dataChunkStart(code) {\n    if (code === null) {\n      effects.exit(\"componentContainerDataSection\");\n      effects.exit(\"componentContainer\");\n      return ok(code);\n    }\n    const token = effects.enter(\"chunkDocument\", {\n      contentType: \"document\",\n      previous\n    });\n    if (previous) {\n      previous.next = token;\n    }\n    previous = token;\n    return dataContentContinue(code);\n  }\n  function dataContentContinue(code) {\n    if (code === null) {\n      effects.exit(\"chunkDocument\");\n      effects.exit(\"componentContainerDataSection\");\n      effects.exit(\"componentContainer\");\n      return ok(code);\n    }\n    if (markdownLineEnding(code)) {\n      effects.consume(code);\n      effects.exit(\"chunkDocument\");\n      return effects.attempt({\n        tokenize: tokenizeDataSection,\n        partial: true\n      }, dataSectionClose, dataChunkStart);\n    }\n    effects.consume(code);\n    return dataContentContinue;\n  }\n  function dataSectionClose(code) {\n    effects.exit(\"componentContainerDataSection\");\n    return factorySpace(effects, next, \"whitespace\")(code);\n  }\n}\n\nconst label = { tokenize: tokenizeLabel, partial: true };\nconst attributes = { tokenize: tokenizeAttributes, partial: true };\nfunction tokenize$2(effects, ok, nok) {\n  const self = this;\n  const initialPrefix = linePrefixSize(this.events);\n  let sizeOpen = 0;\n  let previous;\n  const childContainersSequenceSize = [];\n  let containerFirstLine = true;\n  let visitingCodeFenced = false;\n  const section = useTokenState(\"componentContainerSection\");\n  return start;\n  function start(code) {\n    if (code !== Codes.colon) {\n      throw new Error(\"expected `:`\");\n    }\n    effects.enter(\"componentContainer\");\n    effects.enter(\"componentContainerFence\");\n    effects.enter(\"componentContainerSequence\");\n    return sequenceOpen(code);\n  }\n  function tokenizeSectionClosing(effects2, ok2, nok2) {\n    let size = 0;\n    let sectionIndentSize = 0;\n    let revertSectionState;\n    return closingPrefixAfter;\n    function closingPrefixAfter(code) {\n      sectionIndentSize = linePrefixSize(self.events);\n      revertSectionState = section.exit(effects2);\n      effects2.enter(\"componentContainerSectionSequence\");\n      return closingSectionSequence(code);\n    }\n    function closingSectionSequence(code) {\n      if (code === slotSeparatorCode) {\n        effects2.consume(code);\n        size++;\n        return closingSectionSequence;\n      }\n      if (size !== slotSeparatorLength) {\n        revertSectionState();\n        return nok2(code);\n      }\n      if (sectionIndentSize !== initialPrefix) {\n        revertSectionState();\n        return nok2(code);\n      }\n      if (!asciiAlpha(code)) {\n        revertSectionState();\n        return nok2(code);\n      }\n      effects2.exit(\"componentContainerSectionSequence\");\n      return factorySpace(effects2, ok2, \"whitespace\")(code);\n    }\n  }\n  function sectionOpen(code) {\n    section.enter(effects);\n    if (markdownLineEnding(code)) {\n      return factorySpace(effects, lineStart, \"whitespace\")(code);\n    }\n    effects.enter(\"componentContainerSectionTitle\");\n    return sectionTitle(code);\n  }\n  function sectionTitle(code) {\n    if (markdownLineEnding(code)) {\n      effects.exit(\"componentContainerSectionTitle\");\n      return factorySpace(effects, lineStart, \"linePrefix\", 4)(code);\n    }\n    effects.consume(code);\n    return sectionTitle;\n  }\n  function sequenceOpen(code) {\n    if (code === Codes.colon) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n    if (sizeOpen < ContainerSequenceSize) {\n      return nok(code);\n    }\n    effects.exit(\"componentContainerSequence\");\n    return createName.call(self, effects, afterName, nok, \"componentContainerName\")(code);\n  }\n  function afterName(code) {\n    return code === Codes.openingSquareBracket ? effects.attempt(label, afterLabel, afterLabel)(code) : afterLabel(code);\n  }\n  function afterLabel(code) {\n    return code === Codes.openingCurlyBracket ? effects.attempt(attributes, afterAttributes, afterAttributes)(code) : afterAttributes(code);\n  }\n  function afterAttributes(code) {\n    return factorySpace(effects, openAfter, \"whitespace\")(code);\n  }\n  function openAfter(code) {\n    effects.exit(\"componentContainerFence\");\n    if (code === null) {\n      effects.exit(\"componentContainer\");\n      return ok(code);\n    }\n    if (markdownLineEnding(code)) {\n      effects.enter(\"lineEnding\");\n      effects.consume(code);\n      effects.exit(\"lineEnding\");\n      return self.interrupt ? ok : contentStart;\n    }\n    return nok(code);\n  }\n  function contentStart(code) {\n    if (code === null) {\n      effects.exit(\"componentContainer\");\n      return ok(code);\n    }\n    if (containerFirstLine && (code === Codes.dash || markdownSpace(code))) {\n      containerFirstLine = false;\n      return tokenizeFrontMatter(effects, ok, nok, contentStart, initialPrefix)(code);\n    }\n    effects.enter(\"componentContainerContent\");\n    return lineStart(code);\n  }\n  function lineStartAfterPrefix(code) {\n    if (code === null) {\n      return after(code);\n    }\n    if (code === Codes.backTick) {\n      return effects.check(\n        tokenizeCodeFence,\n        (code2) => {\n          visitingCodeFenced = !visitingCodeFenced;\n          return chunkStart(code2);\n        },\n        chunkStart\n      )(code);\n    }\n    if (visitingCodeFenced) {\n      return chunkStart(code);\n    }\n    if (!childContainersSequenceSize.length && (code === slotSeparatorCode || code === Codes.space)) {\n      return effects.attempt(\n        { tokenize: tokenizeSectionClosing, partial: true },\n        sectionOpen,\n        chunkStart\n      )(code);\n    }\n    if (code === Codes.colon) {\n      return effects.attempt(\n        { tokenize: tokenizeClosingFence, partial: true },\n        after,\n        chunkStart\n      )(code);\n    }\n    return chunkStart(code);\n  }\n  function lineStart(code) {\n    if (code === null) {\n      return after(code);\n    }\n    return initialPrefix ? factorySpace(effects, lineStartAfterPrefix, \"linePrefix\", initialPrefix + 1)(code) : lineStartAfterPrefix(code);\n  }\n  function chunkStart(code) {\n    if (code === null) {\n      return after(code);\n    }\n    section.enterOnce(effects);\n    const token = effects.enter(\"chunkDocument\", {\n      contentType: \"document\",\n      previous\n    });\n    if (previous) {\n      previous.next = token;\n    }\n    previous = token;\n    return contentContinue(code);\n  }\n  function contentContinue(code) {\n    if (code === null) {\n      effects.exit(\"chunkDocument\");\n      return after(code);\n    }\n    if (markdownLineEnding(code)) {\n      effects.consume(code);\n      effects.exit(\"chunkDocument\");\n      return lineStart;\n    }\n    effects.consume(code);\n    return contentContinue;\n  }\n  function after(code) {\n    section.exit(effects);\n    effects.exit(\"componentContainerContent\");\n    effects.exit(\"componentContainer\");\n    return ok(code);\n  }\n  function tokenizeClosingFence(effects2, ok2, nok2) {\n    let size = 0;\n    return factorySpace(effects2, closingPrefixAfter, \"linePrefix\", 4);\n    function closingPrefixAfter(code) {\n      effects2.enter(\"componentContainerFence\");\n      effects2.enter(\"componentContainerSequence\");\n      return closingSequence(code);\n    }\n    function closingSequence(code) {\n      if (code === Codes.colon) {\n        effects2.consume(code);\n        size++;\n        return closingSequence;\n      }\n      if (childContainersSequenceSize.length) {\n        if (size === childContainersSequenceSize[childContainersSequenceSize.length - 1]) {\n          childContainersSequenceSize.pop();\n        }\n        return nok2(code);\n      }\n      if (size !== sizeOpen) {\n        return nok2(code);\n      }\n      effects2.exit(\"componentContainerSequence\");\n      return factorySpace(effects2, closingSequenceEnd, \"whitespace\")(code);\n    }\n    function closingSequenceEnd(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects2.exit(\"componentContainerFence\");\n        return ok2(code);\n      }\n      childContainersSequenceSize.push(size);\n      return nok2(code);\n    }\n  }\n}\nfunction tokenizeLabel(effects, ok, nok) {\n  return createLabel(\n    effects,\n    ok,\n    nok,\n    \"componentContainerLabel\",\n    \"componentContainerLabelMarker\",\n    \"componentContainerLabelString\",\n    true\n  );\n}\nfunction tokenizeAttributes(effects, ok, nok) {\n  return createAttributes(\n    effects,\n    ok,\n    nok,\n    \"componentContainerAttributes\",\n    \"componentContainerAttributesMarker\",\n    \"componentContainerAttribute\",\n    \"componentContainerAttributeId\",\n    \"componentContainerAttributeClass\",\n    \"componentContainerAttributeName\",\n    \"componentContainerAttributeInitializerMarker\",\n    \"componentContainerAttributeValueLiteral\",\n    \"componentContainerAttributeValue\",\n    \"componentContainerAttributeValueMarker\",\n    \"componentContainerAttributeValueData\",\n    true\n  );\n}\nconst tokenizeContainer = {\n  tokenize: tokenize$2,\n  concrete: true\n};\n\nfunction tokenize$1(effects, ok, nok) {\n  const self = this;\n  return factorySpace(effects, lineStart, \"linePrefix\");\n  function lineStart(code) {\n    if (prefixSize(self.events, \"linePrefix\") < 4) {\n      return nok(code);\n    }\n    switch (code) {\n      case Codes.backTick:\n        return codeFenced.tokenize.call(self, effects, ok, nok)(code);\n      case Codes.colon:\n        return tokenizeContainer.tokenize.call(self, effects, ok, nok)(code);\n      default:\n        return nok(code);\n    }\n  }\n}\nconst tokenizeContainerIndented = {\n  tokenize: tokenize$1\n};\n\nfunction tokenize(effects, ok, nok) {\n  const self = this;\n  const tokenizeSugerSyntax = tokenizeInline.tokenize.call(\n    self,\n    effects,\n    factorySpace(effects, exit, \"linePrefix\"),\n    nok\n  );\n  return factorySpace(effects, lineStart, \"linePrefix\");\n  function lineStart(code) {\n    if (code === Codes.colon) {\n      return tokenizeSugerSyntax(code);\n    }\n    return nok(code);\n  }\n  function exit(code) {\n    if (markdownLineEnding(code) || code === Codes.EOF) {\n      return ok(code);\n    }\n    return nok(code);\n  }\n}\nconst tokenizeContainerSuger = {\n  tokenize\n};\n\nfunction micromarkComponentsExtension() {\n  return {\n    text: {\n      [Codes.colon]: tokenizeInline,\n      [Codes.openingSquareBracket]: [tokenizeSpan],\n      [Codes.openingCurlyBracket]: [tokenizeBinding, tokenizeAttribute]\n    },\n    flow: {\n      [Codes.colon]: [tokenizeContainer, tokenizeContainerSuger]\n    },\n    flowInitial: {\n      \"-2\": tokenizeContainerIndented,\n      \"-1\": tokenizeContainerIndented,\n      [Codes.space]: tokenizeContainerIndented\n    }\n  };\n}\n\nconst toFrontMatter = (yamlString) => `---\n${yamlString}\n---`;\nconst index = (function(opts = {}) {\n  const data = this.data();\n  add(\"micromarkExtensions\", micromarkComponentsExtension());\n  add(\"fromMarkdownExtensions\", fromMarkdown(opts));\n  add(\"toMarkdownExtensions\", toMarkdown(opts));\n  function add(field, value) {\n    if (!data[field]) {\n      data[field] = [];\n    }\n    data[field].push(value);\n  }\n  if (opts?.components?.length) {\n    return async (tree, { data: data2 }) => {\n      const jobs = [];\n      visit(tree, [\"textComponent\", \"leafComponent\", \"containerComponent\"], (node) => {\n        bindNode(node);\n        const { instance: handler, options } = opts.components.find((c) => c.name === node.name) || {};\n        if (handler) {\n          jobs.push(handler(options)(node, data2));\n        }\n      });\n      await Promise.all(jobs);\n      return tree;\n    };\n  }\n  return (tree) => {\n    visit(tree, [\"textComponent\", \"leafComponent\", \"containerComponent\"], (node) => {\n      bindNode(node);\n    });\n  };\n});\nfunction bindNode(node) {\n  const nodeData = node.data || (node.data = {});\n  node.fmAttributes = getNodeData(node);\n  nodeData.hName = kebabCase(node.name);\n  nodeData.hProperties = bindData(\n    {\n      ...node.attributes,\n      // Parse data slots and retrieve data\n      ...node.fmAttributes\n    }\n  );\n}\nfunction getNodeData(node) {\n  if (!node.rawData) {\n    return {};\n  }\n  const yaml = node.rawData.replace(/\\s-+$/, \"\");\n  const { data } = parseFrontMatter(toFrontMatter(yaml));\n  return data;\n}\nfunction bindData(data) {\n  const entries = Object.entries(data).map(([key, value]) => {\n    if (key.startsWith(\":\")) {\n      return [key, value];\n    }\n    if (typeof value === \"string\") {\n      return [key, value];\n    }\n    return [`:${key}`, JSON.stringify(value)];\n  });\n  return Object.fromEntries(entries);\n}\n\nexport { index as default, parseFrontMatter, stringifyFrontMatter };\n",
      "start": 1712268127410,
      "end": 1712268127419,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "normal"
    },
    {
      "name": "nuxt:fonts:font-family-injection",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1712268127419,
      "end": 1712268127419,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1712268127419,
      "end": 1712268127420,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1712268127420,
      "end": 1712268127420,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1712268127420,
      "end": 1712268127420,
      "order": "normal"
    }
  ]
}
