{
  "resolvedId": "/Users/rezajafar/peakofeloquence-site/node_modules/@shikijs/core/dist/textmate.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { FontStyle } from './types.mjs';\n\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n({\n    InDebugMode: (typeof process !== 'undefined' && !!process.env['VSCODE_TEXTMATE_DEBUG'])\n});\n\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nvar EncodedTokenAttributes;\n(function (EncodedTokenAttributes) {\n    function toBinaryStr(encodedTokenAttributes) {\n        return encodedTokenAttributes.toString(2).padStart(32, \"0\");\n    }\n    EncodedTokenAttributes.toBinaryStr = toBinaryStr;\n    function print(encodedTokenAttributes) {\n        const languageId = EncodedTokenAttributes.getLanguageId(encodedTokenAttributes);\n        const tokenType = EncodedTokenAttributes.getTokenType(encodedTokenAttributes);\n        const fontStyle = EncodedTokenAttributes.getFontStyle(encodedTokenAttributes);\n        const foreground = EncodedTokenAttributes.getForeground(encodedTokenAttributes);\n        const background = EncodedTokenAttributes.getBackground(encodedTokenAttributes);\n        console.log({\n            languageId: languageId,\n            tokenType: tokenType,\n            fontStyle: fontStyle,\n            foreground: foreground,\n            background: background,\n        });\n    }\n    EncodedTokenAttributes.print = print;\n    function getLanguageId(encodedTokenAttributes) {\n        return ((encodedTokenAttributes & 255 /* EncodedTokenDataConsts.LANGUAGEID_MASK */) >>>\n            0 /* EncodedTokenDataConsts.LANGUAGEID_OFFSET */);\n    }\n    EncodedTokenAttributes.getLanguageId = getLanguageId;\n    function getTokenType(encodedTokenAttributes) {\n        return ((encodedTokenAttributes & 768 /* EncodedTokenDataConsts.TOKEN_TYPE_MASK */) >>>\n            8 /* EncodedTokenDataConsts.TOKEN_TYPE_OFFSET */);\n    }\n    EncodedTokenAttributes.getTokenType = getTokenType;\n    function containsBalancedBrackets(encodedTokenAttributes) {\n        return (encodedTokenAttributes & 1024 /* EncodedTokenDataConsts.BALANCED_BRACKETS_MASK */) !== 0;\n    }\n    EncodedTokenAttributes.containsBalancedBrackets = containsBalancedBrackets;\n    function getFontStyle(encodedTokenAttributes) {\n        return ((encodedTokenAttributes & 30720 /* EncodedTokenDataConsts.FONT_STYLE_MASK */) >>>\n            11 /* EncodedTokenDataConsts.FONT_STYLE_OFFSET */);\n    }\n    EncodedTokenAttributes.getFontStyle = getFontStyle;\n    function getForeground(encodedTokenAttributes) {\n        return ((encodedTokenAttributes & 16744448 /* EncodedTokenDataConsts.FOREGROUND_MASK */) >>>\n            15 /* EncodedTokenDataConsts.FOREGROUND_OFFSET */);\n    }\n    EncodedTokenAttributes.getForeground = getForeground;\n    function getBackground(encodedTokenAttributes) {\n        return ((encodedTokenAttributes & 4278190080 /* EncodedTokenDataConsts.BACKGROUND_MASK */) >>>\n            24 /* EncodedTokenDataConsts.BACKGROUND_OFFSET */);\n    }\n    EncodedTokenAttributes.getBackground = getBackground;\n    /**\n     * Updates the fields in `metadata`.\n     * A value of `0`, `NotSet` or `null` indicates that the corresponding field should be left as is.\n     */\n    function set(encodedTokenAttributes, languageId, tokenType, containsBalancedBrackets, fontStyle, foreground, background) {\n        let _languageId = EncodedTokenAttributes.getLanguageId(encodedTokenAttributes);\n        let _tokenType = EncodedTokenAttributes.getTokenType(encodedTokenAttributes);\n        let _containsBalancedBracketsBit = EncodedTokenAttributes.containsBalancedBrackets(encodedTokenAttributes) ? 1 : 0;\n        let _fontStyle = EncodedTokenAttributes.getFontStyle(encodedTokenAttributes);\n        let _foreground = EncodedTokenAttributes.getForeground(encodedTokenAttributes);\n        let _background = EncodedTokenAttributes.getBackground(encodedTokenAttributes);\n        if (languageId !== 0) {\n            _languageId = languageId;\n        }\n        if (tokenType !== 8 /* OptionalStandardTokenType.NotSet */) {\n            _tokenType = fromOptionalTokenType(tokenType);\n        }\n        if (containsBalancedBrackets !== null) {\n            _containsBalancedBracketsBit = containsBalancedBrackets ? 1 : 0;\n        }\n        if (fontStyle !== -1 /* FontStyle.NotSet */) {\n            _fontStyle = fontStyle;\n        }\n        if (foreground !== 0) {\n            _foreground = foreground;\n        }\n        if (background !== 0) {\n            _background = background;\n        }\n        return (((_languageId << 0 /* EncodedTokenDataConsts.LANGUAGEID_OFFSET */) |\n            (_tokenType << 8 /* EncodedTokenDataConsts.TOKEN_TYPE_OFFSET */) |\n            (_containsBalancedBracketsBit <<\n                10 /* EncodedTokenDataConsts.BALANCED_BRACKETS_OFFSET */) |\n            (_fontStyle << 11 /* EncodedTokenDataConsts.FONT_STYLE_OFFSET */) |\n            (_foreground << 15 /* EncodedTokenDataConsts.FOREGROUND_OFFSET */) |\n            (_background << 24 /* EncodedTokenDataConsts.BACKGROUND_OFFSET */)) >>>\n            0);\n    }\n    EncodedTokenAttributes.set = set;\n})(EncodedTokenAttributes || (EncodedTokenAttributes = {}));\nfunction toOptionalTokenType(standardType) {\n    return standardType;\n}\nfunction fromOptionalTokenType(standardType) {\n    return standardType;\n}\n\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nfunction createMatchers(selector, matchesName) {\n    const results = [];\n    const tokenizer = newTokenizer(selector);\n    let token = tokenizer.next();\n    while (token !== null) {\n        let priority = 0;\n        if (token.length === 2 && token.charAt(1) === ':') {\n            switch (token.charAt(0)) {\n                case 'R':\n                    priority = 1;\n                    break;\n                case 'L':\n                    priority = -1;\n                    break;\n                default:\n                    console.log(`Unknown priority ${token} in scope selector`);\n            }\n            token = tokenizer.next();\n        }\n        let matcher = parseConjunction();\n        results.push({ matcher, priority });\n        if (token !== ',') {\n            break;\n        }\n        token = tokenizer.next();\n    }\n    return results;\n    function parseOperand() {\n        if (token === '-') {\n            token = tokenizer.next();\n            const expressionToNegate = parseOperand();\n            return matcherInput => !!expressionToNegate && !expressionToNegate(matcherInput);\n        }\n        if (token === '(') {\n            token = tokenizer.next();\n            const expressionInParents = parseInnerExpression();\n            if (token === ')') {\n                token = tokenizer.next();\n            }\n            return expressionInParents;\n        }\n        if (isIdentifier(token)) {\n            const identifiers = [];\n            do {\n                identifiers.push(token);\n                token = tokenizer.next();\n            } while (isIdentifier(token));\n            return matcherInput => matchesName(identifiers, matcherInput);\n        }\n        return null;\n    }\n    function parseConjunction() {\n        const matchers = [];\n        let matcher = parseOperand();\n        while (matcher) {\n            matchers.push(matcher);\n            matcher = parseOperand();\n        }\n        return matcherInput => matchers.every(matcher => matcher(matcherInput)); // and\n    }\n    function parseInnerExpression() {\n        const matchers = [];\n        let matcher = parseConjunction();\n        while (matcher) {\n            matchers.push(matcher);\n            if (token === '|' || token === ',') {\n                do {\n                    token = tokenizer.next();\n                } while (token === '|' || token === ','); // ignore subsequent commas\n            }\n            else {\n                break;\n            }\n            matcher = parseConjunction();\n        }\n        return matcherInput => matchers.some(matcher => matcher(matcherInput)); // or\n    }\n}\nfunction isIdentifier(token) {\n    return !!token && !!token.match(/[\\w\\.:]+/);\n}\nfunction newTokenizer(input) {\n    let regex = /([LR]:|[\\w\\.:][\\w\\.:\\-]*|[\\,\\|\\-\\(\\)])/g;\n    let match = regex.exec(input);\n    return {\n        next: () => {\n            if (!match) {\n                return null;\n            }\n            const res = match[0];\n            match = regex.exec(input);\n            return res;\n        }\n    };\n}\n\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nfunction disposeOnigString(str) {\n    if (typeof str.dispose === 'function') {\n        str.dispose();\n    }\n}\n\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nfunction clone(something) {\n    return doClone(something);\n}\nfunction doClone(something) {\n    if (Array.isArray(something)) {\n        return cloneArray(something);\n    }\n    if (typeof something === 'object') {\n        return cloneObj(something);\n    }\n    return something;\n}\nfunction cloneArray(arr) {\n    let r = [];\n    for (let i = 0, len = arr.length; i < len; i++) {\n        r[i] = doClone(arr[i]);\n    }\n    return r;\n}\nfunction cloneObj(obj) {\n    let r = {};\n    for (let key in obj) {\n        r[key] = doClone(obj[key]);\n    }\n    return r;\n}\nfunction mergeObjects(target, ...sources) {\n    sources.forEach(source => {\n        for (let key in source) {\n            target[key] = source[key];\n        }\n    });\n    return target;\n}\nfunction basename(path) {\n    const idx = ~path.lastIndexOf('/') || ~path.lastIndexOf('\\\\');\n    if (idx === 0) {\n        return path;\n    }\n    else if (~idx === path.length - 1) {\n        return basename(path.substring(0, path.length - 1));\n    }\n    else {\n        return path.substr(~idx + 1);\n    }\n}\nlet CAPTURING_REGEX_SOURCE = /\\$(\\d+)|\\${(\\d+):\\/(downcase|upcase)}/g;\nclass RegexSource {\n    static hasCaptures(regexSource) {\n        if (regexSource === null) {\n            return false;\n        }\n        CAPTURING_REGEX_SOURCE.lastIndex = 0;\n        return CAPTURING_REGEX_SOURCE.test(regexSource);\n    }\n    static replaceCaptures(regexSource, captureSource, captureIndices) {\n        return regexSource.replace(CAPTURING_REGEX_SOURCE, (match, index, commandIndex, command) => {\n            let capture = captureIndices[parseInt(index || commandIndex, 10)];\n            if (capture) {\n                let result = captureSource.substring(capture.start, capture.end);\n                // Remove leading dots that would make the selector invalid\n                while (result[0] === '.') {\n                    result = result.substring(1);\n                }\n                switch (command) {\n                    case 'downcase':\n                        return result.toLowerCase();\n                    case 'upcase':\n                        return result.toUpperCase();\n                    default:\n                        return result;\n                }\n            }\n            else {\n                return match;\n            }\n        });\n    }\n}\nfunction strcmp(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nfunction strArrCmp(a, b) {\n    if (a === null && b === null) {\n        return 0;\n    }\n    if (!a) {\n        return -1;\n    }\n    if (!b) {\n        return 1;\n    }\n    let len1 = a.length;\n    let len2 = b.length;\n    if (len1 === len2) {\n        for (let i = 0; i < len1; i++) {\n            let res = strcmp(a[i], b[i]);\n            if (res !== 0) {\n                return res;\n            }\n        }\n        return 0;\n    }\n    return len1 - len2;\n}\nfunction isValidHexColor(hex) {\n    if (/^#[0-9a-f]{6}$/i.test(hex)) {\n        // #rrggbb\n        return true;\n    }\n    if (/^#[0-9a-f]{8}$/i.test(hex)) {\n        // #rrggbbaa\n        return true;\n    }\n    if (/^#[0-9a-f]{3}$/i.test(hex)) {\n        // #rgb\n        return true;\n    }\n    if (/^#[0-9a-f]{4}$/i.test(hex)) {\n        // #rgba\n        return true;\n    }\n    return false;\n}\n/**\n * Escapes regular expression characters in a given string\n */\nfunction escapeRegExpCharacters(value) {\n    return value.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&');\n}\nclass CachedFn {\n    fn;\n    cache = new Map();\n    constructor(fn) {\n        this.fn = fn;\n    }\n    get(key) {\n        if (this.cache.has(key)) {\n            return this.cache.get(key);\n        }\n        const value = this.fn(key);\n        this.cache.set(key, value);\n        return value;\n    }\n}\n\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n/**\n * References the top level rule of a grammar with the given scope name.\n*/\nclass TopLevelRuleReference {\n    scopeName;\n    constructor(scopeName) {\n        this.scopeName = scopeName;\n    }\n    toKey() {\n        return this.scopeName;\n    }\n}\n/**\n * References a rule of a grammar in the top level repository section with the given name.\n*/\nclass TopLevelRepositoryRuleReference {\n    scopeName;\n    ruleName;\n    constructor(scopeName, ruleName) {\n        this.scopeName = scopeName;\n        this.ruleName = ruleName;\n    }\n    toKey() {\n        return `${this.scopeName}#${this.ruleName}`;\n    }\n}\nclass ExternalReferenceCollector {\n    _references = [];\n    _seenReferenceKeys = new Set();\n    get references() {\n        return this._references;\n    }\n    visitedRule = new Set();\n    add(reference) {\n        const key = reference.toKey();\n        if (this._seenReferenceKeys.has(key)) {\n            return;\n        }\n        this._seenReferenceKeys.add(key);\n        this._references.push(reference);\n    }\n}\nclass ScopeDependencyProcessor {\n    repo;\n    initialScopeName;\n    seenFullScopeRequests = new Set();\n    seenPartialScopeRequests = new Set();\n    Q;\n    constructor(repo, initialScopeName) {\n        this.repo = repo;\n        this.initialScopeName = initialScopeName;\n        this.seenFullScopeRequests.add(this.initialScopeName);\n        this.Q = [new TopLevelRuleReference(this.initialScopeName)];\n    }\n    processQueue() {\n        const q = this.Q;\n        this.Q = [];\n        const deps = new ExternalReferenceCollector();\n        for (const dep of q) {\n            collectReferencesOfReference(dep, this.initialScopeName, this.repo, deps);\n        }\n        for (const dep of deps.references) {\n            if (dep instanceof TopLevelRuleReference) {\n                if (this.seenFullScopeRequests.has(dep.scopeName)) {\n                    // already processed\n                    continue;\n                }\n                this.seenFullScopeRequests.add(dep.scopeName);\n                this.Q.push(dep);\n            }\n            else {\n                if (this.seenFullScopeRequests.has(dep.scopeName)) {\n                    // already processed in full\n                    continue;\n                }\n                if (this.seenPartialScopeRequests.has(dep.toKey())) {\n                    // already processed\n                    continue;\n                }\n                this.seenPartialScopeRequests.add(dep.toKey());\n                this.Q.push(dep);\n            }\n        }\n    }\n}\nfunction collectReferencesOfReference(reference, baseGrammarScopeName, repo, result) {\n    const selfGrammar = repo.lookup(reference.scopeName);\n    if (!selfGrammar) {\n        if (reference.scopeName === baseGrammarScopeName) {\n            throw new Error(`No grammar provided for <${baseGrammarScopeName}>`);\n        }\n        return;\n    }\n    const baseGrammar = repo.lookup(baseGrammarScopeName);\n    if (reference instanceof TopLevelRuleReference) {\n        collectExternalReferencesInTopLevelRule({ baseGrammar, selfGrammar }, result);\n    }\n    else {\n        collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, { baseGrammar, selfGrammar, repository: selfGrammar.repository }, result);\n    }\n    const injections = repo.injections(reference.scopeName);\n    if (injections) {\n        for (const injection of injections) {\n            result.add(new TopLevelRuleReference(injection));\n        }\n    }\n}\nfunction collectExternalReferencesInTopLevelRepositoryRule(ruleName, context, result) {\n    if (context.repository && context.repository[ruleName]) {\n        const rule = context.repository[ruleName];\n        collectExternalReferencesInRules([rule], context, result);\n    }\n}\nfunction collectExternalReferencesInTopLevelRule(context, result) {\n    if (context.selfGrammar.patterns && Array.isArray(context.selfGrammar.patterns)) {\n        collectExternalReferencesInRules(context.selfGrammar.patterns, { ...context, repository: context.selfGrammar.repository }, result);\n    }\n    if (context.selfGrammar.injections) {\n        collectExternalReferencesInRules(Object.values(context.selfGrammar.injections), { ...context, repository: context.selfGrammar.repository }, result);\n    }\n}\nfunction collectExternalReferencesInRules(rules, context, result) {\n    for (const rule of rules) {\n        if (result.visitedRule.has(rule)) {\n            continue;\n        }\n        result.visitedRule.add(rule);\n        const patternRepository = rule.repository ? mergeObjects({}, context.repository, rule.repository) : context.repository;\n        if (Array.isArray(rule.patterns)) {\n            collectExternalReferencesInRules(rule.patterns, { ...context, repository: patternRepository }, result);\n        }\n        const include = rule.include;\n        if (!include) {\n            continue;\n        }\n        const reference = parseInclude(include);\n        switch (reference.kind) {\n            case 0 /* IncludeReferenceKind.Base */:\n                collectExternalReferencesInTopLevelRule({ ...context, selfGrammar: context.baseGrammar }, result);\n                break;\n            case 1 /* IncludeReferenceKind.Self */:\n                collectExternalReferencesInTopLevelRule(context, result);\n                break;\n            case 2 /* IncludeReferenceKind.RelativeReference */:\n                collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, { ...context, repository: patternRepository }, result);\n                break;\n            case 3 /* IncludeReferenceKind.TopLevelReference */:\n            case 4 /* IncludeReferenceKind.TopLevelRepositoryReference */:\n                const selfGrammar = reference.scopeName === context.selfGrammar.scopeName\n                    ? context.selfGrammar\n                    : reference.scopeName === context.baseGrammar.scopeName\n                        ? context.baseGrammar\n                        : undefined;\n                if (selfGrammar) {\n                    const newContext = { baseGrammar: context.baseGrammar, selfGrammar, repository: patternRepository };\n                    if (reference.kind === 4 /* IncludeReferenceKind.TopLevelRepositoryReference */) {\n                        collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, newContext, result);\n                    }\n                    else {\n                        collectExternalReferencesInTopLevelRule(newContext, result);\n                    }\n                }\n                else {\n                    if (reference.kind === 4 /* IncludeReferenceKind.TopLevelRepositoryReference */) {\n                        result.add(new TopLevelRepositoryRuleReference(reference.scopeName, reference.ruleName));\n                    }\n                    else {\n                        result.add(new TopLevelRuleReference(reference.scopeName));\n                    }\n                }\n                break;\n        }\n    }\n}\nclass BaseReference {\n    kind = 0 /* IncludeReferenceKind.Base */;\n}\nclass SelfReference {\n    kind = 1 /* IncludeReferenceKind.Self */;\n}\nclass RelativeReference {\n    ruleName;\n    kind = 2 /* IncludeReferenceKind.RelativeReference */;\n    constructor(ruleName) {\n        this.ruleName = ruleName;\n    }\n}\nclass TopLevelReference {\n    scopeName;\n    kind = 3 /* IncludeReferenceKind.TopLevelReference */;\n    constructor(scopeName) {\n        this.scopeName = scopeName;\n    }\n}\nclass TopLevelRepositoryReference {\n    scopeName;\n    ruleName;\n    kind = 4 /* IncludeReferenceKind.TopLevelRepositoryReference */;\n    constructor(scopeName, ruleName) {\n        this.scopeName = scopeName;\n        this.ruleName = ruleName;\n    }\n}\nfunction parseInclude(include) {\n    if (include === '$base') {\n        return new BaseReference();\n    }\n    else if (include === '$self') {\n        return new SelfReference();\n    }\n    const indexOfSharp = include.indexOf(\"#\");\n    if (indexOfSharp === -1) {\n        return new TopLevelReference(include);\n    }\n    else if (indexOfSharp === 0) {\n        return new RelativeReference(include.substring(1));\n    }\n    else {\n        const scopeName = include.substring(0, indexOfSharp);\n        const ruleName = include.substring(indexOfSharp + 1);\n        return new TopLevelRepositoryReference(scopeName, ruleName);\n    }\n}\n\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nconst HAS_BACK_REFERENCES = /\\\\(\\d+)/;\nconst BACK_REFERENCING_END = /\\\\(\\d+)/g;\n// This is a special constant to indicate that the end regexp matched.\nconst endRuleId = -1;\n// This is a special constant to indicate that the while regexp matched.\nconst whileRuleId = -2;\nfunction ruleIdFromNumber(id) {\n    return id;\n}\nfunction ruleIdToNumber(id) {\n    return id;\n}\nclass Rule {\n    $location;\n    id;\n    _nameIsCapturing;\n    _name;\n    _contentNameIsCapturing;\n    _contentName;\n    constructor($location, id, name, contentName) {\n        this.$location = $location;\n        this.id = id;\n        this._name = name || null;\n        this._nameIsCapturing = RegexSource.hasCaptures(this._name);\n        this._contentName = contentName || null;\n        this._contentNameIsCapturing = RegexSource.hasCaptures(this._contentName);\n    }\n    get debugName() {\n        const location = this.$location ? `${basename(this.$location.filename)}:${this.$location.line}` : 'unknown';\n        return `${this.constructor.name}#${this.id} @ ${location}`;\n    }\n    getName(lineText, captureIndices) {\n        if (!this._nameIsCapturing || this._name === null || lineText === null || captureIndices === null) {\n            return this._name;\n        }\n        return RegexSource.replaceCaptures(this._name, lineText, captureIndices);\n    }\n    getContentName(lineText, captureIndices) {\n        if (!this._contentNameIsCapturing || this._contentName === null) {\n            return this._contentName;\n        }\n        return RegexSource.replaceCaptures(this._contentName, lineText, captureIndices);\n    }\n}\nclass CaptureRule extends Rule {\n    retokenizeCapturedWithRuleId;\n    constructor($location, id, name, contentName, retokenizeCapturedWithRuleId) {\n        super($location, id, name, contentName);\n        this.retokenizeCapturedWithRuleId = retokenizeCapturedWithRuleId;\n    }\n    dispose() {\n        // nothing to dispose\n    }\n    collectPatterns(grammar, out) {\n        throw new Error('Not supported!');\n    }\n    compile(grammar, endRegexSource) {\n        throw new Error('Not supported!');\n    }\n    compileAG(grammar, endRegexSource, allowA, allowG) {\n        throw new Error('Not supported!');\n    }\n}\nclass MatchRule extends Rule {\n    _match;\n    captures;\n    _cachedCompiledPatterns;\n    constructor($location, id, name, match, captures) {\n        super($location, id, name, null);\n        this._match = new RegExpSource(match, this.id);\n        this.captures = captures;\n        this._cachedCompiledPatterns = null;\n    }\n    dispose() {\n        if (this._cachedCompiledPatterns) {\n            this._cachedCompiledPatterns.dispose();\n            this._cachedCompiledPatterns = null;\n        }\n    }\n    get debugMatchRegExp() {\n        return `${this._match.source}`;\n    }\n    collectPatterns(grammar, out) {\n        out.push(this._match);\n    }\n    compile(grammar, endRegexSource) {\n        return this._getCachedCompiledPatterns(grammar).compile(grammar);\n    }\n    compileAG(grammar, endRegexSource, allowA, allowG) {\n        return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n    }\n    _getCachedCompiledPatterns(grammar) {\n        if (!this._cachedCompiledPatterns) {\n            this._cachedCompiledPatterns = new RegExpSourceList();\n            this.collectPatterns(grammar, this._cachedCompiledPatterns);\n        }\n        return this._cachedCompiledPatterns;\n    }\n}\nclass IncludeOnlyRule extends Rule {\n    hasMissingPatterns;\n    patterns;\n    _cachedCompiledPatterns;\n    constructor($location, id, name, contentName, patterns) {\n        super($location, id, name, contentName);\n        this.patterns = patterns.patterns;\n        this.hasMissingPatterns = patterns.hasMissingPatterns;\n        this._cachedCompiledPatterns = null;\n    }\n    dispose() {\n        if (this._cachedCompiledPatterns) {\n            this._cachedCompiledPatterns.dispose();\n            this._cachedCompiledPatterns = null;\n        }\n    }\n    collectPatterns(grammar, out) {\n        for (const pattern of this.patterns) {\n            const rule = grammar.getRule(pattern);\n            rule.collectPatterns(grammar, out);\n        }\n    }\n    compile(grammar, endRegexSource) {\n        return this._getCachedCompiledPatterns(grammar).compile(grammar);\n    }\n    compileAG(grammar, endRegexSource, allowA, allowG) {\n        return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n    }\n    _getCachedCompiledPatterns(grammar) {\n        if (!this._cachedCompiledPatterns) {\n            this._cachedCompiledPatterns = new RegExpSourceList();\n            this.collectPatterns(grammar, this._cachedCompiledPatterns);\n        }\n        return this._cachedCompiledPatterns;\n    }\n}\nclass BeginEndRule extends Rule {\n    _begin;\n    beginCaptures;\n    _end;\n    endHasBackReferences;\n    endCaptures;\n    applyEndPatternLast;\n    hasMissingPatterns;\n    patterns;\n    _cachedCompiledPatterns;\n    constructor($location, id, name, contentName, begin, beginCaptures, end, endCaptures, applyEndPatternLast, patterns) {\n        super($location, id, name, contentName);\n        this._begin = new RegExpSource(begin, this.id);\n        this.beginCaptures = beginCaptures;\n        this._end = new RegExpSource(end ? end : '\\uFFFF', -1);\n        this.endHasBackReferences = this._end.hasBackReferences;\n        this.endCaptures = endCaptures;\n        this.applyEndPatternLast = applyEndPatternLast || false;\n        this.patterns = patterns.patterns;\n        this.hasMissingPatterns = patterns.hasMissingPatterns;\n        this._cachedCompiledPatterns = null;\n    }\n    dispose() {\n        if (this._cachedCompiledPatterns) {\n            this._cachedCompiledPatterns.dispose();\n            this._cachedCompiledPatterns = null;\n        }\n    }\n    get debugBeginRegExp() {\n        return `${this._begin.source}`;\n    }\n    get debugEndRegExp() {\n        return `${this._end.source}`;\n    }\n    getEndWithResolvedBackReferences(lineText, captureIndices) {\n        return this._end.resolveBackReferences(lineText, captureIndices);\n    }\n    collectPatterns(grammar, out) {\n        out.push(this._begin);\n    }\n    compile(grammar, endRegexSource) {\n        return this._getCachedCompiledPatterns(grammar, endRegexSource).compile(grammar);\n    }\n    compileAG(grammar, endRegexSource, allowA, allowG) {\n        return this._getCachedCompiledPatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);\n    }\n    _getCachedCompiledPatterns(grammar, endRegexSource) {\n        if (!this._cachedCompiledPatterns) {\n            this._cachedCompiledPatterns = new RegExpSourceList();\n            for (const pattern of this.patterns) {\n                const rule = grammar.getRule(pattern);\n                rule.collectPatterns(grammar, this._cachedCompiledPatterns);\n            }\n            if (this.applyEndPatternLast) {\n                this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end);\n            }\n            else {\n                this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);\n            }\n        }\n        if (this._end.hasBackReferences) {\n            if (this.applyEndPatternLast) {\n                this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, endRegexSource);\n            }\n            else {\n                this._cachedCompiledPatterns.setSource(0, endRegexSource);\n            }\n        }\n        return this._cachedCompiledPatterns;\n    }\n}\nclass BeginWhileRule extends Rule {\n    _begin;\n    beginCaptures;\n    whileCaptures;\n    _while;\n    whileHasBackReferences;\n    hasMissingPatterns;\n    patterns;\n    _cachedCompiledPatterns;\n    _cachedCompiledWhilePatterns;\n    constructor($location, id, name, contentName, begin, beginCaptures, _while, whileCaptures, patterns) {\n        super($location, id, name, contentName);\n        this._begin = new RegExpSource(begin, this.id);\n        this.beginCaptures = beginCaptures;\n        this.whileCaptures = whileCaptures;\n        this._while = new RegExpSource(_while, whileRuleId);\n        this.whileHasBackReferences = this._while.hasBackReferences;\n        this.patterns = patterns.patterns;\n        this.hasMissingPatterns = patterns.hasMissingPatterns;\n        this._cachedCompiledPatterns = null;\n        this._cachedCompiledWhilePatterns = null;\n    }\n    dispose() {\n        if (this._cachedCompiledPatterns) {\n            this._cachedCompiledPatterns.dispose();\n            this._cachedCompiledPatterns = null;\n        }\n        if (this._cachedCompiledWhilePatterns) {\n            this._cachedCompiledWhilePatterns.dispose();\n            this._cachedCompiledWhilePatterns = null;\n        }\n    }\n    get debugBeginRegExp() {\n        return `${this._begin.source}`;\n    }\n    get debugWhileRegExp() {\n        return `${this._while.source}`;\n    }\n    getWhileWithResolvedBackReferences(lineText, captureIndices) {\n        return this._while.resolveBackReferences(lineText, captureIndices);\n    }\n    collectPatterns(grammar, out) {\n        out.push(this._begin);\n    }\n    compile(grammar, endRegexSource) {\n        return this._getCachedCompiledPatterns(grammar).compile(grammar);\n    }\n    compileAG(grammar, endRegexSource, allowA, allowG) {\n        return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n    }\n    _getCachedCompiledPatterns(grammar) {\n        if (!this._cachedCompiledPatterns) {\n            this._cachedCompiledPatterns = new RegExpSourceList();\n            for (const pattern of this.patterns) {\n                const rule = grammar.getRule(pattern);\n                rule.collectPatterns(grammar, this._cachedCompiledPatterns);\n            }\n        }\n        return this._cachedCompiledPatterns;\n    }\n    compileWhile(grammar, endRegexSource) {\n        return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compile(grammar);\n    }\n    compileWhileAG(grammar, endRegexSource, allowA, allowG) {\n        return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);\n    }\n    _getCachedCompiledWhilePatterns(grammar, endRegexSource) {\n        if (!this._cachedCompiledWhilePatterns) {\n            this._cachedCompiledWhilePatterns = new RegExpSourceList();\n            this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while);\n        }\n        if (this._while.hasBackReferences) {\n            this._cachedCompiledWhilePatterns.setSource(0, endRegexSource ? endRegexSource : '\\uFFFF');\n        }\n        return this._cachedCompiledWhilePatterns;\n    }\n}\nclass RuleFactory {\n    static createCaptureRule(helper, $location, name, contentName, retokenizeCapturedWithRuleId) {\n        return helper.registerRule((id) => {\n            return new CaptureRule($location, id, name, contentName, retokenizeCapturedWithRuleId);\n        });\n    }\n    static getCompiledRuleId(desc, helper, repository) {\n        if (!desc.id) {\n            helper.registerRule((id) => {\n                desc.id = id;\n                if (desc.match) {\n                    return new MatchRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.match, RuleFactory._compileCaptures(desc.captures, helper, repository));\n                }\n                if (typeof desc.begin === 'undefined') {\n                    if (desc.repository) {\n                        repository = mergeObjects({}, repository, desc.repository);\n                    }\n                    let patterns = desc.patterns;\n                    if (typeof patterns === 'undefined' && desc.include) {\n                        patterns = [{ include: desc.include }];\n                    }\n                    return new IncludeOnlyRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, RuleFactory._compilePatterns(patterns, helper, repository));\n                }\n                if (desc.while) {\n                    return new BeginWhileRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, desc.begin, RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository), desc.while, RuleFactory._compileCaptures(desc.whileCaptures || desc.captures, helper, repository), RuleFactory._compilePatterns(desc.patterns, helper, repository));\n                }\n                return new BeginEndRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, desc.begin, RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository), desc.end, RuleFactory._compileCaptures(desc.endCaptures || desc.captures, helper, repository), desc.applyEndPatternLast, RuleFactory._compilePatterns(desc.patterns, helper, repository));\n            });\n        }\n        return desc.id;\n    }\n    static _compileCaptures(captures, helper, repository) {\n        let r = [];\n        if (captures) {\n            // Find the maximum capture id\n            let maximumCaptureId = 0;\n            for (const captureId in captures) {\n                if (captureId === '$vscodeTextmateLocation') {\n                    continue;\n                }\n                const numericCaptureId = parseInt(captureId, 10);\n                if (numericCaptureId > maximumCaptureId) {\n                    maximumCaptureId = numericCaptureId;\n                }\n            }\n            // Initialize result\n            for (let i = 0; i <= maximumCaptureId; i++) {\n                r[i] = null;\n            }\n            // Fill out result\n            for (const captureId in captures) {\n                if (captureId === '$vscodeTextmateLocation') {\n                    continue;\n                }\n                const numericCaptureId = parseInt(captureId, 10);\n                let retokenizeCapturedWithRuleId = 0;\n                if (captures[captureId].patterns) {\n                    retokenizeCapturedWithRuleId = RuleFactory.getCompiledRuleId(captures[captureId], helper, repository);\n                }\n                r[numericCaptureId] = RuleFactory.createCaptureRule(helper, captures[captureId].$vscodeTextmateLocation, captures[captureId].name, captures[captureId].contentName, retokenizeCapturedWithRuleId);\n            }\n        }\n        return r;\n    }\n    static _compilePatterns(patterns, helper, repository) {\n        let r = [];\n        if (patterns) {\n            for (let i = 0, len = patterns.length; i < len; i++) {\n                const pattern = patterns[i];\n                let ruleId = -1;\n                if (pattern.include) {\n                    const reference = parseInclude(pattern.include);\n                    switch (reference.kind) {\n                        case 0 /* IncludeReferenceKind.Base */:\n                        case 1 /* IncludeReferenceKind.Self */:\n                            ruleId = RuleFactory.getCompiledRuleId(repository[pattern.include], helper, repository);\n                            break;\n                        case 2 /* IncludeReferenceKind.RelativeReference */:\n                            // Local include found in `repository`\n                            let localIncludedRule = repository[reference.ruleName];\n                            if (localIncludedRule) {\n                                ruleId = RuleFactory.getCompiledRuleId(localIncludedRule, helper, repository);\n                            }\n                            break;\n                        case 3 /* IncludeReferenceKind.TopLevelReference */:\n                        case 4 /* IncludeReferenceKind.TopLevelRepositoryReference */:\n                            const externalGrammarName = reference.scopeName;\n                            const externalGrammarInclude = reference.kind === 4 /* IncludeReferenceKind.TopLevelRepositoryReference */\n                                ? reference.ruleName\n                                : null;\n                            // External include\n                            const externalGrammar = helper.getExternalGrammar(externalGrammarName, repository);\n                            if (externalGrammar) {\n                                if (externalGrammarInclude) {\n                                    let externalIncludedRule = externalGrammar.repository[externalGrammarInclude];\n                                    if (externalIncludedRule) {\n                                        ruleId = RuleFactory.getCompiledRuleId(externalIncludedRule, helper, externalGrammar.repository);\n                                    }\n                                }\n                                else {\n                                    ruleId = RuleFactory.getCompiledRuleId(externalGrammar.repository.$self, helper, externalGrammar.repository);\n                                }\n                            }\n                            break;\n                    }\n                }\n                else {\n                    ruleId = RuleFactory.getCompiledRuleId(pattern, helper, repository);\n                }\n                if (ruleId !== -1) {\n                    const rule = helper.getRule(ruleId);\n                    let skipRule = false;\n                    if (rule instanceof IncludeOnlyRule || rule instanceof BeginEndRule || rule instanceof BeginWhileRule) {\n                        if (rule.hasMissingPatterns && rule.patterns.length === 0) {\n                            skipRule = true;\n                        }\n                    }\n                    if (skipRule) {\n                        // console.log('REMOVING RULE ENTIRELY DUE TO EMPTY PATTERNS THAT ARE MISSING');\n                        continue;\n                    }\n                    r.push(ruleId);\n                }\n            }\n        }\n        return {\n            patterns: r,\n            hasMissingPatterns: ((patterns ? patterns.length : 0) !== r.length)\n        };\n    }\n}\nclass RegExpSource {\n    source;\n    ruleId;\n    hasAnchor;\n    hasBackReferences;\n    _anchorCache;\n    constructor(regExpSource, ruleId) {\n        if (regExpSource) {\n            const len = regExpSource.length;\n            let lastPushedPos = 0;\n            let output = [];\n            let hasAnchor = false;\n            for (let pos = 0; pos < len; pos++) {\n                const ch = regExpSource.charAt(pos);\n                if (ch === '\\\\') {\n                    if (pos + 1 < len) {\n                        const nextCh = regExpSource.charAt(pos + 1);\n                        if (nextCh === 'z') {\n                            output.push(regExpSource.substring(lastPushedPos, pos));\n                            output.push('$(?!\\\\n)(?<!\\\\n)');\n                            lastPushedPos = pos + 2;\n                        }\n                        else if (nextCh === 'A' || nextCh === 'G') {\n                            hasAnchor = true;\n                        }\n                        pos++;\n                    }\n                }\n            }\n            this.hasAnchor = hasAnchor;\n            if (lastPushedPos === 0) {\n                // No \\z hit\n                this.source = regExpSource;\n            }\n            else {\n                output.push(regExpSource.substring(lastPushedPos, len));\n                this.source = output.join('');\n            }\n        }\n        else {\n            this.hasAnchor = false;\n            this.source = regExpSource;\n        }\n        if (this.hasAnchor) {\n            this._anchorCache = this._buildAnchorCache();\n        }\n        else {\n            this._anchorCache = null;\n        }\n        this.ruleId = ruleId;\n        this.hasBackReferences = HAS_BACK_REFERENCES.test(this.source);\n        // console.log('input: ' + regExpSource + ' => ' + this.source + ', ' + this.hasAnchor);\n    }\n    clone() {\n        return new RegExpSource(this.source, this.ruleId);\n    }\n    setSource(newSource) {\n        if (this.source === newSource) {\n            return;\n        }\n        this.source = newSource;\n        if (this.hasAnchor) {\n            this._anchorCache = this._buildAnchorCache();\n        }\n    }\n    resolveBackReferences(lineText, captureIndices) {\n        let capturedValues = captureIndices.map((capture) => {\n            return lineText.substring(capture.start, capture.end);\n        });\n        BACK_REFERENCING_END.lastIndex = 0;\n        return this.source.replace(BACK_REFERENCING_END, (match, g1) => {\n            return escapeRegExpCharacters(capturedValues[parseInt(g1, 10)] || '');\n        });\n    }\n    _buildAnchorCache() {\n        let A0_G0_result = [];\n        let A0_G1_result = [];\n        let A1_G0_result = [];\n        let A1_G1_result = [];\n        let pos, len, ch, nextCh;\n        for (pos = 0, len = this.source.length; pos < len; pos++) {\n            ch = this.source.charAt(pos);\n            A0_G0_result[pos] = ch;\n            A0_G1_result[pos] = ch;\n            A1_G0_result[pos] = ch;\n            A1_G1_result[pos] = ch;\n            if (ch === '\\\\') {\n                if (pos + 1 < len) {\n                    nextCh = this.source.charAt(pos + 1);\n                    if (nextCh === 'A') {\n                        A0_G0_result[pos + 1] = '\\uFFFF';\n                        A0_G1_result[pos + 1] = '\\uFFFF';\n                        A1_G0_result[pos + 1] = 'A';\n                        A1_G1_result[pos + 1] = 'A';\n                    }\n                    else if (nextCh === 'G') {\n                        A0_G0_result[pos + 1] = '\\uFFFF';\n                        A0_G1_result[pos + 1] = 'G';\n                        A1_G0_result[pos + 1] = '\\uFFFF';\n                        A1_G1_result[pos + 1] = 'G';\n                    }\n                    else {\n                        A0_G0_result[pos + 1] = nextCh;\n                        A0_G1_result[pos + 1] = nextCh;\n                        A1_G0_result[pos + 1] = nextCh;\n                        A1_G1_result[pos + 1] = nextCh;\n                    }\n                    pos++;\n                }\n            }\n        }\n        return {\n            A0_G0: A0_G0_result.join(''),\n            A0_G1: A0_G1_result.join(''),\n            A1_G0: A1_G0_result.join(''),\n            A1_G1: A1_G1_result.join('')\n        };\n    }\n    resolveAnchors(allowA, allowG) {\n        if (!this.hasAnchor || !this._anchorCache) {\n            return this.source;\n        }\n        if (allowA) {\n            if (allowG) {\n                return this._anchorCache.A1_G1;\n            }\n            else {\n                return this._anchorCache.A1_G0;\n            }\n        }\n        else {\n            if (allowG) {\n                return this._anchorCache.A0_G1;\n            }\n            else {\n                return this._anchorCache.A0_G0;\n            }\n        }\n    }\n}\nclass RegExpSourceList {\n    _items;\n    _hasAnchors;\n    _cached;\n    _anchorCache;\n    constructor() {\n        this._items = [];\n        this._hasAnchors = false;\n        this._cached = null;\n        this._anchorCache = {\n            A0_G0: null,\n            A0_G1: null,\n            A1_G0: null,\n            A1_G1: null\n        };\n    }\n    dispose() {\n        this._disposeCaches();\n    }\n    _disposeCaches() {\n        if (this._cached) {\n            this._cached.dispose();\n            this._cached = null;\n        }\n        if (this._anchorCache.A0_G0) {\n            this._anchorCache.A0_G0.dispose();\n            this._anchorCache.A0_G0 = null;\n        }\n        if (this._anchorCache.A0_G1) {\n            this._anchorCache.A0_G1.dispose();\n            this._anchorCache.A0_G1 = null;\n        }\n        if (this._anchorCache.A1_G0) {\n            this._anchorCache.A1_G0.dispose();\n            this._anchorCache.A1_G0 = null;\n        }\n        if (this._anchorCache.A1_G1) {\n            this._anchorCache.A1_G1.dispose();\n            this._anchorCache.A1_G1 = null;\n        }\n    }\n    push(item) {\n        this._items.push(item);\n        this._hasAnchors = this._hasAnchors || item.hasAnchor;\n    }\n    unshift(item) {\n        this._items.unshift(item);\n        this._hasAnchors = this._hasAnchors || item.hasAnchor;\n    }\n    length() {\n        return this._items.length;\n    }\n    setSource(index, newSource) {\n        if (this._items[index].source !== newSource) {\n            // bust the cache\n            this._disposeCaches();\n            this._items[index].setSource(newSource);\n        }\n    }\n    compile(onigLib) {\n        if (!this._cached) {\n            let regExps = this._items.map(e => e.source);\n            this._cached = new CompiledRule(onigLib, regExps, this._items.map(e => e.ruleId));\n        }\n        return this._cached;\n    }\n    compileAG(onigLib, allowA, allowG) {\n        if (!this._hasAnchors) {\n            return this.compile(onigLib);\n        }\n        else {\n            if (allowA) {\n                if (allowG) {\n                    if (!this._anchorCache.A1_G1) {\n                        this._anchorCache.A1_G1 = this._resolveAnchors(onigLib, allowA, allowG);\n                    }\n                    return this._anchorCache.A1_G1;\n                }\n                else {\n                    if (!this._anchorCache.A1_G0) {\n                        this._anchorCache.A1_G0 = this._resolveAnchors(onigLib, allowA, allowG);\n                    }\n                    return this._anchorCache.A1_G0;\n                }\n            }\n            else {\n                if (allowG) {\n                    if (!this._anchorCache.A0_G1) {\n                        this._anchorCache.A0_G1 = this._resolveAnchors(onigLib, allowA, allowG);\n                    }\n                    return this._anchorCache.A0_G1;\n                }\n                else {\n                    if (!this._anchorCache.A0_G0) {\n                        this._anchorCache.A0_G0 = this._resolveAnchors(onigLib, allowA, allowG);\n                    }\n                    return this._anchorCache.A0_G0;\n                }\n            }\n        }\n    }\n    _resolveAnchors(onigLib, allowA, allowG) {\n        let regExps = this._items.map(e => e.resolveAnchors(allowA, allowG));\n        return new CompiledRule(onigLib, regExps, this._items.map(e => e.ruleId));\n    }\n}\nclass CompiledRule {\n    regExps;\n    rules;\n    scanner;\n    constructor(onigLib, regExps, rules) {\n        this.regExps = regExps;\n        this.rules = rules;\n        this.scanner = onigLib.createOnigScanner(regExps);\n    }\n    dispose() {\n        if (typeof this.scanner.dispose === \"function\") {\n            this.scanner.dispose();\n        }\n    }\n    toString() {\n        const r = [];\n        for (let i = 0, len = this.rules.length; i < len; i++) {\n            r.push(\"   - \" + this.rules[i] + \": \" + this.regExps[i]);\n        }\n        return r.join(\"\\n\");\n    }\n    findNextMatchSync(string, startPosition, options) {\n        const result = this.scanner.findNextMatchSync(string, startPosition, options);\n        if (!result) {\n            return null;\n        }\n        return {\n            ruleId: this.rules[result.index],\n            captureIndices: result.captureIndices,\n        };\n    }\n}\n\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nclass Theme {\n    _colorMap;\n    _defaults;\n    _root;\n    static createFromRawTheme(source, colorMap) {\n        return this.createFromParsedTheme(parseTheme(source), colorMap);\n    }\n    static createFromParsedTheme(source, colorMap) {\n        return resolveParsedThemeRules(source, colorMap);\n    }\n    _cachedMatchRoot = new CachedFn((scopeName) => this._root.match(scopeName));\n    constructor(_colorMap, _defaults, _root) {\n        this._colorMap = _colorMap;\n        this._defaults = _defaults;\n        this._root = _root;\n    }\n    getColorMap() {\n        return this._colorMap.getColorMap();\n    }\n    getDefaults() {\n        return this._defaults;\n    }\n    match(scopePath) {\n        if (scopePath === null) {\n            return this._defaults;\n        }\n        const scopeName = scopePath.scopeName;\n        const matchingTrieElements = this._cachedMatchRoot.get(scopeName);\n        const effectiveRule = matchingTrieElements.find((v) => _scopePathMatchesParentScopes(scopePath.parent, v.parentScopes));\n        if (!effectiveRule) {\n            return null;\n        }\n        return new StyleAttributes(effectiveRule.fontStyle, effectiveRule.foreground, effectiveRule.background);\n    }\n}\nclass ScopeStack {\n    parent;\n    scopeName;\n    static push(path, scopeNames) {\n        for (const name of scopeNames) {\n            path = new ScopeStack(path, name);\n        }\n        return path;\n    }\n    static from(...segments) {\n        let result = null;\n        for (let i = 0; i < segments.length; i++) {\n            result = new ScopeStack(result, segments[i]);\n        }\n        return result;\n    }\n    constructor(parent, scopeName) {\n        this.parent = parent;\n        this.scopeName = scopeName;\n    }\n    push(scopeName) {\n        return new ScopeStack(this, scopeName);\n    }\n    getSegments() {\n        let item = this;\n        const result = [];\n        while (item) {\n            result.push(item.scopeName);\n            item = item.parent;\n        }\n        result.reverse();\n        return result;\n    }\n    toString() {\n        return this.getSegments().join(' ');\n    }\n    extends(other) {\n        if (this === other) {\n            return true;\n        }\n        if (this.parent === null) {\n            return false;\n        }\n        return this.parent.extends(other);\n    }\n    getExtensionIfDefined(base) {\n        const result = [];\n        let item = this;\n        while (item && item !== base) {\n            result.push(item.scopeName);\n            item = item.parent;\n        }\n        return item === base ? result.reverse() : undefined;\n    }\n}\nfunction _scopePathMatchesParentScopes(scopePath, parentScopes) {\n    if (parentScopes === null) {\n        return true;\n    }\n    let index = 0;\n    let scopePattern = parentScopes[index];\n    while (scopePath) {\n        if (_matchesScope(scopePath.scopeName, scopePattern)) {\n            index++;\n            if (index === parentScopes.length) {\n                return true;\n            }\n            scopePattern = parentScopes[index];\n        }\n        scopePath = scopePath.parent;\n    }\n    return false;\n}\nfunction _matchesScope(scopeName, scopePattern) {\n    return scopePattern === scopeName || (scopeName.startsWith(scopePattern) && scopeName[scopePattern.length] === '.');\n}\nclass StyleAttributes {\n    fontStyle;\n    foregroundId;\n    backgroundId;\n    constructor(fontStyle, foregroundId, backgroundId) {\n        this.fontStyle = fontStyle;\n        this.foregroundId = foregroundId;\n        this.backgroundId = backgroundId;\n    }\n}\n/**\n * Parse a raw theme into rules.\n */\nfunction parseTheme(source) {\n    if (!source) {\n        return [];\n    }\n    if (!source.settings || !Array.isArray(source.settings)) {\n        return [];\n    }\n    let settings = source.settings;\n    let result = [], resultLen = 0;\n    for (let i = 0, len = settings.length; i < len; i++) {\n        let entry = settings[i];\n        if (!entry.settings) {\n            continue;\n        }\n        let scopes;\n        if (typeof entry.scope === 'string') {\n            let _scope = entry.scope;\n            // remove leading commas\n            _scope = _scope.replace(/^[,]+/, '');\n            // remove trailing commans\n            _scope = _scope.replace(/[,]+$/, '');\n            scopes = _scope.split(',');\n        }\n        else if (Array.isArray(entry.scope)) {\n            scopes = entry.scope;\n        }\n        else {\n            scopes = [''];\n        }\n        let fontStyle = -1 /* FontStyle.NotSet */;\n        if (typeof entry.settings.fontStyle === 'string') {\n            fontStyle = 0 /* FontStyle.None */;\n            let segments = entry.settings.fontStyle.split(' ');\n            for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n                let segment = segments[j];\n                switch (segment) {\n                    case 'italic':\n                        fontStyle = fontStyle | 1 /* FontStyle.Italic */;\n                        break;\n                    case 'bold':\n                        fontStyle = fontStyle | 2 /* FontStyle.Bold */;\n                        break;\n                    case 'underline':\n                        fontStyle = fontStyle | 4 /* FontStyle.Underline */;\n                        break;\n                    case 'strikethrough':\n                        fontStyle = fontStyle | 8 /* FontStyle.Strikethrough */;\n                        break;\n                }\n            }\n        }\n        let foreground = null;\n        if (typeof entry.settings.foreground === 'string' && isValidHexColor(entry.settings.foreground)) {\n            foreground = entry.settings.foreground;\n        }\n        let background = null;\n        if (typeof entry.settings.background === 'string' && isValidHexColor(entry.settings.background)) {\n            background = entry.settings.background;\n        }\n        for (let j = 0, lenJ = scopes.length; j < lenJ; j++) {\n            let _scope = scopes[j].trim();\n            let segments = _scope.split(' ');\n            let scope = segments[segments.length - 1];\n            let parentScopes = null;\n            if (segments.length > 1) {\n                parentScopes = segments.slice(0, segments.length - 1);\n                parentScopes.reverse();\n            }\n            result[resultLen++] = new ParsedThemeRule(scope, parentScopes, i, fontStyle, foreground, background);\n        }\n    }\n    return result;\n}\nclass ParsedThemeRule {\n    scope;\n    parentScopes;\n    index;\n    fontStyle;\n    foreground;\n    background;\n    constructor(scope, parentScopes, index, fontStyle, foreground, background) {\n        this.scope = scope;\n        this.parentScopes = parentScopes;\n        this.index = index;\n        this.fontStyle = fontStyle;\n        this.foreground = foreground;\n        this.background = background;\n    }\n}\n/**\n * Resolve rules (i.e. inheritance).\n */\nfunction resolveParsedThemeRules(parsedThemeRules, _colorMap) {\n    // Sort rules lexicographically, and then by index if necessary\n    parsedThemeRules.sort((a, b) => {\n        let r = strcmp(a.scope, b.scope);\n        if (r !== 0) {\n            return r;\n        }\n        r = strArrCmp(a.parentScopes, b.parentScopes);\n        if (r !== 0) {\n            return r;\n        }\n        return a.index - b.index;\n    });\n    // Determine defaults\n    let defaultFontStyle = 0 /* FontStyle.None */;\n    let defaultForeground = '#000000';\n    let defaultBackground = '#ffffff';\n    while (parsedThemeRules.length >= 1 && parsedThemeRules[0].scope === '') {\n        let incomingDefaults = parsedThemeRules.shift();\n        if (incomingDefaults.fontStyle !== -1 /* FontStyle.NotSet */) {\n            defaultFontStyle = incomingDefaults.fontStyle;\n        }\n        if (incomingDefaults.foreground !== null) {\n            defaultForeground = incomingDefaults.foreground;\n        }\n        if (incomingDefaults.background !== null) {\n            defaultBackground = incomingDefaults.background;\n        }\n    }\n    let colorMap = new ColorMap(_colorMap);\n    let defaults = new StyleAttributes(defaultFontStyle, colorMap.getId(defaultForeground), colorMap.getId(defaultBackground));\n    let root = new ThemeTrieElement(new ThemeTrieElementRule(0, null, -1 /* FontStyle.NotSet */, 0, 0), []);\n    for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n        let rule = parsedThemeRules[i];\n        root.insert(0, rule.scope, rule.parentScopes, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n    }\n    return new Theme(colorMap, defaults, root);\n}\nclass ColorMap {\n    _isFrozen;\n    _lastColorId;\n    _id2color;\n    _color2id;\n    constructor(_colorMap) {\n        this._lastColorId = 0;\n        this._id2color = [];\n        this._color2id = Object.create(null);\n        if (Array.isArray(_colorMap)) {\n            this._isFrozen = true;\n            for (let i = 0, len = _colorMap.length; i < len; i++) {\n                this._color2id[_colorMap[i]] = i;\n                this._id2color[i] = _colorMap[i];\n            }\n        }\n        else {\n            this._isFrozen = false;\n        }\n    }\n    getId(color) {\n        if (color === null) {\n            return 0;\n        }\n        color = color.toUpperCase();\n        let value = this._color2id[color];\n        if (value) {\n            return value;\n        }\n        if (this._isFrozen) {\n            throw new Error(`Missing color in color map - ${color}`);\n        }\n        value = ++this._lastColorId;\n        this._color2id[color] = value;\n        this._id2color[value] = color;\n        return value;\n    }\n    getColorMap() {\n        return this._id2color.slice(0);\n    }\n}\nclass ThemeTrieElementRule {\n    scopeDepth;\n    parentScopes;\n    fontStyle;\n    foreground;\n    background;\n    constructor(scopeDepth, parentScopes, fontStyle, foreground, background) {\n        this.scopeDepth = scopeDepth;\n        this.parentScopes = parentScopes;\n        this.fontStyle = fontStyle;\n        this.foreground = foreground;\n        this.background = background;\n    }\n    clone() {\n        return new ThemeTrieElementRule(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);\n    }\n    static cloneArr(arr) {\n        let r = [];\n        for (let i = 0, len = arr.length; i < len; i++) {\n            r[i] = arr[i].clone();\n        }\n        return r;\n    }\n    acceptOverwrite(scopeDepth, fontStyle, foreground, background) {\n        if (this.scopeDepth > scopeDepth) {\n            console.log('how did this happen?');\n        }\n        else {\n            this.scopeDepth = scopeDepth;\n        }\n        // console.log('TODO -> my depth: ' + this.scopeDepth + ', overwriting depth: ' + scopeDepth);\n        if (fontStyle !== -1 /* FontStyle.NotSet */) {\n            this.fontStyle = fontStyle;\n        }\n        if (foreground !== 0) {\n            this.foreground = foreground;\n        }\n        if (background !== 0) {\n            this.background = background;\n        }\n    }\n}\nclass ThemeTrieElement {\n    _mainRule;\n    _children;\n    _rulesWithParentScopes;\n    constructor(_mainRule, rulesWithParentScopes = [], _children = {}) {\n        this._mainRule = _mainRule;\n        this._children = _children;\n        this._rulesWithParentScopes = rulesWithParentScopes;\n    }\n    static _sortBySpecificity(arr) {\n        if (arr.length === 1) {\n            return arr;\n        }\n        arr.sort(this._cmpBySpecificity);\n        return arr;\n    }\n    static _cmpBySpecificity(a, b) {\n        if (a.scopeDepth === b.scopeDepth) {\n            const aParentScopes = a.parentScopes;\n            const bParentScopes = b.parentScopes;\n            let aParentScopesLen = aParentScopes === null ? 0 : aParentScopes.length;\n            let bParentScopesLen = bParentScopes === null ? 0 : bParentScopes.length;\n            if (aParentScopesLen === bParentScopesLen) {\n                for (let i = 0; i < aParentScopesLen; i++) {\n                    const aLen = aParentScopes[i].length;\n                    const bLen = bParentScopes[i].length;\n                    if (aLen !== bLen) {\n                        return bLen - aLen;\n                    }\n                }\n            }\n            return bParentScopesLen - aParentScopesLen;\n        }\n        return b.scopeDepth - a.scopeDepth;\n    }\n    match(scope) {\n        if (scope === '') {\n            return ThemeTrieElement._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));\n        }\n        let dotIndex = scope.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = scope;\n            tail = '';\n        }\n        else {\n            head = scope.substring(0, dotIndex);\n            tail = scope.substring(dotIndex + 1);\n        }\n        if (this._children.hasOwnProperty(head)) {\n            return this._children[head].match(tail);\n        }\n        return ThemeTrieElement._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));\n    }\n    insert(scopeDepth, scope, parentScopes, fontStyle, foreground, background) {\n        if (scope === '') {\n            this._doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background);\n            return;\n        }\n        let dotIndex = scope.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = scope;\n            tail = '';\n        }\n        else {\n            head = scope.substring(0, dotIndex);\n            tail = scope.substring(dotIndex + 1);\n        }\n        let child;\n        if (this._children.hasOwnProperty(head)) {\n            child = this._children[head];\n        }\n        else {\n            child = new ThemeTrieElement(this._mainRule.clone(), ThemeTrieElementRule.cloneArr(this._rulesWithParentScopes));\n            this._children[head] = child;\n        }\n        child.insert(scopeDepth + 1, tail, parentScopes, fontStyle, foreground, background);\n    }\n    _doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background) {\n        if (parentScopes === null) {\n            // Merge into the main rule\n            this._mainRule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);\n            return;\n        }\n        // Try to merge into existing rule\n        for (let i = 0, len = this._rulesWithParentScopes.length; i < len; i++) {\n            let rule = this._rulesWithParentScopes[i];\n            if (strArrCmp(rule.parentScopes, parentScopes) === 0) {\n                // bingo! => we get to merge this into an existing one\n                rule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);\n                return;\n            }\n        }\n        // Must add a new rule\n        // Inherit from main rule\n        if (fontStyle === -1 /* FontStyle.NotSet */) {\n            fontStyle = this._mainRule.fontStyle;\n        }\n        if (foreground === 0) {\n            foreground = this._mainRule.foreground;\n        }\n        if (background === 0) {\n            background = this._mainRule.background;\n        }\n        this._rulesWithParentScopes.push(new ThemeTrieElementRule(scopeDepth, parentScopes, fontStyle, foreground, background));\n    }\n}\n\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nclass BasicScopeAttributes {\n    languageId;\n    tokenType;\n    constructor(languageId, tokenType) {\n        this.languageId = languageId;\n        this.tokenType = tokenType;\n    }\n}\nclass BasicScopeAttributesProvider {\n    _defaultAttributes;\n    _embeddedLanguagesMatcher;\n    constructor(initialLanguageId, embeddedLanguages) {\n        this._defaultAttributes = new BasicScopeAttributes(initialLanguageId, 8 /* OptionalStandardTokenType.NotSet */);\n        this._embeddedLanguagesMatcher = new ScopeMatcher(Object.entries(embeddedLanguages || {}));\n    }\n    getDefaultAttributes() {\n        return this._defaultAttributes;\n    }\n    getBasicScopeAttributes(scopeName) {\n        if (scopeName === null) {\n            return BasicScopeAttributesProvider._NULL_SCOPE_METADATA;\n        }\n        return this._getBasicScopeAttributes.get(scopeName);\n    }\n    static _NULL_SCOPE_METADATA = new BasicScopeAttributes(0, 0);\n    _getBasicScopeAttributes = new CachedFn((scopeName) => {\n        const languageId = this._scopeToLanguage(scopeName);\n        const standardTokenType = this._toStandardTokenType(scopeName);\n        return new BasicScopeAttributes(languageId, standardTokenType);\n    });\n    /**\n     * Given a produced TM scope, return the language that token describes or null if unknown.\n     * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null\n     */\n    _scopeToLanguage(scope) {\n        return this._embeddedLanguagesMatcher.match(scope) || 0;\n    }\n    _toStandardTokenType(scopeName) {\n        const m = scopeName.match(BasicScopeAttributesProvider.STANDARD_TOKEN_TYPE_REGEXP);\n        if (!m) {\n            return 8 /* OptionalStandardTokenType.NotSet */;\n        }\n        switch (m[1]) {\n            case \"comment\":\n                return 1 /* OptionalStandardTokenType.Comment */;\n            case \"string\":\n                return 2 /* OptionalStandardTokenType.String */;\n            case \"regex\":\n                return 3 /* OptionalStandardTokenType.RegEx */;\n            case \"meta.embedded\":\n                return 0 /* OptionalStandardTokenType.Other */;\n        }\n        throw new Error(\"Unexpected match for standard token type!\");\n    }\n    static STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|meta\\.embedded)\\b/;\n}\nclass ScopeMatcher {\n    values;\n    scopesRegExp;\n    constructor(values) {\n        if (values.length === 0) {\n            this.values = null;\n            this.scopesRegExp = null;\n        }\n        else {\n            this.values = new Map(values);\n            // create the regex\n            const escapedScopes = values.map(([scopeName, value]) => escapeRegExpCharacters(scopeName));\n            escapedScopes.sort();\n            escapedScopes.reverse(); // Longest scope first\n            this.scopesRegExp = new RegExp(`^((${escapedScopes.join(\")|(\")}))($|\\\\.)`, \"\");\n        }\n    }\n    match(scope) {\n        if (!this.scopesRegExp) {\n            return undefined;\n        }\n        const m = scope.match(this.scopesRegExp);\n        if (!m) {\n            // no scopes matched\n            return undefined;\n        }\n        return this.values.get(m[1]);\n    }\n}\n\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nclass TokenizeStringResult {\n    stack;\n    stoppedEarly;\n    constructor(stack, stoppedEarly) {\n        this.stack = stack;\n        this.stoppedEarly = stoppedEarly;\n    }\n}\n/**\n * Tokenize a string\n * @param grammar\n * @param lineText\n * @param isFirstLine\n * @param linePos\n * @param stack\n * @param lineTokens\n * @param checkWhileConditions\n * @param timeLimit Use `0` to indicate no time limit\n * @returns the StackElement or StackElement.TIME_LIMIT_REACHED if the time limit has been reached\n */\nfunction _tokenizeString(grammar, lineText, isFirstLine, linePos, stack, lineTokens, checkWhileConditions, timeLimit) {\n    const lineLength = lineText.content.length;\n    let STOP = false;\n    let anchorPosition = -1;\n    if (checkWhileConditions) {\n        const whileCheckResult = _checkWhileConditions(grammar, lineText, isFirstLine, linePos, stack, lineTokens);\n        stack = whileCheckResult.stack;\n        linePos = whileCheckResult.linePos;\n        isFirstLine = whileCheckResult.isFirstLine;\n        anchorPosition = whileCheckResult.anchorPosition;\n    }\n    const startTime = Date.now();\n    while (!STOP) {\n        if (timeLimit !== 0) {\n            const elapsedTime = Date.now() - startTime;\n            if (elapsedTime > timeLimit) {\n                return new TokenizeStringResult(stack, true);\n            }\n        }\n        scanNext(); // potentially modifies linePos && anchorPosition\n    }\n    return new TokenizeStringResult(stack, false);\n    function scanNext() {\n        const r = matchRuleOrInjections(grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n        if (!r) {\n            // No match\n            lineTokens.produce(stack, lineLength);\n            STOP = true;\n            return;\n        }\n        const captureIndices = r.captureIndices;\n        const matchedRuleId = r.matchedRuleId;\n        const hasAdvanced = captureIndices && captureIndices.length > 0\n            ? captureIndices[0].end > linePos\n            : false;\n        if (matchedRuleId === endRuleId) {\n            // We matched the `end` for this rule => pop it\n            const poppedRule = stack.getRule(grammar);\n            lineTokens.produce(stack, captureIndices[0].start);\n            stack = stack.withContentNameScopesList(stack.nameScopesList);\n            handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, poppedRule.endCaptures, captureIndices);\n            lineTokens.produce(stack, captureIndices[0].end);\n            // pop\n            const popped = stack;\n            stack = stack.parent;\n            anchorPosition = popped.getAnchorPos();\n            if (!hasAdvanced && popped.getEnterPos() === linePos) {\n                // See https://github.com/Microsoft/vscode-textmate/issues/12\n                // Let's assume this was a mistake by the grammar author and the intent was to continue in this state\n                stack = popped;\n                lineTokens.produce(stack, lineLength);\n                STOP = true;\n                return;\n            }\n        }\n        else {\n            // We matched a rule!\n            const _rule = grammar.getRule(matchedRuleId);\n            lineTokens.produce(stack, captureIndices[0].start);\n            const beforePush = stack;\n            // push it on the stack rule\n            const scopeName = _rule.getName(lineText.content, captureIndices);\n            const nameScopesList = stack.contentNameScopesList.pushAttributed(scopeName, grammar);\n            stack = stack.push(matchedRuleId, linePos, anchorPosition, captureIndices[0].end === lineLength, null, nameScopesList, nameScopesList);\n            if (_rule instanceof BeginEndRule) {\n                const pushedRule = _rule;\n                handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, pushedRule.beginCaptures, captureIndices);\n                lineTokens.produce(stack, captureIndices[0].end);\n                anchorPosition = captureIndices[0].end;\n                const contentName = pushedRule.getContentName(lineText.content, captureIndices);\n                const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);\n                stack = stack.withContentNameScopesList(contentNameScopesList);\n                if (pushedRule.endHasBackReferences) {\n                    stack = stack.withEndRule(pushedRule.getEndWithResolvedBackReferences(lineText.content, captureIndices));\n                }\n                if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {\n                    stack = stack.pop();\n                    lineTokens.produce(stack, lineLength);\n                    STOP = true;\n                    return;\n                }\n            }\n            else if (_rule instanceof BeginWhileRule) {\n                const pushedRule = _rule;\n                handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, pushedRule.beginCaptures, captureIndices);\n                lineTokens.produce(stack, captureIndices[0].end);\n                anchorPosition = captureIndices[0].end;\n                const contentName = pushedRule.getContentName(lineText.content, captureIndices);\n                const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);\n                stack = stack.withContentNameScopesList(contentNameScopesList);\n                if (pushedRule.whileHasBackReferences) {\n                    stack = stack.withEndRule(pushedRule.getWhileWithResolvedBackReferences(lineText.content, captureIndices));\n                }\n                if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {\n                    stack = stack.pop();\n                    lineTokens.produce(stack, lineLength);\n                    STOP = true;\n                    return;\n                }\n            }\n            else {\n                const matchingRule = _rule;\n                handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, matchingRule.captures, captureIndices);\n                lineTokens.produce(stack, captureIndices[0].end);\n                // pop rule immediately since it is a MatchRule\n                stack = stack.pop();\n                if (!hasAdvanced) {\n                    stack = stack.safePop();\n                    lineTokens.produce(stack, lineLength);\n                    STOP = true;\n                    return;\n                }\n            }\n        }\n        if (captureIndices[0].end > linePos) {\n            // Advance stream\n            linePos = captureIndices[0].end;\n            isFirstLine = false;\n        }\n    }\n}\n/**\n * Walk the stack from bottom to top, and check each while condition in this order.\n * If any fails, cut off the entire stack above the failed while condition. While conditions\n * may also advance the linePosition.\n */\nfunction _checkWhileConditions(grammar, lineText, isFirstLine, linePos, stack, lineTokens) {\n    let anchorPosition = (stack.beginRuleCapturedEOL ? 0 : -1);\n    const whileRules = [];\n    for (let node = stack; node; node = node.pop()) {\n        const nodeRule = node.getRule(grammar);\n        if (nodeRule instanceof BeginWhileRule) {\n            whileRules.push({\n                rule: nodeRule,\n                stack: node\n            });\n        }\n    }\n    for (let whileRule = whileRules.pop(); whileRule; whileRule = whileRules.pop()) {\n        const { ruleScanner, findOptions } = prepareRuleWhileSearch(whileRule.rule, grammar, whileRule.stack.endRule, isFirstLine, linePos === anchorPosition);\n        const r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n        if (r) {\n            const matchedRuleId = r.ruleId;\n            if (matchedRuleId !== whileRuleId) {\n                // we shouldn't end up here\n                stack = whileRule.stack.pop();\n                break;\n            }\n            if (r.captureIndices && r.captureIndices.length) {\n                lineTokens.produce(whileRule.stack, r.captureIndices[0].start);\n                handleCaptures(grammar, lineText, isFirstLine, whileRule.stack, lineTokens, whileRule.rule.whileCaptures, r.captureIndices);\n                lineTokens.produce(whileRule.stack, r.captureIndices[0].end);\n                anchorPosition = r.captureIndices[0].end;\n                if (r.captureIndices[0].end > linePos) {\n                    linePos = r.captureIndices[0].end;\n                    isFirstLine = false;\n                }\n            }\n        }\n        else {\n            stack = whileRule.stack.pop();\n            break;\n        }\n    }\n    return { stack: stack, linePos: linePos, anchorPosition: anchorPosition, isFirstLine: isFirstLine };\n}\nfunction matchRuleOrInjections(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n    // Look for normal grammar rule\n    const matchResult = matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n    // Look for injected rules\n    const injections = grammar.getInjections();\n    if (injections.length === 0) {\n        // No injections whatsoever => early return\n        return matchResult;\n    }\n    const injectionResult = matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n    if (!injectionResult) {\n        // No injections matched => early return\n        return matchResult;\n    }\n    if (!matchResult) {\n        // Only injections matched => early return\n        return injectionResult;\n    }\n    // Decide if `matchResult` or `injectionResult` should win\n    const matchResultScore = matchResult.captureIndices[0].start;\n    const injectionResultScore = injectionResult.captureIndices[0].start;\n    if (injectionResultScore < matchResultScore || (injectionResult.priorityMatch && injectionResultScore === matchResultScore)) {\n        // injection won!\n        return injectionResult;\n    }\n    return matchResult;\n}\nfunction matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n    const rule = stack.getRule(grammar);\n    const { ruleScanner, findOptions } = prepareRuleSearch(rule, grammar, stack.endRule, isFirstLine, linePos === anchorPosition);\n    const r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n    if (r) {\n        return {\n            captureIndices: r.captureIndices,\n            matchedRuleId: r.ruleId\n        };\n    }\n    return null;\n}\nfunction matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n    // The lower the better\n    let bestMatchRating = Number.MAX_VALUE;\n    let bestMatchCaptureIndices = null;\n    let bestMatchRuleId;\n    let bestMatchResultPriority = 0;\n    const scopes = stack.contentNameScopesList.getScopeNames();\n    for (let i = 0, len = injections.length; i < len; i++) {\n        const injection = injections[i];\n        if (!injection.matcher(scopes)) {\n            // injection selector doesn't match stack\n            continue;\n        }\n        const rule = grammar.getRule(injection.ruleId);\n        const { ruleScanner, findOptions } = prepareRuleSearch(rule, grammar, null, isFirstLine, linePos === anchorPosition);\n        const matchResult = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n        if (!matchResult) {\n            continue;\n        }\n        const matchRating = matchResult.captureIndices[0].start;\n        if (matchRating >= bestMatchRating) {\n            // Injections are sorted by priority, so the previous injection had a better or equal priority\n            continue;\n        }\n        bestMatchRating = matchRating;\n        bestMatchCaptureIndices = matchResult.captureIndices;\n        bestMatchRuleId = matchResult.ruleId;\n        bestMatchResultPriority = injection.priority;\n        if (bestMatchRating === linePos) {\n            // No more need to look at the rest of the injections.\n            break;\n        }\n    }\n    if (bestMatchCaptureIndices) {\n        return {\n            priorityMatch: bestMatchResultPriority === -1,\n            captureIndices: bestMatchCaptureIndices,\n            matchedRuleId: bestMatchRuleId\n        };\n    }\n    return null;\n}\nfunction prepareRuleSearch(rule, grammar, endRegexSource, allowA, allowG) {\n    const ruleScanner = rule.compileAG(grammar, endRegexSource, allowA, allowG);\n    return { ruleScanner, findOptions: 0 /* FindOption.None */ };\n}\nfunction prepareRuleWhileSearch(rule, grammar, endRegexSource, allowA, allowG) {\n    const ruleScanner = rule.compileWhileAG(grammar, endRegexSource, allowA, allowG);\n    return { ruleScanner, findOptions: 0 /* FindOption.None */ };\n}\nfunction handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, captures, captureIndices) {\n    if (captures.length === 0) {\n        return;\n    }\n    const lineTextContent = lineText.content;\n    const len = Math.min(captures.length, captureIndices.length);\n    const localStack = [];\n    const maxEnd = captureIndices[0].end;\n    for (let i = 0; i < len; i++) {\n        const captureRule = captures[i];\n        if (captureRule === null) {\n            // Not interested\n            continue;\n        }\n        const captureIndex = captureIndices[i];\n        if (captureIndex.length === 0) {\n            // Nothing really captured\n            continue;\n        }\n        if (captureIndex.start > maxEnd) {\n            // Capture going beyond consumed string\n            break;\n        }\n        // pop captures while needed\n        while (localStack.length > 0 && localStack[localStack.length - 1].endPos <= captureIndex.start) {\n            // pop!\n            lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);\n            localStack.pop();\n        }\n        if (localStack.length > 0) {\n            lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, captureIndex.start);\n        }\n        else {\n            lineTokens.produce(stack, captureIndex.start);\n        }\n        if (captureRule.retokenizeCapturedWithRuleId) {\n            // the capture requires additional matching\n            const scopeName = captureRule.getName(lineTextContent, captureIndices);\n            const nameScopesList = stack.contentNameScopesList.pushAttributed(scopeName, grammar);\n            const contentName = captureRule.getContentName(lineTextContent, captureIndices);\n            const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);\n            const stackClone = stack.push(captureRule.retokenizeCapturedWithRuleId, captureIndex.start, -1, false, null, nameScopesList, contentNameScopesList);\n            const onigSubStr = grammar.createOnigString(lineTextContent.substring(0, captureIndex.end));\n            _tokenizeString(grammar, onigSubStr, (isFirstLine && captureIndex.start === 0), captureIndex.start, stackClone, lineTokens, false, /* no time limit */ 0);\n            disposeOnigString(onigSubStr);\n            continue;\n        }\n        const captureRuleScopeName = captureRule.getName(lineTextContent, captureIndices);\n        if (captureRuleScopeName !== null) {\n            // push\n            const base = localStack.length > 0 ? localStack[localStack.length - 1].scopes : stack.contentNameScopesList;\n            const captureRuleScopesList = base.pushAttributed(captureRuleScopeName, grammar);\n            localStack.push(new LocalStackElement(captureRuleScopesList, captureIndex.end));\n        }\n    }\n    while (localStack.length > 0) {\n        // pop!\n        lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);\n        localStack.pop();\n    }\n}\nclass LocalStackElement {\n    scopes;\n    endPos;\n    constructor(scopes, endPos) {\n        this.scopes = scopes;\n        this.endPos = endPos;\n    }\n}\n\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nfunction createGrammar(scopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, onigLib) {\n    return new Grammar(scopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, onigLib); //TODO\n}\nfunction collectInjections(result, selector, rule, ruleFactoryHelper, grammar) {\n    const matchers = createMatchers(selector, nameMatcher);\n    const ruleId = RuleFactory.getCompiledRuleId(rule, ruleFactoryHelper, grammar.repository);\n    for (const matcher of matchers) {\n        result.push({\n            debugSelector: selector,\n            matcher: matcher.matcher,\n            ruleId: ruleId,\n            grammar: grammar,\n            priority: matcher.priority\n        });\n    }\n}\nfunction nameMatcher(identifers, scopes) {\n    if (scopes.length < identifers.length) {\n        return false;\n    }\n    let lastIndex = 0;\n    return identifers.every(identifier => {\n        for (let i = lastIndex; i < scopes.length; i++) {\n            if (scopesAreMatching(scopes[i], identifier)) {\n                lastIndex = i + 1;\n                return true;\n            }\n        }\n        return false;\n    });\n}\nfunction scopesAreMatching(thisScopeName, scopeName) {\n    if (!thisScopeName) {\n        return false;\n    }\n    if (thisScopeName === scopeName) {\n        return true;\n    }\n    const len = scopeName.length;\n    return thisScopeName.length > len && thisScopeName.substr(0, len) === scopeName && thisScopeName[len] === '.';\n}\nclass Grammar {\n    _rootScopeName;\n    balancedBracketSelectors;\n    _onigLib;\n    _rootId;\n    _lastRuleId;\n    _ruleId2desc;\n    _includedGrammars;\n    _grammarRepository;\n    _grammar;\n    _injections;\n    _basicScopeAttributesProvider;\n    _tokenTypeMatchers;\n    get themeProvider() { return this._grammarRepository; }\n    constructor(_rootScopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, _onigLib) {\n        this._rootScopeName = _rootScopeName;\n        this.balancedBracketSelectors = balancedBracketSelectors;\n        this._onigLib = _onigLib;\n        this._basicScopeAttributesProvider = new BasicScopeAttributesProvider(initialLanguage, embeddedLanguages);\n        this._rootId = -1;\n        this._lastRuleId = 0;\n        this._ruleId2desc = [null];\n        this._includedGrammars = {};\n        this._grammarRepository = grammarRepository;\n        this._grammar = initGrammar(grammar, null);\n        this._injections = null;\n        this._tokenTypeMatchers = [];\n        if (tokenTypes) {\n            for (const selector of Object.keys(tokenTypes)) {\n                const matchers = createMatchers(selector, nameMatcher);\n                for (const matcher of matchers) {\n                    this._tokenTypeMatchers.push({\n                        matcher: matcher.matcher,\n                        type: tokenTypes[selector],\n                    });\n                }\n            }\n        }\n    }\n    dispose() {\n        for (const rule of this._ruleId2desc) {\n            if (rule) {\n                rule.dispose();\n            }\n        }\n    }\n    createOnigScanner(sources) {\n        return this._onigLib.createOnigScanner(sources);\n    }\n    createOnigString(sources) {\n        return this._onigLib.createOnigString(sources);\n    }\n    getMetadataForScope(scope) {\n        return this._basicScopeAttributesProvider.getBasicScopeAttributes(scope);\n    }\n    _collectInjections() {\n        const grammarRepository = {\n            lookup: (scopeName) => {\n                if (scopeName === this._rootScopeName) {\n                    return this._grammar;\n                }\n                return this.getExternalGrammar(scopeName);\n            },\n            injections: (scopeName) => {\n                return this._grammarRepository.injections(scopeName);\n            },\n        };\n        const result = [];\n        const scopeName = this._rootScopeName;\n        const grammar = grammarRepository.lookup(scopeName);\n        if (grammar) {\n            // add injections from the current grammar\n            const rawInjections = grammar.injections;\n            if (rawInjections) {\n                for (let expression in rawInjections) {\n                    collectInjections(result, expression, rawInjections[expression], this, grammar);\n                }\n            }\n            // add injection grammars contributed for the current scope\n            const injectionScopeNames = this._grammarRepository.injections(scopeName);\n            if (injectionScopeNames) {\n                injectionScopeNames.forEach((injectionScopeName) => {\n                    const injectionGrammar = this.getExternalGrammar(injectionScopeName);\n                    if (injectionGrammar) {\n                        const selector = injectionGrammar.injectionSelector;\n                        if (selector) {\n                            collectInjections(result, selector, injectionGrammar, this, injectionGrammar);\n                        }\n                    }\n                });\n            }\n        }\n        result.sort((i1, i2) => i1.priority - i2.priority); // sort by priority\n        return result;\n    }\n    getInjections() {\n        if (this._injections === null) {\n            this._injections = this._collectInjections();\n        }\n        return this._injections;\n    }\n    registerRule(factory) {\n        const id = ++this._lastRuleId;\n        const result = factory(ruleIdFromNumber(id));\n        this._ruleId2desc[id] = result;\n        return result;\n    }\n    getRule(ruleId) {\n        return this._ruleId2desc[ruleIdToNumber(ruleId)];\n    }\n    getExternalGrammar(scopeName, repository) {\n        if (this._includedGrammars[scopeName]) {\n            return this._includedGrammars[scopeName];\n        }\n        else if (this._grammarRepository) {\n            const rawIncludedGrammar = this._grammarRepository.lookup(scopeName);\n            if (rawIncludedGrammar) {\n                // console.log('LOADED GRAMMAR ' + pattern.include);\n                this._includedGrammars[scopeName] = initGrammar(rawIncludedGrammar, repository && repository.$base);\n                return this._includedGrammars[scopeName];\n            }\n        }\n        return undefined;\n    }\n    tokenizeLine(lineText, prevState, timeLimit = 0) {\n        const r = this._tokenize(lineText, prevState, false, timeLimit);\n        return {\n            tokens: r.lineTokens.getResult(r.ruleStack, r.lineLength),\n            ruleStack: r.ruleStack,\n            stoppedEarly: r.stoppedEarly,\n        };\n    }\n    tokenizeLine2(lineText, prevState, timeLimit = 0) {\n        const r = this._tokenize(lineText, prevState, true, timeLimit);\n        return {\n            tokens: r.lineTokens.getBinaryResult(r.ruleStack, r.lineLength),\n            ruleStack: r.ruleStack,\n            stoppedEarly: r.stoppedEarly,\n        };\n    }\n    _tokenize(lineText, prevState, emitBinaryTokens, timeLimit) {\n        if (this._rootId === -1) {\n            this._rootId = RuleFactory.getCompiledRuleId(this._grammar.repository.$self, this, this._grammar.repository);\n            // This ensures ids are deterministic, and thus equal in renderer and webworker.\n            this.getInjections();\n        }\n        let isFirstLine;\n        if (!prevState || prevState === StateStackImpl.NULL) {\n            isFirstLine = true;\n            const rawDefaultMetadata = this._basicScopeAttributesProvider.getDefaultAttributes();\n            const defaultStyle = this.themeProvider.getDefaults();\n            const defaultMetadata = EncodedTokenAttributes.set(0, rawDefaultMetadata.languageId, rawDefaultMetadata.tokenType, null, defaultStyle.fontStyle, defaultStyle.foregroundId, defaultStyle.backgroundId);\n            const rootScopeName = this.getRule(this._rootId).getName(null, null);\n            let scopeList;\n            if (rootScopeName) {\n                scopeList = AttributedScopeStack.createRootAndLookUpScopeName(rootScopeName, defaultMetadata, this);\n            }\n            else {\n                scopeList = AttributedScopeStack.createRoot(\"unknown\", defaultMetadata);\n            }\n            prevState = new StateStackImpl(null, this._rootId, -1, -1, false, null, scopeList, scopeList);\n        }\n        else {\n            isFirstLine = false;\n            prevState.reset();\n        }\n        lineText = lineText + \"\\n\";\n        const onigLineText = this.createOnigString(lineText);\n        const lineLength = onigLineText.content.length;\n        const lineTokens = new LineTokens(emitBinaryTokens, lineText, this._tokenTypeMatchers, this.balancedBracketSelectors);\n        const r = _tokenizeString(this, onigLineText, isFirstLine, 0, prevState, lineTokens, true, timeLimit);\n        disposeOnigString(onigLineText);\n        return {\n            lineLength: lineLength,\n            lineTokens: lineTokens,\n            ruleStack: r.stack,\n            stoppedEarly: r.stoppedEarly,\n        };\n    }\n}\nfunction initGrammar(grammar, base) {\n    grammar = clone(grammar);\n    grammar.repository = grammar.repository || {};\n    grammar.repository.$self = {\n        $vscodeTextmateLocation: grammar.$vscodeTextmateLocation,\n        patterns: grammar.patterns,\n        name: grammar.scopeName\n    };\n    grammar.repository.$base = base || grammar.repository.$self;\n    return grammar;\n}\nclass AttributedScopeStack {\n    parent;\n    scopePath;\n    tokenAttributes;\n    static fromExtension(namesScopeList, contentNameScopesList) {\n        let current = namesScopeList;\n        let scopeNames = namesScopeList?.scopePath ?? null;\n        for (const frame of contentNameScopesList) {\n            scopeNames = ScopeStack.push(scopeNames, frame.scopeNames);\n            current = new AttributedScopeStack(current, scopeNames, frame.encodedTokenAttributes);\n        }\n        return current;\n    }\n    static createRoot(scopeName, tokenAttributes) {\n        return new AttributedScopeStack(null, new ScopeStack(null, scopeName), tokenAttributes);\n    }\n    static createRootAndLookUpScopeName(scopeName, tokenAttributes, grammar) {\n        const rawRootMetadata = grammar.getMetadataForScope(scopeName);\n        const scopePath = new ScopeStack(null, scopeName);\n        const rootStyle = grammar.themeProvider.themeMatch(scopePath);\n        const resolvedTokenAttributes = AttributedScopeStack.mergeAttributes(tokenAttributes, rawRootMetadata, rootStyle);\n        return new AttributedScopeStack(null, scopePath, resolvedTokenAttributes);\n    }\n    get scopeName() { return this.scopePath.scopeName; }\n    /**\n     * Invariant:\n     * ```\n     * if (parent && !scopePath.extends(parent.scopePath)) {\n     * \tthrow new Error();\n     * }\n     * ```\n     */\n    constructor(parent, scopePath, tokenAttributes) {\n        this.parent = parent;\n        this.scopePath = scopePath;\n        this.tokenAttributes = tokenAttributes;\n    }\n    toString() {\n        return this.getScopeNames().join(' ');\n    }\n    equals(other) {\n        return AttributedScopeStack.equals(this, other);\n    }\n    static equals(a, b) {\n        do {\n            if (a === b) {\n                return true;\n            }\n            if (!a && !b) {\n                // End of list reached for both\n                return true;\n            }\n            if (!a || !b) {\n                // End of list reached only for one\n                return false;\n            }\n            if (a.scopeName !== b.scopeName || a.tokenAttributes !== b.tokenAttributes) {\n                return false;\n            }\n            // Go to previous pair\n            a = a.parent;\n            b = b.parent;\n        } while (true);\n    }\n    static mergeAttributes(existingTokenAttributes, basicScopeAttributes, styleAttributes) {\n        let fontStyle = -1 /* FontStyle.NotSet */;\n        let foreground = 0;\n        let background = 0;\n        if (styleAttributes !== null) {\n            fontStyle = styleAttributes.fontStyle;\n            foreground = styleAttributes.foregroundId;\n            background = styleAttributes.backgroundId;\n        }\n        return EncodedTokenAttributes.set(existingTokenAttributes, basicScopeAttributes.languageId, basicScopeAttributes.tokenType, null, fontStyle, foreground, background);\n    }\n    pushAttributed(scopePath, grammar) {\n        if (scopePath === null) {\n            return this;\n        }\n        if (scopePath.indexOf(' ') === -1) {\n            // This is the common case and much faster\n            return AttributedScopeStack._pushAttributed(this, scopePath, grammar);\n        }\n        const scopes = scopePath.split(/ /g);\n        let result = this;\n        for (const scope of scopes) {\n            result = AttributedScopeStack._pushAttributed(result, scope, grammar);\n        }\n        return result;\n    }\n    static _pushAttributed(target, scopeName, grammar) {\n        const rawMetadata = grammar.getMetadataForScope(scopeName);\n        const newPath = target.scopePath.push(scopeName);\n        const scopeThemeMatchResult = grammar.themeProvider.themeMatch(newPath);\n        const metadata = AttributedScopeStack.mergeAttributes(target.tokenAttributes, rawMetadata, scopeThemeMatchResult);\n        return new AttributedScopeStack(target, newPath, metadata);\n    }\n    getScopeNames() {\n        return this.scopePath.getSegments();\n    }\n    getExtensionIfDefined(base) {\n        const result = [];\n        let self = this;\n        while (self && self !== base) {\n            result.push({\n                encodedTokenAttributes: self.tokenAttributes,\n                scopeNames: self.scopePath.getExtensionIfDefined(self.parent?.scopePath ?? null),\n            });\n            self = self.parent;\n        }\n        return self === base ? result.reverse() : undefined;\n    }\n}\n/**\n * Represents a \"pushed\" state on the stack (as a linked list element).\n */\nclass StateStackImpl {\n    parent;\n    ruleId;\n    beginRuleCapturedEOL;\n    endRule;\n    nameScopesList;\n    contentNameScopesList;\n    _stackElementBrand = undefined;\n    // TODO remove me\n    static NULL = new StateStackImpl(null, 0, 0, 0, false, null, null, null);\n    /**\n     * The position on the current line where this state was pushed.\n     * This is relevant only while tokenizing a line, to detect endless loops.\n     * Its value is meaningless across lines.\n     */\n    _enterPos;\n    /**\n     * The captured anchor position when this stack element was pushed.\n     * This is relevant only while tokenizing a line, to restore the anchor position when popping.\n     * Its value is meaningless across lines.\n     */\n    _anchorPos;\n    /**\n     * The depth of the stack.\n     */\n    depth;\n    /**\n     * Invariant:\n     * ```\n     * if (contentNameScopesList !== nameScopesList && contentNameScopesList?.parent !== nameScopesList) {\n     * \tthrow new Error();\n     * }\n     * if (this.parent && !nameScopesList.extends(this.parent.contentNameScopesList)) {\n     * \tthrow new Error();\n     * }\n     * ```\n     */\n    constructor(\n    /**\n     * The previous state on the stack (or null for the root state).\n     */\n    parent, \n    /**\n     * The state (rule) that this element represents.\n     */\n    ruleId, enterPos, anchorPos, \n    /**\n     * The state has entered and captured \\n. This means that the next line should have an anchorPosition of 0.\n     */\n    beginRuleCapturedEOL, \n    /**\n     * The \"pop\" (end) condition for this state in case that it was dynamically generated through captured text.\n     */\n    endRule, \n    /**\n     * The list of scopes containing the \"name\" for this state.\n     */\n    nameScopesList, \n    /**\n     * The list of scopes containing the \"contentName\" (besides \"name\") for this state.\n     * This list **must** contain as an element `scopeName`.\n     */\n    contentNameScopesList) {\n        this.parent = parent;\n        this.ruleId = ruleId;\n        this.beginRuleCapturedEOL = beginRuleCapturedEOL;\n        this.endRule = endRule;\n        this.nameScopesList = nameScopesList;\n        this.contentNameScopesList = contentNameScopesList;\n        this.depth = this.parent ? this.parent.depth + 1 : 1;\n        this._enterPos = enterPos;\n        this._anchorPos = anchorPos;\n    }\n    equals(other) {\n        if (other === null) {\n            return false;\n        }\n        return StateStackImpl._equals(this, other);\n    }\n    static _equals(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (!this._structuralEquals(a, b)) {\n            return false;\n        }\n        return AttributedScopeStack.equals(a.contentNameScopesList, b.contentNameScopesList);\n    }\n    /**\n     * A structural equals check. Does not take into account `scopes`.\n     */\n    static _structuralEquals(a, b) {\n        do {\n            if (a === b) {\n                return true;\n            }\n            if (!a && !b) {\n                // End of list reached for both\n                return true;\n            }\n            if (!a || !b) {\n                // End of list reached only for one\n                return false;\n            }\n            if (a.depth !== b.depth ||\n                a.ruleId !== b.ruleId ||\n                a.endRule !== b.endRule) {\n                return false;\n            }\n            // Go to previous pair\n            a = a.parent;\n            b = b.parent;\n        } while (true);\n    }\n    clone() {\n        return this;\n    }\n    static _reset(el) {\n        while (el) {\n            el._enterPos = -1;\n            el._anchorPos = -1;\n            el = el.parent;\n        }\n    }\n    reset() {\n        StateStackImpl._reset(this);\n    }\n    pop() {\n        return this.parent;\n    }\n    safePop() {\n        if (this.parent) {\n            return this.parent;\n        }\n        return this;\n    }\n    push(ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList) {\n        return new StateStackImpl(this, ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList);\n    }\n    getEnterPos() {\n        return this._enterPos;\n    }\n    getAnchorPos() {\n        return this._anchorPos;\n    }\n    getRule(grammar) {\n        return grammar.getRule(this.ruleId);\n    }\n    toString() {\n        const r = [];\n        this._writeString(r, 0);\n        return \"[\" + r.join(\",\") + \"]\";\n    }\n    _writeString(res, outIndex) {\n        if (this.parent) {\n            outIndex = this.parent._writeString(res, outIndex);\n        }\n        res[outIndex++] = `(${this.ruleId}, ${this.nameScopesList?.toString()}, ${this.contentNameScopesList?.toString()})`;\n        return outIndex;\n    }\n    withContentNameScopesList(contentNameScopeStack) {\n        if (this.contentNameScopesList === contentNameScopeStack) {\n            return this;\n        }\n        return this.parent.push(this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, this.endRule, this.nameScopesList, contentNameScopeStack);\n    }\n    withEndRule(endRule) {\n        if (this.endRule === endRule) {\n            return this;\n        }\n        return new StateStackImpl(this.parent, this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, endRule, this.nameScopesList, this.contentNameScopesList);\n    }\n    // Used to warn of endless loops\n    hasSameRuleAs(other) {\n        let el = this;\n        while (el && el._enterPos === other._enterPos) {\n            if (el.ruleId === other.ruleId) {\n                return true;\n            }\n            el = el.parent;\n        }\n        return false;\n    }\n    toStateStackFrame() {\n        return {\n            ruleId: ruleIdToNumber(this.ruleId),\n            beginRuleCapturedEOL: this.beginRuleCapturedEOL,\n            endRule: this.endRule,\n            nameScopesList: this.nameScopesList?.getExtensionIfDefined(this.parent?.nameScopesList ?? null) ?? [],\n            contentNameScopesList: this.contentNameScopesList?.getExtensionIfDefined(this.nameScopesList) ?? [],\n        };\n    }\n    static pushFrame(self, frame) {\n        const namesScopeList = AttributedScopeStack.fromExtension(self?.nameScopesList ?? null, frame.nameScopesList);\n        return new StateStackImpl(self, ruleIdFromNumber(frame.ruleId), frame.enterPos ?? -1, frame.anchorPos ?? -1, frame.beginRuleCapturedEOL, frame.endRule, namesScopeList, AttributedScopeStack.fromExtension(namesScopeList, frame.contentNameScopesList));\n    }\n}\nclass BalancedBracketSelectors {\n    balancedBracketScopes;\n    unbalancedBracketScopes;\n    allowAny = false;\n    constructor(balancedBracketScopes, unbalancedBracketScopes) {\n        this.balancedBracketScopes = balancedBracketScopes.flatMap((selector) => {\n            if (selector === '*') {\n                this.allowAny = true;\n                return [];\n            }\n            return createMatchers(selector, nameMatcher).map((m) => m.matcher);\n        });\n        this.unbalancedBracketScopes = unbalancedBracketScopes.flatMap((selector) => createMatchers(selector, nameMatcher).map((m) => m.matcher));\n    }\n    get matchesAlways() {\n        return this.allowAny && this.unbalancedBracketScopes.length === 0;\n    }\n    get matchesNever() {\n        return this.balancedBracketScopes.length === 0 && !this.allowAny;\n    }\n    match(scopes) {\n        for (const excluder of this.unbalancedBracketScopes) {\n            if (excluder(scopes)) {\n                return false;\n            }\n        }\n        for (const includer of this.balancedBracketScopes) {\n            if (includer(scopes)) {\n                return true;\n            }\n        }\n        return this.allowAny;\n    }\n}\nclass LineTokens {\n    balancedBracketSelectors;\n    _emitBinaryTokens;\n    /**\n     * defined only if `false`.\n     */\n    _lineText;\n    /**\n     * used only if `_emitBinaryTokens` is false.\n     */\n    _tokens;\n    /**\n     * used only if `_emitBinaryTokens` is true.\n     */\n    _binaryTokens;\n    _lastTokenEndIndex;\n    _tokenTypeOverrides;\n    constructor(emitBinaryTokens, lineText, tokenTypeOverrides, balancedBracketSelectors) {\n        this.balancedBracketSelectors = balancedBracketSelectors;\n        this._emitBinaryTokens = emitBinaryTokens;\n        this._tokenTypeOverrides = tokenTypeOverrides;\n        {\n            this._lineText = null;\n        }\n        this._tokens = [];\n        this._binaryTokens = [];\n        this._lastTokenEndIndex = 0;\n    }\n    produce(stack, endIndex) {\n        this.produceFromScopes(stack.contentNameScopesList, endIndex);\n    }\n    produceFromScopes(scopesList, endIndex) {\n        if (this._lastTokenEndIndex >= endIndex) {\n            return;\n        }\n        if (this._emitBinaryTokens) {\n            let metadata = scopesList?.tokenAttributes ?? 0;\n            let containsBalancedBrackets = false;\n            if (this.balancedBracketSelectors?.matchesAlways) {\n                containsBalancedBrackets = true;\n            }\n            if (this._tokenTypeOverrides.length > 0 || (this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever)) {\n                // Only generate scope array when required to improve performance\n                const scopes = scopesList?.getScopeNames() ?? [];\n                for (const tokenType of this._tokenTypeOverrides) {\n                    if (tokenType.matcher(scopes)) {\n                        metadata = EncodedTokenAttributes.set(metadata, 0, toOptionalTokenType(tokenType.type), null, -1 /* FontStyle.NotSet */, 0, 0);\n                    }\n                }\n                if (this.balancedBracketSelectors) {\n                    containsBalancedBrackets = this.balancedBracketSelectors.match(scopes);\n                }\n            }\n            if (containsBalancedBrackets) {\n                metadata = EncodedTokenAttributes.set(metadata, 0, 8 /* OptionalStandardTokenType.NotSet */, containsBalancedBrackets, -1 /* FontStyle.NotSet */, 0, 0);\n            }\n            if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === metadata) {\n                // no need to push a token with the same metadata\n                this._lastTokenEndIndex = endIndex;\n                return;\n            }\n            this._binaryTokens.push(this._lastTokenEndIndex);\n            this._binaryTokens.push(metadata);\n            this._lastTokenEndIndex = endIndex;\n            return;\n        }\n        const scopes = scopesList?.getScopeNames() ?? [];\n        this._tokens.push({\n            startIndex: this._lastTokenEndIndex,\n            endIndex: endIndex,\n            // value: lineText.substring(lastTokenEndIndex, endIndex),\n            scopes: scopes\n        });\n        this._lastTokenEndIndex = endIndex;\n    }\n    getResult(stack, lineLength) {\n        if (this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === lineLength - 1) {\n            // pop produced token for newline\n            this._tokens.pop();\n        }\n        if (this._tokens.length === 0) {\n            this._lastTokenEndIndex = -1;\n            this.produce(stack, lineLength);\n            this._tokens[this._tokens.length - 1].startIndex = 0;\n        }\n        return this._tokens;\n    }\n    getBinaryResult(stack, lineLength) {\n        if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === lineLength - 1) {\n            // pop produced token for newline\n            this._binaryTokens.pop();\n            this._binaryTokens.pop();\n        }\n        if (this._binaryTokens.length === 0) {\n            this._lastTokenEndIndex = -1;\n            this.produce(stack, lineLength);\n            this._binaryTokens[this._binaryTokens.length - 2] = 0;\n        }\n        const result = new Uint32Array(this._binaryTokens.length);\n        for (let i = 0, len = this._binaryTokens.length; i < len; i++) {\n            result[i] = this._binaryTokens[i];\n        }\n        return result;\n    }\n}\n\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\nclass SyncRegistry {\n    _onigLibPromise;\n    _grammars = new Map();\n    _rawGrammars = new Map();\n    _injectionGrammars = new Map();\n    _theme;\n    constructor(theme, _onigLibPromise) {\n        this._onigLibPromise = _onigLibPromise;\n        this._theme = theme;\n    }\n    dispose() {\n        for (const grammar of this._grammars.values()) {\n            grammar.dispose();\n        }\n    }\n    setTheme(theme) {\n        this._theme = theme;\n    }\n    getColorMap() {\n        return this._theme.getColorMap();\n    }\n    /**\n     * Add `grammar` to registry and return a list of referenced scope names\n     */\n    addGrammar(grammar, injectionScopeNames) {\n        this._rawGrammars.set(grammar.scopeName, grammar);\n        if (injectionScopeNames) {\n            this._injectionGrammars.set(grammar.scopeName, injectionScopeNames);\n        }\n    }\n    /**\n     * Lookup a raw grammar.\n     */\n    lookup(scopeName) {\n        return this._rawGrammars.get(scopeName);\n    }\n    /**\n     * Returns the injections for the given grammar\n     */\n    injections(targetScope) {\n        return this._injectionGrammars.get(targetScope);\n    }\n    /**\n     * Get the default theme settings\n     */\n    getDefaults() {\n        return this._theme.getDefaults();\n    }\n    /**\n     * Match a scope in the theme.\n     */\n    themeMatch(scopePath) {\n        return this._theme.match(scopePath);\n    }\n    /**\n     * Lookup a grammar.\n     */\n    async grammarForScopeName(scopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {\n        if (!this._grammars.has(scopeName)) {\n            let rawGrammar = this._rawGrammars.get(scopeName);\n            if (!rawGrammar) {\n                return null;\n            }\n            this._grammars.set(scopeName, createGrammar(scopeName, rawGrammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, this, await this._onigLibPromise));\n        }\n        return this._grammars.get(scopeName);\n    }\n}\n\n/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n/**\n * The registry that will hold all grammars.\n */\nlet Registry$1 = class Registry {\n    _options;\n    _syncRegistry;\n    _ensureGrammarCache;\n    constructor(options) {\n        this._options = options;\n        this._syncRegistry = new SyncRegistry(Theme.createFromRawTheme(options.theme, options.colorMap), options.onigLib);\n        this._ensureGrammarCache = new Map();\n    }\n    dispose() {\n        this._syncRegistry.dispose();\n    }\n    /**\n     * Change the theme. Once called, no previous `ruleStack` should be used anymore.\n     */\n    setTheme(theme, colorMap) {\n        this._syncRegistry.setTheme(Theme.createFromRawTheme(theme, colorMap));\n    }\n    /**\n     * Returns a lookup array for color ids.\n     */\n    getColorMap() {\n        return this._syncRegistry.getColorMap();\n    }\n    /**\n     * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n     * Please do not use language id 0.\n     */\n    loadGrammarWithEmbeddedLanguages(initialScopeName, initialLanguage, embeddedLanguages) {\n        return this.loadGrammarWithConfiguration(initialScopeName, initialLanguage, { embeddedLanguages });\n    }\n    /**\n     * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n     * Please do not use language id 0.\n     */\n    loadGrammarWithConfiguration(initialScopeName, initialLanguage, configuration) {\n        return this._loadGrammar(initialScopeName, initialLanguage, configuration.embeddedLanguages, configuration.tokenTypes, new BalancedBracketSelectors(configuration.balancedBracketSelectors || [], configuration.unbalancedBracketSelectors || []));\n    }\n    /**\n     * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n     */\n    loadGrammar(initialScopeName) {\n        return this._loadGrammar(initialScopeName, 0, null, null, null);\n    }\n    async _loadGrammar(initialScopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {\n        const dependencyProcessor = new ScopeDependencyProcessor(this._syncRegistry, initialScopeName);\n        while (dependencyProcessor.Q.length > 0) {\n            await Promise.all(dependencyProcessor.Q.map((request) => this._loadSingleGrammar(request.scopeName)));\n            dependencyProcessor.processQueue();\n        }\n        return this._grammarForScopeName(initialScopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors);\n    }\n    async _loadSingleGrammar(scopeName) {\n        if (!this._ensureGrammarCache.has(scopeName)) {\n            this._ensureGrammarCache.set(scopeName, this._doLoadSingleGrammar(scopeName));\n        }\n        return this._ensureGrammarCache.get(scopeName);\n    }\n    async _doLoadSingleGrammar(scopeName) {\n        const grammar = await this._options.loadGrammar(scopeName);\n        if (grammar) {\n            const injections = typeof this._options.getInjections === \"function\" ? this._options.getInjections(scopeName) : undefined;\n            this._syncRegistry.addGrammar(grammar, injections);\n        }\n    }\n    /**\n     * Adds a rawGrammar.\n     */\n    async addGrammar(rawGrammar, injections = [], initialLanguage = 0, embeddedLanguages = null) {\n        this._syncRegistry.addGrammar(rawGrammar, injections);\n        return (await this._grammarForScopeName(rawGrammar.scopeName, initialLanguage, embeddedLanguages));\n    }\n    /**\n     * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `addGrammar`.\n     */\n    _grammarForScopeName(scopeName, initialLanguage = 0, embeddedLanguages = null, tokenTypes = null, balancedBracketSelectors = null) {\n        return this._syncRegistry.grammarForScopeName(scopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors);\n    }\n};\nconst INITIAL = StateStackImpl.NULL;\n\n/**\n * Helpers to manage the \"collapsed\" metadata of an entire StackElement stack.\n * The following assumptions have been made:\n *  - languageId < 256 => needs 8 bits\n *  - unique color count < 512 => needs 9 bits\n *\n * The binary format is:\n * - -------------------------------------------\n *     3322 2222 2222 1111 1111 1100 0000 0000\n *     1098 7654 3210 9876 5432 1098 7654 3210\n * - -------------------------------------------\n *     xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx\n *     bbbb bbbb bfff ffff ffFF FTTT LLLL LLLL\n * - -------------------------------------------\n *  - L = LanguageId (8 bits)\n *  - T = StandardTokenType (3 bits)\n *  - F = FontStyle (3 bits)\n *  - f = foreground color (9 bits)\n *  - b = background color (9 bits)\n */\nconst MetadataConsts = {\n    LANGUAGEID_MASK: 0b00000000000000000000000011111111,\n    TOKEN_TYPE_MASK: 0b00000000000000000000001100000000,\n    BALANCED_BRACKETS_MASK: 0b00000000000000000000010000000000,\n    FONT_STYLE_MASK: 0b00000000000000000011100000000000,\n    FOREGROUND_MASK: 0b00000000011111111100000000000000,\n    BACKGROUND_MASK: 0b11111111100000000000000000000000,\n    LANGUAGEID_OFFSET: 0,\n    TOKEN_TYPE_OFFSET: 8,\n    BALANCED_BRACKETS_OFFSET: 10,\n    FONT_STYLE_OFFSET: 11,\n    FOREGROUND_OFFSET: 15,\n    BACKGROUND_OFFSET: 24,\n};\nclass StackElementMetadata {\n    static toBinaryStr(metadata) {\n        let r = metadata.toString(2);\n        while (r.length < 32)\n            r = `0${r}`;\n        return r;\n    }\n    // public static printMetadata(metadata: number): void {\n    //   const languageId = StackElementMetadata.getLanguageId(metadata)\n    //   const tokenType = StackElementMetadata.getTokenType(metadata)\n    //   const fontStyle = StackElementMetadata.getFontStyle(metadata)\n    //   const foreground = StackElementMetadata.getForeground(metadata)\n    //   const background = StackElementMetadata.getBackground(metadata)\n    //   console.log({\n    //     languageId,\n    //     tokenType,\n    //     fontStyle,\n    //     foreground,\n    //     background,\n    //   })\n    // }\n    static getLanguageId(metadata) {\n        return (metadata & MetadataConsts.LANGUAGEID_MASK) >>> MetadataConsts.LANGUAGEID_OFFSET;\n    }\n    static getTokenType(metadata) {\n        return (metadata & MetadataConsts.TOKEN_TYPE_MASK) >>> MetadataConsts.TOKEN_TYPE_OFFSET;\n    }\n    static getFontStyle(metadata) {\n        return (metadata & MetadataConsts.FONT_STYLE_MASK) >>> MetadataConsts.FONT_STYLE_OFFSET;\n    }\n    static getForeground(metadata) {\n        return (metadata & MetadataConsts.FOREGROUND_MASK) >>> MetadataConsts.FOREGROUND_OFFSET;\n    }\n    static getBackground(metadata) {\n        return (metadata & MetadataConsts.BACKGROUND_MASK) >>> MetadataConsts.BACKGROUND_OFFSET;\n    }\n    static containsBalancedBrackets(metadata) {\n        return (metadata & MetadataConsts.BALANCED_BRACKETS_MASK) !== 0;\n    }\n    static set(metadata, languageId, tokenType, fontStyle, foreground, background) {\n        let _languageId = StackElementMetadata.getLanguageId(metadata);\n        let _tokenType = StackElementMetadata.getTokenType(metadata);\n        let _fontStyle = StackElementMetadata.getFontStyle(metadata);\n        let _foreground = StackElementMetadata.getForeground(metadata);\n        let _background = StackElementMetadata.getBackground(metadata);\n        const _containsBalancedBracketsBit = StackElementMetadata.containsBalancedBrackets(metadata)\n            ? 1\n            : 0;\n        if (languageId !== 0)\n            _languageId = languageId;\n        if (tokenType !== 0 /* TemporaryStandardTokenType.Other */) {\n            _tokenType\n                = tokenType === 8 /* TemporaryStandardTokenType.MetaEmbedded */ ? 0 /* StandardTokenType.Other */ : tokenType;\n        }\n        if (fontStyle !== FontStyle.NotSet)\n            _fontStyle = fontStyle;\n        if (foreground !== 0)\n            _foreground = foreground;\n        if (background !== 0)\n            _background = background;\n        return (((_languageId << MetadataConsts.LANGUAGEID_OFFSET)\n            | (_tokenType << MetadataConsts.TOKEN_TYPE_OFFSET)\n            | (_fontStyle << MetadataConsts.FONT_STYLE_OFFSET)\n            | (_containsBalancedBracketsBit << MetadataConsts.BALANCED_BRACKETS_OFFSET)\n            | (_foreground << MetadataConsts.FOREGROUND_OFFSET)\n            | (_background << MetadataConsts.BACKGROUND_OFFSET))\n            >>> 0);\n    }\n}\n\nexport { INITIAL, Registry$1 as Registry, StackElementMetadata };\n",
      "start": 1712268127879,
      "end": 1712268127894,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1712268127894,
      "end": 1712268127894,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1712268127894,
      "end": 1712268127894,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1712268127894,
      "end": 1712268127894,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1712268127894,
      "end": 1712268127894,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1712268127894,
      "end": 1712268127894,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1712268127894,
      "end": 1712268127894,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1712268127894,
      "end": 1712268127894,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1712268127894,
      "end": 1712268127894,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1712268127894,
      "end": 1712268127894,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1712268127894,
      "end": 1712268127894,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1712268127894,
      "end": 1712268127894,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1712268127894,
      "end": 1712268127894,
      "order": "normal"
    },
    {
      "name": "nuxt:fonts:font-family-injection",
      "start": 1712268127894,
      "end": 1712268127894,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1712268127894,
      "end": 1712268127894,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1712268127894,
      "end": 1712268127894,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1712268127894,
      "end": 1712268127895,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1712268127895,
      "end": 1712268127895,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "var define_process_env_default = {};\nimport { FontStyle } from \"./types.mjs\";\n({\n  InDebugMode: typeof process !== \"undefined\" && !!define_process_env_default[\"VSCODE_TEXTMATE_DEBUG\"]\n});\nvar EncodedTokenAttributes;\n(function(EncodedTokenAttributes2) {\n  function toBinaryStr(encodedTokenAttributes) {\n    return encodedTokenAttributes.toString(2).padStart(32, \"0\");\n  }\n  EncodedTokenAttributes2.toBinaryStr = toBinaryStr;\n  function print(encodedTokenAttributes) {\n    const languageId = EncodedTokenAttributes2.getLanguageId(encodedTokenAttributes);\n    const tokenType = EncodedTokenAttributes2.getTokenType(encodedTokenAttributes);\n    const fontStyle = EncodedTokenAttributes2.getFontStyle(encodedTokenAttributes);\n    const foreground = EncodedTokenAttributes2.getForeground(encodedTokenAttributes);\n    const background = EncodedTokenAttributes2.getBackground(encodedTokenAttributes);\n    console.log({\n      languageId,\n      tokenType,\n      fontStyle,\n      foreground,\n      background\n    });\n  }\n  EncodedTokenAttributes2.print = print;\n  function getLanguageId(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 255) >>> 0;\n  }\n  EncodedTokenAttributes2.getLanguageId = getLanguageId;\n  function getTokenType(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 768) >>> 8;\n  }\n  EncodedTokenAttributes2.getTokenType = getTokenType;\n  function containsBalancedBrackets(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 1024) !== 0;\n  }\n  EncodedTokenAttributes2.containsBalancedBrackets = containsBalancedBrackets;\n  function getFontStyle(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 30720) >>> 11;\n  }\n  EncodedTokenAttributes2.getFontStyle = getFontStyle;\n  function getForeground(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 16744448) >>> 15;\n  }\n  EncodedTokenAttributes2.getForeground = getForeground;\n  function getBackground(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 4278190080) >>> 24;\n  }\n  EncodedTokenAttributes2.getBackground = getBackground;\n  function set(encodedTokenAttributes, languageId, tokenType, containsBalancedBrackets2, fontStyle, foreground, background) {\n    let _languageId = EncodedTokenAttributes2.getLanguageId(encodedTokenAttributes);\n    let _tokenType = EncodedTokenAttributes2.getTokenType(encodedTokenAttributes);\n    let _containsBalancedBracketsBit = EncodedTokenAttributes2.containsBalancedBrackets(encodedTokenAttributes) ? 1 : 0;\n    let _fontStyle = EncodedTokenAttributes2.getFontStyle(encodedTokenAttributes);\n    let _foreground = EncodedTokenAttributes2.getForeground(encodedTokenAttributes);\n    let _background = EncodedTokenAttributes2.getBackground(encodedTokenAttributes);\n    if (languageId !== 0) {\n      _languageId = languageId;\n    }\n    if (tokenType !== 8) {\n      _tokenType = fromOptionalTokenType(tokenType);\n    }\n    if (containsBalancedBrackets2 !== null) {\n      _containsBalancedBracketsBit = containsBalancedBrackets2 ? 1 : 0;\n    }\n    if (fontStyle !== -1) {\n      _fontStyle = fontStyle;\n    }\n    if (foreground !== 0) {\n      _foreground = foreground;\n    }\n    if (background !== 0) {\n      _background = background;\n    }\n    return (_languageId << 0 | _tokenType << 8 | _containsBalancedBracketsBit << 10 | _fontStyle << 11 | _foreground << 15 | _background << 24) >>> 0;\n  }\n  EncodedTokenAttributes2.set = set;\n})(EncodedTokenAttributes || (EncodedTokenAttributes = {}));\nfunction toOptionalTokenType(standardType) {\n  return standardType;\n}\nfunction fromOptionalTokenType(standardType) {\n  return standardType;\n}\nfunction createMatchers(selector, matchesName) {\n  const results = [];\n  const tokenizer = newTokenizer(selector);\n  let token = tokenizer.next();\n  while (token !== null) {\n    let priority = 0;\n    if (token.length === 2 && token.charAt(1) === \":\") {\n      switch (token.charAt(0)) {\n        case \"R\":\n          priority = 1;\n          break;\n        case \"L\":\n          priority = -1;\n          break;\n        default:\n          console.log(`Unknown priority ${token} in scope selector`);\n      }\n      token = tokenizer.next();\n    }\n    let matcher = parseConjunction();\n    results.push({ matcher, priority });\n    if (token !== \",\") {\n      break;\n    }\n    token = tokenizer.next();\n  }\n  return results;\n  function parseOperand() {\n    if (token === \"-\") {\n      token = tokenizer.next();\n      const expressionToNegate = parseOperand();\n      return (matcherInput) => !!expressionToNegate && !expressionToNegate(matcherInput);\n    }\n    if (token === \"(\") {\n      token = tokenizer.next();\n      const expressionInParents = parseInnerExpression();\n      if (token === \")\") {\n        token = tokenizer.next();\n      }\n      return expressionInParents;\n    }\n    if (isIdentifier(token)) {\n      const identifiers = [];\n      do {\n        identifiers.push(token);\n        token = tokenizer.next();\n      } while (isIdentifier(token));\n      return (matcherInput) => matchesName(identifiers, matcherInput);\n    }\n    return null;\n  }\n  function parseConjunction() {\n    const matchers = [];\n    let matcher = parseOperand();\n    while (matcher) {\n      matchers.push(matcher);\n      matcher = parseOperand();\n    }\n    return (matcherInput) => matchers.every((matcher2) => matcher2(matcherInput));\n  }\n  function parseInnerExpression() {\n    const matchers = [];\n    let matcher = parseConjunction();\n    while (matcher) {\n      matchers.push(matcher);\n      if (token === \"|\" || token === \",\") {\n        do {\n          token = tokenizer.next();\n        } while (token === \"|\" || token === \",\");\n      } else {\n        break;\n      }\n      matcher = parseConjunction();\n    }\n    return (matcherInput) => matchers.some((matcher2) => matcher2(matcherInput));\n  }\n}\nfunction isIdentifier(token) {\n  return !!token && !!token.match(/[\\w\\.:]+/);\n}\nfunction newTokenizer(input) {\n  let regex = /([LR]:|[\\w\\.:][\\w\\.:\\-]*|[\\,\\|\\-\\(\\)])/g;\n  let match = regex.exec(input);\n  return {\n    next: () => {\n      if (!match) {\n        return null;\n      }\n      const res = match[0];\n      match = regex.exec(input);\n      return res;\n    }\n  };\n}\nfunction disposeOnigString(str) {\n  if (typeof str.dispose === \"function\") {\n    str.dispose();\n  }\n}\nfunction clone(something) {\n  return doClone(something);\n}\nfunction doClone(something) {\n  if (Array.isArray(something)) {\n    return cloneArray(something);\n  }\n  if (typeof something === \"object\") {\n    return cloneObj(something);\n  }\n  return something;\n}\nfunction cloneArray(arr) {\n  let r = [];\n  for (let i = 0, len = arr.length; i < len; i++) {\n    r[i] = doClone(arr[i]);\n  }\n  return r;\n}\nfunction cloneObj(obj) {\n  let r = {};\n  for (let key in obj) {\n    r[key] = doClone(obj[key]);\n  }\n  return r;\n}\nfunction mergeObjects(target, ...sources) {\n  sources.forEach((source) => {\n    for (let key in source) {\n      target[key] = source[key];\n    }\n  });\n  return target;\n}\nfunction basename(path) {\n  const idx = ~path.lastIndexOf(\"/\") || ~path.lastIndexOf(\"\\\\\");\n  if (idx === 0) {\n    return path;\n  } else if (~idx === path.length - 1) {\n    return basename(path.substring(0, path.length - 1));\n  } else {\n    return path.substr(~idx + 1);\n  }\n}\nlet CAPTURING_REGEX_SOURCE = /\\$(\\d+)|\\${(\\d+):\\/(downcase|upcase)}/g;\nclass RegexSource {\n  static hasCaptures(regexSource) {\n    if (regexSource === null) {\n      return false;\n    }\n    CAPTURING_REGEX_SOURCE.lastIndex = 0;\n    return CAPTURING_REGEX_SOURCE.test(regexSource);\n  }\n  static replaceCaptures(regexSource, captureSource, captureIndices) {\n    return regexSource.replace(CAPTURING_REGEX_SOURCE, (match, index, commandIndex, command) => {\n      let capture = captureIndices[parseInt(index || commandIndex, 10)];\n      if (capture) {\n        let result = captureSource.substring(capture.start, capture.end);\n        while (result[0] === \".\") {\n          result = result.substring(1);\n        }\n        switch (command) {\n          case \"downcase\":\n            return result.toLowerCase();\n          case \"upcase\":\n            return result.toUpperCase();\n          default:\n            return result;\n        }\n      } else {\n        return match;\n      }\n    });\n  }\n}\nfunction strcmp(a, b) {\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}\nfunction strArrCmp(a, b) {\n  if (a === null && b === null) {\n    return 0;\n  }\n  if (!a) {\n    return -1;\n  }\n  if (!b) {\n    return 1;\n  }\n  let len1 = a.length;\n  let len2 = b.length;\n  if (len1 === len2) {\n    for (let i = 0; i < len1; i++) {\n      let res = strcmp(a[i], b[i]);\n      if (res !== 0) {\n        return res;\n      }\n    }\n    return 0;\n  }\n  return len1 - len2;\n}\nfunction isValidHexColor(hex) {\n  if (/^#[0-9a-f]{6}$/i.test(hex)) {\n    return true;\n  }\n  if (/^#[0-9a-f]{8}$/i.test(hex)) {\n    return true;\n  }\n  if (/^#[0-9a-f]{3}$/i.test(hex)) {\n    return true;\n  }\n  if (/^#[0-9a-f]{4}$/i.test(hex)) {\n    return true;\n  }\n  return false;\n}\nfunction escapeRegExpCharacters(value) {\n  return value.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, \"\\\\$&\");\n}\nclass CachedFn {\n  fn;\n  cache = /* @__PURE__ */ new Map();\n  constructor(fn) {\n    this.fn = fn;\n  }\n  get(key) {\n    if (this.cache.has(key)) {\n      return this.cache.get(key);\n    }\n    const value = this.fn(key);\n    this.cache.set(key, value);\n    return value;\n  }\n}\nclass TopLevelRuleReference {\n  scopeName;\n  constructor(scopeName) {\n    this.scopeName = scopeName;\n  }\n  toKey() {\n    return this.scopeName;\n  }\n}\nclass TopLevelRepositoryRuleReference {\n  scopeName;\n  ruleName;\n  constructor(scopeName, ruleName) {\n    this.scopeName = scopeName;\n    this.ruleName = ruleName;\n  }\n  toKey() {\n    return `${this.scopeName}#${this.ruleName}`;\n  }\n}\nclass ExternalReferenceCollector {\n  _references = [];\n  _seenReferenceKeys = /* @__PURE__ */ new Set();\n  get references() {\n    return this._references;\n  }\n  visitedRule = /* @__PURE__ */ new Set();\n  add(reference) {\n    const key = reference.toKey();\n    if (this._seenReferenceKeys.has(key)) {\n      return;\n    }\n    this._seenReferenceKeys.add(key);\n    this._references.push(reference);\n  }\n}\nclass ScopeDependencyProcessor {\n  repo;\n  initialScopeName;\n  seenFullScopeRequests = /* @__PURE__ */ new Set();\n  seenPartialScopeRequests = /* @__PURE__ */ new Set();\n  Q;\n  constructor(repo, initialScopeName) {\n    this.repo = repo;\n    this.initialScopeName = initialScopeName;\n    this.seenFullScopeRequests.add(this.initialScopeName);\n    this.Q = [new TopLevelRuleReference(this.initialScopeName)];\n  }\n  processQueue() {\n    const q = this.Q;\n    this.Q = [];\n    const deps = new ExternalReferenceCollector();\n    for (const dep of q) {\n      collectReferencesOfReference(dep, this.initialScopeName, this.repo, deps);\n    }\n    for (const dep of deps.references) {\n      if (dep instanceof TopLevelRuleReference) {\n        if (this.seenFullScopeRequests.has(dep.scopeName)) {\n          continue;\n        }\n        this.seenFullScopeRequests.add(dep.scopeName);\n        this.Q.push(dep);\n      } else {\n        if (this.seenFullScopeRequests.has(dep.scopeName)) {\n          continue;\n        }\n        if (this.seenPartialScopeRequests.has(dep.toKey())) {\n          continue;\n        }\n        this.seenPartialScopeRequests.add(dep.toKey());\n        this.Q.push(dep);\n      }\n    }\n  }\n}\nfunction collectReferencesOfReference(reference, baseGrammarScopeName, repo, result) {\n  const selfGrammar = repo.lookup(reference.scopeName);\n  if (!selfGrammar) {\n    if (reference.scopeName === baseGrammarScopeName) {\n      throw new Error(`No grammar provided for <${baseGrammarScopeName}>`);\n    }\n    return;\n  }\n  const baseGrammar = repo.lookup(baseGrammarScopeName);\n  if (reference instanceof TopLevelRuleReference) {\n    collectExternalReferencesInTopLevelRule({ baseGrammar, selfGrammar }, result);\n  } else {\n    collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, { baseGrammar, selfGrammar, repository: selfGrammar.repository }, result);\n  }\n  const injections = repo.injections(reference.scopeName);\n  if (injections) {\n    for (const injection of injections) {\n      result.add(new TopLevelRuleReference(injection));\n    }\n  }\n}\nfunction collectExternalReferencesInTopLevelRepositoryRule(ruleName, context, result) {\n  if (context.repository && context.repository[ruleName]) {\n    const rule = context.repository[ruleName];\n    collectExternalReferencesInRules([rule], context, result);\n  }\n}\nfunction collectExternalReferencesInTopLevelRule(context, result) {\n  if (context.selfGrammar.patterns && Array.isArray(context.selfGrammar.patterns)) {\n    collectExternalReferencesInRules(context.selfGrammar.patterns, { ...context, repository: context.selfGrammar.repository }, result);\n  }\n  if (context.selfGrammar.injections) {\n    collectExternalReferencesInRules(Object.values(context.selfGrammar.injections), { ...context, repository: context.selfGrammar.repository }, result);\n  }\n}\nfunction collectExternalReferencesInRules(rules, context, result) {\n  for (const rule of rules) {\n    if (result.visitedRule.has(rule)) {\n      continue;\n    }\n    result.visitedRule.add(rule);\n    const patternRepository = rule.repository ? mergeObjects({}, context.repository, rule.repository) : context.repository;\n    if (Array.isArray(rule.patterns)) {\n      collectExternalReferencesInRules(rule.patterns, { ...context, repository: patternRepository }, result);\n    }\n    const include = rule.include;\n    if (!include) {\n      continue;\n    }\n    const reference = parseInclude(include);\n    switch (reference.kind) {\n      case 0:\n        collectExternalReferencesInTopLevelRule({ ...context, selfGrammar: context.baseGrammar }, result);\n        break;\n      case 1:\n        collectExternalReferencesInTopLevelRule(context, result);\n        break;\n      case 2:\n        collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, { ...context, repository: patternRepository }, result);\n        break;\n      case 3:\n      case 4:\n        const selfGrammar = reference.scopeName === context.selfGrammar.scopeName ? context.selfGrammar : reference.scopeName === context.baseGrammar.scopeName ? context.baseGrammar : void 0;\n        if (selfGrammar) {\n          const newContext = { baseGrammar: context.baseGrammar, selfGrammar, repository: patternRepository };\n          if (reference.kind === 4) {\n            collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, newContext, result);\n          } else {\n            collectExternalReferencesInTopLevelRule(newContext, result);\n          }\n        } else {\n          if (reference.kind === 4) {\n            result.add(new TopLevelRepositoryRuleReference(reference.scopeName, reference.ruleName));\n          } else {\n            result.add(new TopLevelRuleReference(reference.scopeName));\n          }\n        }\n        break;\n    }\n  }\n}\nclass BaseReference {\n  kind = 0;\n}\nclass SelfReference {\n  kind = 1;\n}\nclass RelativeReference {\n  ruleName;\n  kind = 2;\n  constructor(ruleName) {\n    this.ruleName = ruleName;\n  }\n}\nclass TopLevelReference {\n  scopeName;\n  kind = 3;\n  constructor(scopeName) {\n    this.scopeName = scopeName;\n  }\n}\nclass TopLevelRepositoryReference {\n  scopeName;\n  ruleName;\n  kind = 4;\n  constructor(scopeName, ruleName) {\n    this.scopeName = scopeName;\n    this.ruleName = ruleName;\n  }\n}\nfunction parseInclude(include) {\n  if (include === \"$base\") {\n    return new BaseReference();\n  } else if (include === \"$self\") {\n    return new SelfReference();\n  }\n  const indexOfSharp = include.indexOf(\"#\");\n  if (indexOfSharp === -1) {\n    return new TopLevelReference(include);\n  } else if (indexOfSharp === 0) {\n    return new RelativeReference(include.substring(1));\n  } else {\n    const scopeName = include.substring(0, indexOfSharp);\n    const ruleName = include.substring(indexOfSharp + 1);\n    return new TopLevelRepositoryReference(scopeName, ruleName);\n  }\n}\nconst HAS_BACK_REFERENCES = /\\\\(\\d+)/;\nconst BACK_REFERENCING_END = /\\\\(\\d+)/g;\nconst endRuleId = -1;\nconst whileRuleId = -2;\nfunction ruleIdFromNumber(id) {\n  return id;\n}\nfunction ruleIdToNumber(id) {\n  return id;\n}\nclass Rule {\n  $location;\n  id;\n  _nameIsCapturing;\n  _name;\n  _contentNameIsCapturing;\n  _contentName;\n  constructor($location, id, name, contentName) {\n    this.$location = $location;\n    this.id = id;\n    this._name = name || null;\n    this._nameIsCapturing = RegexSource.hasCaptures(this._name);\n    this._contentName = contentName || null;\n    this._contentNameIsCapturing = RegexSource.hasCaptures(this._contentName);\n  }\n  get debugName() {\n    const location = this.$location ? `${basename(this.$location.filename)}:${this.$location.line}` : \"unknown\";\n    return `${this.constructor.name}#${this.id} @ ${location}`;\n  }\n  getName(lineText, captureIndices) {\n    if (!this._nameIsCapturing || this._name === null || lineText === null || captureIndices === null) {\n      return this._name;\n    }\n    return RegexSource.replaceCaptures(this._name, lineText, captureIndices);\n  }\n  getContentName(lineText, captureIndices) {\n    if (!this._contentNameIsCapturing || this._contentName === null) {\n      return this._contentName;\n    }\n    return RegexSource.replaceCaptures(this._contentName, lineText, captureIndices);\n  }\n}\nclass CaptureRule extends Rule {\n  retokenizeCapturedWithRuleId;\n  constructor($location, id, name, contentName, retokenizeCapturedWithRuleId) {\n    super($location, id, name, contentName);\n    this.retokenizeCapturedWithRuleId = retokenizeCapturedWithRuleId;\n  }\n  dispose() {\n  }\n  collectPatterns(grammar, out) {\n    throw new Error(\"Not supported!\");\n  }\n  compile(grammar, endRegexSource) {\n    throw new Error(\"Not supported!\");\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    throw new Error(\"Not supported!\");\n  }\n}\nclass MatchRule extends Rule {\n  _match;\n  captures;\n  _cachedCompiledPatterns;\n  constructor($location, id, name, match, captures) {\n    super($location, id, name, null);\n    this._match = new RegExpSource(match, this.id);\n    this.captures = captures;\n    this._cachedCompiledPatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n  }\n  get debugMatchRegExp() {\n    return `${this._match.source}`;\n  }\n  collectPatterns(grammar, out) {\n    out.push(this._match);\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      this.collectPatterns(grammar, this._cachedCompiledPatterns);\n    }\n    return this._cachedCompiledPatterns;\n  }\n}\nclass IncludeOnlyRule extends Rule {\n  hasMissingPatterns;\n  patterns;\n  _cachedCompiledPatterns;\n  constructor($location, id, name, contentName, patterns) {\n    super($location, id, name, contentName);\n    this.patterns = patterns.patterns;\n    this.hasMissingPatterns = patterns.hasMissingPatterns;\n    this._cachedCompiledPatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n  }\n  collectPatterns(grammar, out) {\n    for (const pattern of this.patterns) {\n      const rule = grammar.getRule(pattern);\n      rule.collectPatterns(grammar, out);\n    }\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      this.collectPatterns(grammar, this._cachedCompiledPatterns);\n    }\n    return this._cachedCompiledPatterns;\n  }\n}\nclass BeginEndRule extends Rule {\n  _begin;\n  beginCaptures;\n  _end;\n  endHasBackReferences;\n  endCaptures;\n  applyEndPatternLast;\n  hasMissingPatterns;\n  patterns;\n  _cachedCompiledPatterns;\n  constructor($location, id, name, contentName, begin, beginCaptures, end, endCaptures, applyEndPatternLast, patterns) {\n    super($location, id, name, contentName);\n    this._begin = new RegExpSource(begin, this.id);\n    this.beginCaptures = beginCaptures;\n    this._end = new RegExpSource(end ? end : \"￿\", -1);\n    this.endHasBackReferences = this._end.hasBackReferences;\n    this.endCaptures = endCaptures;\n    this.applyEndPatternLast = applyEndPatternLast || false;\n    this.patterns = patterns.patterns;\n    this.hasMissingPatterns = patterns.hasMissingPatterns;\n    this._cachedCompiledPatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n  }\n  get debugBeginRegExp() {\n    return `${this._begin.source}`;\n  }\n  get debugEndRegExp() {\n    return `${this._end.source}`;\n  }\n  getEndWithResolvedBackReferences(lineText, captureIndices) {\n    return this._end.resolveBackReferences(lineText, captureIndices);\n  }\n  collectPatterns(grammar, out) {\n    out.push(this._begin);\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar, endRegexSource).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar, endRegexSource) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      for (const pattern of this.patterns) {\n        const rule = grammar.getRule(pattern);\n        rule.collectPatterns(grammar, this._cachedCompiledPatterns);\n      }\n      if (this.applyEndPatternLast) {\n        this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end);\n      } else {\n        this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);\n      }\n    }\n    if (this._end.hasBackReferences) {\n      if (this.applyEndPatternLast) {\n        this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, endRegexSource);\n      } else {\n        this._cachedCompiledPatterns.setSource(0, endRegexSource);\n      }\n    }\n    return this._cachedCompiledPatterns;\n  }\n}\nclass BeginWhileRule extends Rule {\n  _begin;\n  beginCaptures;\n  whileCaptures;\n  _while;\n  whileHasBackReferences;\n  hasMissingPatterns;\n  patterns;\n  _cachedCompiledPatterns;\n  _cachedCompiledWhilePatterns;\n  constructor($location, id, name, contentName, begin, beginCaptures, _while, whileCaptures, patterns) {\n    super($location, id, name, contentName);\n    this._begin = new RegExpSource(begin, this.id);\n    this.beginCaptures = beginCaptures;\n    this.whileCaptures = whileCaptures;\n    this._while = new RegExpSource(_while, whileRuleId);\n    this.whileHasBackReferences = this._while.hasBackReferences;\n    this.patterns = patterns.patterns;\n    this.hasMissingPatterns = patterns.hasMissingPatterns;\n    this._cachedCompiledPatterns = null;\n    this._cachedCompiledWhilePatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n    if (this._cachedCompiledWhilePatterns) {\n      this._cachedCompiledWhilePatterns.dispose();\n      this._cachedCompiledWhilePatterns = null;\n    }\n  }\n  get debugBeginRegExp() {\n    return `${this._begin.source}`;\n  }\n  get debugWhileRegExp() {\n    return `${this._while.source}`;\n  }\n  getWhileWithResolvedBackReferences(lineText, captureIndices) {\n    return this._while.resolveBackReferences(lineText, captureIndices);\n  }\n  collectPatterns(grammar, out) {\n    out.push(this._begin);\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      for (const pattern of this.patterns) {\n        const rule = grammar.getRule(pattern);\n        rule.collectPatterns(grammar, this._cachedCompiledPatterns);\n      }\n    }\n    return this._cachedCompiledPatterns;\n  }\n  compileWhile(grammar, endRegexSource) {\n    return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compile(grammar);\n  }\n  compileWhileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledWhilePatterns(grammar, endRegexSource) {\n    if (!this._cachedCompiledWhilePatterns) {\n      this._cachedCompiledWhilePatterns = new RegExpSourceList();\n      this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while);\n    }\n    if (this._while.hasBackReferences) {\n      this._cachedCompiledWhilePatterns.setSource(0, endRegexSource ? endRegexSource : \"￿\");\n    }\n    return this._cachedCompiledWhilePatterns;\n  }\n}\nclass RuleFactory {\n  static createCaptureRule(helper, $location, name, contentName, retokenizeCapturedWithRuleId) {\n    return helper.registerRule((id) => {\n      return new CaptureRule($location, id, name, contentName, retokenizeCapturedWithRuleId);\n    });\n  }\n  static getCompiledRuleId(desc, helper, repository) {\n    if (!desc.id) {\n      helper.registerRule((id) => {\n        desc.id = id;\n        if (desc.match) {\n          return new MatchRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.match, RuleFactory._compileCaptures(desc.captures, helper, repository));\n        }\n        if (typeof desc.begin === \"undefined\") {\n          if (desc.repository) {\n            repository = mergeObjects({}, repository, desc.repository);\n          }\n          let patterns = desc.patterns;\n          if (typeof patterns === \"undefined\" && desc.include) {\n            patterns = [{ include: desc.include }];\n          }\n          return new IncludeOnlyRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, RuleFactory._compilePatterns(patterns, helper, repository));\n        }\n        if (desc.while) {\n          return new BeginWhileRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, desc.begin, RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository), desc.while, RuleFactory._compileCaptures(desc.whileCaptures || desc.captures, helper, repository), RuleFactory._compilePatterns(desc.patterns, helper, repository));\n        }\n        return new BeginEndRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, desc.begin, RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository), desc.end, RuleFactory._compileCaptures(desc.endCaptures || desc.captures, helper, repository), desc.applyEndPatternLast, RuleFactory._compilePatterns(desc.patterns, helper, repository));\n      });\n    }\n    return desc.id;\n  }\n  static _compileCaptures(captures, helper, repository) {\n    let r = [];\n    if (captures) {\n      let maximumCaptureId = 0;\n      for (const captureId in captures) {\n        if (captureId === \"$vscodeTextmateLocation\") {\n          continue;\n        }\n        const numericCaptureId = parseInt(captureId, 10);\n        if (numericCaptureId > maximumCaptureId) {\n          maximumCaptureId = numericCaptureId;\n        }\n      }\n      for (let i = 0; i <= maximumCaptureId; i++) {\n        r[i] = null;\n      }\n      for (const captureId in captures) {\n        if (captureId === \"$vscodeTextmateLocation\") {\n          continue;\n        }\n        const numericCaptureId = parseInt(captureId, 10);\n        let retokenizeCapturedWithRuleId = 0;\n        if (captures[captureId].patterns) {\n          retokenizeCapturedWithRuleId = RuleFactory.getCompiledRuleId(captures[captureId], helper, repository);\n        }\n        r[numericCaptureId] = RuleFactory.createCaptureRule(helper, captures[captureId].$vscodeTextmateLocation, captures[captureId].name, captures[captureId].contentName, retokenizeCapturedWithRuleId);\n      }\n    }\n    return r;\n  }\n  static _compilePatterns(patterns, helper, repository) {\n    let r = [];\n    if (patterns) {\n      for (let i = 0, len = patterns.length; i < len; i++) {\n        const pattern = patterns[i];\n        let ruleId = -1;\n        if (pattern.include) {\n          const reference = parseInclude(pattern.include);\n          switch (reference.kind) {\n            case 0:\n            case 1:\n              ruleId = RuleFactory.getCompiledRuleId(repository[pattern.include], helper, repository);\n              break;\n            case 2:\n              let localIncludedRule = repository[reference.ruleName];\n              if (localIncludedRule) {\n                ruleId = RuleFactory.getCompiledRuleId(localIncludedRule, helper, repository);\n              }\n              break;\n            case 3:\n            case 4:\n              const externalGrammarName = reference.scopeName;\n              const externalGrammarInclude = reference.kind === 4 ? reference.ruleName : null;\n              const externalGrammar = helper.getExternalGrammar(externalGrammarName, repository);\n              if (externalGrammar) {\n                if (externalGrammarInclude) {\n                  let externalIncludedRule = externalGrammar.repository[externalGrammarInclude];\n                  if (externalIncludedRule) {\n                    ruleId = RuleFactory.getCompiledRuleId(externalIncludedRule, helper, externalGrammar.repository);\n                  }\n                } else {\n                  ruleId = RuleFactory.getCompiledRuleId(externalGrammar.repository.$self, helper, externalGrammar.repository);\n                }\n              }\n              break;\n          }\n        } else {\n          ruleId = RuleFactory.getCompiledRuleId(pattern, helper, repository);\n        }\n        if (ruleId !== -1) {\n          const rule = helper.getRule(ruleId);\n          let skipRule = false;\n          if (rule instanceof IncludeOnlyRule || rule instanceof BeginEndRule || rule instanceof BeginWhileRule) {\n            if (rule.hasMissingPatterns && rule.patterns.length === 0) {\n              skipRule = true;\n            }\n          }\n          if (skipRule) {\n            continue;\n          }\n          r.push(ruleId);\n        }\n      }\n    }\n    return {\n      patterns: r,\n      hasMissingPatterns: (patterns ? patterns.length : 0) !== r.length\n    };\n  }\n}\nclass RegExpSource {\n  source;\n  ruleId;\n  hasAnchor;\n  hasBackReferences;\n  _anchorCache;\n  constructor(regExpSource, ruleId) {\n    if (regExpSource) {\n      const len = regExpSource.length;\n      let lastPushedPos = 0;\n      let output = [];\n      let hasAnchor = false;\n      for (let pos = 0; pos < len; pos++) {\n        const ch = regExpSource.charAt(pos);\n        if (ch === \"\\\\\") {\n          if (pos + 1 < len) {\n            const nextCh = regExpSource.charAt(pos + 1);\n            if (nextCh === \"z\") {\n              output.push(regExpSource.substring(lastPushedPos, pos));\n              output.push(\"$(?!\\\\n)(?<!\\\\n)\");\n              lastPushedPos = pos + 2;\n            } else if (nextCh === \"A\" || nextCh === \"G\") {\n              hasAnchor = true;\n            }\n            pos++;\n          }\n        }\n      }\n      this.hasAnchor = hasAnchor;\n      if (lastPushedPos === 0) {\n        this.source = regExpSource;\n      } else {\n        output.push(regExpSource.substring(lastPushedPos, len));\n        this.source = output.join(\"\");\n      }\n    } else {\n      this.hasAnchor = false;\n      this.source = regExpSource;\n    }\n    if (this.hasAnchor) {\n      this._anchorCache = this._buildAnchorCache();\n    } else {\n      this._anchorCache = null;\n    }\n    this.ruleId = ruleId;\n    this.hasBackReferences = HAS_BACK_REFERENCES.test(this.source);\n  }\n  clone() {\n    return new RegExpSource(this.source, this.ruleId);\n  }\n  setSource(newSource) {\n    if (this.source === newSource) {\n      return;\n    }\n    this.source = newSource;\n    if (this.hasAnchor) {\n      this._anchorCache = this._buildAnchorCache();\n    }\n  }\n  resolveBackReferences(lineText, captureIndices) {\n    let capturedValues = captureIndices.map((capture) => {\n      return lineText.substring(capture.start, capture.end);\n    });\n    BACK_REFERENCING_END.lastIndex = 0;\n    return this.source.replace(BACK_REFERENCING_END, (match, g1) => {\n      return escapeRegExpCharacters(capturedValues[parseInt(g1, 10)] || \"\");\n    });\n  }\n  _buildAnchorCache() {\n    let A0_G0_result = [];\n    let A0_G1_result = [];\n    let A1_G0_result = [];\n    let A1_G1_result = [];\n    let pos, len, ch, nextCh;\n    for (pos = 0, len = this.source.length; pos < len; pos++) {\n      ch = this.source.charAt(pos);\n      A0_G0_result[pos] = ch;\n      A0_G1_result[pos] = ch;\n      A1_G0_result[pos] = ch;\n      A1_G1_result[pos] = ch;\n      if (ch === \"\\\\\") {\n        if (pos + 1 < len) {\n          nextCh = this.source.charAt(pos + 1);\n          if (nextCh === \"A\") {\n            A0_G0_result[pos + 1] = \"￿\";\n            A0_G1_result[pos + 1] = \"￿\";\n            A1_G0_result[pos + 1] = \"A\";\n            A1_G1_result[pos + 1] = \"A\";\n          } else if (nextCh === \"G\") {\n            A0_G0_result[pos + 1] = \"￿\";\n            A0_G1_result[pos + 1] = \"G\";\n            A1_G0_result[pos + 1] = \"￿\";\n            A1_G1_result[pos + 1] = \"G\";\n          } else {\n            A0_G0_result[pos + 1] = nextCh;\n            A0_G1_result[pos + 1] = nextCh;\n            A1_G0_result[pos + 1] = nextCh;\n            A1_G1_result[pos + 1] = nextCh;\n          }\n          pos++;\n        }\n      }\n    }\n    return {\n      A0_G0: A0_G0_result.join(\"\"),\n      A0_G1: A0_G1_result.join(\"\"),\n      A1_G0: A1_G0_result.join(\"\"),\n      A1_G1: A1_G1_result.join(\"\")\n    };\n  }\n  resolveAnchors(allowA, allowG) {\n    if (!this.hasAnchor || !this._anchorCache) {\n      return this.source;\n    }\n    if (allowA) {\n      if (allowG) {\n        return this._anchorCache.A1_G1;\n      } else {\n        return this._anchorCache.A1_G0;\n      }\n    } else {\n      if (allowG) {\n        return this._anchorCache.A0_G1;\n      } else {\n        return this._anchorCache.A0_G0;\n      }\n    }\n  }\n}\nclass RegExpSourceList {\n  _items;\n  _hasAnchors;\n  _cached;\n  _anchorCache;\n  constructor() {\n    this._items = [];\n    this._hasAnchors = false;\n    this._cached = null;\n    this._anchorCache = {\n      A0_G0: null,\n      A0_G1: null,\n      A1_G0: null,\n      A1_G1: null\n    };\n  }\n  dispose() {\n    this._disposeCaches();\n  }\n  _disposeCaches() {\n    if (this._cached) {\n      this._cached.dispose();\n      this._cached = null;\n    }\n    if (this._anchorCache.A0_G0) {\n      this._anchorCache.A0_G0.dispose();\n      this._anchorCache.A0_G0 = null;\n    }\n    if (this._anchorCache.A0_G1) {\n      this._anchorCache.A0_G1.dispose();\n      this._anchorCache.A0_G1 = null;\n    }\n    if (this._anchorCache.A1_G0) {\n      this._anchorCache.A1_G0.dispose();\n      this._anchorCache.A1_G0 = null;\n    }\n    if (this._anchorCache.A1_G1) {\n      this._anchorCache.A1_G1.dispose();\n      this._anchorCache.A1_G1 = null;\n    }\n  }\n  push(item) {\n    this._items.push(item);\n    this._hasAnchors = this._hasAnchors || item.hasAnchor;\n  }\n  unshift(item) {\n    this._items.unshift(item);\n    this._hasAnchors = this._hasAnchors || item.hasAnchor;\n  }\n  length() {\n    return this._items.length;\n  }\n  setSource(index, newSource) {\n    if (this._items[index].source !== newSource) {\n      this._disposeCaches();\n      this._items[index].setSource(newSource);\n    }\n  }\n  compile(onigLib) {\n    if (!this._cached) {\n      let regExps = this._items.map((e) => e.source);\n      this._cached = new CompiledRule(onigLib, regExps, this._items.map((e) => e.ruleId));\n    }\n    return this._cached;\n  }\n  compileAG(onigLib, allowA, allowG) {\n    if (!this._hasAnchors) {\n      return this.compile(onigLib);\n    } else {\n      if (allowA) {\n        if (allowG) {\n          if (!this._anchorCache.A1_G1) {\n            this._anchorCache.A1_G1 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A1_G1;\n        } else {\n          if (!this._anchorCache.A1_G0) {\n            this._anchorCache.A1_G0 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A1_G0;\n        }\n      } else {\n        if (allowG) {\n          if (!this._anchorCache.A0_G1) {\n            this._anchorCache.A0_G1 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A0_G1;\n        } else {\n          if (!this._anchorCache.A0_G0) {\n            this._anchorCache.A0_G0 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A0_G0;\n        }\n      }\n    }\n  }\n  _resolveAnchors(onigLib, allowA, allowG) {\n    let regExps = this._items.map((e) => e.resolveAnchors(allowA, allowG));\n    return new CompiledRule(onigLib, regExps, this._items.map((e) => e.ruleId));\n  }\n}\nclass CompiledRule {\n  regExps;\n  rules;\n  scanner;\n  constructor(onigLib, regExps, rules) {\n    this.regExps = regExps;\n    this.rules = rules;\n    this.scanner = onigLib.createOnigScanner(regExps);\n  }\n  dispose() {\n    if (typeof this.scanner.dispose === \"function\") {\n      this.scanner.dispose();\n    }\n  }\n  toString() {\n    const r = [];\n    for (let i = 0, len = this.rules.length; i < len; i++) {\n      r.push(\"   - \" + this.rules[i] + \": \" + this.regExps[i]);\n    }\n    return r.join(\"\\n\");\n  }\n  findNextMatchSync(string, startPosition, options) {\n    const result = this.scanner.findNextMatchSync(string, startPosition, options);\n    if (!result) {\n      return null;\n    }\n    return {\n      ruleId: this.rules[result.index],\n      captureIndices: result.captureIndices\n    };\n  }\n}\nclass Theme {\n  _colorMap;\n  _defaults;\n  _root;\n  static createFromRawTheme(source, colorMap) {\n    return this.createFromParsedTheme(parseTheme(source), colorMap);\n  }\n  static createFromParsedTheme(source, colorMap) {\n    return resolveParsedThemeRules(source, colorMap);\n  }\n  _cachedMatchRoot = new CachedFn((scopeName) => this._root.match(scopeName));\n  constructor(_colorMap, _defaults, _root) {\n    this._colorMap = _colorMap;\n    this._defaults = _defaults;\n    this._root = _root;\n  }\n  getColorMap() {\n    return this._colorMap.getColorMap();\n  }\n  getDefaults() {\n    return this._defaults;\n  }\n  match(scopePath) {\n    if (scopePath === null) {\n      return this._defaults;\n    }\n    const scopeName = scopePath.scopeName;\n    const matchingTrieElements = this._cachedMatchRoot.get(scopeName);\n    const effectiveRule = matchingTrieElements.find((v) => _scopePathMatchesParentScopes(scopePath.parent, v.parentScopes));\n    if (!effectiveRule) {\n      return null;\n    }\n    return new StyleAttributes(effectiveRule.fontStyle, effectiveRule.foreground, effectiveRule.background);\n  }\n}\nclass ScopeStack {\n  parent;\n  scopeName;\n  static push(path, scopeNames) {\n    for (const name of scopeNames) {\n      path = new ScopeStack(path, name);\n    }\n    return path;\n  }\n  static from(...segments) {\n    let result = null;\n    for (let i = 0; i < segments.length; i++) {\n      result = new ScopeStack(result, segments[i]);\n    }\n    return result;\n  }\n  constructor(parent, scopeName) {\n    this.parent = parent;\n    this.scopeName = scopeName;\n  }\n  push(scopeName) {\n    return new ScopeStack(this, scopeName);\n  }\n  getSegments() {\n    let item = this;\n    const result = [];\n    while (item) {\n      result.push(item.scopeName);\n      item = item.parent;\n    }\n    result.reverse();\n    return result;\n  }\n  toString() {\n    return this.getSegments().join(\" \");\n  }\n  extends(other) {\n    if (this === other) {\n      return true;\n    }\n    if (this.parent === null) {\n      return false;\n    }\n    return this.parent.extends(other);\n  }\n  getExtensionIfDefined(base) {\n    const result = [];\n    let item = this;\n    while (item && item !== base) {\n      result.push(item.scopeName);\n      item = item.parent;\n    }\n    return item === base ? result.reverse() : void 0;\n  }\n}\nfunction _scopePathMatchesParentScopes(scopePath, parentScopes) {\n  if (parentScopes === null) {\n    return true;\n  }\n  let index = 0;\n  let scopePattern = parentScopes[index];\n  while (scopePath) {\n    if (_matchesScope(scopePath.scopeName, scopePattern)) {\n      index++;\n      if (index === parentScopes.length) {\n        return true;\n      }\n      scopePattern = parentScopes[index];\n    }\n    scopePath = scopePath.parent;\n  }\n  return false;\n}\nfunction _matchesScope(scopeName, scopePattern) {\n  return scopePattern === scopeName || scopeName.startsWith(scopePattern) && scopeName[scopePattern.length] === \".\";\n}\nclass StyleAttributes {\n  fontStyle;\n  foregroundId;\n  backgroundId;\n  constructor(fontStyle, foregroundId, backgroundId) {\n    this.fontStyle = fontStyle;\n    this.foregroundId = foregroundId;\n    this.backgroundId = backgroundId;\n  }\n}\nfunction parseTheme(source) {\n  if (!source) {\n    return [];\n  }\n  if (!source.settings || !Array.isArray(source.settings)) {\n    return [];\n  }\n  let settings = source.settings;\n  let result = [], resultLen = 0;\n  for (let i = 0, len = settings.length; i < len; i++) {\n    let entry = settings[i];\n    if (!entry.settings) {\n      continue;\n    }\n    let scopes;\n    if (typeof entry.scope === \"string\") {\n      let _scope = entry.scope;\n      _scope = _scope.replace(/^[,]+/, \"\");\n      _scope = _scope.replace(/[,]+$/, \"\");\n      scopes = _scope.split(\",\");\n    } else if (Array.isArray(entry.scope)) {\n      scopes = entry.scope;\n    } else {\n      scopes = [\"\"];\n    }\n    let fontStyle = -1;\n    if (typeof entry.settings.fontStyle === \"string\") {\n      fontStyle = 0;\n      let segments = entry.settings.fontStyle.split(\" \");\n      for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n        let segment = segments[j];\n        switch (segment) {\n          case \"italic\":\n            fontStyle = fontStyle | 1;\n            break;\n          case \"bold\":\n            fontStyle = fontStyle | 2;\n            break;\n          case \"underline\":\n            fontStyle = fontStyle | 4;\n            break;\n          case \"strikethrough\":\n            fontStyle = fontStyle | 8;\n            break;\n        }\n      }\n    }\n    let foreground = null;\n    if (typeof entry.settings.foreground === \"string\" && isValidHexColor(entry.settings.foreground)) {\n      foreground = entry.settings.foreground;\n    }\n    let background = null;\n    if (typeof entry.settings.background === \"string\" && isValidHexColor(entry.settings.background)) {\n      background = entry.settings.background;\n    }\n    for (let j = 0, lenJ = scopes.length; j < lenJ; j++) {\n      let _scope = scopes[j].trim();\n      let segments = _scope.split(\" \");\n      let scope = segments[segments.length - 1];\n      let parentScopes = null;\n      if (segments.length > 1) {\n        parentScopes = segments.slice(0, segments.length - 1);\n        parentScopes.reverse();\n      }\n      result[resultLen++] = new ParsedThemeRule(scope, parentScopes, i, fontStyle, foreground, background);\n    }\n  }\n  return result;\n}\nclass ParsedThemeRule {\n  scope;\n  parentScopes;\n  index;\n  fontStyle;\n  foreground;\n  background;\n  constructor(scope, parentScopes, index, fontStyle, foreground, background) {\n    this.scope = scope;\n    this.parentScopes = parentScopes;\n    this.index = index;\n    this.fontStyle = fontStyle;\n    this.foreground = foreground;\n    this.background = background;\n  }\n}\nfunction resolveParsedThemeRules(parsedThemeRules, _colorMap) {\n  parsedThemeRules.sort((a, b) => {\n    let r = strcmp(a.scope, b.scope);\n    if (r !== 0) {\n      return r;\n    }\n    r = strArrCmp(a.parentScopes, b.parentScopes);\n    if (r !== 0) {\n      return r;\n    }\n    return a.index - b.index;\n  });\n  let defaultFontStyle = 0;\n  let defaultForeground = \"#000000\";\n  let defaultBackground = \"#ffffff\";\n  while (parsedThemeRules.length >= 1 && parsedThemeRules[0].scope === \"\") {\n    let incomingDefaults = parsedThemeRules.shift();\n    if (incomingDefaults.fontStyle !== -1) {\n      defaultFontStyle = incomingDefaults.fontStyle;\n    }\n    if (incomingDefaults.foreground !== null) {\n      defaultForeground = incomingDefaults.foreground;\n    }\n    if (incomingDefaults.background !== null) {\n      defaultBackground = incomingDefaults.background;\n    }\n  }\n  let colorMap = new ColorMap(_colorMap);\n  let defaults = new StyleAttributes(defaultFontStyle, colorMap.getId(defaultForeground), colorMap.getId(defaultBackground));\n  let root = new ThemeTrieElement(new ThemeTrieElementRule(0, null, -1, 0, 0), []);\n  for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n    let rule = parsedThemeRules[i];\n    root.insert(0, rule.scope, rule.parentScopes, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n  }\n  return new Theme(colorMap, defaults, root);\n}\nclass ColorMap {\n  _isFrozen;\n  _lastColorId;\n  _id2color;\n  _color2id;\n  constructor(_colorMap) {\n    this._lastColorId = 0;\n    this._id2color = [];\n    this._color2id = /* @__PURE__ */ Object.create(null);\n    if (Array.isArray(_colorMap)) {\n      this._isFrozen = true;\n      for (let i = 0, len = _colorMap.length; i < len; i++) {\n        this._color2id[_colorMap[i]] = i;\n        this._id2color[i] = _colorMap[i];\n      }\n    } else {\n      this._isFrozen = false;\n    }\n  }\n  getId(color) {\n    if (color === null) {\n      return 0;\n    }\n    color = color.toUpperCase();\n    let value = this._color2id[color];\n    if (value) {\n      return value;\n    }\n    if (this._isFrozen) {\n      throw new Error(`Missing color in color map - ${color}`);\n    }\n    value = ++this._lastColorId;\n    this._color2id[color] = value;\n    this._id2color[value] = color;\n    return value;\n  }\n  getColorMap() {\n    return this._id2color.slice(0);\n  }\n}\nclass ThemeTrieElementRule {\n  scopeDepth;\n  parentScopes;\n  fontStyle;\n  foreground;\n  background;\n  constructor(scopeDepth, parentScopes, fontStyle, foreground, background) {\n    this.scopeDepth = scopeDepth;\n    this.parentScopes = parentScopes;\n    this.fontStyle = fontStyle;\n    this.foreground = foreground;\n    this.background = background;\n  }\n  clone() {\n    return new ThemeTrieElementRule(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);\n  }\n  static cloneArr(arr) {\n    let r = [];\n    for (let i = 0, len = arr.length; i < len; i++) {\n      r[i] = arr[i].clone();\n    }\n    return r;\n  }\n  acceptOverwrite(scopeDepth, fontStyle, foreground, background) {\n    if (this.scopeDepth > scopeDepth) {\n      console.log(\"how did this happen?\");\n    } else {\n      this.scopeDepth = scopeDepth;\n    }\n    if (fontStyle !== -1) {\n      this.fontStyle = fontStyle;\n    }\n    if (foreground !== 0) {\n      this.foreground = foreground;\n    }\n    if (background !== 0) {\n      this.background = background;\n    }\n  }\n}\nclass ThemeTrieElement {\n  _mainRule;\n  _children;\n  _rulesWithParentScopes;\n  constructor(_mainRule, rulesWithParentScopes = [], _children = {}) {\n    this._mainRule = _mainRule;\n    this._children = _children;\n    this._rulesWithParentScopes = rulesWithParentScopes;\n  }\n  static _sortBySpecificity(arr) {\n    if (arr.length === 1) {\n      return arr;\n    }\n    arr.sort(this._cmpBySpecificity);\n    return arr;\n  }\n  static _cmpBySpecificity(a, b) {\n    if (a.scopeDepth === b.scopeDepth) {\n      const aParentScopes = a.parentScopes;\n      const bParentScopes = b.parentScopes;\n      let aParentScopesLen = aParentScopes === null ? 0 : aParentScopes.length;\n      let bParentScopesLen = bParentScopes === null ? 0 : bParentScopes.length;\n      if (aParentScopesLen === bParentScopesLen) {\n        for (let i = 0; i < aParentScopesLen; i++) {\n          const aLen = aParentScopes[i].length;\n          const bLen = bParentScopes[i].length;\n          if (aLen !== bLen) {\n            return bLen - aLen;\n          }\n        }\n      }\n      return bParentScopesLen - aParentScopesLen;\n    }\n    return b.scopeDepth - a.scopeDepth;\n  }\n  match(scope) {\n    if (scope === \"\") {\n      return ThemeTrieElement._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));\n    }\n    let dotIndex = scope.indexOf(\".\");\n    let head;\n    let tail;\n    if (dotIndex === -1) {\n      head = scope;\n      tail = \"\";\n    } else {\n      head = scope.substring(0, dotIndex);\n      tail = scope.substring(dotIndex + 1);\n    }\n    if (this._children.hasOwnProperty(head)) {\n      return this._children[head].match(tail);\n    }\n    return ThemeTrieElement._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));\n  }\n  insert(scopeDepth, scope, parentScopes, fontStyle, foreground, background) {\n    if (scope === \"\") {\n      this._doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background);\n      return;\n    }\n    let dotIndex = scope.indexOf(\".\");\n    let head;\n    let tail;\n    if (dotIndex === -1) {\n      head = scope;\n      tail = \"\";\n    } else {\n      head = scope.substring(0, dotIndex);\n      tail = scope.substring(dotIndex + 1);\n    }\n    let child;\n    if (this._children.hasOwnProperty(head)) {\n      child = this._children[head];\n    } else {\n      child = new ThemeTrieElement(this._mainRule.clone(), ThemeTrieElementRule.cloneArr(this._rulesWithParentScopes));\n      this._children[head] = child;\n    }\n    child.insert(scopeDepth + 1, tail, parentScopes, fontStyle, foreground, background);\n  }\n  _doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background) {\n    if (parentScopes === null) {\n      this._mainRule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);\n      return;\n    }\n    for (let i = 0, len = this._rulesWithParentScopes.length; i < len; i++) {\n      let rule = this._rulesWithParentScopes[i];\n      if (strArrCmp(rule.parentScopes, parentScopes) === 0) {\n        rule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);\n        return;\n      }\n    }\n    if (fontStyle === -1) {\n      fontStyle = this._mainRule.fontStyle;\n    }\n    if (foreground === 0) {\n      foreground = this._mainRule.foreground;\n    }\n    if (background === 0) {\n      background = this._mainRule.background;\n    }\n    this._rulesWithParentScopes.push(new ThemeTrieElementRule(scopeDepth, parentScopes, fontStyle, foreground, background));\n  }\n}\nclass BasicScopeAttributes {\n  languageId;\n  tokenType;\n  constructor(languageId, tokenType) {\n    this.languageId = languageId;\n    this.tokenType = tokenType;\n  }\n}\nclass BasicScopeAttributesProvider {\n  _defaultAttributes;\n  _embeddedLanguagesMatcher;\n  constructor(initialLanguageId, embeddedLanguages) {\n    this._defaultAttributes = new BasicScopeAttributes(\n      initialLanguageId,\n      8\n      /* OptionalStandardTokenType.NotSet */\n    );\n    this._embeddedLanguagesMatcher = new ScopeMatcher(Object.entries(embeddedLanguages || {}));\n  }\n  getDefaultAttributes() {\n    return this._defaultAttributes;\n  }\n  getBasicScopeAttributes(scopeName) {\n    if (scopeName === null) {\n      return BasicScopeAttributesProvider._NULL_SCOPE_METADATA;\n    }\n    return this._getBasicScopeAttributes.get(scopeName);\n  }\n  static _NULL_SCOPE_METADATA = new BasicScopeAttributes(0, 0);\n  _getBasicScopeAttributes = new CachedFn((scopeName) => {\n    const languageId = this._scopeToLanguage(scopeName);\n    const standardTokenType = this._toStandardTokenType(scopeName);\n    return new BasicScopeAttributes(languageId, standardTokenType);\n  });\n  /**\n   * Given a produced TM scope, return the language that token describes or null if unknown.\n   * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null\n   */\n  _scopeToLanguage(scope) {\n    return this._embeddedLanguagesMatcher.match(scope) || 0;\n  }\n  _toStandardTokenType(scopeName) {\n    const m = scopeName.match(BasicScopeAttributesProvider.STANDARD_TOKEN_TYPE_REGEXP);\n    if (!m) {\n      return 8;\n    }\n    switch (m[1]) {\n      case \"comment\":\n        return 1;\n      case \"string\":\n        return 2;\n      case \"regex\":\n        return 3;\n      case \"meta.embedded\":\n        return 0;\n    }\n    throw new Error(\"Unexpected match for standard token type!\");\n  }\n  static STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|meta\\.embedded)\\b/;\n}\nclass ScopeMatcher {\n  values;\n  scopesRegExp;\n  constructor(values) {\n    if (values.length === 0) {\n      this.values = null;\n      this.scopesRegExp = null;\n    } else {\n      this.values = new Map(values);\n      const escapedScopes = values.map(([scopeName, value]) => escapeRegExpCharacters(scopeName));\n      escapedScopes.sort();\n      escapedScopes.reverse();\n      this.scopesRegExp = new RegExp(`^((${escapedScopes.join(\")|(\")}))($|\\\\.)`, \"\");\n    }\n  }\n  match(scope) {\n    if (!this.scopesRegExp) {\n      return void 0;\n    }\n    const m = scope.match(this.scopesRegExp);\n    if (!m) {\n      return void 0;\n    }\n    return this.values.get(m[1]);\n  }\n}\nclass TokenizeStringResult {\n  stack;\n  stoppedEarly;\n  constructor(stack, stoppedEarly) {\n    this.stack = stack;\n    this.stoppedEarly = stoppedEarly;\n  }\n}\nfunction _tokenizeString(grammar, lineText, isFirstLine, linePos, stack, lineTokens, checkWhileConditions, timeLimit) {\n  const lineLength = lineText.content.length;\n  let STOP = false;\n  let anchorPosition = -1;\n  if (checkWhileConditions) {\n    const whileCheckResult = _checkWhileConditions(grammar, lineText, isFirstLine, linePos, stack, lineTokens);\n    stack = whileCheckResult.stack;\n    linePos = whileCheckResult.linePos;\n    isFirstLine = whileCheckResult.isFirstLine;\n    anchorPosition = whileCheckResult.anchorPosition;\n  }\n  const startTime = Date.now();\n  while (!STOP) {\n    if (timeLimit !== 0) {\n      const elapsedTime = Date.now() - startTime;\n      if (elapsedTime > timeLimit) {\n        return new TokenizeStringResult(stack, true);\n      }\n    }\n    scanNext();\n  }\n  return new TokenizeStringResult(stack, false);\n  function scanNext() {\n    const r = matchRuleOrInjections(grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n    if (!r) {\n      lineTokens.produce(stack, lineLength);\n      STOP = true;\n      return;\n    }\n    const captureIndices = r.captureIndices;\n    const matchedRuleId = r.matchedRuleId;\n    const hasAdvanced = captureIndices && captureIndices.length > 0 ? captureIndices[0].end > linePos : false;\n    if (matchedRuleId === endRuleId) {\n      const poppedRule = stack.getRule(grammar);\n      lineTokens.produce(stack, captureIndices[0].start);\n      stack = stack.withContentNameScopesList(stack.nameScopesList);\n      handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, poppedRule.endCaptures, captureIndices);\n      lineTokens.produce(stack, captureIndices[0].end);\n      const popped = stack;\n      stack = stack.parent;\n      anchorPosition = popped.getAnchorPos();\n      if (!hasAdvanced && popped.getEnterPos() === linePos) {\n        stack = popped;\n        lineTokens.produce(stack, lineLength);\n        STOP = true;\n        return;\n      }\n    } else {\n      const _rule = grammar.getRule(matchedRuleId);\n      lineTokens.produce(stack, captureIndices[0].start);\n      const beforePush = stack;\n      const scopeName = _rule.getName(lineText.content, captureIndices);\n      const nameScopesList = stack.contentNameScopesList.pushAttributed(scopeName, grammar);\n      stack = stack.push(matchedRuleId, linePos, anchorPosition, captureIndices[0].end === lineLength, null, nameScopesList, nameScopesList);\n      if (_rule instanceof BeginEndRule) {\n        const pushedRule = _rule;\n        handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, pushedRule.beginCaptures, captureIndices);\n        lineTokens.produce(stack, captureIndices[0].end);\n        anchorPosition = captureIndices[0].end;\n        const contentName = pushedRule.getContentName(lineText.content, captureIndices);\n        const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);\n        stack = stack.withContentNameScopesList(contentNameScopesList);\n        if (pushedRule.endHasBackReferences) {\n          stack = stack.withEndRule(pushedRule.getEndWithResolvedBackReferences(lineText.content, captureIndices));\n        }\n        if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {\n          stack = stack.pop();\n          lineTokens.produce(stack, lineLength);\n          STOP = true;\n          return;\n        }\n      } else if (_rule instanceof BeginWhileRule) {\n        const pushedRule = _rule;\n        handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, pushedRule.beginCaptures, captureIndices);\n        lineTokens.produce(stack, captureIndices[0].end);\n        anchorPosition = captureIndices[0].end;\n        const contentName = pushedRule.getContentName(lineText.content, captureIndices);\n        const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);\n        stack = stack.withContentNameScopesList(contentNameScopesList);\n        if (pushedRule.whileHasBackReferences) {\n          stack = stack.withEndRule(pushedRule.getWhileWithResolvedBackReferences(lineText.content, captureIndices));\n        }\n        if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {\n          stack = stack.pop();\n          lineTokens.produce(stack, lineLength);\n          STOP = true;\n          return;\n        }\n      } else {\n        const matchingRule = _rule;\n        handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, matchingRule.captures, captureIndices);\n        lineTokens.produce(stack, captureIndices[0].end);\n        stack = stack.pop();\n        if (!hasAdvanced) {\n          stack = stack.safePop();\n          lineTokens.produce(stack, lineLength);\n          STOP = true;\n          return;\n        }\n      }\n    }\n    if (captureIndices[0].end > linePos) {\n      linePos = captureIndices[0].end;\n      isFirstLine = false;\n    }\n  }\n}\nfunction _checkWhileConditions(grammar, lineText, isFirstLine, linePos, stack, lineTokens) {\n  let anchorPosition = stack.beginRuleCapturedEOL ? 0 : -1;\n  const whileRules = [];\n  for (let node = stack; node; node = node.pop()) {\n    const nodeRule = node.getRule(grammar);\n    if (nodeRule instanceof BeginWhileRule) {\n      whileRules.push({\n        rule: nodeRule,\n        stack: node\n      });\n    }\n  }\n  for (let whileRule = whileRules.pop(); whileRule; whileRule = whileRules.pop()) {\n    const { ruleScanner, findOptions } = prepareRuleWhileSearch(whileRule.rule, grammar, whileRule.stack.endRule, isFirstLine, linePos === anchorPosition);\n    const r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n    if (r) {\n      const matchedRuleId = r.ruleId;\n      if (matchedRuleId !== whileRuleId) {\n        stack = whileRule.stack.pop();\n        break;\n      }\n      if (r.captureIndices && r.captureIndices.length) {\n        lineTokens.produce(whileRule.stack, r.captureIndices[0].start);\n        handleCaptures(grammar, lineText, isFirstLine, whileRule.stack, lineTokens, whileRule.rule.whileCaptures, r.captureIndices);\n        lineTokens.produce(whileRule.stack, r.captureIndices[0].end);\n        anchorPosition = r.captureIndices[0].end;\n        if (r.captureIndices[0].end > linePos) {\n          linePos = r.captureIndices[0].end;\n          isFirstLine = false;\n        }\n      }\n    } else {\n      stack = whileRule.stack.pop();\n      break;\n    }\n  }\n  return { stack, linePos, anchorPosition, isFirstLine };\n}\nfunction matchRuleOrInjections(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n  const matchResult = matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n  const injections = grammar.getInjections();\n  if (injections.length === 0) {\n    return matchResult;\n  }\n  const injectionResult = matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n  if (!injectionResult) {\n    return matchResult;\n  }\n  if (!matchResult) {\n    return injectionResult;\n  }\n  const matchResultScore = matchResult.captureIndices[0].start;\n  const injectionResultScore = injectionResult.captureIndices[0].start;\n  if (injectionResultScore < matchResultScore || injectionResult.priorityMatch && injectionResultScore === matchResultScore) {\n    return injectionResult;\n  }\n  return matchResult;\n}\nfunction matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n  const rule = stack.getRule(grammar);\n  const { ruleScanner, findOptions } = prepareRuleSearch(rule, grammar, stack.endRule, isFirstLine, linePos === anchorPosition);\n  const r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n  if (r) {\n    return {\n      captureIndices: r.captureIndices,\n      matchedRuleId: r.ruleId\n    };\n  }\n  return null;\n}\nfunction matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n  let bestMatchRating = Number.MAX_VALUE;\n  let bestMatchCaptureIndices = null;\n  let bestMatchRuleId;\n  let bestMatchResultPriority = 0;\n  const scopes = stack.contentNameScopesList.getScopeNames();\n  for (let i = 0, len = injections.length; i < len; i++) {\n    const injection = injections[i];\n    if (!injection.matcher(scopes)) {\n      continue;\n    }\n    const rule = grammar.getRule(injection.ruleId);\n    const { ruleScanner, findOptions } = prepareRuleSearch(rule, grammar, null, isFirstLine, linePos === anchorPosition);\n    const matchResult = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n    if (!matchResult) {\n      continue;\n    }\n    const matchRating = matchResult.captureIndices[0].start;\n    if (matchRating >= bestMatchRating) {\n      continue;\n    }\n    bestMatchRating = matchRating;\n    bestMatchCaptureIndices = matchResult.captureIndices;\n    bestMatchRuleId = matchResult.ruleId;\n    bestMatchResultPriority = injection.priority;\n    if (bestMatchRating === linePos) {\n      break;\n    }\n  }\n  if (bestMatchCaptureIndices) {\n    return {\n      priorityMatch: bestMatchResultPriority === -1,\n      captureIndices: bestMatchCaptureIndices,\n      matchedRuleId: bestMatchRuleId\n    };\n  }\n  return null;\n}\nfunction prepareRuleSearch(rule, grammar, endRegexSource, allowA, allowG) {\n  const ruleScanner = rule.compileAG(grammar, endRegexSource, allowA, allowG);\n  return {\n    ruleScanner,\n    findOptions: 0\n    /* FindOption.None */\n  };\n}\nfunction prepareRuleWhileSearch(rule, grammar, endRegexSource, allowA, allowG) {\n  const ruleScanner = rule.compileWhileAG(grammar, endRegexSource, allowA, allowG);\n  return {\n    ruleScanner,\n    findOptions: 0\n    /* FindOption.None */\n  };\n}\nfunction handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, captures, captureIndices) {\n  if (captures.length === 0) {\n    return;\n  }\n  const lineTextContent = lineText.content;\n  const len = Math.min(captures.length, captureIndices.length);\n  const localStack = [];\n  const maxEnd = captureIndices[0].end;\n  for (let i = 0; i < len; i++) {\n    const captureRule = captures[i];\n    if (captureRule === null) {\n      continue;\n    }\n    const captureIndex = captureIndices[i];\n    if (captureIndex.length === 0) {\n      continue;\n    }\n    if (captureIndex.start > maxEnd) {\n      break;\n    }\n    while (localStack.length > 0 && localStack[localStack.length - 1].endPos <= captureIndex.start) {\n      lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);\n      localStack.pop();\n    }\n    if (localStack.length > 0) {\n      lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, captureIndex.start);\n    } else {\n      lineTokens.produce(stack, captureIndex.start);\n    }\n    if (captureRule.retokenizeCapturedWithRuleId) {\n      const scopeName = captureRule.getName(lineTextContent, captureIndices);\n      const nameScopesList = stack.contentNameScopesList.pushAttributed(scopeName, grammar);\n      const contentName = captureRule.getContentName(lineTextContent, captureIndices);\n      const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);\n      const stackClone = stack.push(captureRule.retokenizeCapturedWithRuleId, captureIndex.start, -1, false, null, nameScopesList, contentNameScopesList);\n      const onigSubStr = grammar.createOnigString(lineTextContent.substring(0, captureIndex.end));\n      _tokenizeString(\n        grammar,\n        onigSubStr,\n        isFirstLine && captureIndex.start === 0,\n        captureIndex.start,\n        stackClone,\n        lineTokens,\n        false,\n        /* no time limit */\n        0\n      );\n      disposeOnigString(onigSubStr);\n      continue;\n    }\n    const captureRuleScopeName = captureRule.getName(lineTextContent, captureIndices);\n    if (captureRuleScopeName !== null) {\n      const base = localStack.length > 0 ? localStack[localStack.length - 1].scopes : stack.contentNameScopesList;\n      const captureRuleScopesList = base.pushAttributed(captureRuleScopeName, grammar);\n      localStack.push(new LocalStackElement(captureRuleScopesList, captureIndex.end));\n    }\n  }\n  while (localStack.length > 0) {\n    lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);\n    localStack.pop();\n  }\n}\nclass LocalStackElement {\n  scopes;\n  endPos;\n  constructor(scopes, endPos) {\n    this.scopes = scopes;\n    this.endPos = endPos;\n  }\n}\nfunction createGrammar(scopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, onigLib) {\n  return new Grammar(scopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, onigLib);\n}\nfunction collectInjections(result, selector, rule, ruleFactoryHelper, grammar) {\n  const matchers = createMatchers(selector, nameMatcher);\n  const ruleId = RuleFactory.getCompiledRuleId(rule, ruleFactoryHelper, grammar.repository);\n  for (const matcher of matchers) {\n    result.push({\n      debugSelector: selector,\n      matcher: matcher.matcher,\n      ruleId,\n      grammar,\n      priority: matcher.priority\n    });\n  }\n}\nfunction nameMatcher(identifers, scopes) {\n  if (scopes.length < identifers.length) {\n    return false;\n  }\n  let lastIndex = 0;\n  return identifers.every((identifier) => {\n    for (let i = lastIndex; i < scopes.length; i++) {\n      if (scopesAreMatching(scopes[i], identifier)) {\n        lastIndex = i + 1;\n        return true;\n      }\n    }\n    return false;\n  });\n}\nfunction scopesAreMatching(thisScopeName, scopeName) {\n  if (!thisScopeName) {\n    return false;\n  }\n  if (thisScopeName === scopeName) {\n    return true;\n  }\n  const len = scopeName.length;\n  return thisScopeName.length > len && thisScopeName.substr(0, len) === scopeName && thisScopeName[len] === \".\";\n}\nclass Grammar {\n  _rootScopeName;\n  balancedBracketSelectors;\n  _onigLib;\n  _rootId;\n  _lastRuleId;\n  _ruleId2desc;\n  _includedGrammars;\n  _grammarRepository;\n  _grammar;\n  _injections;\n  _basicScopeAttributesProvider;\n  _tokenTypeMatchers;\n  get themeProvider() {\n    return this._grammarRepository;\n  }\n  constructor(_rootScopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, _onigLib) {\n    this._rootScopeName = _rootScopeName;\n    this.balancedBracketSelectors = balancedBracketSelectors;\n    this._onigLib = _onigLib;\n    this._basicScopeAttributesProvider = new BasicScopeAttributesProvider(initialLanguage, embeddedLanguages);\n    this._rootId = -1;\n    this._lastRuleId = 0;\n    this._ruleId2desc = [null];\n    this._includedGrammars = {};\n    this._grammarRepository = grammarRepository;\n    this._grammar = initGrammar(grammar, null);\n    this._injections = null;\n    this._tokenTypeMatchers = [];\n    if (tokenTypes) {\n      for (const selector of Object.keys(tokenTypes)) {\n        const matchers = createMatchers(selector, nameMatcher);\n        for (const matcher of matchers) {\n          this._tokenTypeMatchers.push({\n            matcher: matcher.matcher,\n            type: tokenTypes[selector]\n          });\n        }\n      }\n    }\n  }\n  dispose() {\n    for (const rule of this._ruleId2desc) {\n      if (rule) {\n        rule.dispose();\n      }\n    }\n  }\n  createOnigScanner(sources) {\n    return this._onigLib.createOnigScanner(sources);\n  }\n  createOnigString(sources) {\n    return this._onigLib.createOnigString(sources);\n  }\n  getMetadataForScope(scope) {\n    return this._basicScopeAttributesProvider.getBasicScopeAttributes(scope);\n  }\n  _collectInjections() {\n    const grammarRepository = {\n      lookup: (scopeName2) => {\n        if (scopeName2 === this._rootScopeName) {\n          return this._grammar;\n        }\n        return this.getExternalGrammar(scopeName2);\n      },\n      injections: (scopeName2) => {\n        return this._grammarRepository.injections(scopeName2);\n      }\n    };\n    const result = [];\n    const scopeName = this._rootScopeName;\n    const grammar = grammarRepository.lookup(scopeName);\n    if (grammar) {\n      const rawInjections = grammar.injections;\n      if (rawInjections) {\n        for (let expression in rawInjections) {\n          collectInjections(result, expression, rawInjections[expression], this, grammar);\n        }\n      }\n      const injectionScopeNames = this._grammarRepository.injections(scopeName);\n      if (injectionScopeNames) {\n        injectionScopeNames.forEach((injectionScopeName) => {\n          const injectionGrammar = this.getExternalGrammar(injectionScopeName);\n          if (injectionGrammar) {\n            const selector = injectionGrammar.injectionSelector;\n            if (selector) {\n              collectInjections(result, selector, injectionGrammar, this, injectionGrammar);\n            }\n          }\n        });\n      }\n    }\n    result.sort((i1, i2) => i1.priority - i2.priority);\n    return result;\n  }\n  getInjections() {\n    if (this._injections === null) {\n      this._injections = this._collectInjections();\n    }\n    return this._injections;\n  }\n  registerRule(factory) {\n    const id = ++this._lastRuleId;\n    const result = factory(ruleIdFromNumber(id));\n    this._ruleId2desc[id] = result;\n    return result;\n  }\n  getRule(ruleId) {\n    return this._ruleId2desc[ruleIdToNumber(ruleId)];\n  }\n  getExternalGrammar(scopeName, repository) {\n    if (this._includedGrammars[scopeName]) {\n      return this._includedGrammars[scopeName];\n    } else if (this._grammarRepository) {\n      const rawIncludedGrammar = this._grammarRepository.lookup(scopeName);\n      if (rawIncludedGrammar) {\n        this._includedGrammars[scopeName] = initGrammar(rawIncludedGrammar, repository && repository.$base);\n        return this._includedGrammars[scopeName];\n      }\n    }\n    return void 0;\n  }\n  tokenizeLine(lineText, prevState, timeLimit = 0) {\n    const r = this._tokenize(lineText, prevState, false, timeLimit);\n    return {\n      tokens: r.lineTokens.getResult(r.ruleStack, r.lineLength),\n      ruleStack: r.ruleStack,\n      stoppedEarly: r.stoppedEarly\n    };\n  }\n  tokenizeLine2(lineText, prevState, timeLimit = 0) {\n    const r = this._tokenize(lineText, prevState, true, timeLimit);\n    return {\n      tokens: r.lineTokens.getBinaryResult(r.ruleStack, r.lineLength),\n      ruleStack: r.ruleStack,\n      stoppedEarly: r.stoppedEarly\n    };\n  }\n  _tokenize(lineText, prevState, emitBinaryTokens, timeLimit) {\n    if (this._rootId === -1) {\n      this._rootId = RuleFactory.getCompiledRuleId(this._grammar.repository.$self, this, this._grammar.repository);\n      this.getInjections();\n    }\n    let isFirstLine;\n    if (!prevState || prevState === StateStackImpl.NULL) {\n      isFirstLine = true;\n      const rawDefaultMetadata = this._basicScopeAttributesProvider.getDefaultAttributes();\n      const defaultStyle = this.themeProvider.getDefaults();\n      const defaultMetadata = EncodedTokenAttributes.set(0, rawDefaultMetadata.languageId, rawDefaultMetadata.tokenType, null, defaultStyle.fontStyle, defaultStyle.foregroundId, defaultStyle.backgroundId);\n      const rootScopeName = this.getRule(this._rootId).getName(null, null);\n      let scopeList;\n      if (rootScopeName) {\n        scopeList = AttributedScopeStack.createRootAndLookUpScopeName(rootScopeName, defaultMetadata, this);\n      } else {\n        scopeList = AttributedScopeStack.createRoot(\"unknown\", defaultMetadata);\n      }\n      prevState = new StateStackImpl(null, this._rootId, -1, -1, false, null, scopeList, scopeList);\n    } else {\n      isFirstLine = false;\n      prevState.reset();\n    }\n    lineText = lineText + \"\\n\";\n    const onigLineText = this.createOnigString(lineText);\n    const lineLength = onigLineText.content.length;\n    const lineTokens = new LineTokens(emitBinaryTokens, lineText, this._tokenTypeMatchers, this.balancedBracketSelectors);\n    const r = _tokenizeString(this, onigLineText, isFirstLine, 0, prevState, lineTokens, true, timeLimit);\n    disposeOnigString(onigLineText);\n    return {\n      lineLength,\n      lineTokens,\n      ruleStack: r.stack,\n      stoppedEarly: r.stoppedEarly\n    };\n  }\n}\nfunction initGrammar(grammar, base) {\n  grammar = clone(grammar);\n  grammar.repository = grammar.repository || {};\n  grammar.repository.$self = {\n    $vscodeTextmateLocation: grammar.$vscodeTextmateLocation,\n    patterns: grammar.patterns,\n    name: grammar.scopeName\n  };\n  grammar.repository.$base = base || grammar.repository.$self;\n  return grammar;\n}\nclass AttributedScopeStack {\n  parent;\n  scopePath;\n  tokenAttributes;\n  static fromExtension(namesScopeList, contentNameScopesList) {\n    let current = namesScopeList;\n    let scopeNames = namesScopeList?.scopePath ?? null;\n    for (const frame of contentNameScopesList) {\n      scopeNames = ScopeStack.push(scopeNames, frame.scopeNames);\n      current = new AttributedScopeStack(current, scopeNames, frame.encodedTokenAttributes);\n    }\n    return current;\n  }\n  static createRoot(scopeName, tokenAttributes) {\n    return new AttributedScopeStack(null, new ScopeStack(null, scopeName), tokenAttributes);\n  }\n  static createRootAndLookUpScopeName(scopeName, tokenAttributes, grammar) {\n    const rawRootMetadata = grammar.getMetadataForScope(scopeName);\n    const scopePath = new ScopeStack(null, scopeName);\n    const rootStyle = grammar.themeProvider.themeMatch(scopePath);\n    const resolvedTokenAttributes = AttributedScopeStack.mergeAttributes(tokenAttributes, rawRootMetadata, rootStyle);\n    return new AttributedScopeStack(null, scopePath, resolvedTokenAttributes);\n  }\n  get scopeName() {\n    return this.scopePath.scopeName;\n  }\n  /**\n   * Invariant:\n   * ```\n   * if (parent && !scopePath.extends(parent.scopePath)) {\n   * \tthrow new Error();\n   * }\n   * ```\n   */\n  constructor(parent, scopePath, tokenAttributes) {\n    this.parent = parent;\n    this.scopePath = scopePath;\n    this.tokenAttributes = tokenAttributes;\n  }\n  toString() {\n    return this.getScopeNames().join(\" \");\n  }\n  equals(other) {\n    return AttributedScopeStack.equals(this, other);\n  }\n  static equals(a, b) {\n    do {\n      if (a === b) {\n        return true;\n      }\n      if (!a && !b) {\n        return true;\n      }\n      if (!a || !b) {\n        return false;\n      }\n      if (a.scopeName !== b.scopeName || a.tokenAttributes !== b.tokenAttributes) {\n        return false;\n      }\n      a = a.parent;\n      b = b.parent;\n    } while (true);\n  }\n  static mergeAttributes(existingTokenAttributes, basicScopeAttributes, styleAttributes) {\n    let fontStyle = -1;\n    let foreground = 0;\n    let background = 0;\n    if (styleAttributes !== null) {\n      fontStyle = styleAttributes.fontStyle;\n      foreground = styleAttributes.foregroundId;\n      background = styleAttributes.backgroundId;\n    }\n    return EncodedTokenAttributes.set(existingTokenAttributes, basicScopeAttributes.languageId, basicScopeAttributes.tokenType, null, fontStyle, foreground, background);\n  }\n  pushAttributed(scopePath, grammar) {\n    if (scopePath === null) {\n      return this;\n    }\n    if (scopePath.indexOf(\" \") === -1) {\n      return AttributedScopeStack._pushAttributed(this, scopePath, grammar);\n    }\n    const scopes = scopePath.split(/ /g);\n    let result = this;\n    for (const scope of scopes) {\n      result = AttributedScopeStack._pushAttributed(result, scope, grammar);\n    }\n    return result;\n  }\n  static _pushAttributed(target, scopeName, grammar) {\n    const rawMetadata = grammar.getMetadataForScope(scopeName);\n    const newPath = target.scopePath.push(scopeName);\n    const scopeThemeMatchResult = grammar.themeProvider.themeMatch(newPath);\n    const metadata = AttributedScopeStack.mergeAttributes(target.tokenAttributes, rawMetadata, scopeThemeMatchResult);\n    return new AttributedScopeStack(target, newPath, metadata);\n  }\n  getScopeNames() {\n    return this.scopePath.getSegments();\n  }\n  getExtensionIfDefined(base) {\n    const result = [];\n    let self = this;\n    while (self && self !== base) {\n      result.push({\n        encodedTokenAttributes: self.tokenAttributes,\n        scopeNames: self.scopePath.getExtensionIfDefined(self.parent?.scopePath ?? null)\n      });\n      self = self.parent;\n    }\n    return self === base ? result.reverse() : void 0;\n  }\n}\nclass StateStackImpl {\n  parent;\n  ruleId;\n  beginRuleCapturedEOL;\n  endRule;\n  nameScopesList;\n  contentNameScopesList;\n  _stackElementBrand = void 0;\n  // TODO remove me\n  static NULL = new StateStackImpl(null, 0, 0, 0, false, null, null, null);\n  /**\n   * The position on the current line where this state was pushed.\n   * This is relevant only while tokenizing a line, to detect endless loops.\n   * Its value is meaningless across lines.\n   */\n  _enterPos;\n  /**\n   * The captured anchor position when this stack element was pushed.\n   * This is relevant only while tokenizing a line, to restore the anchor position when popping.\n   * Its value is meaningless across lines.\n   */\n  _anchorPos;\n  /**\n   * The depth of the stack.\n   */\n  depth;\n  /**\n   * Invariant:\n   * ```\n   * if (contentNameScopesList !== nameScopesList && contentNameScopesList?.parent !== nameScopesList) {\n   * \tthrow new Error();\n   * }\n   * if (this.parent && !nameScopesList.extends(this.parent.contentNameScopesList)) {\n   * \tthrow new Error();\n   * }\n   * ```\n   */\n  constructor(parent, ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList) {\n    this.parent = parent;\n    this.ruleId = ruleId;\n    this.beginRuleCapturedEOL = beginRuleCapturedEOL;\n    this.endRule = endRule;\n    this.nameScopesList = nameScopesList;\n    this.contentNameScopesList = contentNameScopesList;\n    this.depth = this.parent ? this.parent.depth + 1 : 1;\n    this._enterPos = enterPos;\n    this._anchorPos = anchorPos;\n  }\n  equals(other) {\n    if (other === null) {\n      return false;\n    }\n    return StateStackImpl._equals(this, other);\n  }\n  static _equals(a, b) {\n    if (a === b) {\n      return true;\n    }\n    if (!this._structuralEquals(a, b)) {\n      return false;\n    }\n    return AttributedScopeStack.equals(a.contentNameScopesList, b.contentNameScopesList);\n  }\n  /**\n   * A structural equals check. Does not take into account `scopes`.\n   */\n  static _structuralEquals(a, b) {\n    do {\n      if (a === b) {\n        return true;\n      }\n      if (!a && !b) {\n        return true;\n      }\n      if (!a || !b) {\n        return false;\n      }\n      if (a.depth !== b.depth || a.ruleId !== b.ruleId || a.endRule !== b.endRule) {\n        return false;\n      }\n      a = a.parent;\n      b = b.parent;\n    } while (true);\n  }\n  clone() {\n    return this;\n  }\n  static _reset(el) {\n    while (el) {\n      el._enterPos = -1;\n      el._anchorPos = -1;\n      el = el.parent;\n    }\n  }\n  reset() {\n    StateStackImpl._reset(this);\n  }\n  pop() {\n    return this.parent;\n  }\n  safePop() {\n    if (this.parent) {\n      return this.parent;\n    }\n    return this;\n  }\n  push(ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList) {\n    return new StateStackImpl(this, ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList);\n  }\n  getEnterPos() {\n    return this._enterPos;\n  }\n  getAnchorPos() {\n    return this._anchorPos;\n  }\n  getRule(grammar) {\n    return grammar.getRule(this.ruleId);\n  }\n  toString() {\n    const r = [];\n    this._writeString(r, 0);\n    return \"[\" + r.join(\",\") + \"]\";\n  }\n  _writeString(res, outIndex) {\n    if (this.parent) {\n      outIndex = this.parent._writeString(res, outIndex);\n    }\n    res[outIndex++] = `(${this.ruleId}, ${this.nameScopesList?.toString()}, ${this.contentNameScopesList?.toString()})`;\n    return outIndex;\n  }\n  withContentNameScopesList(contentNameScopeStack) {\n    if (this.contentNameScopesList === contentNameScopeStack) {\n      return this;\n    }\n    return this.parent.push(this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, this.endRule, this.nameScopesList, contentNameScopeStack);\n  }\n  withEndRule(endRule) {\n    if (this.endRule === endRule) {\n      return this;\n    }\n    return new StateStackImpl(this.parent, this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, endRule, this.nameScopesList, this.contentNameScopesList);\n  }\n  // Used to warn of endless loops\n  hasSameRuleAs(other) {\n    let el = this;\n    while (el && el._enterPos === other._enterPos) {\n      if (el.ruleId === other.ruleId) {\n        return true;\n      }\n      el = el.parent;\n    }\n    return false;\n  }\n  toStateStackFrame() {\n    return {\n      ruleId: ruleIdToNumber(this.ruleId),\n      beginRuleCapturedEOL: this.beginRuleCapturedEOL,\n      endRule: this.endRule,\n      nameScopesList: this.nameScopesList?.getExtensionIfDefined(this.parent?.nameScopesList ?? null) ?? [],\n      contentNameScopesList: this.contentNameScopesList?.getExtensionIfDefined(this.nameScopesList) ?? []\n    };\n  }\n  static pushFrame(self, frame) {\n    const namesScopeList = AttributedScopeStack.fromExtension(self?.nameScopesList ?? null, frame.nameScopesList);\n    return new StateStackImpl(self, ruleIdFromNumber(frame.ruleId), frame.enterPos ?? -1, frame.anchorPos ?? -1, frame.beginRuleCapturedEOL, frame.endRule, namesScopeList, AttributedScopeStack.fromExtension(namesScopeList, frame.contentNameScopesList));\n  }\n}\nclass BalancedBracketSelectors {\n  balancedBracketScopes;\n  unbalancedBracketScopes;\n  allowAny = false;\n  constructor(balancedBracketScopes, unbalancedBracketScopes) {\n    this.balancedBracketScopes = balancedBracketScopes.flatMap((selector) => {\n      if (selector === \"*\") {\n        this.allowAny = true;\n        return [];\n      }\n      return createMatchers(selector, nameMatcher).map((m) => m.matcher);\n    });\n    this.unbalancedBracketScopes = unbalancedBracketScopes.flatMap((selector) => createMatchers(selector, nameMatcher).map((m) => m.matcher));\n  }\n  get matchesAlways() {\n    return this.allowAny && this.unbalancedBracketScopes.length === 0;\n  }\n  get matchesNever() {\n    return this.balancedBracketScopes.length === 0 && !this.allowAny;\n  }\n  match(scopes) {\n    for (const excluder of this.unbalancedBracketScopes) {\n      if (excluder(scopes)) {\n        return false;\n      }\n    }\n    for (const includer of this.balancedBracketScopes) {\n      if (includer(scopes)) {\n        return true;\n      }\n    }\n    return this.allowAny;\n  }\n}\nclass LineTokens {\n  balancedBracketSelectors;\n  _emitBinaryTokens;\n  /**\n   * defined only if `false`.\n   */\n  _lineText;\n  /**\n   * used only if `_emitBinaryTokens` is false.\n   */\n  _tokens;\n  /**\n   * used only if `_emitBinaryTokens` is true.\n   */\n  _binaryTokens;\n  _lastTokenEndIndex;\n  _tokenTypeOverrides;\n  constructor(emitBinaryTokens, lineText, tokenTypeOverrides, balancedBracketSelectors) {\n    this.balancedBracketSelectors = balancedBracketSelectors;\n    this._emitBinaryTokens = emitBinaryTokens;\n    this._tokenTypeOverrides = tokenTypeOverrides;\n    {\n      this._lineText = null;\n    }\n    this._tokens = [];\n    this._binaryTokens = [];\n    this._lastTokenEndIndex = 0;\n  }\n  produce(stack, endIndex) {\n    this.produceFromScopes(stack.contentNameScopesList, endIndex);\n  }\n  produceFromScopes(scopesList, endIndex) {\n    if (this._lastTokenEndIndex >= endIndex) {\n      return;\n    }\n    if (this._emitBinaryTokens) {\n      let metadata = scopesList?.tokenAttributes ?? 0;\n      let containsBalancedBrackets = false;\n      if (this.balancedBracketSelectors?.matchesAlways) {\n        containsBalancedBrackets = true;\n      }\n      if (this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {\n        const scopes2 = scopesList?.getScopeNames() ?? [];\n        for (const tokenType of this._tokenTypeOverrides) {\n          if (tokenType.matcher(scopes2)) {\n            metadata = EncodedTokenAttributes.set(metadata, 0, toOptionalTokenType(tokenType.type), null, -1, 0, 0);\n          }\n        }\n        if (this.balancedBracketSelectors) {\n          containsBalancedBrackets = this.balancedBracketSelectors.match(scopes2);\n        }\n      }\n      if (containsBalancedBrackets) {\n        metadata = EncodedTokenAttributes.set(metadata, 0, 8, containsBalancedBrackets, -1, 0, 0);\n      }\n      if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === metadata) {\n        this._lastTokenEndIndex = endIndex;\n        return;\n      }\n      this._binaryTokens.push(this._lastTokenEndIndex);\n      this._binaryTokens.push(metadata);\n      this._lastTokenEndIndex = endIndex;\n      return;\n    }\n    const scopes = scopesList?.getScopeNames() ?? [];\n    this._tokens.push({\n      startIndex: this._lastTokenEndIndex,\n      endIndex,\n      // value: lineText.substring(lastTokenEndIndex, endIndex),\n      scopes\n    });\n    this._lastTokenEndIndex = endIndex;\n  }\n  getResult(stack, lineLength) {\n    if (this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === lineLength - 1) {\n      this._tokens.pop();\n    }\n    if (this._tokens.length === 0) {\n      this._lastTokenEndIndex = -1;\n      this.produce(stack, lineLength);\n      this._tokens[this._tokens.length - 1].startIndex = 0;\n    }\n    return this._tokens;\n  }\n  getBinaryResult(stack, lineLength) {\n    if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === lineLength - 1) {\n      this._binaryTokens.pop();\n      this._binaryTokens.pop();\n    }\n    if (this._binaryTokens.length === 0) {\n      this._lastTokenEndIndex = -1;\n      this.produce(stack, lineLength);\n      this._binaryTokens[this._binaryTokens.length - 2] = 0;\n    }\n    const result = new Uint32Array(this._binaryTokens.length);\n    for (let i = 0, len = this._binaryTokens.length; i < len; i++) {\n      result[i] = this._binaryTokens[i];\n    }\n    return result;\n  }\n}\nclass SyncRegistry {\n  _onigLibPromise;\n  _grammars = /* @__PURE__ */ new Map();\n  _rawGrammars = /* @__PURE__ */ new Map();\n  _injectionGrammars = /* @__PURE__ */ new Map();\n  _theme;\n  constructor(theme, _onigLibPromise) {\n    this._onigLibPromise = _onigLibPromise;\n    this._theme = theme;\n  }\n  dispose() {\n    for (const grammar of this._grammars.values()) {\n      grammar.dispose();\n    }\n  }\n  setTheme(theme) {\n    this._theme = theme;\n  }\n  getColorMap() {\n    return this._theme.getColorMap();\n  }\n  /**\n   * Add `grammar` to registry and return a list of referenced scope names\n   */\n  addGrammar(grammar, injectionScopeNames) {\n    this._rawGrammars.set(grammar.scopeName, grammar);\n    if (injectionScopeNames) {\n      this._injectionGrammars.set(grammar.scopeName, injectionScopeNames);\n    }\n  }\n  /**\n   * Lookup a raw grammar.\n   */\n  lookup(scopeName) {\n    return this._rawGrammars.get(scopeName);\n  }\n  /**\n   * Returns the injections for the given grammar\n   */\n  injections(targetScope) {\n    return this._injectionGrammars.get(targetScope);\n  }\n  /**\n   * Get the default theme settings\n   */\n  getDefaults() {\n    return this._theme.getDefaults();\n  }\n  /**\n   * Match a scope in the theme.\n   */\n  themeMatch(scopePath) {\n    return this._theme.match(scopePath);\n  }\n  /**\n   * Lookup a grammar.\n   */\n  async grammarForScopeName(scopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {\n    if (!this._grammars.has(scopeName)) {\n      let rawGrammar = this._rawGrammars.get(scopeName);\n      if (!rawGrammar) {\n        return null;\n      }\n      this._grammars.set(scopeName, createGrammar(scopeName, rawGrammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, this, await this._onigLibPromise));\n    }\n    return this._grammars.get(scopeName);\n  }\n}\nlet Registry$1 = class Registry {\n  _options;\n  _syncRegistry;\n  _ensureGrammarCache;\n  constructor(options) {\n    this._options = options;\n    this._syncRegistry = new SyncRegistry(Theme.createFromRawTheme(options.theme, options.colorMap), options.onigLib);\n    this._ensureGrammarCache = /* @__PURE__ */ new Map();\n  }\n  dispose() {\n    this._syncRegistry.dispose();\n  }\n  /**\n   * Change the theme. Once called, no previous `ruleStack` should be used anymore.\n   */\n  setTheme(theme, colorMap) {\n    this._syncRegistry.setTheme(Theme.createFromRawTheme(theme, colorMap));\n  }\n  /**\n   * Returns a lookup array for color ids.\n   */\n  getColorMap() {\n    return this._syncRegistry.getColorMap();\n  }\n  /**\n   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n   * Please do not use language id 0.\n   */\n  loadGrammarWithEmbeddedLanguages(initialScopeName, initialLanguage, embeddedLanguages) {\n    return this.loadGrammarWithConfiguration(initialScopeName, initialLanguage, { embeddedLanguages });\n  }\n  /**\n   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n   * Please do not use language id 0.\n   */\n  loadGrammarWithConfiguration(initialScopeName, initialLanguage, configuration) {\n    return this._loadGrammar(initialScopeName, initialLanguage, configuration.embeddedLanguages, configuration.tokenTypes, new BalancedBracketSelectors(configuration.balancedBracketSelectors || [], configuration.unbalancedBracketSelectors || []));\n  }\n  /**\n   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n   */\n  loadGrammar(initialScopeName) {\n    return this._loadGrammar(initialScopeName, 0, null, null, null);\n  }\n  async _loadGrammar(initialScopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {\n    const dependencyProcessor = new ScopeDependencyProcessor(this._syncRegistry, initialScopeName);\n    while (dependencyProcessor.Q.length > 0) {\n      await Promise.all(dependencyProcessor.Q.map((request) => this._loadSingleGrammar(request.scopeName)));\n      dependencyProcessor.processQueue();\n    }\n    return this._grammarForScopeName(initialScopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors);\n  }\n  async _loadSingleGrammar(scopeName) {\n    if (!this._ensureGrammarCache.has(scopeName)) {\n      this._ensureGrammarCache.set(scopeName, this._doLoadSingleGrammar(scopeName));\n    }\n    return this._ensureGrammarCache.get(scopeName);\n  }\n  async _doLoadSingleGrammar(scopeName) {\n    const grammar = await this._options.loadGrammar(scopeName);\n    if (grammar) {\n      const injections = typeof this._options.getInjections === \"function\" ? this._options.getInjections(scopeName) : void 0;\n      this._syncRegistry.addGrammar(grammar, injections);\n    }\n  }\n  /**\n   * Adds a rawGrammar.\n   */\n  async addGrammar(rawGrammar, injections = [], initialLanguage = 0, embeddedLanguages = null) {\n    this._syncRegistry.addGrammar(rawGrammar, injections);\n    return await this._grammarForScopeName(rawGrammar.scopeName, initialLanguage, embeddedLanguages);\n  }\n  /**\n   * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `addGrammar`.\n   */\n  _grammarForScopeName(scopeName, initialLanguage = 0, embeddedLanguages = null, tokenTypes = null, balancedBracketSelectors = null) {\n    return this._syncRegistry.grammarForScopeName(scopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors);\n  }\n};\nconst INITIAL = StateStackImpl.NULL;\nconst MetadataConsts = {\n  LANGUAGEID_MASK: 255,\n  TOKEN_TYPE_MASK: 768,\n  BALANCED_BRACKETS_MASK: 1024,\n  FONT_STYLE_MASK: 14336,\n  FOREGROUND_MASK: 8372224,\n  BACKGROUND_MASK: 4286578688,\n  LANGUAGEID_OFFSET: 0,\n  TOKEN_TYPE_OFFSET: 8,\n  BALANCED_BRACKETS_OFFSET: 10,\n  FONT_STYLE_OFFSET: 11,\n  FOREGROUND_OFFSET: 15,\n  BACKGROUND_OFFSET: 24\n};\nclass StackElementMetadata {\n  static toBinaryStr(metadata) {\n    let r = metadata.toString(2);\n    while (r.length < 32)\n      r = `0${r}`;\n    return r;\n  }\n  // public static printMetadata(metadata: number): void {\n  //   const languageId = StackElementMetadata.getLanguageId(metadata)\n  //   const tokenType = StackElementMetadata.getTokenType(metadata)\n  //   const fontStyle = StackElementMetadata.getFontStyle(metadata)\n  //   const foreground = StackElementMetadata.getForeground(metadata)\n  //   const background = StackElementMetadata.getBackground(metadata)\n  //   console.log({\n  //     languageId,\n  //     tokenType,\n  //     fontStyle,\n  //     foreground,\n  //     background,\n  //   })\n  // }\n  static getLanguageId(metadata) {\n    return (metadata & MetadataConsts.LANGUAGEID_MASK) >>> MetadataConsts.LANGUAGEID_OFFSET;\n  }\n  static getTokenType(metadata) {\n    return (metadata & MetadataConsts.TOKEN_TYPE_MASK) >>> MetadataConsts.TOKEN_TYPE_OFFSET;\n  }\n  static getFontStyle(metadata) {\n    return (metadata & MetadataConsts.FONT_STYLE_MASK) >>> MetadataConsts.FONT_STYLE_OFFSET;\n  }\n  static getForeground(metadata) {\n    return (metadata & MetadataConsts.FOREGROUND_MASK) >>> MetadataConsts.FOREGROUND_OFFSET;\n  }\n  static getBackground(metadata) {\n    return (metadata & MetadataConsts.BACKGROUND_MASK) >>> MetadataConsts.BACKGROUND_OFFSET;\n  }\n  static containsBalancedBrackets(metadata) {\n    return (metadata & MetadataConsts.BALANCED_BRACKETS_MASK) !== 0;\n  }\n  static set(metadata, languageId, tokenType, fontStyle, foreground, background) {\n    let _languageId = StackElementMetadata.getLanguageId(metadata);\n    let _tokenType = StackElementMetadata.getTokenType(metadata);\n    let _fontStyle = StackElementMetadata.getFontStyle(metadata);\n    let _foreground = StackElementMetadata.getForeground(metadata);\n    let _background = StackElementMetadata.getBackground(metadata);\n    const _containsBalancedBracketsBit = StackElementMetadata.containsBalancedBrackets(metadata) ? 1 : 0;\n    if (languageId !== 0)\n      _languageId = languageId;\n    if (tokenType !== 0) {\n      _tokenType = tokenType === 8 ? 0 : tokenType;\n    }\n    if (fontStyle !== FontStyle.NotSet)\n      _fontStyle = fontStyle;\n    if (foreground !== 0)\n      _foreground = foreground;\n    if (background !== 0)\n      _background = background;\n    return (_languageId << MetadataConsts.LANGUAGEID_OFFSET | _tokenType << MetadataConsts.TOKEN_TYPE_OFFSET | _fontStyle << MetadataConsts.FONT_STYLE_OFFSET | _containsBalancedBracketsBit << MetadataConsts.BALANCED_BRACKETS_OFFSET | _foreground << MetadataConsts.FOREGROUND_OFFSET | _background << MetadataConsts.BACKGROUND_OFFSET) >>> 0;\n  }\n}\nexport { INITIAL, Registry$1 as Registry, StackElementMetadata };\n",
      "start": 1712268127895,
      "end": 1712268127966,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:css-post",
      "start": 1712268127966,
      "end": 1712268127966,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1712268127966,
      "end": 1712268127966,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1712268127966,
      "end": 1712268127966,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1712268127966,
      "end": 1712268127966,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1712268127966,
      "end": 1712268127966,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1712268127966,
      "end": 1712268127966,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1712268127966,
      "end": 1712268127966,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1712268127966,
      "end": 1712268127967,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1712268127967,
      "end": 1712268127967,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1712268127967,
      "end": 1712268127967,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1712268127967,
      "end": 1712268127967,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1712268127967,
      "end": 1712268127967,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1712268127967,
      "end": 1712268127967,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1712268127967,
      "end": 1712268127967,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1712268127967,
      "end": 1712268127967,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1712268127967,
      "end": 1712268127967,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1712268127967,
      "end": 1712268127967,
      "order": "normal"
    }
  ]
}
