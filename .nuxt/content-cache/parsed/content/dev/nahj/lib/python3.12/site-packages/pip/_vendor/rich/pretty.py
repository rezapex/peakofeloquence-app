{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:rich:pretty.py","body":"import builtins\nimport collections\nimport dataclasses\nimport inspect\nimport os\nimport sys\nfrom array import array\nfrom collections import Counter, UserDict, UserList, defaultdict, deque\nfrom dataclasses import dataclass, fields, is_dataclass\nfrom inspect import isclass\nfrom itertools import islice\nfrom types import MappingProxyType\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    DefaultDict,\n    Dict,\n    Iterable,\n    List,\n    Optional,\n    Sequence,\n    Set,\n    Tuple,\n    Union,\n)\n\nfrom pip._vendor.rich.repr import RichReprResult\n\ntry:\n    import attr as _attr_module\n\n    _has_attrs = hasattr(_attr_module, \"ib\")\nexcept ImportError:  # pragma: no cover\n    _has_attrs = False\n\nfrom . import get_console\nfrom ._loop import loop_last\nfrom ._pick import pick_bool\nfrom .abc import RichRenderable\nfrom .cells import cell_len\nfrom .highlighter import ReprHighlighter\nfrom .jupyter import JupyterMixin, JupyterRenderable\nfrom .measure import Measurement\nfrom .text import Text\n\nif TYPE_CHECKING:\n    from .console import (\n        Console,\n        ConsoleOptions,\n        HighlighterType,\n        JustifyMethod,\n        OverflowMethod,\n        RenderResult,\n    )\n\n\ndef _is_attr_object(obj: Any) -> bool:\n    \"\"\"Check if an object was created with attrs module.\"\"\"\n    return _has_attrs and _attr_module.has(type(obj))\n\n\ndef _get_attr_fields(obj: Any) -> Sequence[\"_attr_module.Attribute[Any]\"]:\n    \"\"\"Get fields for an attrs object.\"\"\"\n    return _attr_module.fields(type(obj)) if _has_attrs else []\n\n\ndef _is_dataclass_repr(obj: object) -> bool:\n    \"\"\"Check if an instance of a dataclass contains the default repr.\n\n    Args:\n        obj (object): A dataclass instance.\n\n    Returns:\n        bool: True if the default repr is used, False if there is a custom repr.\n    \"\"\"\n    # Digging in to a lot of internals here\n    # Catching all exceptions in case something is missing on a non CPython implementation\n    try:\n        return obj.__repr__.__code__.co_filename == dataclasses.__file__\n    except Exception:  # pragma: no coverage\n        return False\n\n\n_dummy_namedtuple = collections.namedtuple(\"_dummy_namedtuple\", [])\n\n\ndef _has_default_namedtuple_repr(obj: object) -> bool:\n    \"\"\"Check if an instance of namedtuple contains the default repr\n\n    Args:\n        obj (object): A namedtuple\n\n    Returns:\n        bool: True if the default repr is used, False if there's a custom repr.\n    \"\"\"\n    obj_file = None\n    try:\n        obj_file = inspect.getfile(obj.__repr__)\n    except (OSError, TypeError):\n        # OSError handles case where object is defined in __main__ scope, e.g. REPL - no filename available.\n        # TypeError trapped defensively, in case of object without filename slips through.\n        pass\n    default_repr_file = inspect.getfile(_dummy_namedtuple.__repr__)\n    return obj_file == default_repr_file\n\n\ndef _ipy_display_hook(\n    value: Any,\n    console: Optional[\"Console\"] = None,\n    overflow: \"OverflowMethod\" = \"ignore\",\n    crop: bool = False,\n    indent_guides: bool = False,\n    max_length: Optional[int] = None,\n    max_string: Optional[int] = None,\n    max_depth: Optional[int] = None,\n    expand_all: bool = False,\n) -> Union[str, None]:\n    # needed here to prevent circular import:\n    from .console import ConsoleRenderable\n\n    # always skip rich generated jupyter renderables or None values\n    if _safe_isinstance(value, JupyterRenderable) or value is None:\n        return None\n\n    console = console or get_console()\n\n    with console.capture() as capture:\n        # certain renderables should start on a new line\n        if _safe_isinstance(value, ConsoleRenderable):\n            console.line()\n        console.print(\n            value\n            if _safe_isinstance(value, RichRenderable)\n            else Pretty(\n                value,\n                overflow=overflow,\n                indent_guides=indent_guides,\n                max_length=max_length,\n                max_string=max_string,\n                max_depth=max_depth,\n                expand_all=expand_all,\n                margin=12,\n            ),\n            crop=crop,\n            new_line_start=True,\n            end=\"\",\n        )\n    # strip trailing newline, not usually part of a text repr\n    # I'm not sure if this should be prevented at a lower level\n    return capture.get().rstrip(\"\\n\")\n\n\ndef _safe_isinstance(\n    obj: object, class_or_tuple: Union[type, Tuple[type, ...]]\n) -> bool:\n    \"\"\"isinstance can fail in rare cases, for example types with no __class__\"\"\"\n    try:\n        return isinstance(obj, class_or_tuple)\n    except Exception:\n        return False\n\n\ndef install(\n    console: Optional[\"Console\"] = None,\n    overflow: \"OverflowMethod\" = \"ignore\",\n    crop: bool = False,\n    indent_guides: bool = False,\n    max_length: Optional[int] = None,\n    max_string: Optional[int] = None,\n    max_depth: Optional[int] = None,\n    expand_all: bool = False,\n) -> None:\n    \"\"\"Install automatic pretty printing in the Python REPL.\n\n    Args:\n        console (Console, optional): Console instance or ``None`` to use global console. Defaults to None.\n        overflow (Optional[OverflowMethod], optional): Overflow method. Defaults to \"ignore\".\n        crop (Optional[bool], optional): Enable cropping of long lines. Defaults to False.\n        indent_guides (bool, optional): Enable indentation guides. Defaults to False.\n        max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n            Defaults to None.\n        max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to None.\n        max_depth (int, optional): Maximum depth of nested data structures, or None for no maximum. Defaults to None.\n        expand_all (bool, optional): Expand all containers. Defaults to False.\n        max_frames (int): Maximum number of frames to show in a traceback, 0 for no maximum. Defaults to 100.\n    \"\"\"\n    from pip._vendor.rich import get_console\n\n    console = console or get_console()\n    assert console is not None\n\n    def display_hook(value: Any) -> None:\n        \"\"\"Replacement sys.displayhook which prettifies objects with Rich.\"\"\"\n        if value is not None:\n            assert console is not None\n            builtins._ = None  # type: ignore[attr-defined]\n            console.print(\n                value\n                if _safe_isinstance(value, RichRenderable)\n                else Pretty(\n                    value,\n                    overflow=overflow,\n                    indent_guides=indent_guides,\n                    max_length=max_length,\n                    max_string=max_string,\n                    max_depth=max_depth,\n                    expand_all=expand_all,\n                ),\n                crop=crop,\n            )\n            builtins._ = value  # type: ignore[attr-defined]\n\n    if \"get_ipython\" in globals():\n        ip = get_ipython()  # type: ignore[name-defined]\n        from IPython.core.formatters import BaseFormatter\n\n        class RichFormatter(BaseFormatter):  # type: ignore[misc]\n            pprint: bool = True\n\n            def __call__(self, value: Any) -> Any:\n                if self.pprint:\n                    return _ipy_display_hook(\n                        value,\n                        console=get_console(),\n                        overflow=overflow,\n                        indent_guides=indent_guides,\n                        max_length=max_length,\n                        max_string=max_string,\n                        max_depth=max_depth,\n                        expand_all=expand_all,\n                    )\n                else:\n                    return repr(value)\n\n        # replace plain text formatter with rich formatter\n        rich_formatter = RichFormatter()\n        ip.display_formatter.formatters[\"text/plain\"] = rich_formatter\n    else:\n        sys.displayhook = display_hook\n\n\nclass Pretty(JupyterMixin):\n    \"\"\"A rich renderable that pretty prints an object.\n\n    Args:\n        _object (Any): An object to pretty print.\n        highlighter (HighlighterType, optional): Highlighter object to apply to result, or None for ReprHighlighter. Defaults to None.\n        indent_size (int, optional): Number of spaces in indent. Defaults to 4.\n        justify (JustifyMethod, optional): Justify method, or None for default. Defaults to None.\n        overflow (OverflowMethod, optional): Overflow method, or None for default. Defaults to None.\n        no_wrap (Optional[bool], optional): Disable word wrapping. Defaults to False.\n        indent_guides (bool, optional): Enable indentation guides. Defaults to False.\n        max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n            Defaults to None.\n        max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to None.\n        max_depth (int, optional): Maximum depth of nested data structures, or None for no maximum. Defaults to None.\n        expand_all (bool, optional): Expand all containers. Defaults to False.\n        margin (int, optional): Subtrace a margin from width to force containers to expand earlier. Defaults to 0.\n        insert_line (bool, optional): Insert a new line if the output has multiple new lines. Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        _object: Any,\n        highlighter: Optional[\"HighlighterType\"] = None,\n        *,\n        indent_size: int = 4,\n        justify: Optional[\"JustifyMethod\"] = None,\n        overflow: Optional[\"OverflowMethod\"] = None,\n        no_wrap: Optional[bool] = False,\n        indent_guides: bool = False,\n        max_length: Optional[int] = None,\n        max_string: Optional[int] = None,\n        max_depth: Optional[int] = None,\n        expand_all: bool = False,\n        margin: int = 0,\n        insert_line: bool = False,\n    ) -> None:\n        self._object = _object\n        self.highlighter = highlighter or ReprHighlighter()\n        self.indent_size = indent_size\n        self.justify: Optional[\"JustifyMethod\"] = justify\n        self.overflow: Optional[\"OverflowMethod\"] = overflow\n        self.no_wrap = no_wrap\n        self.indent_guides = indent_guides\n        self.max_length = max_length\n        self.max_string = max_string\n        self.max_depth = max_depth\n        self.expand_all = expand_all\n        self.margin = margin\n        self.insert_line = insert_line\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        pretty_str = pretty_repr(\n            self._object,\n            max_width=options.max_width - self.margin,\n            indent_size=self.indent_size,\n            max_length=self.max_length,\n            max_string=self.max_string,\n            max_depth=self.max_depth,\n            expand_all=self.expand_all,\n        )\n        pretty_text = Text.from_ansi(\n            pretty_str,\n            justify=self.justify or options.justify,\n            overflow=self.overflow or options.overflow,\n            no_wrap=pick_bool(self.no_wrap, options.no_wrap),\n            style=\"pretty\",\n        )\n        pretty_text = (\n            self.highlighter(pretty_text)\n            if pretty_text\n            else Text(\n                f\"{type(self._object)}.__repr__ returned empty string\",\n                style=\"dim italic\",\n            )\n        )\n        if self.indent_guides and not options.ascii_only:\n            pretty_text = pretty_text.with_indent_guides(\n                self.indent_size, style=\"repr.indent\"\n            )\n        if self.insert_line and \"\\n\" in pretty_text:\n            yield \"\"\n        yield pretty_text\n\n    def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"Measurement\":\n        pretty_str = pretty_repr(\n            self._object,\n            max_width=options.max_width,\n            indent_size=self.indent_size,\n            max_length=self.max_length,\n            max_string=self.max_string,\n            max_depth=self.max_depth,\n            expand_all=self.expand_all,\n        )\n        text_width = (\n            max(cell_len(line) for line in pretty_str.splitlines()) if pretty_str else 0\n        )\n        return Measurement(text_width, text_width)\n\n\ndef _get_braces_for_defaultdict(_object: DefaultDict[Any, Any]) -> Tuple[str, str, str]:\n    return (\n        f\"defaultdict({_object.default_factory!r}, {{\",\n        \"})\",\n        f\"defaultdict({_object.default_factory!r}, {{}})\",\n    )\n\n\ndef _get_braces_for_array(_object: \"array[Any]\") -> Tuple[str, str, str]:\n    return (f\"array({_object.typecode!r}, [\", \"])\", f\"array({_object.typecode!r})\")\n\n\n_BRACES: Dict[type, Callable[[Any], Tuple[str, str, str]]] = {\n    os._Environ: lambda _object: (\"environ({\", \"})\", \"environ({})\"),\n    array: _get_braces_for_array,\n    defaultdict: _get_braces_for_defaultdict,\n    Counter: lambda _object: (\"Counter({\", \"})\", \"Counter()\"),\n    deque: lambda _object: (\"deque([\", \"])\", \"deque()\"),\n    dict: lambda _object: (\"{\", \"}\", \"{}\"),\n    UserDict: lambda _object: (\"{\", \"}\", \"{}\"),\n    frozenset: lambda _object: (\"frozenset({\", \"})\", \"frozenset()\"),\n    list: lambda _object: (\"[\", \"]\", \"[]\"),\n    UserList: lambda _object: (\"[\", \"]\", \"[]\"),\n    set: lambda _object: (\"{\", \"}\", \"set()\"),\n    tuple: lambda _object: (\"(\", \")\", \"()\"),\n    MappingProxyType: lambda _object: (\"mappingproxy({\", \"})\", \"mappingproxy({})\"),\n}\n_CONTAINERS = tuple(_BRACES.keys())\n_MAPPING_CONTAINERS = (dict, os._Environ, MappingProxyType, UserDict)\n\n\ndef is_expandable(obj: Any) -> bool:\n    \"\"\"Check if an object may be expanded by pretty print.\"\"\"\n    return (\n        _safe_isinstance(obj, _CONTAINERS)\n        or (is_dataclass(obj))\n        or (hasattr(obj, \"__rich_repr__\"))\n        or _is_attr_object(obj)\n    ) and not isclass(obj)\n\n\n@dataclass\nclass Node:\n    \"\"\"A node in a repr tree. May be atomic or a container.\"\"\"\n\n    key_repr: str = \"\"\n    value_repr: str = \"\"\n    open_brace: str = \"\"\n    close_brace: str = \"\"\n    empty: str = \"\"\n    last: bool = False\n    is_tuple: bool = False\n    is_namedtuple: bool = False\n    children: Optional[List[\"Node\"]] = None\n    key_separator: str = \": \"\n    separator: str = \", \"\n\n    def iter_tokens(self) -> Iterable[str]:\n        \"\"\"Generate tokens for this node.\"\"\"\n        if self.key_repr:\n            yield self.key_repr\n            yield self.key_separator\n        if self.value_repr:\n            yield self.value_repr\n        elif self.children is not None:\n            if self.children:\n                yield self.open_brace\n                if self.is_tuple and not self.is_namedtuple and len(self.children) == 1:\n                    yield from self.children[0].iter_tokens()\n                    yield \",\"\n                else:\n                    for child in self.children:\n                        yield from child.iter_tokens()\n                        if not child.last:\n                            yield self.separator\n                yield self.close_brace\n            else:\n                yield self.empty\n\n    def check_length(self, start_length: int, max_length: int) -> bool:\n        \"\"\"Check the length fits within a limit.\n\n        Args:\n            start_length (int): Starting length of the line (indent, prefix, suffix).\n            max_length (int): Maximum length.\n\n        Returns:\n            bool: True if the node can be rendered within max length, otherwise False.\n        \"\"\"\n        total_length = start_length\n        for token in self.iter_tokens():\n            total_length += cell_len(token)\n            if total_length > max_length:\n                return False\n        return True\n\n    def __str__(self) -> str:\n        repr_text = \"\".join(self.iter_tokens())\n        return repr_text\n\n    def render(\n        self, max_width: int = 80, indent_size: int = 4, expand_all: bool = False\n    ) -> str:\n        \"\"\"Render the node to a pretty repr.\n\n        Args:\n            max_width (int, optional): Maximum width of the repr. Defaults to 80.\n            indent_size (int, optional): Size of indents. Defaults to 4.\n            expand_all (bool, optional): Expand all levels. Defaults to False.\n\n        Returns:\n            str: A repr string of the original object.\n        \"\"\"\n        lines = [_Line(node=self, is_root=True)]\n        line_no = 0\n        while line_no < len(lines):\n            line = lines[line_no]\n            if line.expandable and not line.expanded:\n                if expand_all or not line.check_length(max_width):\n                    lines[line_no : line_no + 1] = line.expand(indent_size)\n            line_no += 1\n\n        repr_str = \"\\n\".join(str(line) for line in lines)\n        return repr_str\n\n\n@dataclass\nclass _Line:\n    \"\"\"A line in repr output.\"\"\"\n\n    parent: Optional[\"_Line\"] = None\n    is_root: bool = False\n    node: Optional[Node] = None\n    text: str = \"\"\n    suffix: str = \"\"\n    whitespace: str = \"\"\n    expanded: bool = False\n    last: bool = False\n\n    @property\n    def expandable(self) -> bool:\n        \"\"\"Check if the line may be expanded.\"\"\"\n        return bool(self.node is not None and self.node.children)\n\n    def check_length(self, max_length: int) -> bool:\n        \"\"\"Check this line fits within a given number of cells.\"\"\"\n        start_length = (\n            len(self.whitespace) + cell_len(self.text) + cell_len(self.suffix)\n        )\n        assert self.node is not None\n        return self.node.check_length(start_length, max_length)\n\n    def expand(self, indent_size: int) -> Iterable[\"_Line\"]:\n        \"\"\"Expand this line by adding children on their own line.\"\"\"\n        node = self.node\n        assert node is not None\n        whitespace = self.whitespace\n        assert node.children\n        if node.key_repr:\n            new_line = yield _Line(\n                text=f\"{node.key_repr}{node.key_separator}{node.open_brace}\",\n                whitespace=whitespace,\n            )\n        else:\n            new_line = yield _Line(text=node.open_brace, whitespace=whitespace)\n        child_whitespace = self.whitespace + \" \" * indent_size\n        tuple_of_one = node.is_tuple and len(node.children) == 1\n        for last, child in loop_last(node.children):\n            separator = \",\" if tuple_of_one else node.separator\n            line = _Line(\n                parent=new_line,\n                node=child,\n                whitespace=child_whitespace,\n                suffix=separator,\n                last=last and not tuple_of_one,\n            )\n            yield line\n\n        yield _Line(\n            text=node.close_brace,\n            whitespace=whitespace,\n            suffix=self.suffix,\n            last=self.last,\n        )\n\n    def __str__(self) -> str:\n        if self.last:\n            return f\"{self.whitespace}{self.text}{self.node or ''}\"\n        else:\n            return (\n                f\"{self.whitespace}{self.text}{self.node or ''}{self.suffix.rstrip()}\"\n            )\n\n\ndef _is_namedtuple(obj: Any) -> bool:\n    \"\"\"Checks if an object is most likely a namedtuple. It is possible\n    to craft an object that passes this check and isn't a namedtuple, but\n    there is only a minuscule chance of this happening unintentionally.\n\n    Args:\n        obj (Any): The object to test\n\n    Returns:\n        bool: True if the object is a namedtuple. False otherwise.\n    \"\"\"\n    try:\n        fields = getattr(obj, \"_fields\", None)\n    except Exception:\n        # Being very defensive - if we cannot get the attr then its not a namedtuple\n        return False\n    return isinstance(obj, tuple) and isinstance(fields, tuple)\n\n\ndef traverse(\n    _object: Any,\n    max_length: Optional[int] = None,\n    max_string: Optional[int] = None,\n    max_depth: Optional[int] = None,\n) -> Node:\n    \"\"\"Traverse object and generate a tree.\n\n    Args:\n        _object (Any): Object to be traversed.\n        max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n            Defaults to None.\n        max_string (int, optional): Maximum length of string before truncating, or None to disable truncating.\n            Defaults to None.\n        max_depth (int, optional): Maximum depth of data structures, or None for no maximum.\n            Defaults to None.\n\n    Returns:\n        Node: The root of a tree structure which can be used to render a pretty repr.\n    \"\"\"\n\n    def to_repr(obj: Any) -> str:\n        \"\"\"Get repr string for an object, but catch errors.\"\"\"\n        if (\n            max_string is not None\n            and _safe_isinstance(obj, (bytes, str))\n            and len(obj) > max_string\n        ):\n            truncated = len(obj) - max_string\n            obj_repr = f\"{obj[:max_string]!r}+{truncated}\"\n        else:\n            try:\n                obj_repr = repr(obj)\n            except Exception as error:\n                obj_repr = f\"<repr-error {str(error)!r}>\"\n        return obj_repr\n\n    visited_ids: Set[int] = set()\n    push_visited = visited_ids.add\n    pop_visited = visited_ids.remove\n\n    def _traverse(obj: Any, root: bool = False, depth: int = 0) -> Node:\n        \"\"\"Walk the object depth first.\"\"\"\n\n        obj_id = id(obj)\n        if obj_id in visited_ids:\n            # Recursion detected\n            return Node(value_repr=\"...\")\n\n        obj_type = type(obj)\n        children: List[Node]\n        reached_max_depth = max_depth is not None and depth >= max_depth\n\n        def iter_rich_args(rich_args: Any) -> Iterable[Union[Any, Tuple[str, Any]]]:\n            for arg in rich_args:\n                if _safe_isinstance(arg, tuple):\n                    if len(arg) == 3:\n                        key, child, default = arg\n                        if default == child:\n                            continue\n                        yield key, child\n                    elif len(arg) == 2:\n                        key, child = arg\n                        yield key, child\n                    elif len(arg) == 1:\n                        yield arg[0]\n                else:\n                    yield arg\n\n        try:\n            fake_attributes = hasattr(\n                obj, \"awehoi234_wdfjwljet234_234wdfoijsdfmmnxpi492\"\n            )\n        except Exception:\n            fake_attributes = False\n\n        rich_repr_result: Optional[RichReprResult] = None\n        if not fake_attributes:\n            try:\n                if hasattr(obj, \"__rich_repr__\") and not isclass(obj):\n                    rich_repr_result = obj.__rich_repr__()\n            except Exception:\n                pass\n\n        if rich_repr_result is not None:\n            push_visited(obj_id)\n            angular = getattr(obj.__rich_repr__, \"angular\", False)\n            args = list(iter_rich_args(rich_repr_result))\n            class_name = obj.__class__.__name__\n\n            if args:\n                children = []\n                append = children.append\n\n                if reached_max_depth:\n                    if angular:\n                        node = Node(value_repr=f\"<{class_name}...>\")\n                    else:\n                        node = Node(value_repr=f\"{class_name}(...)\")\n                else:\n                    if angular:\n                        node = Node(\n                            open_brace=f\"<{class_name} \",\n                            close_brace=\">\",\n                            children=children,\n                            last=root,\n                            separator=\" \",\n                        )\n                    else:\n                        node = Node(\n                            open_brace=f\"{class_name}(\",\n                            close_brace=\")\",\n                            children=children,\n                            last=root,\n                        )\n                    for last, arg in loop_last(args):\n                        if _safe_isinstance(arg, tuple):\n                            key, child = arg\n                            child_node = _traverse(child, depth=depth + 1)\n                            child_node.last = last\n                            child_node.key_repr = key\n                            child_node.key_separator = \"=\"\n                            append(child_node)\n                        else:\n                            child_node = _traverse(arg, depth=depth + 1)\n                            child_node.last = last\n                            append(child_node)\n            else:\n                node = Node(\n                    value_repr=f\"<{class_name}>\" if angular else f\"{class_name}()\",\n                    children=[],\n                    last=root,\n                )\n            pop_visited(obj_id)\n        elif _is_attr_object(obj) and not fake_attributes:\n            push_visited(obj_id)\n            children = []\n            append = children.append\n\n            attr_fields = _get_attr_fields(obj)\n            if attr_fields:\n                if reached_max_depth:\n                    node = Node(value_repr=f\"{obj.__class__.__name__}(...)\")\n                else:\n                    node = Node(\n                        open_brace=f\"{obj.__class__.__name__}(\",\n                        close_brace=\")\",\n                        children=children,\n                        last=root,\n                    )\n\n                    def iter_attrs() -> Iterable[\n                        Tuple[str, Any, Optional[Callable[[Any], str]]]\n                    ]:\n                        \"\"\"Iterate over attr fields and values.\"\"\"\n                        for attr in attr_fields:\n                            if attr.repr:\n                                try:\n                                    value = getattr(obj, attr.name)\n                                except Exception as error:\n                                    # Can happen, albeit rarely\n                                    yield (attr.name, error, None)\n                                else:\n                                    yield (\n                                        attr.name,\n                                        value,\n                                        attr.repr if callable(attr.repr) else None,\n                                    )\n\n                    for last, (name, value, repr_callable) in loop_last(iter_attrs()):\n                        if repr_callable:\n                            child_node = Node(value_repr=str(repr_callable(value)))\n                        else:\n                            child_node = _traverse(value, depth=depth + 1)\n                        child_node.last = last\n                        child_node.key_repr = name\n                        child_node.key_separator = \"=\"\n                        append(child_node)\n            else:\n                node = Node(\n                    value_repr=f\"{obj.__class__.__name__}()\", children=[], last=root\n                )\n            pop_visited(obj_id)\n        elif (\n            is_dataclass(obj)\n            and not _safe_isinstance(obj, type)\n            and not fake_attributes\n            and _is_dataclass_repr(obj)\n        ):\n            push_visited(obj_id)\n            children = []\n            append = children.append\n            if reached_max_depth:\n                node = Node(value_repr=f\"{obj.__class__.__name__}(...)\")\n            else:\n                node = Node(\n                    open_brace=f\"{obj.__class__.__name__}(\",\n                    close_brace=\")\",\n                    children=children,\n                    last=root,\n                    empty=f\"{obj.__class__.__name__}()\",\n                )\n\n                for last, field in loop_last(\n                    field for field in fields(obj) if field.repr\n                ):\n                    child_node = _traverse(getattr(obj, field.name), depth=depth + 1)\n                    child_node.key_repr = field.name\n                    child_node.last = last\n                    child_node.key_separator = \"=\"\n                    append(child_node)\n\n            pop_visited(obj_id)\n        elif _is_namedtuple(obj) and _has_default_namedtuple_repr(obj):\n            push_visited(obj_id)\n            class_name = obj.__class__.__name__\n            if reached_max_depth:\n                # If we've reached the max depth, we still show the class name, but not its contents\n                node = Node(\n                    value_repr=f\"{class_name}(...)\",\n                )\n            else:\n                children = []\n                append = children.append\n                node = Node(\n                    open_brace=f\"{class_name}(\",\n                    close_brace=\")\",\n                    children=children,\n                    empty=f\"{class_name}()\",\n                )\n                for last, (key, value) in loop_last(obj._asdict().items()):\n                    child_node = _traverse(value, depth=depth + 1)\n                    child_node.key_repr = key\n                    child_node.last = last\n                    child_node.key_separator = \"=\"\n                    append(child_node)\n            pop_visited(obj_id)\n        elif _safe_isinstance(obj, _CONTAINERS):\n            for container_type in _CONTAINERS:\n                if _safe_isinstance(obj, container_type):\n                    obj_type = container_type\n                    break\n\n            push_visited(obj_id)\n\n            open_brace, close_brace, empty = _BRACES[obj_type](obj)\n\n            if reached_max_depth:\n                node = Node(value_repr=f\"{open_brace}...{close_brace}\")\n            elif obj_type.__repr__ != type(obj).__repr__:\n                node = Node(value_repr=to_repr(obj), last=root)\n            elif obj:\n                children = []\n                node = Node(\n                    open_brace=open_brace,\n                    close_brace=close_brace,\n                    children=children,\n                    last=root,\n                )\n                append = children.append\n                num_items = len(obj)\n                last_item_index = num_items - 1\n\n                if _safe_isinstance(obj, _MAPPING_CONTAINERS):\n                    iter_items = iter(obj.items())\n                    if max_length is not None:\n                        iter_items = islice(iter_items, max_length)\n                    for index, (key, child) in enumerate(iter_items):\n                        child_node = _traverse(child, depth=depth + 1)\n                        child_node.key_repr = to_repr(key)\n                        child_node.last = index == last_item_index\n                        append(child_node)\n                else:\n                    iter_values = iter(obj)\n                    if max_length is not None:\n                        iter_values = islice(iter_values, max_length)\n                    for index, child in enumerate(iter_values):\n                        child_node = _traverse(child, depth=depth + 1)\n                        child_node.last = index == last_item_index\n                        append(child_node)\n                if max_length is not None and num_items > max_length:\n                    append(Node(value_repr=f\"... +{num_items - max_length}\", last=True))\n            else:\n                node = Node(empty=empty, children=[], last=root)\n\n            pop_visited(obj_id)\n        else:\n            node = Node(value_repr=to_repr(obj), last=root)\n        node.is_tuple = _safe_isinstance(obj, tuple)\n        node.is_namedtuple = _is_namedtuple(obj)\n        return node\n\n    node = _traverse(_object, root=True)\n    return node\n\n\ndef pretty_repr(\n    _object: Any,\n    *,\n    max_width: int = 80,\n    indent_size: int = 4,\n    max_length: Optional[int] = None,\n    max_string: Optional[int] = None,\n    max_depth: Optional[int] = None,\n    expand_all: bool = False,\n) -> str:\n    \"\"\"Prettify repr string by expanding on to new lines to fit within a given width.\n\n    Args:\n        _object (Any): Object to repr.\n        max_width (int, optional): Desired maximum width of repr string. Defaults to 80.\n        indent_size (int, optional): Number of spaces to indent. Defaults to 4.\n        max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n            Defaults to None.\n        max_string (int, optional): Maximum length of string before truncating, or None to disable truncating.\n            Defaults to None.\n        max_depth (int, optional): Maximum depth of nested data structure, or None for no depth.\n            Defaults to None.\n        expand_all (bool, optional): Expand all containers regardless of available width. Defaults to False.\n\n    Returns:\n        str: A possibly multi-line representation of the object.\n    \"\"\"\n\n    if _safe_isinstance(_object, Node):\n        node = _object\n    else:\n        node = traverse(\n            _object, max_length=max_length, max_string=max_string, max_depth=max_depth\n        )\n    repr_str: str = node.render(\n        max_width=max_width, indent_size=indent_size, expand_all=expand_all\n    )\n    return repr_str\n\n\ndef pprint(\n    _object: Any,\n    *,\n    console: Optional[\"Console\"] = None,\n    indent_guides: bool = True,\n    max_length: Optional[int] = None,\n    max_string: Optional[int] = None,\n    max_depth: Optional[int] = None,\n    expand_all: bool = False,\n) -> None:\n    \"\"\"A convenience function for pretty printing.\n\n    Args:\n        _object (Any): Object to pretty print.\n        console (Console, optional): Console instance, or None to use default. Defaults to None.\n        max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n            Defaults to None.\n        max_string (int, optional): Maximum length of strings before truncating, or None to disable. Defaults to None.\n        max_depth (int, optional): Maximum depth for nested data structures, or None for unlimited depth. Defaults to None.\n        indent_guides (bool, optional): Enable indentation guides. Defaults to True.\n        expand_all (bool, optional): Expand all containers. Defaults to False.\n    \"\"\"\n    _console = get_console() if console is None else console\n    _console.print(\n        Pretty(\n            _object,\n            max_length=max_length,\n            max_string=max_string,\n            max_depth=max_depth,\n            indent_guides=indent_guides,\n            expand_all=expand_all,\n            overflow=\"ignore\",\n        ),\n        soft_wrap=True,\n    )\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n\n    class BrokenRepr:\n        def __repr__(self) -> str:\n            1 / 0\n            return \"this will fail\"\n\n    from typing import NamedTuple\n\n    class StockKeepingUnit(NamedTuple):\n        name: str\n        description: str\n        price: float\n        category: str\n        reviews: List[str]\n\n    d = defaultdict(int)\n    d[\"foo\"] = 5\n    data = {\n        \"foo\": [\n            1,\n            \"Hello World!\",\n            100.123,\n            323.232,\n            432324.0,\n            {5, 6, 7, (1, 2, 3, 4), 8},\n        ],\n        \"bar\": frozenset({1, 2, 3}),\n        \"defaultdict\": defaultdict(\n            list, {\"crumble\": [\"apple\", \"rhubarb\", \"butter\", \"sugar\", \"flour\"]}\n        ),\n        \"counter\": Counter(\n            [\n                \"apple\",\n                \"orange\",\n                \"pear\",\n                \"kumquat\",\n                \"kumquat\",\n                \"durian\" * 100,\n            ]\n        ),\n        \"atomic\": (False, True, None),\n        \"namedtuple\": StockKeepingUnit(\n            \"Sparkling British Spring Water\",\n            \"Carbonated spring water\",\n            0.9,\n            \"water\",\n            [\"its amazing!\", \"its terrible!\"],\n        ),\n        \"Broken\": BrokenRepr(),\n    }\n    data[\"foo\"].append(data)  # type: ignore[attr-defined]\n\n    from pip._vendor.rich import print\n\n    # print(Pretty(data, indent_guides=True, max_string=20))\n\n    class Thing:\n        def __repr__(self) -> str:\n            return \"Hello\\x1b[38;5;239m World!\"\n\n    print(Pretty(Thing()))\n"},"hash":"TIs3D8dYvM"}