{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:commands:index.py","body":"import logging\nfrom optparse import Values\nfrom typing import Any, Iterable, List, Optional, Union\n\nfrom pip._vendor.packaging.version import LegacyVersion, Version\n\nfrom pip._internal.cli import cmdoptions\nfrom pip._internal.cli.req_command import IndexGroupCommand\nfrom pip._internal.cli.status_codes import ERROR, SUCCESS\nfrom pip._internal.commands.search import print_dist_installation_info\nfrom pip._internal.exceptions import CommandError, DistributionNotFound, PipError\nfrom pip._internal.index.collector import LinkCollector\nfrom pip._internal.index.package_finder import PackageFinder\nfrom pip._internal.models.selection_prefs import SelectionPreferences\nfrom pip._internal.models.target_python import TargetPython\nfrom pip._internal.network.session import PipSession\nfrom pip._internal.utils.misc import write_output\n\nlogger = logging.getLogger(__name__)\n\n\nclass IndexCommand(IndexGroupCommand):\n    \"\"\"\n    Inspect information available from package indexes.\n    \"\"\"\n\n    ignore_require_venv = True\n    usage = \"\"\"\n        %prog versions <package>\n    \"\"\"\n\n    def add_options(self) -> None:\n        cmdoptions.add_target_python_options(self.cmd_opts)\n\n        self.cmd_opts.add_option(cmdoptions.ignore_requires_python())\n        self.cmd_opts.add_option(cmdoptions.pre())\n        self.cmd_opts.add_option(cmdoptions.no_binary())\n        self.cmd_opts.add_option(cmdoptions.only_binary())\n\n        index_opts = cmdoptions.make_option_group(\n            cmdoptions.index_group,\n            self.parser,\n        )\n\n        self.parser.insert_option_group(0, index_opts)\n        self.parser.insert_option_group(0, self.cmd_opts)\n\n    def run(self, options: Values, args: List[str]) -> int:\n        handlers = {\n            \"versions\": self.get_available_package_versions,\n        }\n\n        logger.warning(\n            \"pip index is currently an experimental command. \"\n            \"It may be removed/changed in a future release \"\n            \"without prior warning.\"\n        )\n\n        # Determine action\n        if not args or args[0] not in handlers:\n            logger.error(\n                \"Need an action (%s) to perform.\",\n                \", \".join(sorted(handlers)),\n            )\n            return ERROR\n\n        action = args[0]\n\n        # Error handling happens here, not in the action-handlers.\n        try:\n            handlers[action](options, args[1:])\n        except PipError as e:\n            logger.error(e.args[0])\n            return ERROR\n\n        return SUCCESS\n\n    def _build_package_finder(\n        self,\n        options: Values,\n        session: PipSession,\n        target_python: Optional[TargetPython] = None,\n        ignore_requires_python: Optional[bool] = None,\n    ) -> PackageFinder:\n        \"\"\"\n        Create a package finder appropriate to the index command.\n        \"\"\"\n        link_collector = LinkCollector.create(session, options=options)\n\n        # Pass allow_yanked=False to ignore yanked versions.\n        selection_prefs = SelectionPreferences(\n            allow_yanked=False,\n            allow_all_prereleases=options.pre,\n            ignore_requires_python=ignore_requires_python,\n        )\n\n        return PackageFinder.create(\n            link_collector=link_collector,\n            selection_prefs=selection_prefs,\n            target_python=target_python,\n        )\n\n    def get_available_package_versions(self, options: Values, args: List[Any]) -> None:\n        if len(args) != 1:\n            raise CommandError(\"You need to specify exactly one argument\")\n\n        target_python = cmdoptions.make_target_python(options)\n        query = args[0]\n\n        with self._build_session(options) as session:\n            finder = self._build_package_finder(\n                options=options,\n                session=session,\n                target_python=target_python,\n                ignore_requires_python=options.ignore_requires_python,\n            )\n\n            versions: Iterable[Union[LegacyVersion, Version]] = (\n                candidate.version for candidate in finder.find_all_candidates(query)\n            )\n\n            if not options.pre:\n                # Remove prereleases\n                versions = (\n                    version for version in versions if not version.is_prerelease\n                )\n            versions = set(versions)\n\n            if not versions:\n                raise DistributionNotFound(\n                    f\"No matching distribution found for {query}\"\n                )\n\n            formatted_versions = [str(ver) for ver in sorted(versions, reverse=True)]\n            latest = formatted_versions[0]\n\n        write_output(f\"{query} ({latest})\")\n        write_output(\"Available versions: {}\".format(\", \".join(formatted_versions)))\n        print_dist_installation_info(query, latest)\n"},"hash":"nNUa7fohpI"}