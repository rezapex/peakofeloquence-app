{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:metadata:pkg_resources.py","body":"import email.message\nimport email.parser\nimport logging\nimport os\nimport zipfile\nfrom typing import Collection, Iterable, Iterator, List, Mapping, NamedTuple, Optional\n\nfrom pip._vendor import pkg_resources\nfrom pip._vendor.packaging.requirements import Requirement\nfrom pip._vendor.packaging.utils import NormalizedName, canonicalize_name\nfrom pip._vendor.packaging.version import parse as parse_version\n\nfrom pip._internal.exceptions import InvalidWheel, NoneMetadataError, UnsupportedWheel\nfrom pip._internal.utils.egg_link import egg_link_path_from_location\nfrom pip._internal.utils.misc import display_path, normalize_path\nfrom pip._internal.utils.wheel import parse_wheel, read_wheel_metadata_file\n\nfrom .base import (\n    BaseDistribution,\n    BaseEntryPoint,\n    BaseEnvironment,\n    DistributionVersion,\n    InfoPath,\n    Wheel,\n)\n\n__all__ = [\"NAME\", \"Distribution\", \"Environment\"]\n\nlogger = logging.getLogger(__name__)\n\nNAME = \"pkg_resources\"\n\n\nclass EntryPoint(NamedTuple):\n    name: str\n    value: str\n    group: str\n\n\nclass InMemoryMetadata:\n    \"\"\"IMetadataProvider that reads metadata files from a dictionary.\n\n    This also maps metadata decoding exceptions to our internal exception type.\n    \"\"\"\n\n    def __init__(self, metadata: Mapping[str, bytes], wheel_name: str) -> None:\n        self._metadata = metadata\n        self._wheel_name = wheel_name\n\n    def has_metadata(self, name: str) -> bool:\n        return name in self._metadata\n\n    def get_metadata(self, name: str) -> str:\n        try:\n            return self._metadata[name].decode()\n        except UnicodeDecodeError as e:\n            # Augment the default error with the origin of the file.\n            raise UnsupportedWheel(\n                f\"Error decoding metadata for {self._wheel_name}: {e} in {name} file\"\n            )\n\n    def get_metadata_lines(self, name: str) -> Iterable[str]:\n        return pkg_resources.yield_lines(self.get_metadata(name))\n\n    def metadata_isdir(self, name: str) -> bool:\n        return False\n\n    def metadata_listdir(self, name: str) -> List[str]:\n        return []\n\n    def run_script(self, script_name: str, namespace: str) -> None:\n        pass\n\n\nclass Distribution(BaseDistribution):\n    def __init__(self, dist: pkg_resources.Distribution) -> None:\n        self._dist = dist\n\n    @classmethod\n    def from_directory(cls, directory: str) -> BaseDistribution:\n        dist_dir = directory.rstrip(os.sep)\n\n        # Build a PathMetadata object, from path to metadata. :wink:\n        base_dir, dist_dir_name = os.path.split(dist_dir)\n        metadata = pkg_resources.PathMetadata(base_dir, dist_dir)\n\n        # Determine the correct Distribution object type.\n        if dist_dir.endswith(\".egg-info\"):\n            dist_cls = pkg_resources.Distribution\n            dist_name = os.path.splitext(dist_dir_name)[0]\n        else:\n            assert dist_dir.endswith(\".dist-info\")\n            dist_cls = pkg_resources.DistInfoDistribution\n            dist_name = os.path.splitext(dist_dir_name)[0].split(\"-\")[0]\n\n        dist = dist_cls(base_dir, project_name=dist_name, metadata=metadata)\n        return cls(dist)\n\n    @classmethod\n    def from_metadata_file_contents(\n        cls,\n        metadata_contents: bytes,\n        filename: str,\n        project_name: str,\n    ) -> BaseDistribution:\n        metadata_dict = {\n            \"METADATA\": metadata_contents,\n        }\n        dist = pkg_resources.DistInfoDistribution(\n            location=filename,\n            metadata=InMemoryMetadata(metadata_dict, filename),\n            project_name=project_name,\n        )\n        return cls(dist)\n\n    @classmethod\n    def from_wheel(cls, wheel: Wheel, name: str) -> BaseDistribution:\n        try:\n            with wheel.as_zipfile() as zf:\n                info_dir, _ = parse_wheel(zf, name)\n                metadata_dict = {\n                    path.split(\"/\", 1)[-1]: read_wheel_metadata_file(zf, path)\n                    for path in zf.namelist()\n                    if path.startswith(f\"{info_dir}/\")\n                }\n        except zipfile.BadZipFile as e:\n            raise InvalidWheel(wheel.location, name) from e\n        except UnsupportedWheel as e:\n            raise UnsupportedWheel(f\"{name} has an invalid wheel, {e}\")\n        dist = pkg_resources.DistInfoDistribution(\n            location=wheel.location,\n            metadata=InMemoryMetadata(metadata_dict, wheel.location),\n            project_name=name,\n        )\n        return cls(dist)\n\n    @property\n    def location(self) -> Optional[str]:\n        return self._dist.location\n\n    @property\n    def installed_location(self) -> Optional[str]:\n        egg_link = egg_link_path_from_location(self.raw_name)\n        if egg_link:\n            location = egg_link\n        elif self.location:\n            location = self.location\n        else:\n            return None\n        return normalize_path(location)\n\n    @property\n    def info_location(self) -> Optional[str]:\n        return self._dist.egg_info\n\n    @property\n    def installed_by_distutils(self) -> bool:\n        # A distutils-installed distribution is provided by FileMetadata. This\n        # provider has a \"path\" attribute not present anywhere else. Not the\n        # best introspection logic, but pip has been doing this for a long time.\n        try:\n            return bool(self._dist._provider.path)\n        except AttributeError:\n            return False\n\n    @property\n    def canonical_name(self) -> NormalizedName:\n        return canonicalize_name(self._dist.project_name)\n\n    @property\n    def version(self) -> DistributionVersion:\n        return parse_version(self._dist.version)\n\n    def is_file(self, path: InfoPath) -> bool:\n        return self._dist.has_metadata(str(path))\n\n    def iter_distutils_script_names(self) -> Iterator[str]:\n        yield from self._dist.metadata_listdir(\"scripts\")\n\n    def read_text(self, path: InfoPath) -> str:\n        name = str(path)\n        if not self._dist.has_metadata(name):\n            raise FileNotFoundError(name)\n        content = self._dist.get_metadata(name)\n        if content is None:\n            raise NoneMetadataError(self, name)\n        return content\n\n    def iter_entry_points(self) -> Iterable[BaseEntryPoint]:\n        for group, entries in self._dist.get_entry_map().items():\n            for name, entry_point in entries.items():\n                name, _, value = str(entry_point).partition(\"=\")\n                yield EntryPoint(name=name.strip(), value=value.strip(), group=group)\n\n    def _metadata_impl(self) -> email.message.Message:\n        \"\"\"\n        :raises NoneMetadataError: if the distribution reports `has_metadata()`\n            True but `get_metadata()` returns None.\n        \"\"\"\n        if isinstance(self._dist, pkg_resources.DistInfoDistribution):\n            metadata_name = \"METADATA\"\n        else:\n            metadata_name = \"PKG-INFO\"\n        try:\n            metadata = self.read_text(metadata_name)\n        except FileNotFoundError:\n            if self.location:\n                displaying_path = display_path(self.location)\n            else:\n                displaying_path = repr(self.location)\n            logger.warning(\"No metadata found in %s\", displaying_path)\n            metadata = \"\"\n        feed_parser = email.parser.FeedParser()\n        feed_parser.feed(metadata)\n        return feed_parser.close()\n\n    def iter_dependencies(self, extras: Collection[str] = ()) -> Iterable[Requirement]:\n        if extras:  # pkg_resources raises on invalid extras, so we sanitize.\n            extras = frozenset(pkg_resources.safe_extra(e) for e in extras)\n            extras = extras.intersection(self._dist.extras)\n        return self._dist.requires(extras)\n\n    def iter_provided_extras(self) -> Iterable[str]:\n        return self._dist.extras\n\n    def is_extra_provided(self, extra: str) -> bool:\n        return pkg_resources.safe_extra(extra) in self._dist.extras\n\n\nclass Environment(BaseEnvironment):\n    def __init__(self, ws: pkg_resources.WorkingSet) -> None:\n        self._ws = ws\n\n    @classmethod\n    def default(cls) -> BaseEnvironment:\n        return cls(pkg_resources.working_set)\n\n    @classmethod\n    def from_paths(cls, paths: Optional[List[str]]) -> BaseEnvironment:\n        return cls(pkg_resources.WorkingSet(paths))\n\n    def _iter_distributions(self) -> Iterator[BaseDistribution]:\n        for dist in self._ws:\n            yield Distribution(dist)\n\n    def _search_distribution(self, name: str) -> Optional[BaseDistribution]:\n        \"\"\"Find a distribution matching the ``name`` in the environment.\n\n        This searches from *all* distributions available in the environment, to\n        match the behavior of ``pkg_resources.get_distribution()``.\n        \"\"\"\n        canonical_name = canonicalize_name(name)\n        for dist in self.iter_all_distributions():\n            if dist.canonical_name == canonical_name:\n                return dist\n        return None\n\n    def get_distribution(self, name: str) -> Optional[BaseDistribution]:\n        # Search the distribution by looking through the working set.\n        dist = self._search_distribution(name)\n        if dist:\n            return dist\n\n        # If distribution could not be found, call working_set.require to\n        # update the working set, and try to find the distribution again.\n        # This might happen for e.g. when you install a package twice, once\n        # using setup.py develop and again using setup.py install. Now when\n        # running pip uninstall twice, the package gets removed from the\n        # working set in the first uninstall, so we have to populate the\n        # working set again so that pip knows about it and the packages gets\n        # picked up and is successfully uninstalled the second time too.\n        try:\n            # We didn't pass in any version specifiers, so this can never\n            # raise pkg_resources.VersionConflict.\n            self._ws.require(name)\n        except pkg_resources.DistributionNotFound:\n            return None\n        return self._search_distribution(name)\n"},"hash":"29XmlpWfVu"}