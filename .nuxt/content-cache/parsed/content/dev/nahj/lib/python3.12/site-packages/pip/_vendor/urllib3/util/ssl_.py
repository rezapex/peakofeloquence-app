{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:urllib3:util:ssl_.py","body":"from __future__ import absolute_import\n\nimport hmac\nimport os\nimport sys\nimport warnings\nfrom binascii import hexlify, unhexlify\nfrom hashlib import md5, sha1, sha256\n\nfrom ..exceptions import (\n    InsecurePlatformWarning,\n    ProxySchemeUnsupported,\n    SNIMissingWarning,\n    SSLError,\n)\nfrom ..packages import six\nfrom .url import BRACELESS_IPV6_ADDRZ_RE, IPV4_RE\n\nSSLContext = None\nSSLTransport = None\nHAS_SNI = False\nIS_PYOPENSSL = False\nIS_SECURETRANSPORT = False\nALPN_PROTOCOLS = [\"http/1.1\"]\n\n# Maps the length of a digest to a possible hash function producing this digest\nHASHFUNC_MAP = {32: md5, 40: sha1, 64: sha256}\n\n\ndef _const_compare_digest_backport(a, b):\n    \"\"\"\n    Compare two digests of equal length in constant time.\n\n    The digests must be of type str/bytes.\n    Returns True if the digests match, and False otherwise.\n    \"\"\"\n    result = abs(len(a) - len(b))\n    for left, right in zip(bytearray(a), bytearray(b)):\n        result |= left ^ right\n    return result == 0\n\n\n_const_compare_digest = getattr(hmac, \"compare_digest\", _const_compare_digest_backport)\n\ntry:  # Test for SSL features\n    import ssl\n    from ssl import CERT_REQUIRED, wrap_socket\nexcept ImportError:\n    pass\n\ntry:\n    from ssl import HAS_SNI  # Has SNI?\nexcept ImportError:\n    pass\n\ntry:\n    from .ssltransport import SSLTransport\nexcept ImportError:\n    pass\n\n\ntry:  # Platform-specific: Python 3.6\n    from ssl import PROTOCOL_TLS\n\n    PROTOCOL_SSLv23 = PROTOCOL_TLS\nexcept ImportError:\n    try:\n        from ssl import PROTOCOL_SSLv23 as PROTOCOL_TLS\n\n        PROTOCOL_SSLv23 = PROTOCOL_TLS\n    except ImportError:\n        PROTOCOL_SSLv23 = PROTOCOL_TLS = 2\n\ntry:\n    from ssl import PROTOCOL_TLS_CLIENT\nexcept ImportError:\n    PROTOCOL_TLS_CLIENT = PROTOCOL_TLS\n\n\ntry:\n    from ssl import OP_NO_COMPRESSION, OP_NO_SSLv2, OP_NO_SSLv3\nexcept ImportError:\n    OP_NO_SSLv2, OP_NO_SSLv3 = 0x1000000, 0x2000000\n    OP_NO_COMPRESSION = 0x20000\n\n\ntry:  # OP_NO_TICKET was added in Python 3.6\n    from ssl import OP_NO_TICKET\nexcept ImportError:\n    OP_NO_TICKET = 0x4000\n\n\n# A secure default.\n# Sources for more information on TLS ciphers:\n#\n# - https://wiki.mozilla.org/Security/Server_Side_TLS\n# - https://www.ssllabs.com/projects/best-practices/index.html\n# - https://hynek.me/articles/hardening-your-web-servers-ssl-ciphers/\n#\n# The general intent is:\n# - prefer cipher suites that offer perfect forward secrecy (DHE/ECDHE),\n# - prefer ECDHE over DHE for better performance,\n# - prefer any AES-GCM and ChaCha20 over any AES-CBC for better performance and\n#   security,\n# - prefer AES-GCM over ChaCha20 because hardware-accelerated AES is common,\n# - disable NULL authentication, MD5 MACs, DSS, and other\n#   insecure ciphers for security reasons.\n# - NOTE: TLS 1.3 cipher suites are managed through a different interface\n#   not exposed by CPython (yet!) and are enabled by default if they're available.\nDEFAULT_CIPHERS = \":\".join(\n    [\n        \"ECDHE+AESGCM\",\n        \"ECDHE+CHACHA20\",\n        \"DHE+AESGCM\",\n        \"DHE+CHACHA20\",\n        \"ECDH+AESGCM\",\n        \"DH+AESGCM\",\n        \"ECDH+AES\",\n        \"DH+AES\",\n        \"RSA+AESGCM\",\n        \"RSA+AES\",\n        \"!aNULL\",\n        \"!eNULL\",\n        \"!MD5\",\n        \"!DSS\",\n    ]\n)\n\ntry:\n    from ssl import SSLContext  # Modern SSL?\nexcept ImportError:\n\n    class SSLContext(object):  # Platform-specific: Python 2\n        def __init__(self, protocol_version):\n            self.protocol = protocol_version\n            # Use default values from a real SSLContext\n            self.check_hostname = False\n            self.verify_mode = ssl.CERT_NONE\n            self.ca_certs = None\n            self.options = 0\n            self.certfile = None\n            self.keyfile = None\n            self.ciphers = None\n\n        def load_cert_chain(self, certfile, keyfile):\n            self.certfile = certfile\n            self.keyfile = keyfile\n\n        def load_verify_locations(self, cafile=None, capath=None, cadata=None):\n            self.ca_certs = cafile\n\n            if capath is not None:\n                raise SSLError(\"CA directories not supported in older Pythons\")\n\n            if cadata is not None:\n                raise SSLError(\"CA data not supported in older Pythons\")\n\n        def set_ciphers(self, cipher_suite):\n            self.ciphers = cipher_suite\n\n        def wrap_socket(self, socket, server_hostname=None, server_side=False):\n            warnings.warn(\n                \"A true SSLContext object is not available. This prevents \"\n                \"urllib3 from configuring SSL appropriately and may cause \"\n                \"certain SSL connections to fail. You can upgrade to a newer \"\n                \"version of Python to solve this. For more information, see \"\n                \"https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html\"\n                \"#ssl-warnings\",\n                InsecurePlatformWarning,\n            )\n            kwargs = {\n                \"keyfile\": self.keyfile,\n                \"certfile\": self.certfile,\n                \"ca_certs\": self.ca_certs,\n                \"cert_reqs\": self.verify_mode,\n                \"ssl_version\": self.protocol,\n                \"server_side\": server_side,\n            }\n            return wrap_socket(socket, ciphers=self.ciphers, **kwargs)\n\n\ndef assert_fingerprint(cert, fingerprint):\n    \"\"\"\n    Checks if given fingerprint matches the supplied certificate.\n\n    :param cert:\n        Certificate as bytes object.\n    :param fingerprint:\n        Fingerprint as string of hexdigits, can be interspersed by colons.\n    \"\"\"\n\n    fingerprint = fingerprint.replace(\":\", \"\").lower()\n    digest_length = len(fingerprint)\n    hashfunc = HASHFUNC_MAP.get(digest_length)\n    if not hashfunc:\n        raise SSLError(\"Fingerprint of invalid length: {0}\".format(fingerprint))\n\n    # We need encode() here for py32; works on py2 and p33.\n    fingerprint_bytes = unhexlify(fingerprint.encode())\n\n    cert_digest = hashfunc(cert).digest()\n\n    if not _const_compare_digest(cert_digest, fingerprint_bytes):\n        raise SSLError(\n            'Fingerprints did not match. Expected \"{0}\", got \"{1}\".'.format(\n                fingerprint, hexlify(cert_digest)\n            )\n        )\n\n\ndef resolve_cert_reqs(candidate):\n    \"\"\"\n    Resolves the argument to a numeric constant, which can be passed to\n    the wrap_socket function/method from the ssl module.\n    Defaults to :data:`ssl.CERT_REQUIRED`.\n    If given a string it is assumed to be the name of the constant in the\n    :mod:`ssl` module or its abbreviation.\n    (So you can specify `REQUIRED` instead of `CERT_REQUIRED`.\n    If it's neither `None` nor a string we assume it is already the numeric\n    constant which can directly be passed to wrap_socket.\n    \"\"\"\n    if candidate is None:\n        return CERT_REQUIRED\n\n    if isinstance(candidate, str):\n        res = getattr(ssl, candidate, None)\n        if res is None:\n            res = getattr(ssl, \"CERT_\" + candidate)\n        return res\n\n    return candidate\n\n\ndef resolve_ssl_version(candidate):\n    \"\"\"\n    like resolve_cert_reqs\n    \"\"\"\n    if candidate is None:\n        return PROTOCOL_TLS\n\n    if isinstance(candidate, str):\n        res = getattr(ssl, candidate, None)\n        if res is None:\n            res = getattr(ssl, \"PROTOCOL_\" + candidate)\n        return res\n\n    return candidate\n\n\ndef create_urllib3_context(\n    ssl_version=None, cert_reqs=None, options=None, ciphers=None\n):\n    \"\"\"All arguments have the same meaning as ``ssl_wrap_socket``.\n\n    By default, this function does a lot of the same work that\n    ``ssl.create_default_context`` does on Python 3.4+. It:\n\n    - Disables SSLv2, SSLv3, and compression\n    - Sets a restricted set of server ciphers\n\n    If you wish to enable SSLv3, you can do::\n\n        from pip._vendor.urllib3.util import ssl_\n        context = ssl_.create_urllib3_context()\n        context.options &= ~ssl_.OP_NO_SSLv3\n\n    You can do the same to enable compression (substituting ``COMPRESSION``\n    for ``SSLv3`` in the last line above).\n\n    :param ssl_version:\n        The desired protocol version to use. This will default to\n        PROTOCOL_SSLv23 which will negotiate the highest protocol that both\n        the server and your installation of OpenSSL support.\n    :param cert_reqs:\n        Whether to require the certificate verification. This defaults to\n        ``ssl.CERT_REQUIRED``.\n    :param options:\n        Specific OpenSSL options. These default to ``ssl.OP_NO_SSLv2``,\n        ``ssl.OP_NO_SSLv3``, ``ssl.OP_NO_COMPRESSION``, and ``ssl.OP_NO_TICKET``.\n    :param ciphers:\n        Which cipher suites to allow the server to select.\n    :returns:\n        Constructed SSLContext object with specified options\n    :rtype: SSLContext\n    \"\"\"\n    # PROTOCOL_TLS is deprecated in Python 3.10\n    if not ssl_version or ssl_version == PROTOCOL_TLS:\n        ssl_version = PROTOCOL_TLS_CLIENT\n\n    context = SSLContext(ssl_version)\n\n    context.set_ciphers(ciphers or DEFAULT_CIPHERS)\n\n    # Setting the default here, as we may have no ssl module on import\n    cert_reqs = ssl.CERT_REQUIRED if cert_reqs is None else cert_reqs\n\n    if options is None:\n        options = 0\n        # SSLv2 is easily broken and is considered harmful and dangerous\n        options |= OP_NO_SSLv2\n        # SSLv3 has several problems and is now dangerous\n        options |= OP_NO_SSLv3\n        # Disable compression to prevent CRIME attacks for OpenSSL 1.0+\n        # (issue #309)\n        options |= OP_NO_COMPRESSION\n        # TLSv1.2 only. Unless set explicitly, do not request tickets.\n        # This may save some bandwidth on wire, and although the ticket is encrypted,\n        # there is a risk associated with it being on wire,\n        # if the server is not rotating its ticketing keys properly.\n        options |= OP_NO_TICKET\n\n    context.options |= options\n\n    # Enable post-handshake authentication for TLS 1.3, see GH #1634. PHA is\n    # necessary for conditional client cert authentication with TLS 1.3.\n    # The attribute is None for OpenSSL <= 1.1.0 or does not exist in older\n    # versions of Python.  We only enable on Python 3.7.4+ or if certificate\n    # verification is enabled to work around Python issue #37428\n    # See: https://bugs.python.org/issue37428\n    if (cert_reqs == ssl.CERT_REQUIRED or sys.version_info >= (3, 7, 4)) and getattr(\n        context, \"post_handshake_auth\", None\n    ) is not None:\n        context.post_handshake_auth = True\n\n    def disable_check_hostname():\n        if (\n            getattr(context, \"check_hostname\", None) is not None\n        ):  # Platform-specific: Python 3.2\n            # We do our own verification, including fingerprints and alternative\n            # hostnames. So disable it here\n            context.check_hostname = False\n\n    # The order of the below lines setting verify_mode and check_hostname\n    # matter due to safe-guards SSLContext has to prevent an SSLContext with\n    # check_hostname=True, verify_mode=NONE/OPTIONAL. This is made even more\n    # complex because we don't know whether PROTOCOL_TLS_CLIENT will be used\n    # or not so we don't know the initial state of the freshly created SSLContext.\n    if cert_reqs == ssl.CERT_REQUIRED:\n        context.verify_mode = cert_reqs\n        disable_check_hostname()\n    else:\n        disable_check_hostname()\n        context.verify_mode = cert_reqs\n\n    # Enable logging of TLS session keys via defacto standard environment variable\n    # 'SSLKEYLOGFILE', if the feature is available (Python 3.8+). Skip empty values.\n    if hasattr(context, \"keylog_filename\"):\n        sslkeylogfile = os.environ.get(\"SSLKEYLOGFILE\")\n        if sslkeylogfile:\n            context.keylog_filename = sslkeylogfile\n\n    return context\n\n\ndef ssl_wrap_socket(\n    sock,\n    keyfile=None,\n    certfile=None,\n    cert_reqs=None,\n    ca_certs=None,\n    server_hostname=None,\n    ssl_version=None,\n    ciphers=None,\n    ssl_context=None,\n    ca_cert_dir=None,\n    key_password=None,\n    ca_cert_data=None,\n    tls_in_tls=False,\n):\n    \"\"\"\n    All arguments except for server_hostname, ssl_context, and ca_cert_dir have\n    the same meaning as they do when using :func:`ssl.wrap_socket`.\n\n    :param server_hostname:\n        When SNI is supported, the expected hostname of the certificate\n    :param ssl_context:\n        A pre-made :class:`SSLContext` object. If none is provided, one will\n        be created using :func:`create_urllib3_context`.\n    :param ciphers:\n        A string of ciphers we wish the client to support.\n    :param ca_cert_dir:\n        A directory containing CA certificates in multiple separate files, as\n        supported by OpenSSL's -CApath flag or the capath argument to\n        SSLContext.load_verify_locations().\n    :param key_password:\n        Optional password if the keyfile is encrypted.\n    :param ca_cert_data:\n        Optional string containing CA certificates in PEM format suitable for\n        passing as the cadata parameter to SSLContext.load_verify_locations()\n    :param tls_in_tls:\n        Use SSLTransport to wrap the existing socket.\n    \"\"\"\n    context = ssl_context\n    if context is None:\n        # Note: This branch of code and all the variables in it are no longer\n        # used by urllib3 itself. We should consider deprecating and removing\n        # this code.\n        context = create_urllib3_context(ssl_version, cert_reqs, ciphers=ciphers)\n\n    if ca_certs or ca_cert_dir or ca_cert_data:\n        try:\n            context.load_verify_locations(ca_certs, ca_cert_dir, ca_cert_data)\n        except (IOError, OSError) as e:\n            raise SSLError(e)\n\n    elif ssl_context is None and hasattr(context, \"load_default_certs\"):\n        # try to load OS default certs; works well on Windows (require Python3.4+)\n        context.load_default_certs()\n\n    # Attempt to detect if we get the goofy behavior of the\n    # keyfile being encrypted and OpenSSL asking for the\n    # passphrase via the terminal and instead error out.\n    if keyfile and key_password is None and _is_key_file_encrypted(keyfile):\n        raise SSLError(\"Client private key is encrypted, password is required\")\n\n    if certfile:\n        if key_password is None:\n            context.load_cert_chain(certfile, keyfile)\n        else:\n            context.load_cert_chain(certfile, keyfile, key_password)\n\n    try:\n        if hasattr(context, \"set_alpn_protocols\"):\n            context.set_alpn_protocols(ALPN_PROTOCOLS)\n    except NotImplementedError:  # Defensive: in CI, we always have set_alpn_protocols\n        pass\n\n    # If we detect server_hostname is an IP address then the SNI\n    # extension should not be used according to RFC3546 Section 3.1\n    use_sni_hostname = server_hostname and not is_ipaddress(server_hostname)\n    # SecureTransport uses server_hostname in certificate verification.\n    send_sni = (use_sni_hostname and HAS_SNI) or (\n        IS_SECURETRANSPORT and server_hostname\n    )\n    # Do not warn the user if server_hostname is an invalid SNI hostname.\n    if not HAS_SNI and use_sni_hostname:\n        warnings.warn(\n            \"An HTTPS request has been made, but the SNI (Server Name \"\n            \"Indication) extension to TLS is not available on this platform. \"\n            \"This may cause the server to present an incorrect TLS \"\n            \"certificate, which can cause validation failures. You can upgrade to \"\n            \"a newer version of Python to solve this. For more information, see \"\n            \"https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html\"\n            \"#ssl-warnings\",\n            SNIMissingWarning,\n        )\n\n    if send_sni:\n        ssl_sock = _ssl_wrap_socket_impl(\n            sock, context, tls_in_tls, server_hostname=server_hostname\n        )\n    else:\n        ssl_sock = _ssl_wrap_socket_impl(sock, context, tls_in_tls)\n    return ssl_sock\n\n\ndef is_ipaddress(hostname):\n    \"\"\"Detects whether the hostname given is an IPv4 or IPv6 address.\n    Also detects IPv6 addresses with Zone IDs.\n\n    :param str hostname: Hostname to examine.\n    :return: True if the hostname is an IP address, False otherwise.\n    \"\"\"\n    if not six.PY2 and isinstance(hostname, bytes):\n        # IDN A-label bytes are ASCII compatible.\n        hostname = hostname.decode(\"ascii\")\n    return bool(IPV4_RE.match(hostname) or BRACELESS_IPV6_ADDRZ_RE.match(hostname))\n\n\ndef _is_key_file_encrypted(key_file):\n    \"\"\"Detects if a key file is encrypted or not.\"\"\"\n    with open(key_file, \"r\") as f:\n        for line in f:\n            # Look for Proc-Type: 4,ENCRYPTED\n            if \"ENCRYPTED\" in line:\n                return True\n\n    return False\n\n\ndef _ssl_wrap_socket_impl(sock, ssl_context, tls_in_tls, server_hostname=None):\n    if tls_in_tls:\n        if not SSLTransport:\n            # Import error, ssl is not available.\n            raise ProxySchemeUnsupported(\n                \"TLS in TLS requires support for the 'ssl' module\"\n            )\n\n        SSLTransport._validate_ssl_context_for_tls_in_tls(ssl_context)\n        return SSLTransport(sock, ssl_context, server_hostname)\n\n    if server_hostname:\n        return ssl_context.wrap_socket(sock, server_hostname=server_hostname)\n    else:\n        return ssl_context.wrap_socket(sock)\n"},"hash":"8gXNWNrurL"}