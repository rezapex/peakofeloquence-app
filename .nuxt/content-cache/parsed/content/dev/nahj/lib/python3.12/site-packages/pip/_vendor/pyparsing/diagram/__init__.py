{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:pyparsing:diagram:__init__.py","body":"# mypy: ignore-errors\nimport railroad\nfrom pip._vendor import pyparsing\nimport typing\nfrom typing import (\n    List,\n    NamedTuple,\n    Generic,\n    TypeVar,\n    Dict,\n    Callable,\n    Set,\n    Iterable,\n)\nfrom jinja2 import Template\nfrom io import StringIO\nimport inspect\n\n\njinja2_template_source = \"\"\"\\\n{% if not embed %}\n<!DOCTYPE html>\n<html>\n<head>\n{% endif %}\n    {% if not head %}\n        <style>\n            .railroad-heading {\n                font-family: monospace;\n            }\n        </style>\n    {% else %}\n        {{ head | safe }}\n    {% endif %}\n{% if not embed %}\n</head>\n<body>\n{% endif %}\n{{ body | safe }}\n{% for diagram in diagrams %}\n    <div class=\"railroad-group\">\n        <h1 class=\"railroad-heading\">{{ diagram.title }}</h1>\n        <div class=\"railroad-description\">{{ diagram.text }}</div>\n        <div class=\"railroad-svg\">\n            {{ diagram.svg }}\n        </div>\n    </div>\n{% endfor %}\n{% if not embed %}\n</body>\n</html>\n{% endif %}\n\"\"\"\n\ntemplate = Template(jinja2_template_source)\n\n# Note: ideally this would be a dataclass, but we're supporting Python 3.5+ so we can't do this yet\nNamedDiagram = NamedTuple(\n    \"NamedDiagram\",\n    [(\"name\", str), (\"diagram\", typing.Optional[railroad.DiagramItem]), (\"index\", int)],\n)\n\"\"\"\nA simple structure for associating a name with a railroad diagram\n\"\"\"\n\nT = TypeVar(\"T\")\n\n\nclass EachItem(railroad.Group):\n    \"\"\"\n    Custom railroad item to compose a:\n    - Group containing a\n      - OneOrMore containing a\n        - Choice of the elements in the Each\n    with the group label indicating that all must be matched\n    \"\"\"\n\n    all_label = \"[ALL]\"\n\n    def __init__(self, *items):\n        choice_item = railroad.Choice(len(items) - 1, *items)\n        one_or_more_item = railroad.OneOrMore(item=choice_item)\n        super().__init__(one_or_more_item, label=self.all_label)\n\n\nclass AnnotatedItem(railroad.Group):\n    \"\"\"\n    Simple subclass of Group that creates an annotation label\n    \"\"\"\n\n    def __init__(self, label: str, item):\n        super().__init__(item=item, label=\"[{}]\".format(label) if label else label)\n\n\nclass EditablePartial(Generic[T]):\n    \"\"\"\n    Acts like a functools.partial, but can be edited. In other words, it represents a type that hasn't yet been\n    constructed.\n    \"\"\"\n\n    # We need this here because the railroad constructors actually transform the data, so can't be called until the\n    # entire tree is assembled\n\n    def __init__(self, func: Callable[..., T], args: list, kwargs: dict):\n        self.func = func\n        self.args = args\n        self.kwargs = kwargs\n\n    @classmethod\n    def from_call(cls, func: Callable[..., T], *args, **kwargs) -> \"EditablePartial[T]\":\n        \"\"\"\n        If you call this function in the same way that you would call the constructor, it will store the arguments\n        as you expect. For example EditablePartial.from_call(Fraction, 1, 3)() == Fraction(1, 3)\n        \"\"\"\n        return EditablePartial(func=func, args=list(args), kwargs=kwargs)\n\n    @property\n    def name(self):\n        return self.kwargs[\"name\"]\n\n    def __call__(self) -> T:\n        \"\"\"\n        Evaluate the partial and return the result\n        \"\"\"\n        args = self.args.copy()\n        kwargs = self.kwargs.copy()\n\n        # This is a helpful hack to allow you to specify varargs parameters (e.g. *args) as keyword args (e.g.\n        # args=['list', 'of', 'things'])\n        arg_spec = inspect.getfullargspec(self.func)\n        if arg_spec.varargs in self.kwargs:\n            args += kwargs.pop(arg_spec.varargs)\n\n        return self.func(*args, **kwargs)\n\n\ndef railroad_to_html(diagrams: List[NamedDiagram], embed=False, **kwargs) -> str:\n    \"\"\"\n    Given a list of NamedDiagram, produce a single HTML string that visualises those diagrams\n    :params kwargs: kwargs to be passed in to the template\n    \"\"\"\n    data = []\n    for diagram in diagrams:\n        if diagram.diagram is None:\n            continue\n        io = StringIO()\n        try:\n            css = kwargs.get('css')\n            diagram.diagram.writeStandalone(io.write, css=css)\n        except AttributeError:\n            diagram.diagram.writeSvg(io.write)\n        title = diagram.name\n        if diagram.index == 0:\n            title += \" (root)\"\n        data.append({\"title\": title, \"text\": \"\", \"svg\": io.getvalue()})\n\n    return template.render(diagrams=data, embed=embed, **kwargs)\n\n\ndef resolve_partial(partial: \"EditablePartial[T]\") -> T:\n    \"\"\"\n    Recursively resolves a collection of Partials into whatever type they are\n    \"\"\"\n    if isinstance(partial, EditablePartial):\n        partial.args = resolve_partial(partial.args)\n        partial.kwargs = resolve_partial(partial.kwargs)\n        return partial()\n    elif isinstance(partial, list):\n        return [resolve_partial(x) for x in partial]\n    elif isinstance(partial, dict):\n        return {key: resolve_partial(x) for key, x in partial.items()}\n    else:\n        return partial\n\n\ndef to_railroad(\n    element: pyparsing.ParserElement,\n    diagram_kwargs: typing.Optional[dict] = None,\n    vertical: int = 3,\n    show_results_names: bool = False,\n    show_groups: bool = False,\n) -> List[NamedDiagram]:\n    \"\"\"\n    Convert a pyparsing element tree into a list of diagrams. This is the recommended entrypoint to diagram\n    creation if you want to access the Railroad tree before it is converted to HTML\n    :param element: base element of the parser being diagrammed\n    :param diagram_kwargs: kwargs to pass to the Diagram() constructor\n    :param vertical: (optional) - int - limit at which number of alternatives should be\n       shown vertically instead of horizontally\n    :param show_results_names - bool to indicate whether results name annotations should be\n       included in the diagram\n    :param show_groups - bool to indicate whether groups should be highlighted with an unlabeled\n       surrounding box\n    \"\"\"\n    # Convert the whole tree underneath the root\n    lookup = ConverterState(diagram_kwargs=diagram_kwargs or {})\n    _to_diagram_element(\n        element,\n        lookup=lookup,\n        parent=None,\n        vertical=vertical,\n        show_results_names=show_results_names,\n        show_groups=show_groups,\n    )\n\n    root_id = id(element)\n    # Convert the root if it hasn't been already\n    if root_id in lookup:\n        if not element.customName:\n            lookup[root_id].name = \"\"\n        lookup[root_id].mark_for_extraction(root_id, lookup, force=True)\n\n    # Now that we're finished, we can convert from intermediate structures into Railroad elements\n    diags = list(lookup.diagrams.values())\n    if len(diags) > 1:\n        # collapse out duplicate diags with the same name\n        seen = set()\n        deduped_diags = []\n        for d in diags:\n            # don't extract SkipTo elements, they are uninformative as subdiagrams\n            if d.name == \"...\":\n                continue\n            if d.name is not None and d.name not in seen:\n                seen.add(d.name)\n                deduped_diags.append(d)\n        resolved = [resolve_partial(partial) for partial in deduped_diags]\n    else:\n        # special case - if just one diagram, always display it, even if\n        # it has no name\n        resolved = [resolve_partial(partial) for partial in diags]\n    return sorted(resolved, key=lambda diag: diag.index)\n\n\ndef _should_vertical(\n    specification: int, exprs: Iterable[pyparsing.ParserElement]\n) -> bool:\n    \"\"\"\n    Returns true if we should return a vertical list of elements\n    \"\"\"\n    if specification is None:\n        return False\n    else:\n        return len(_visible_exprs(exprs)) >= specification\n\n\nclass ElementState:\n    \"\"\"\n    State recorded for an individual pyparsing Element\n    \"\"\"\n\n    # Note: this should be a dataclass, but we have to support Python 3.5\n    def __init__(\n        self,\n        element: pyparsing.ParserElement,\n        converted: EditablePartial,\n        parent: EditablePartial,\n        number: int,\n        name: str = None,\n        parent_index: typing.Optional[int] = None,\n    ):\n        #: The pyparsing element that this represents\n        self.element: pyparsing.ParserElement = element\n        #: The name of the element\n        self.name: typing.Optional[str] = name\n        #: The output Railroad element in an unconverted state\n        self.converted: EditablePartial = converted\n        #: The parent Railroad element, which we store so that we can extract this if it's duplicated\n        self.parent: EditablePartial = parent\n        #: The order in which we found this element, used for sorting diagrams if this is extracted into a diagram\n        self.number: int = number\n        #: The index of this inside its parent\n        self.parent_index: typing.Optional[int] = parent_index\n        #: If true, we should extract this out into a subdiagram\n        self.extract: bool = False\n        #: If true, all of this element's children have been filled out\n        self.complete: bool = False\n\n    def mark_for_extraction(\n        self, el_id: int, state: \"ConverterState\", name: str = None, force: bool = False\n    ):\n        \"\"\"\n        Called when this instance has been seen twice, and thus should eventually be extracted into a sub-diagram\n        :param el_id: id of the element\n        :param state: element/diagram state tracker\n        :param name: name to use for this element's text\n        :param force: If true, force extraction now, regardless of the state of this. Only useful for extracting the\n        root element when we know we're finished\n        \"\"\"\n        self.extract = True\n\n        # Set the name\n        if not self.name:\n            if name:\n                # Allow forcing a custom name\n                self.name = name\n            elif self.element.customName:\n                self.name = self.element.customName\n            else:\n                self.name = \"\"\n\n        # Just because this is marked for extraction doesn't mean we can do it yet. We may have to wait for children\n        # to be added\n        # Also, if this is just a string literal etc, don't bother extracting it\n        if force or (self.complete and _worth_extracting(self.element)):\n            state.extract_into_diagram(el_id)\n\n\nclass ConverterState:\n    \"\"\"\n    Stores some state that persists between recursions into the element tree\n    \"\"\"\n\n    def __init__(self, diagram_kwargs: typing.Optional[dict] = None):\n        #: A dictionary mapping ParserElements to state relating to them\n        self._element_diagram_states: Dict[int, ElementState] = {}\n        #: A dictionary mapping ParserElement IDs to subdiagrams generated from them\n        self.diagrams: Dict[int, EditablePartial[NamedDiagram]] = {}\n        #: The index of the next unnamed element\n        self.unnamed_index: int = 1\n        #: The index of the next element. This is used for sorting\n        self.index: int = 0\n        #: Shared kwargs that are used to customize the construction of diagrams\n        self.diagram_kwargs: dict = diagram_kwargs or {}\n        self.extracted_diagram_names: Set[str] = set()\n\n    def __setitem__(self, key: int, value: ElementState):\n        self._element_diagram_states[key] = value\n\n    def __getitem__(self, key: int) -> ElementState:\n        return self._element_diagram_states[key]\n\n    def __delitem__(self, key: int):\n        del self._element_diagram_states[key]\n\n    def __contains__(self, key: int):\n        return key in self._element_diagram_states\n\n    def generate_unnamed(self) -> int:\n        \"\"\"\n        Generate a number used in the name of an otherwise unnamed diagram\n        \"\"\"\n        self.unnamed_index += 1\n        return self.unnamed_index\n\n    def generate_index(self) -> int:\n        \"\"\"\n        Generate a number used to index a diagram\n        \"\"\"\n        self.index += 1\n        return self.index\n\n    def extract_into_diagram(self, el_id: int):\n        \"\"\"\n        Used when we encounter the same token twice in the same tree. When this\n        happens, we replace all instances of that token with a terminal, and\n        create a new subdiagram for the token\n        \"\"\"\n        position = self[el_id]\n\n        # Replace the original definition of this element with a regular block\n        if position.parent:\n            ret = EditablePartial.from_call(railroad.NonTerminal, text=position.name)\n            if \"item\" in position.parent.kwargs:\n                position.parent.kwargs[\"item\"] = ret\n            elif \"items\" in position.parent.kwargs:\n                position.parent.kwargs[\"items\"][position.parent_index] = ret\n\n        # If the element we're extracting is a group, skip to its content but keep the title\n        if position.converted.func == railroad.Group:\n            content = position.converted.kwargs[\"item\"]\n        else:\n            content = position.converted\n\n        self.diagrams[el_id] = EditablePartial.from_call(\n            NamedDiagram,\n            name=position.name,\n            diagram=EditablePartial.from_call(\n                railroad.Diagram, content, **self.diagram_kwargs\n            ),\n            index=position.number,\n        )\n\n        del self[el_id]\n\n\ndef _worth_extracting(element: pyparsing.ParserElement) -> bool:\n    \"\"\"\n    Returns true if this element is worth having its own sub-diagram. Simply, if any of its children\n    themselves have children, then its complex enough to extract\n    \"\"\"\n    children = element.recurse()\n    return any(child.recurse() for child in children)\n\n\ndef _apply_diagram_item_enhancements(fn):\n    \"\"\"\n    decorator to ensure enhancements to a diagram item (such as results name annotations)\n    get applied on return from _to_diagram_element (we do this since there are several\n    returns in _to_diagram_element)\n    \"\"\"\n\n    def _inner(\n        element: pyparsing.ParserElement,\n        parent: typing.Optional[EditablePartial],\n        lookup: ConverterState = None,\n        vertical: int = None,\n        index: int = 0,\n        name_hint: str = None,\n        show_results_names: bool = False,\n        show_groups: bool = False,\n    ) -> typing.Optional[EditablePartial]:\n        ret = fn(\n            element,\n            parent,\n            lookup,\n            vertical,\n            index,\n            name_hint,\n            show_results_names,\n            show_groups,\n        )\n\n        # apply annotation for results name, if present\n        if show_results_names and ret is not None:\n            element_results_name = element.resultsName\n            if element_results_name:\n                # add \"*\" to indicate if this is a \"list all results\" name\n                element_results_name += \"\" if element.modalResults else \"*\"\n                ret = EditablePartial.from_call(\n                    railroad.Group, item=ret, label=element_results_name\n                )\n\n        return ret\n\n    return _inner\n\n\ndef _visible_exprs(exprs: Iterable[pyparsing.ParserElement]):\n    non_diagramming_exprs = (\n        pyparsing.ParseElementEnhance,\n        pyparsing.PositionToken,\n        pyparsing.And._ErrorStop,\n    )\n    return [\n        e\n        for e in exprs\n        if not (e.customName or e.resultsName or isinstance(e, non_diagramming_exprs))\n    ]\n\n\n@_apply_diagram_item_enhancements\ndef _to_diagram_element(\n    element: pyparsing.ParserElement,\n    parent: typing.Optional[EditablePartial],\n    lookup: ConverterState = None,\n    vertical: int = None,\n    index: int = 0,\n    name_hint: str = None,\n    show_results_names: bool = False,\n    show_groups: bool = False,\n) -> typing.Optional[EditablePartial]:\n    \"\"\"\n    Recursively converts a PyParsing Element to a railroad Element\n    :param lookup: The shared converter state that keeps track of useful things\n    :param index: The index of this element within the parent\n    :param parent: The parent of this element in the output tree\n    :param vertical: Controls at what point we make a list of elements vertical. If this is an integer (the default),\n    it sets the threshold of the number of items before we go vertical. If True, always go vertical, if False, never\n    do so\n    :param name_hint: If provided, this will override the generated name\n    :param show_results_names: bool flag indicating whether to add annotations for results names\n    :returns: The converted version of the input element, but as a Partial that hasn't yet been constructed\n    :param show_groups: bool flag indicating whether to show groups using bounding box\n    \"\"\"\n    exprs = element.recurse()\n    name = name_hint or element.customName or element.__class__.__name__\n\n    # Python's id() is used to provide a unique identifier for elements\n    el_id = id(element)\n\n    element_results_name = element.resultsName\n\n    # Here we basically bypass processing certain wrapper elements if they contribute nothing to the diagram\n    if not element.customName:\n        if isinstance(\n            element,\n            (\n                # pyparsing.TokenConverter,\n                # pyparsing.Forward,\n                pyparsing.Located,\n            ),\n        ):\n            # However, if this element has a useful custom name, and its child does not, we can pass it on to the child\n            if exprs:\n                if not exprs[0].customName:\n                    propagated_name = name\n                else:\n                    propagated_name = None\n\n                return _to_diagram_element(\n                    element.expr,\n                    parent=parent,\n                    lookup=lookup,\n                    vertical=vertical,\n                    index=index,\n                    name_hint=propagated_name,\n                    show_results_names=show_results_names,\n                    show_groups=show_groups,\n                )\n\n    # If the element isn't worth extracting, we always treat it as the first time we say it\n    if _worth_extracting(element):\n        if el_id in lookup:\n            # If we've seen this element exactly once before, we are only just now finding out that it's a duplicate,\n            # so we have to extract it into a new diagram.\n            looked_up = lookup[el_id]\n            looked_up.mark_for_extraction(el_id, lookup, name=name_hint)\n            ret = EditablePartial.from_call(railroad.NonTerminal, text=looked_up.name)\n            return ret\n\n        elif el_id in lookup.diagrams:\n            # If we have seen the element at least twice before, and have already extracted it into a subdiagram, we\n            # just put in a marker element that refers to the sub-diagram\n            ret = EditablePartial.from_call(\n                railroad.NonTerminal, text=lookup.diagrams[el_id].kwargs[\"name\"]\n            )\n            return ret\n\n    # Recursively convert child elements\n    # Here we find the most relevant Railroad element for matching pyparsing Element\n    # We use ``items=[]`` here to hold the place for where the child elements will go once created\n    if isinstance(element, pyparsing.And):\n        # detect And's created with ``expr*N`` notation - for these use a OneOrMore with a repeat\n        # (all will have the same name, and resultsName)\n        if not exprs:\n            return None\n        if len(set((e.name, e.resultsName) for e in exprs)) == 1:\n            ret = EditablePartial.from_call(\n                railroad.OneOrMore, item=\"\", repeat=str(len(exprs))\n            )\n        elif _should_vertical(vertical, exprs):\n            ret = EditablePartial.from_call(railroad.Stack, items=[])\n        else:\n            ret = EditablePartial.from_call(railroad.Sequence, items=[])\n    elif isinstance(element, (pyparsing.Or, pyparsing.MatchFirst)):\n        if not exprs:\n            return None\n        if _should_vertical(vertical, exprs):\n            ret = EditablePartial.from_call(railroad.Choice, 0, items=[])\n        else:\n            ret = EditablePartial.from_call(railroad.HorizontalChoice, items=[])\n    elif isinstance(element, pyparsing.Each):\n        if not exprs:\n            return None\n        ret = EditablePartial.from_call(EachItem, items=[])\n    elif isinstance(element, pyparsing.NotAny):\n        ret = EditablePartial.from_call(AnnotatedItem, label=\"NOT\", item=\"\")\n    elif isinstance(element, pyparsing.FollowedBy):\n        ret = EditablePartial.from_call(AnnotatedItem, label=\"LOOKAHEAD\", item=\"\")\n    elif isinstance(element, pyparsing.PrecededBy):\n        ret = EditablePartial.from_call(AnnotatedItem, label=\"LOOKBEHIND\", item=\"\")\n    elif isinstance(element, pyparsing.Group):\n        if show_groups:\n            ret = EditablePartial.from_call(AnnotatedItem, label=\"\", item=\"\")\n        else:\n            ret = EditablePartial.from_call(railroad.Group, label=\"\", item=\"\")\n    elif isinstance(element, pyparsing.TokenConverter):\n        label = type(element).__name__.lower()\n        if label == \"tokenconverter\":\n            ret = EditablePartial.from_call(railroad.Sequence, items=[])\n        else:\n            ret = EditablePartial.from_call(AnnotatedItem, label=label, item=\"\")\n    elif isinstance(element, pyparsing.Opt):\n        ret = EditablePartial.from_call(railroad.Optional, item=\"\")\n    elif isinstance(element, pyparsing.OneOrMore):\n        ret = EditablePartial.from_call(railroad.OneOrMore, item=\"\")\n    elif isinstance(element, pyparsing.ZeroOrMore):\n        ret = EditablePartial.from_call(railroad.ZeroOrMore, item=\"\")\n    elif isinstance(element, pyparsing.Group):\n        ret = EditablePartial.from_call(\n            railroad.Group, item=None, label=element_results_name\n        )\n    elif isinstance(element, pyparsing.Empty) and not element.customName:\n        # Skip unnamed \"Empty\" elements\n        ret = None\n    elif isinstance(element, pyparsing.ParseElementEnhance):\n        ret = EditablePartial.from_call(railroad.Sequence, items=[])\n    elif len(exprs) > 0 and not element_results_name:\n        ret = EditablePartial.from_call(railroad.Group, item=\"\", label=name)\n    elif len(exprs) > 0:\n        ret = EditablePartial.from_call(railroad.Sequence, items=[])\n    else:\n        terminal = EditablePartial.from_call(railroad.Terminal, element.defaultName)\n        ret = terminal\n\n    if ret is None:\n        return\n\n    # Indicate this element's position in the tree so we can extract it if necessary\n    lookup[el_id] = ElementState(\n        element=element,\n        converted=ret,\n        parent=parent,\n        parent_index=index,\n        number=lookup.generate_index(),\n    )\n    if element.customName:\n        lookup[el_id].mark_for_extraction(el_id, lookup, element.customName)\n\n    i = 0\n    for expr in exprs:\n        # Add a placeholder index in case we have to extract the child before we even add it to the parent\n        if \"items\" in ret.kwargs:\n            ret.kwargs[\"items\"].insert(i, None)\n\n        item = _to_diagram_element(\n            expr,\n            parent=ret,\n            lookup=lookup,\n            vertical=vertical,\n            index=i,\n            show_results_names=show_results_names,\n            show_groups=show_groups,\n        )\n\n        # Some elements don't need to be shown in the diagram\n        if item is not None:\n            if \"item\" in ret.kwargs:\n                ret.kwargs[\"item\"] = item\n            elif \"items\" in ret.kwargs:\n                # If we've already extracted the child, don't touch this index, since it's occupied by a nonterminal\n                ret.kwargs[\"items\"][i] = item\n                i += 1\n        elif \"items\" in ret.kwargs:\n            # If we're supposed to skip this element, remove it from the parent\n            del ret.kwargs[\"items\"][i]\n\n    # If all this items children are none, skip this item\n    if ret and (\n        (\"items\" in ret.kwargs and len(ret.kwargs[\"items\"]) == 0)\n        or (\"item\" in ret.kwargs and ret.kwargs[\"item\"] is None)\n    ):\n        ret = EditablePartial.from_call(railroad.Terminal, name)\n\n    # Mark this element as \"complete\", ie it has all of its children\n    if el_id in lookup:\n        lookup[el_id].complete = True\n\n    if el_id in lookup and lookup[el_id].extract and lookup[el_id].complete:\n        lookup.extract_into_diagram(el_id)\n        if ret is not None:\n            ret = EditablePartial.from_call(\n                railroad.NonTerminal, text=lookup.diagrams[el_id].kwargs[\"name\"]\n            )\n\n    return ret\n"},"hash":"mbKL6JEwhg"}