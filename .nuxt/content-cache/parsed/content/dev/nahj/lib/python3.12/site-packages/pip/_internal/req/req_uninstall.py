{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:req:req_uninstall.py","body":"import functools\nimport os\nimport sys\nimport sysconfig\nfrom importlib.util import cache_from_source\nfrom typing import Any, Callable, Dict, Generator, Iterable, List, Optional, Set, Tuple\n\nfrom pip._internal.exceptions import UninstallationError\nfrom pip._internal.locations import get_bin_prefix, get_bin_user\nfrom pip._internal.metadata import BaseDistribution\nfrom pip._internal.utils.compat import WINDOWS\nfrom pip._internal.utils.egg_link import egg_link_path_from_location\nfrom pip._internal.utils.logging import getLogger, indent_log\nfrom pip._internal.utils.misc import ask, normalize_path, renames, rmtree\nfrom pip._internal.utils.temp_dir import AdjacentTempDirectory, TempDirectory\nfrom pip._internal.utils.virtualenv import running_under_virtualenv\n\nlogger = getLogger(__name__)\n\n\ndef _script_names(\n    bin_dir: str, script_name: str, is_gui: bool\n) -> Generator[str, None, None]:\n    \"\"\"Create the fully qualified name of the files created by\n    {console,gui}_scripts for the given ``dist``.\n    Returns the list of file names\n    \"\"\"\n    exe_name = os.path.join(bin_dir, script_name)\n    yield exe_name\n    if not WINDOWS:\n        return\n    yield f\"{exe_name}.exe\"\n    yield f\"{exe_name}.exe.manifest\"\n    if is_gui:\n        yield f\"{exe_name}-script.pyw\"\n    else:\n        yield f\"{exe_name}-script.py\"\n\n\ndef _unique(\n    fn: Callable[..., Generator[Any, None, None]]\n) -> Callable[..., Generator[Any, None, None]]:\n    @functools.wraps(fn)\n    def unique(*args: Any, **kw: Any) -> Generator[Any, None, None]:\n        seen: Set[Any] = set()\n        for item in fn(*args, **kw):\n            if item not in seen:\n                seen.add(item)\n                yield item\n\n    return unique\n\n\n@_unique\ndef uninstallation_paths(dist: BaseDistribution) -> Generator[str, None, None]:\n    \"\"\"\n    Yield all the uninstallation paths for dist based on RECORD-without-.py[co]\n\n    Yield paths to all the files in RECORD. For each .py file in RECORD, add\n    the .pyc and .pyo in the same directory.\n\n    UninstallPathSet.add() takes care of the __pycache__ .py[co].\n\n    If RECORD is not found, raises UninstallationError,\n    with possible information from the INSTALLER file.\n\n    https://packaging.python.org/specifications/recording-installed-packages/\n    \"\"\"\n    location = dist.location\n    assert location is not None, \"not installed\"\n\n    entries = dist.iter_declared_entries()\n    if entries is None:\n        msg = f\"Cannot uninstall {dist}, RECORD file not found.\"\n        installer = dist.installer\n        if not installer or installer == \"pip\":\n            dep = f\"{dist.raw_name}=={dist.version}\"\n            msg += (\n                \" You might be able to recover from this via: \"\n                f\"'pip install --force-reinstall --no-deps {dep}'.\"\n            )\n        else:\n            msg += f\" Hint: The package was installed by {installer}.\"\n        raise UninstallationError(msg)\n\n    for entry in entries:\n        path = os.path.join(location, entry)\n        yield path\n        if path.endswith(\".py\"):\n            dn, fn = os.path.split(path)\n            base = fn[:-3]\n            path = os.path.join(dn, base + \".pyc\")\n            yield path\n            path = os.path.join(dn, base + \".pyo\")\n            yield path\n\n\ndef compact(paths: Iterable[str]) -> Set[str]:\n    \"\"\"Compact a path set to contain the minimal number of paths\n    necessary to contain all paths in the set. If /a/path/ and\n    /a/path/to/a/file.txt are both in the set, leave only the\n    shorter path.\"\"\"\n\n    sep = os.path.sep\n    short_paths: Set[str] = set()\n    for path in sorted(paths, key=len):\n        should_skip = any(\n            path.startswith(shortpath.rstrip(\"*\"))\n            and path[len(shortpath.rstrip(\"*\").rstrip(sep))] == sep\n            for shortpath in short_paths\n        )\n        if not should_skip:\n            short_paths.add(path)\n    return short_paths\n\n\ndef compress_for_rename(paths: Iterable[str]) -> Set[str]:\n    \"\"\"Returns a set containing the paths that need to be renamed.\n\n    This set may include directories when the original sequence of paths\n    included every file on disk.\n    \"\"\"\n    case_map = {os.path.normcase(p): p for p in paths}\n    remaining = set(case_map)\n    unchecked = sorted({os.path.split(p)[0] for p in case_map.values()}, key=len)\n    wildcards: Set[str] = set()\n\n    def norm_join(*a: str) -> str:\n        return os.path.normcase(os.path.join(*a))\n\n    for root in unchecked:\n        if any(os.path.normcase(root).startswith(w) for w in wildcards):\n            # This directory has already been handled.\n            continue\n\n        all_files: Set[str] = set()\n        all_subdirs: Set[str] = set()\n        for dirname, subdirs, files in os.walk(root):\n            all_subdirs.update(norm_join(root, dirname, d) for d in subdirs)\n            all_files.update(norm_join(root, dirname, f) for f in files)\n        # If all the files we found are in our remaining set of files to\n        # remove, then remove them from the latter set and add a wildcard\n        # for the directory.\n        if not (all_files - remaining):\n            remaining.difference_update(all_files)\n            wildcards.add(root + os.sep)\n\n    return set(map(case_map.__getitem__, remaining)) | wildcards\n\n\ndef compress_for_output_listing(paths: Iterable[str]) -> Tuple[Set[str], Set[str]]:\n    \"\"\"Returns a tuple of 2 sets of which paths to display to user\n\n    The first set contains paths that would be deleted. Files of a package\n    are not added and the top-level directory of the package has a '*' added\n    at the end - to signify that all it's contents are removed.\n\n    The second set contains files that would have been skipped in the above\n    folders.\n    \"\"\"\n\n    will_remove = set(paths)\n    will_skip = set()\n\n    # Determine folders and files\n    folders = set()\n    files = set()\n    for path in will_remove:\n        if path.endswith(\".pyc\"):\n            continue\n        if path.endswith(\"__init__.py\") or \".dist-info\" in path:\n            folders.add(os.path.dirname(path))\n        files.add(path)\n\n    _normcased_files = set(map(os.path.normcase, files))\n\n    folders = compact(folders)\n\n    # This walks the tree using os.walk to not miss extra folders\n    # that might get added.\n    for folder in folders:\n        for dirpath, _, dirfiles in os.walk(folder):\n            for fname in dirfiles:\n                if fname.endswith(\".pyc\"):\n                    continue\n\n                file_ = os.path.join(dirpath, fname)\n                if (\n                    os.path.isfile(file_)\n                    and os.path.normcase(file_) not in _normcased_files\n                ):\n                    # We are skipping this file. Add it to the set.\n                    will_skip.add(file_)\n\n    will_remove = files | {os.path.join(folder, \"*\") for folder in folders}\n\n    return will_remove, will_skip\n\n\nclass StashedUninstallPathSet:\n    \"\"\"A set of file rename operations to stash files while\n    tentatively uninstalling them.\"\"\"\n\n    def __init__(self) -> None:\n        # Mapping from source file root to [Adjacent]TempDirectory\n        # for files under that directory.\n        self._save_dirs: Dict[str, TempDirectory] = {}\n        # (old path, new path) tuples for each move that may need\n        # to be undone.\n        self._moves: List[Tuple[str, str]] = []\n\n    def _get_directory_stash(self, path: str) -> str:\n        \"\"\"Stashes a directory.\n\n        Directories are stashed adjacent to their original location if\n        possible, or else moved/copied into the user's temp dir.\"\"\"\n\n        try:\n            save_dir: TempDirectory = AdjacentTempDirectory(path)\n        except OSError:\n            save_dir = TempDirectory(kind=\"uninstall\")\n        self._save_dirs[os.path.normcase(path)] = save_dir\n\n        return save_dir.path\n\n    def _get_file_stash(self, path: str) -> str:\n        \"\"\"Stashes a file.\n\n        If no root has been provided, one will be created for the directory\n        in the user's temp directory.\"\"\"\n        path = os.path.normcase(path)\n        head, old_head = os.path.dirname(path), None\n        save_dir = None\n\n        while head != old_head:\n            try:\n                save_dir = self._save_dirs[head]\n                break\n            except KeyError:\n                pass\n            head, old_head = os.path.dirname(head), head\n        else:\n            # Did not find any suitable root\n            head = os.path.dirname(path)\n            save_dir = TempDirectory(kind=\"uninstall\")\n            self._save_dirs[head] = save_dir\n\n        relpath = os.path.relpath(path, head)\n        if relpath and relpath != os.path.curdir:\n            return os.path.join(save_dir.path, relpath)\n        return save_dir.path\n\n    def stash(self, path: str) -> str:\n        \"\"\"Stashes the directory or file and returns its new location.\n        Handle symlinks as files to avoid modifying the symlink targets.\n        \"\"\"\n        path_is_dir = os.path.isdir(path) and not os.path.islink(path)\n        if path_is_dir:\n            new_path = self._get_directory_stash(path)\n        else:\n            new_path = self._get_file_stash(path)\n\n        self._moves.append((path, new_path))\n        if path_is_dir and os.path.isdir(new_path):\n            # If we're moving a directory, we need to\n            # remove the destination first or else it will be\n            # moved to inside the existing directory.\n            # We just created new_path ourselves, so it will\n            # be removable.\n            os.rmdir(new_path)\n        renames(path, new_path)\n        return new_path\n\n    def commit(self) -> None:\n        \"\"\"Commits the uninstall by removing stashed files.\"\"\"\n        for save_dir in self._save_dirs.values():\n            save_dir.cleanup()\n        self._moves = []\n        self._save_dirs = {}\n\n    def rollback(self) -> None:\n        \"\"\"Undoes the uninstall by moving stashed files back.\"\"\"\n        for p in self._moves:\n            logger.info(\"Moving to %s\\n from %s\", *p)\n\n        for new_path, path in self._moves:\n            try:\n                logger.debug(\"Replacing %s from %s\", new_path, path)\n                if os.path.isfile(new_path) or os.path.islink(new_path):\n                    os.unlink(new_path)\n                elif os.path.isdir(new_path):\n                    rmtree(new_path)\n                renames(path, new_path)\n            except OSError as ex:\n                logger.error(\"Failed to restore %s\", new_path)\n                logger.debug(\"Exception: %s\", ex)\n\n        self.commit()\n\n    @property\n    def can_rollback(self) -> bool:\n        return bool(self._moves)\n\n\nclass UninstallPathSet:\n    \"\"\"A set of file paths to be removed in the uninstallation of a\n    requirement.\"\"\"\n\n    def __init__(self, dist: BaseDistribution) -> None:\n        self._paths: Set[str] = set()\n        self._refuse: Set[str] = set()\n        self._pth: Dict[str, UninstallPthEntries] = {}\n        self._dist = dist\n        self._moved_paths = StashedUninstallPathSet()\n        # Create local cache of normalize_path results. Creating an UninstallPathSet\n        # can result in hundreds/thousands of redundant calls to normalize_path with\n        # the same args, which hurts performance.\n        self._normalize_path_cached = functools.lru_cache()(normalize_path)\n\n    def _permitted(self, path: str) -> bool:\n        \"\"\"\n        Return True if the given path is one we are permitted to\n        remove/modify, False otherwise.\n\n        \"\"\"\n        # aka is_local, but caching normalized sys.prefix\n        if not running_under_virtualenv():\n            return True\n        return path.startswith(self._normalize_path_cached(sys.prefix))\n\n    def add(self, path: str) -> None:\n        head, tail = os.path.split(path)\n\n        # we normalize the head to resolve parent directory symlinks, but not\n        # the tail, since we only want to uninstall symlinks, not their targets\n        path = os.path.join(self._normalize_path_cached(head), os.path.normcase(tail))\n\n        if not os.path.exists(path):\n            return\n        if self._permitted(path):\n            self._paths.add(path)\n        else:\n            self._refuse.add(path)\n\n        # __pycache__ files can show up after 'installed-files.txt' is created,\n        # due to imports\n        if os.path.splitext(path)[1] == \".py\":\n            self.add(cache_from_source(path))\n\n    def add_pth(self, pth_file: str, entry: str) -> None:\n        pth_file = self._normalize_path_cached(pth_file)\n        if self._permitted(pth_file):\n            if pth_file not in self._pth:\n                self._pth[pth_file] = UninstallPthEntries(pth_file)\n            self._pth[pth_file].add(entry)\n        else:\n            self._refuse.add(pth_file)\n\n    def remove(self, auto_confirm: bool = False, verbose: bool = False) -> None:\n        \"\"\"Remove paths in ``self._paths`` with confirmation (unless\n        ``auto_confirm`` is True).\"\"\"\n\n        if not self._paths:\n            logger.info(\n                \"Can't uninstall '%s'. No files were found to uninstall.\",\n                self._dist.raw_name,\n            )\n            return\n\n        dist_name_version = f\"{self._dist.raw_name}-{self._dist.version}\"\n        logger.info(\"Uninstalling %s:\", dist_name_version)\n\n        with indent_log():\n            if auto_confirm or self._allowed_to_proceed(verbose):\n                moved = self._moved_paths\n\n                for_rename = compress_for_rename(self._paths)\n\n                for path in sorted(compact(for_rename)):\n                    moved.stash(path)\n                    logger.verbose(\"Removing file or directory %s\", path)\n\n                for pth in self._pth.values():\n                    pth.remove()\n\n                logger.info(\"Successfully uninstalled %s\", dist_name_version)\n\n    def _allowed_to_proceed(self, verbose: bool) -> bool:\n        \"\"\"Display which files would be deleted and prompt for confirmation\"\"\"\n\n        def _display(msg: str, paths: Iterable[str]) -> None:\n            if not paths:\n                return\n\n            logger.info(msg)\n            with indent_log():\n                for path in sorted(compact(paths)):\n                    logger.info(path)\n\n        if not verbose:\n            will_remove, will_skip = compress_for_output_listing(self._paths)\n        else:\n            # In verbose mode, display all the files that are going to be\n            # deleted.\n            will_remove = set(self._paths)\n            will_skip = set()\n\n        _display(\"Would remove:\", will_remove)\n        _display(\"Would not remove (might be manually added):\", will_skip)\n        _display(\"Would not remove (outside of prefix):\", self._refuse)\n        if verbose:\n            _display(\"Will actually move:\", compress_for_rename(self._paths))\n\n        return ask(\"Proceed (Y/n)? \", (\"y\", \"n\", \"\")) != \"n\"\n\n    def rollback(self) -> None:\n        \"\"\"Rollback the changes previously made by remove().\"\"\"\n        if not self._moved_paths.can_rollback:\n            logger.error(\n                \"Can't roll back %s; was not uninstalled\",\n                self._dist.raw_name,\n            )\n            return\n        logger.info(\"Rolling back uninstall of %s\", self._dist.raw_name)\n        self._moved_paths.rollback()\n        for pth in self._pth.values():\n            pth.rollback()\n\n    def commit(self) -> None:\n        \"\"\"Remove temporary save dir: rollback will no longer be possible.\"\"\"\n        self._moved_paths.commit()\n\n    @classmethod\n    def from_dist(cls, dist: BaseDistribution) -> \"UninstallPathSet\":\n        dist_location = dist.location\n        info_location = dist.info_location\n        if dist_location is None:\n            logger.info(\n                \"Not uninstalling %s since it is not installed\",\n                dist.canonical_name,\n            )\n            return cls(dist)\n\n        normalized_dist_location = normalize_path(dist_location)\n        if not dist.local:\n            logger.info(\n                \"Not uninstalling %s at %s, outside environment %s\",\n                dist.canonical_name,\n                normalized_dist_location,\n                sys.prefix,\n            )\n            return cls(dist)\n\n        if normalized_dist_location in {\n            p\n            for p in {sysconfig.get_path(\"stdlib\"), sysconfig.get_path(\"platstdlib\")}\n            if p\n        }:\n            logger.info(\n                \"Not uninstalling %s at %s, as it is in the standard library.\",\n                dist.canonical_name,\n                normalized_dist_location,\n            )\n            return cls(dist)\n\n        paths_to_remove = cls(dist)\n        develop_egg_link = egg_link_path_from_location(dist.raw_name)\n\n        # Distribution is installed with metadata in a \"flat\" .egg-info\n        # directory. This means it is not a modern .dist-info installation, an\n        # egg, or legacy editable.\n        setuptools_flat_installation = (\n            dist.installed_with_setuptools_egg_info\n            and info_location is not None\n            and os.path.exists(info_location)\n            # If dist is editable and the location points to a ``.egg-info``,\n            # we are in fact in the legacy editable case.\n            and not info_location.endswith(f\"{dist.setuptools_filename}.egg-info\")\n        )\n\n        # Uninstall cases order do matter as in the case of 2 installs of the\n        # same package, pip needs to uninstall the currently detected version\n        if setuptools_flat_installation:\n            if info_location is not None:\n                paths_to_remove.add(info_location)\n            installed_files = dist.iter_declared_entries()\n            if installed_files is not None:\n                for installed_file in installed_files:\n                    paths_to_remove.add(os.path.join(dist_location, installed_file))\n            # FIXME: need a test for this elif block\n            # occurs with --single-version-externally-managed/--record outside\n            # of pip\n            elif dist.is_file(\"top_level.txt\"):\n                try:\n                    namespace_packages = dist.read_text(\"namespace_packages.txt\")\n                except FileNotFoundError:\n                    namespaces = []\n                else:\n                    namespaces = namespace_packages.splitlines(keepends=False)\n                for top_level_pkg in [\n                    p\n                    for p in dist.read_text(\"top_level.txt\").splitlines()\n                    if p and p not in namespaces\n                ]:\n                    path = os.path.join(dist_location, top_level_pkg)\n                    paths_to_remove.add(path)\n                    paths_to_remove.add(f\"{path}.py\")\n                    paths_to_remove.add(f\"{path}.pyc\")\n                    paths_to_remove.add(f\"{path}.pyo\")\n\n        elif dist.installed_by_distutils:\n            raise UninstallationError(\n                \"Cannot uninstall {!r}. It is a distutils installed project \"\n                \"and thus we cannot accurately determine which files belong \"\n                \"to it which would lead to only a partial uninstall.\".format(\n                    dist.raw_name,\n                )\n            )\n\n        elif dist.installed_as_egg:\n            # package installed by easy_install\n            # We cannot match on dist.egg_name because it can slightly vary\n            # i.e. setuptools-0.6c11-py2.6.egg vs setuptools-0.6rc11-py2.6.egg\n            paths_to_remove.add(dist_location)\n            easy_install_egg = os.path.split(dist_location)[1]\n            easy_install_pth = os.path.join(\n                os.path.dirname(dist_location),\n                \"easy-install.pth\",\n            )\n            paths_to_remove.add_pth(easy_install_pth, \"./\" + easy_install_egg)\n\n        elif dist.installed_with_dist_info:\n            for path in uninstallation_paths(dist):\n                paths_to_remove.add(path)\n\n        elif develop_egg_link:\n            # PEP 660 modern editable is handled in the ``.dist-info`` case\n            # above, so this only covers the setuptools-style editable.\n            with open(develop_egg_link) as fh:\n                link_pointer = os.path.normcase(fh.readline().strip())\n                normalized_link_pointer = paths_to_remove._normalize_path_cached(\n                    link_pointer\n                )\n            assert os.path.samefile(\n                normalized_link_pointer, normalized_dist_location\n            ), (\n                f\"Egg-link {develop_egg_link} (to {link_pointer}) does not match \"\n                f\"installed location of {dist.raw_name} (at {dist_location})\"\n            )\n            paths_to_remove.add(develop_egg_link)\n            easy_install_pth = os.path.join(\n                os.path.dirname(develop_egg_link), \"easy-install.pth\"\n            )\n            paths_to_remove.add_pth(easy_install_pth, dist_location)\n\n        else:\n            logger.debug(\n                \"Not sure how to uninstall: %s - Check: %s\",\n                dist,\n                dist_location,\n            )\n\n        if dist.in_usersite:\n            bin_dir = get_bin_user()\n        else:\n            bin_dir = get_bin_prefix()\n\n        # find distutils scripts= scripts\n        try:\n            for script in dist.iter_distutils_script_names():\n                paths_to_remove.add(os.path.join(bin_dir, script))\n                if WINDOWS:\n                    paths_to_remove.add(os.path.join(bin_dir, f\"{script}.bat\"))\n        except (FileNotFoundError, NotADirectoryError):\n            pass\n\n        # find console_scripts and gui_scripts\n        def iter_scripts_to_remove(\n            dist: BaseDistribution,\n            bin_dir: str,\n        ) -> Generator[str, None, None]:\n            for entry_point in dist.iter_entry_points():\n                if entry_point.group == \"console_scripts\":\n                    yield from _script_names(bin_dir, entry_point.name, False)\n                elif entry_point.group == \"gui_scripts\":\n                    yield from _script_names(bin_dir, entry_point.name, True)\n\n        for s in iter_scripts_to_remove(dist, bin_dir):\n            paths_to_remove.add(s)\n\n        return paths_to_remove\n\n\nclass UninstallPthEntries:\n    def __init__(self, pth_file: str) -> None:\n        self.file = pth_file\n        self.entries: Set[str] = set()\n        self._saved_lines: Optional[List[bytes]] = None\n\n    def add(self, entry: str) -> None:\n        entry = os.path.normcase(entry)\n        # On Windows, os.path.normcase converts the entry to use\n        # backslashes.  This is correct for entries that describe absolute\n        # paths outside of site-packages, but all the others use forward\n        # slashes.\n        # os.path.splitdrive is used instead of os.path.isabs because isabs\n        # treats non-absolute paths with drive letter markings like c:foo\\bar\n        # as absolute paths. It also does not recognize UNC paths if they don't\n        # have more than \"\\\\sever\\share\". Valid examples: \"\\\\server\\share\\\" or\n        # \"\\\\server\\share\\folder\".\n        if WINDOWS and not os.path.splitdrive(entry)[0]:\n            entry = entry.replace(\"\\\\\", \"/\")\n        self.entries.add(entry)\n\n    def remove(self) -> None:\n        logger.verbose(\"Removing pth entries from %s:\", self.file)\n\n        # If the file doesn't exist, log a warning and return\n        if not os.path.isfile(self.file):\n            logger.warning(\"Cannot remove entries from nonexistent file %s\", self.file)\n            return\n        with open(self.file, \"rb\") as fh:\n            # windows uses '\\r\\n' with py3k, but uses '\\n' with py2.x\n            lines = fh.readlines()\n            self._saved_lines = lines\n        if any(b\"\\r\\n\" in line for line in lines):\n            endline = \"\\r\\n\"\n        else:\n            endline = \"\\n\"\n        # handle missing trailing newline\n        if lines and not lines[-1].endswith(endline.encode(\"utf-8\")):\n            lines[-1] = lines[-1] + endline.encode(\"utf-8\")\n        for entry in self.entries:\n            try:\n                logger.verbose(\"Removing entry: %s\", entry)\n                lines.remove((entry + endline).encode(\"utf-8\"))\n            except ValueError:\n                pass\n        with open(self.file, \"wb\") as fh:\n            fh.writelines(lines)\n\n    def rollback(self) -> bool:\n        if self._saved_lines is None:\n            logger.error(\"Cannot roll back changes to %s, none were made\", self.file)\n            return False\n        logger.debug(\"Rolling %s back to previous state\", self.file)\n        with open(self.file, \"wb\") as fh:\n            fh.writelines(self._saved_lines)\n        return True\n"},"hash":"Nw0wp4YWdu"}