{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:pygments:scanner.py","body":"\"\"\"\n    pygments.scanner\n    ~~~~~~~~~~~~~~~~\n\n    This library implements a regex based scanner. Some languages\n    like Pascal are easy to parse but have some keywords that\n    depend on the context. Because of this it's impossible to lex\n    that just by using a regular expression lexer like the\n    `RegexLexer`.\n\n    Have a look at the `DelphiLexer` to get an idea of how to use\n    this scanner.\n\n    :copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.\n    :license: BSD, see LICENSE for details.\n\"\"\"\nimport re\n\n\nclass EndOfText(RuntimeError):\n    \"\"\"\n    Raise if end of text is reached and the user\n    tried to call a match function.\n    \"\"\"\n\n\nclass Scanner:\n    \"\"\"\n    Simple scanner\n\n    All method patterns are regular expression strings (not\n    compiled expressions!)\n    \"\"\"\n\n    def __init__(self, text, flags=0):\n        \"\"\"\n        :param text:    The text which should be scanned\n        :param flags:   default regular expression flags\n        \"\"\"\n        self.data = text\n        self.data_length = len(text)\n        self.start_pos = 0\n        self.pos = 0\n        self.flags = flags\n        self.last = None\n        self.match = None\n        self._re_cache = {}\n\n    def eos(self):\n        \"\"\"`True` if the scanner reached the end of text.\"\"\"\n        return self.pos >= self.data_length\n    eos = property(eos, eos.__doc__)\n\n    def check(self, pattern):\n        \"\"\"\n        Apply `pattern` on the current position and return\n        the match object. (Doesn't touch pos). Use this for\n        lookahead.\n        \"\"\"\n        if self.eos:\n            raise EndOfText()\n        if pattern not in self._re_cache:\n            self._re_cache[pattern] = re.compile(pattern, self.flags)\n        return self._re_cache[pattern].match(self.data, self.pos)\n\n    def test(self, pattern):\n        \"\"\"Apply a pattern on the current position and check\n        if it patches. Doesn't touch pos.\n        \"\"\"\n        return self.check(pattern) is not None\n\n    def scan(self, pattern):\n        \"\"\"\n        Scan the text for the given pattern and update pos/match\n        and related fields. The return value is a boolean that\n        indicates if the pattern matched. The matched value is\n        stored on the instance as ``match``, the last value is\n        stored as ``last``. ``start_pos`` is the position of the\n        pointer before the pattern was matched, ``pos`` is the\n        end position.\n        \"\"\"\n        if self.eos:\n            raise EndOfText()\n        if pattern not in self._re_cache:\n            self._re_cache[pattern] = re.compile(pattern, self.flags)\n        self.last = self.match\n        m = self._re_cache[pattern].match(self.data, self.pos)\n        if m is None:\n            return False\n        self.start_pos = m.start()\n        self.pos = m.end()\n        self.match = m.group()\n        return True\n\n    def get_char(self):\n        \"\"\"Scan exactly one char.\"\"\"\n        self.scan('.')\n\n    def __repr__(self):\n        return '<%s %d/%d>' % (\n            self.__class__.__name__,\n            self.pos,\n            self.data_length\n        )\n"},"hash":"DltiKIQt1U"}