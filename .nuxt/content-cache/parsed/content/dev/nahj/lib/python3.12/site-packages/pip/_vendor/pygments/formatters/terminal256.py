{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:pygments:formatters:terminal256.py","body":"\"\"\"\n    pygments.formatters.terminal256\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Formatter for 256-color terminal output with ANSI sequences.\n\n    RGB-to-XTERM color conversion routines adapted from xterm256-conv\n    tool (http://frexx.de/xterm-256-notes/data/xterm256-conv2.tar.bz2)\n    by Wolfgang Frisch.\n\n    Formatter version 1.\n\n    :copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.\n    :license: BSD, see LICENSE for details.\n\"\"\"\n\n# TODO:\n#  - Options to map style's bold/underline/italic/border attributes\n#    to some ANSI attrbutes (something like 'italic=underline')\n#  - An option to output \"style RGB to xterm RGB/index\" conversion table\n#  - An option to indicate that we are running in \"reverse background\"\n#    xterm. This means that default colors are white-on-black, not\n#    black-on-while, so colors like \"white background\" need to be converted\n#    to \"white background, black foreground\", etc...\n\nfrom pip._vendor.pygments.formatter import Formatter\nfrom pip._vendor.pygments.console import codes\nfrom pip._vendor.pygments.style import ansicolors\n\n\n__all__ = ['Terminal256Formatter', 'TerminalTrueColorFormatter']\n\n\nclass EscapeSequence:\n    def __init__(self, fg=None, bg=None, bold=False, underline=False, italic=False):\n        self.fg = fg\n        self.bg = bg\n        self.bold = bold\n        self.underline = underline\n        self.italic = italic\n\n    def escape(self, attrs):\n        if len(attrs):\n            return \"\\x1b[\" + \";\".join(attrs) + \"m\"\n        return \"\"\n\n    def color_string(self):\n        attrs = []\n        if self.fg is not None:\n            if self.fg in ansicolors:\n                esc = codes[self.fg.replace('ansi','')]\n                if ';01m' in esc:\n                    self.bold = True\n                # extract fg color code.\n                attrs.append(esc[2:4])\n            else:\n                attrs.extend((\"38\", \"5\", \"%i\" % self.fg))\n        if self.bg is not None:\n            if self.bg in ansicolors:\n                esc = codes[self.bg.replace('ansi','')]\n                # extract fg color code, add 10 for bg.\n                attrs.append(str(int(esc[2:4])+10))\n            else:\n                attrs.extend((\"48\", \"5\", \"%i\" % self.bg))\n        if self.bold:\n            attrs.append(\"01\")\n        if self.underline:\n            attrs.append(\"04\")\n        if self.italic:\n            attrs.append(\"03\")\n        return self.escape(attrs)\n\n    def true_color_string(self):\n        attrs = []\n        if self.fg:\n            attrs.extend((\"38\", \"2\", str(self.fg[0]), str(self.fg[1]), str(self.fg[2])))\n        if self.bg:\n            attrs.extend((\"48\", \"2\", str(self.bg[0]), str(self.bg[1]), str(self.bg[2])))\n        if self.bold:\n            attrs.append(\"01\")\n        if self.underline:\n            attrs.append(\"04\")\n        if self.italic:\n            attrs.append(\"03\")\n        return self.escape(attrs)\n\n    def reset_string(self):\n        attrs = []\n        if self.fg is not None:\n            attrs.append(\"39\")\n        if self.bg is not None:\n            attrs.append(\"49\")\n        if self.bold or self.underline or self.italic:\n            attrs.append(\"00\")\n        return self.escape(attrs)\n\n\nclass Terminal256Formatter(Formatter):\n    \"\"\"\n    Format tokens with ANSI color sequences, for output in a 256-color\n    terminal or console.  Like in `TerminalFormatter` color sequences\n    are terminated at newlines, so that paging the output works correctly.\n\n    The formatter takes colors from a style defined by the `style` option\n    and converts them to nearest ANSI 256-color escape sequences. Bold and\n    underline attributes from the style are preserved (and displayed).\n\n    .. versionadded:: 0.9\n\n    .. versionchanged:: 2.2\n       If the used style defines foreground colors in the form ``#ansi*``, then\n       `Terminal256Formatter` will map these to non extended foreground color.\n       See :ref:`AnsiTerminalStyle` for more information.\n\n    .. versionchanged:: 2.4\n       The ANSI color names have been updated with names that are easier to\n       understand and align with colornames of other projects and terminals.\n       See :ref:`this table <new-ansi-color-names>` for more information.\n\n\n    Options accepted:\n\n    `style`\n        The style to use, can be a string or a Style subclass (default:\n        ``'default'``).\n\n    `linenos`\n        Set to ``True`` to have line numbers on the terminal output as well\n        (default: ``False`` = no line numbers).\n    \"\"\"\n    name = 'Terminal256'\n    aliases = ['terminal256', 'console256', '256']\n    filenames = []\n\n    def __init__(self, **options):\n        Formatter.__init__(self, **options)\n\n        self.xterm_colors = []\n        self.best_match = {}\n        self.style_string = {}\n\n        self.usebold = 'nobold' not in options\n        self.useunderline = 'nounderline' not in options\n        self.useitalic = 'noitalic' not in options\n\n        self._build_color_table()  # build an RGB-to-256 color conversion table\n        self._setup_styles()  # convert selected style's colors to term. colors\n\n        self.linenos = options.get('linenos', False)\n        self._lineno = 0\n\n    def _build_color_table(self):\n        # colors 0..15: 16 basic colors\n\n        self.xterm_colors.append((0x00, 0x00, 0x00))  # 0\n        self.xterm_colors.append((0xcd, 0x00, 0x00))  # 1\n        self.xterm_colors.append((0x00, 0xcd, 0x00))  # 2\n        self.xterm_colors.append((0xcd, 0xcd, 0x00))  # 3\n        self.xterm_colors.append((0x00, 0x00, 0xee))  # 4\n        self.xterm_colors.append((0xcd, 0x00, 0xcd))  # 5\n        self.xterm_colors.append((0x00, 0xcd, 0xcd))  # 6\n        self.xterm_colors.append((0xe5, 0xe5, 0xe5))  # 7\n        self.xterm_colors.append((0x7f, 0x7f, 0x7f))  # 8\n        self.xterm_colors.append((0xff, 0x00, 0x00))  # 9\n        self.xterm_colors.append((0x00, 0xff, 0x00))  # 10\n        self.xterm_colors.append((0xff, 0xff, 0x00))  # 11\n        self.xterm_colors.append((0x5c, 0x5c, 0xff))  # 12\n        self.xterm_colors.append((0xff, 0x00, 0xff))  # 13\n        self.xterm_colors.append((0x00, 0xff, 0xff))  # 14\n        self.xterm_colors.append((0xff, 0xff, 0xff))  # 15\n\n        # colors 16..232: the 6x6x6 color cube\n\n        valuerange = (0x00, 0x5f, 0x87, 0xaf, 0xd7, 0xff)\n\n        for i in range(217):\n            r = valuerange[(i // 36) % 6]\n            g = valuerange[(i // 6) % 6]\n            b = valuerange[i % 6]\n            self.xterm_colors.append((r, g, b))\n\n        # colors 233..253: grayscale\n\n        for i in range(1, 22):\n            v = 8 + i * 10\n            self.xterm_colors.append((v, v, v))\n\n    def _closest_color(self, r, g, b):\n        distance = 257*257*3  # \"infinity\" (>distance from #000000 to #ffffff)\n        match = 0\n\n        for i in range(0, 254):\n            values = self.xterm_colors[i]\n\n            rd = r - values[0]\n            gd = g - values[1]\n            bd = b - values[2]\n            d = rd*rd + gd*gd + bd*bd\n\n            if d < distance:\n                match = i\n                distance = d\n        return match\n\n    def _color_index(self, color):\n        index = self.best_match.get(color, None)\n        if color in ansicolors:\n            # strip the `ansi/#ansi` part and look up code\n            index = color\n            self.best_match[color] = index\n        if index is None:\n            try:\n                rgb = int(str(color), 16)\n            except ValueError:\n                rgb = 0\n\n            r = (rgb >> 16) & 0xff\n            g = (rgb >> 8) & 0xff\n            b = rgb & 0xff\n            index = self._closest_color(r, g, b)\n            self.best_match[color] = index\n        return index\n\n    def _setup_styles(self):\n        for ttype, ndef in self.style:\n            escape = EscapeSequence()\n            # get foreground from ansicolor if set\n            if ndef['ansicolor']:\n                escape.fg = self._color_index(ndef['ansicolor'])\n            elif ndef['color']:\n                escape.fg = self._color_index(ndef['color'])\n            if ndef['bgansicolor']:\n                escape.bg = self._color_index(ndef['bgansicolor'])\n            elif ndef['bgcolor']:\n                escape.bg = self._color_index(ndef['bgcolor'])\n            if self.usebold and ndef['bold']:\n                escape.bold = True\n            if self.useunderline and ndef['underline']:\n                escape.underline = True\n            if self.useitalic and ndef['italic']:\n                escape.italic = True\n            self.style_string[str(ttype)] = (escape.color_string(),\n                                             escape.reset_string())\n\n    def _write_lineno(self, outfile):\n        self._lineno += 1\n        outfile.write(\"%s%04d: \" % (self._lineno != 1 and '\\n' or '', self._lineno))\n\n    def format(self, tokensource, outfile):\n        return Formatter.format(self, tokensource, outfile)\n\n    def format_unencoded(self, tokensource, outfile):\n        if self.linenos:\n            self._write_lineno(outfile)\n\n        for ttype, value in tokensource:\n            not_found = True\n            while ttype and not_found:\n                try:\n                    # outfile.write( \"<\" + str(ttype) + \">\" )\n                    on, off = self.style_string[str(ttype)]\n\n                    # Like TerminalFormatter, add \"reset colors\" escape sequence\n                    # on newline.\n                    spl = value.split('\\n')\n                    for line in spl[:-1]:\n                        if line:\n                            outfile.write(on + line + off)\n                        if self.linenos:\n                            self._write_lineno(outfile)\n                        else:\n                            outfile.write('\\n')\n\n                    if spl[-1]:\n                        outfile.write(on + spl[-1] + off)\n\n                    not_found = False\n                    # outfile.write( '#' + str(ttype) + '#' )\n\n                except KeyError:\n                    # ottype = ttype\n                    ttype = ttype.parent\n                    # outfile.write( '!' + str(ottype) + '->' + str(ttype) + '!' )\n\n            if not_found:\n                outfile.write(value)\n\n        if self.linenos:\n            outfile.write(\"\\n\")\n\n\n\nclass TerminalTrueColorFormatter(Terminal256Formatter):\n    r\"\"\"\n    Format tokens with ANSI color sequences, for output in a true-color\n    terminal or console.  Like in `TerminalFormatter` color sequences\n    are terminated at newlines, so that paging the output works correctly.\n\n    .. versionadded:: 2.1\n\n    Options accepted:\n\n    `style`\n        The style to use, can be a string or a Style subclass (default:\n        ``'default'``).\n    \"\"\"\n    name = 'TerminalTrueColor'\n    aliases = ['terminal16m', 'console16m', '16m']\n    filenames = []\n\n    def _build_color_table(self):\n        pass\n\n    def _color_tuple(self, color):\n        try:\n            rgb = int(str(color), 16)\n        except ValueError:\n            return None\n        r = (rgb >> 16) & 0xff\n        g = (rgb >> 8) & 0xff\n        b = rgb & 0xff\n        return (r, g, b)\n\n    def _setup_styles(self):\n        for ttype, ndef in self.style:\n            escape = EscapeSequence()\n            if ndef['color']:\n                escape.fg = self._color_tuple(ndef['color'])\n            if ndef['bgcolor']:\n                escape.bg = self._color_tuple(ndef['bgcolor'])\n            if self.usebold and ndef['bold']:\n                escape.bold = True\n            if self.useunderline and ndef['underline']:\n                escape.underline = True\n            if self.useitalic and ndef['italic']:\n                escape.italic = True\n            self.style_string[str(ttype)] = (escape.true_color_string(),\n                                             escape.reset_string())\n"},"hash":"dcywz0rw4p"}