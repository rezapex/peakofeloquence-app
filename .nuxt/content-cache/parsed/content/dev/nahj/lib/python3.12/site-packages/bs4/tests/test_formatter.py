{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:bs4:tests:test_formatter.py","body":"import pytest\n\nfrom bs4.element import Tag\nfrom bs4.formatter import (\n    Formatter,\n    HTMLFormatter,\n    XMLFormatter,\n)\nfrom . import SoupTest\n\nclass TestFormatter(SoupTest):\n\n    def test_default_attributes(self):\n        # Test the default behavior of Formatter.attributes().\n        formatter = Formatter()\n        tag = Tag(name=\"tag\")\n        tag['b'] = 1\n        tag['a'] = 2\n\n        # Attributes come out sorted by name. In Python 3, attributes\n        # normally come out of a dictionary in the order they were\n        # added.\n        assert [('a', 2), ('b', 1)] == formatter.attributes(tag)\n\n        # This works even if Tag.attrs is None, though this shouldn't\n        # normally happen.\n        tag.attrs = None\n        assert [] == formatter.attributes(tag)\n\n        assert ' ' == formatter.indent\n        \n    def test_sort_attributes(self):\n        # Test the ability to override Formatter.attributes() to,\n        # e.g., disable the normal sorting of attributes.\n        class UnsortedFormatter(Formatter):\n            def attributes(self, tag):\n                self.called_with = tag\n                for k, v in sorted(tag.attrs.items()):\n                    if k == 'ignore':\n                        continue\n                    yield k,v\n\n        soup = self.soup('<p cval=\"1\" aval=\"2\" ignore=\"ignored\"></p>')\n        formatter = UnsortedFormatter()\n        decoded = soup.decode(formatter=formatter)\n\n        # attributes() was called on the <p> tag. It filtered out one\n        # attribute and sorted the other two.\n        assert formatter.called_with == soup.p\n        assert '<p aval=\"2\" cval=\"1\"></p>' == decoded\n\n    def test_empty_attributes_are_booleans(self):\n        # Test the behavior of empty_attributes_are_booleans as well\n        # as which Formatters have it enabled.\n        \n        for name in ('html', 'minimal', None):\n            formatter = HTMLFormatter.REGISTRY[name]\n            assert False == formatter.empty_attributes_are_booleans\n\n        formatter = XMLFormatter.REGISTRY[None]\n        assert False == formatter.empty_attributes_are_booleans\n\n        formatter = HTMLFormatter.REGISTRY['html5']\n        assert True == formatter.empty_attributes_are_booleans\n\n        # Verify that the constructor sets the value.\n        formatter = Formatter(empty_attributes_are_booleans=True)\n        assert True == formatter.empty_attributes_are_booleans\n\n        # Now demonstrate what it does to markup.\n        for markup in (\n                \"<option selected></option>\",\n                '<option selected=\"\"></option>'\n        ):\n            soup = self.soup(markup)\n            for formatter in ('html', 'minimal', 'xml', None):\n                assert b'<option selected=\"\"></option>' == soup.option.encode(formatter='html')\n                assert b'<option selected></option>' == soup.option.encode(formatter='html5')\n\n    @pytest.mark.parametrize(\n        \"indent,expect\",\n        [\n            (None, '<a>\\n<b>\\ntext\\n</b>\\n</a>\\n'),\n            (-1, '<a>\\n<b>\\ntext\\n</b>\\n</a>\\n'),\n            (0, '<a>\\n<b>\\ntext\\n</b>\\n</a>\\n'),\n            (\"\", '<a>\\n<b>\\ntext\\n</b>\\n</a>\\n'),\n\n            (1, '<a>\\n <b>\\n  text\\n </b>\\n</a>\\n'),\n            (2, '<a>\\n  <b>\\n    text\\n  </b>\\n</a>\\n'),\n\n            (\"\\t\", '<a>\\n\\t<b>\\n\\t\\ttext\\n\\t</b>\\n</a>\\n'),\n            ('abc', '<a>\\nabc<b>\\nabcabctext\\nabc</b>\\n</a>\\n'),\n\n            # Some invalid inputs -- the default behavior is used.\n            (object(), '<a>\\n <b>\\n  text\\n </b>\\n</a>\\n'),\n            (b'bytes', '<a>\\n <b>\\n  text\\n </b>\\n</a>\\n'),\n        ]\n    )\n    def test_indent(self, indent, expect):\n        # Pretty-print a tree with a Formatter set to\n        # indent in a certain way and verify the results.\n        soup = self.soup(\"<a><b>text</b></a>\")\n        formatter = Formatter(indent=indent)\n        assert soup.prettify(formatter=formatter) == expect\n\n        # Pretty-printing only happens with prettify(), not\n        # encode().\n        assert soup.encode(formatter=formatter) != expect\n        \n    def test_default_indent_value(self):\n        formatter = Formatter()\n        assert formatter.indent == ' '\n\n"},"hash":"I1ihJL5ODq"}