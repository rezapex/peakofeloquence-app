{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:pygments:cmdline.py","body":"\"\"\"\n    pygments.cmdline\n    ~~~~~~~~~~~~~~~~\n\n    Command line interface.\n\n    :copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.\n    :license: BSD, see LICENSE for details.\n\"\"\"\n\nimport os\nimport sys\nimport shutil\nimport argparse\nfrom textwrap import dedent\n\nfrom pip._vendor.pygments import __version__, highlight\nfrom pip._vendor.pygments.util import ClassNotFound, OptionError, docstring_headline, \\\n    guess_decode, guess_decode_from_terminal, terminal_encoding, \\\n    UnclosingTextIOWrapper\nfrom pip._vendor.pygments.lexers import get_all_lexers, get_lexer_by_name, guess_lexer, \\\n    load_lexer_from_file, get_lexer_for_filename, find_lexer_class_for_filename\nfrom pip._vendor.pygments.lexers.special import TextLexer\nfrom pip._vendor.pygments.formatters.latex import LatexEmbeddedLexer, LatexFormatter\nfrom pip._vendor.pygments.formatters import get_all_formatters, get_formatter_by_name, \\\n    load_formatter_from_file, get_formatter_for_filename, find_formatter_class\nfrom pip._vendor.pygments.formatters.terminal import TerminalFormatter\nfrom pip._vendor.pygments.formatters.terminal256 import Terminal256Formatter, TerminalTrueColorFormatter\nfrom pip._vendor.pygments.filters import get_all_filters, find_filter_class\nfrom pip._vendor.pygments.styles import get_all_styles, get_style_by_name\n\n\ndef _parse_options(o_strs):\n    opts = {}\n    if not o_strs:\n        return opts\n    for o_str in o_strs:\n        if not o_str.strip():\n            continue\n        o_args = o_str.split(',')\n        for o_arg in o_args:\n            o_arg = o_arg.strip()\n            try:\n                o_key, o_val = o_arg.split('=', 1)\n                o_key = o_key.strip()\n                o_val = o_val.strip()\n            except ValueError:\n                opts[o_arg] = True\n            else:\n                opts[o_key] = o_val\n    return opts\n\n\ndef _parse_filters(f_strs):\n    filters = []\n    if not f_strs:\n        return filters\n    for f_str in f_strs:\n        if ':' in f_str:\n            fname, fopts = f_str.split(':', 1)\n            filters.append((fname, _parse_options([fopts])))\n        else:\n            filters.append((f_str, {}))\n    return filters\n\n\ndef _print_help(what, name):\n    try:\n        if what == 'lexer':\n            cls = get_lexer_by_name(name)\n            print(\"Help on the %s lexer:\" % cls.name)\n            print(dedent(cls.__doc__))\n        elif what == 'formatter':\n            cls = find_formatter_class(name)\n            print(\"Help on the %s formatter:\" % cls.name)\n            print(dedent(cls.__doc__))\n        elif what == 'filter':\n            cls = find_filter_class(name)\n            print(\"Help on the %s filter:\" % name)\n            print(dedent(cls.__doc__))\n        return 0\n    except (AttributeError, ValueError):\n        print(\"%s not found!\" % what, file=sys.stderr)\n        return 1\n\n\ndef _print_list(what):\n    if what == 'lexer':\n        print()\n        print(\"Lexers:\")\n        print(\"~~~~~~~\")\n\n        info = []\n        for fullname, names, exts, _ in get_all_lexers():\n            tup = (', '.join(names)+':', fullname,\n                   exts and '(filenames ' + ', '.join(exts) + ')' or '')\n            info.append(tup)\n        info.sort()\n        for i in info:\n            print(('* %s\\n    %s %s') % i)\n\n    elif what == 'formatter':\n        print()\n        print(\"Formatters:\")\n        print(\"~~~~~~~~~~~\")\n\n        info = []\n        for cls in get_all_formatters():\n            doc = docstring_headline(cls)\n            tup = (', '.join(cls.aliases) + ':', doc, cls.filenames and\n                   '(filenames ' + ', '.join(cls.filenames) + ')' or '')\n            info.append(tup)\n        info.sort()\n        for i in info:\n            print(('* %s\\n    %s %s') % i)\n\n    elif what == 'filter':\n        print()\n        print(\"Filters:\")\n        print(\"~~~~~~~~\")\n\n        for name in get_all_filters():\n            cls = find_filter_class(name)\n            print(\"* \" + name + ':')\n            print(\"    %s\" % docstring_headline(cls))\n\n    elif what == 'style':\n        print()\n        print(\"Styles:\")\n        print(\"~~~~~~~\")\n\n        for name in get_all_styles():\n            cls = get_style_by_name(name)\n            print(\"* \" + name + ':')\n            print(\"    %s\" % docstring_headline(cls))\n\n\ndef _print_list_as_json(requested_items):\n    import json\n    result = {}\n    if 'lexer' in requested_items:\n        info = {}\n        for fullname, names, filenames, mimetypes in get_all_lexers():\n            info[fullname] = {\n                'aliases': names,\n                'filenames': filenames,\n                'mimetypes': mimetypes\n            }\n        result['lexers'] = info\n\n    if 'formatter' in requested_items:\n        info = {}\n        for cls in get_all_formatters():\n            doc = docstring_headline(cls)\n            info[cls.name] = {\n                'aliases': cls.aliases,\n                'filenames': cls.filenames,\n                'doc': doc\n            }\n        result['formatters'] = info\n\n    if 'filter' in requested_items:\n        info = {}\n        for name in get_all_filters():\n            cls = find_filter_class(name)\n            info[name] = {\n                'doc': docstring_headline(cls)\n            }\n        result['filters'] = info\n\n    if 'style' in requested_items:\n        info = {}\n        for name in get_all_styles():\n            cls = get_style_by_name(name)\n            info[name] = {\n                'doc': docstring_headline(cls)\n            }\n        result['styles'] = info\n\n    json.dump(result, sys.stdout)\n\ndef main_inner(parser, argns):\n    if argns.help:\n        parser.print_help()\n        return 0\n\n    if argns.V:\n        print('Pygments version %s, (c) 2006-2023 by Georg Brandl, Matth√§us '\n              'Chajdas and contributors.' % __version__)\n        return 0\n\n    def is_only_option(opt):\n        return not any(v for (k, v) in vars(argns).items() if k != opt)\n\n    # handle ``pygmentize -L``\n    if argns.L is not None:\n        arg_set = set()\n        for k, v in vars(argns).items():\n            if v:\n                arg_set.add(k)\n\n        arg_set.discard('L')\n        arg_set.discard('json')\n\n        if arg_set:\n            parser.print_help(sys.stderr)\n            return 2\n\n        # print version\n        if not argns.json:\n            main(['', '-V'])\n        allowed_types = {'lexer', 'formatter', 'filter', 'style'}\n        largs = [arg.rstrip('s') for arg in argns.L]\n        if any(arg not in allowed_types for arg in largs):\n            parser.print_help(sys.stderr)\n            return 0\n        if not largs:\n            largs = allowed_types\n        if not argns.json:\n            for arg in largs:\n                _print_list(arg)\n        else:\n            _print_list_as_json(largs)\n        return 0\n\n    # handle ``pygmentize -H``\n    if argns.H:\n        if not is_only_option('H'):\n            parser.print_help(sys.stderr)\n            return 2\n        what, name = argns.H\n        if what not in ('lexer', 'formatter', 'filter'):\n            parser.print_help(sys.stderr)\n            return 2\n        return _print_help(what, name)\n\n    # parse -O options\n    parsed_opts = _parse_options(argns.O or [])\n\n    # parse -P options\n    for p_opt in argns.P or []:\n        try:\n            name, value = p_opt.split('=', 1)\n        except ValueError:\n            parsed_opts[p_opt] = True\n        else:\n            parsed_opts[name] = value\n\n    # encodings\n    inencoding = parsed_opts.get('inencoding', parsed_opts.get('encoding'))\n    outencoding = parsed_opts.get('outencoding', parsed_opts.get('encoding'))\n\n    # handle ``pygmentize -N``\n    if argns.N:\n        lexer = find_lexer_class_for_filename(argns.N)\n        if lexer is None:\n            lexer = TextLexer\n\n        print(lexer.aliases[0])\n        return 0\n\n    # handle ``pygmentize -C``\n    if argns.C:\n        inp = sys.stdin.buffer.read()\n        try:\n            lexer = guess_lexer(inp, inencoding=inencoding)\n        except ClassNotFound:\n            lexer = TextLexer\n\n        print(lexer.aliases[0])\n        return 0\n\n    # handle ``pygmentize -S``\n    S_opt = argns.S\n    a_opt = argns.a\n    if S_opt is not None:\n        f_opt = argns.f\n        if not f_opt:\n            parser.print_help(sys.stderr)\n            return 2\n        if argns.l or argns.INPUTFILE:\n            parser.print_help(sys.stderr)\n            return 2\n\n        try:\n            parsed_opts['style'] = S_opt\n            fmter = get_formatter_by_name(f_opt, **parsed_opts)\n        except ClassNotFound as err:\n            print(err, file=sys.stderr)\n            return 1\n\n        print(fmter.get_style_defs(a_opt or ''))\n        return 0\n\n    # if no -S is given, -a is not allowed\n    if argns.a is not None:\n        parser.print_help(sys.stderr)\n        return 2\n\n    # parse -F options\n    F_opts = _parse_filters(argns.F or [])\n\n    # -x: allow custom (eXternal) lexers and formatters\n    allow_custom_lexer_formatter = bool(argns.x)\n\n    # select lexer\n    lexer = None\n\n    # given by name?\n    lexername = argns.l\n    if lexername:\n        # custom lexer, located relative to user's cwd\n        if allow_custom_lexer_formatter and '.py' in lexername:\n            try:\n                filename = None\n                name = None\n                if ':' in lexername:\n                    filename, name = lexername.rsplit(':', 1)\n\n                    if '.py' in name:\n                        # This can happen on Windows: If the lexername is\n                        # C:\\lexer.py -- return to normal load path in that case\n                        name = None\n\n                if filename and name:\n                    lexer = load_lexer_from_file(filename, name,\n                                                 **parsed_opts)\n                else:\n                    lexer = load_lexer_from_file(lexername, **parsed_opts)\n            except ClassNotFound as err:\n                print('Error:', err, file=sys.stderr)\n                return 1\n        else:\n            try:\n                lexer = get_lexer_by_name(lexername, **parsed_opts)\n            except (OptionError, ClassNotFound) as err:\n                print('Error:', err, file=sys.stderr)\n                return 1\n\n    # read input code\n    code = None\n\n    if argns.INPUTFILE:\n        if argns.s:\n            print('Error: -s option not usable when input file specified',\n                  file=sys.stderr)\n            return 2\n\n        infn = argns.INPUTFILE\n        try:\n            with open(infn, 'rb') as infp:\n                code = infp.read()\n        except Exception as err:\n            print('Error: cannot read infile:', err, file=sys.stderr)\n            return 1\n        if not inencoding:\n            code, inencoding = guess_decode(code)\n\n        # do we have to guess the lexer?\n        if not lexer:\n            try:\n                lexer = get_lexer_for_filename(infn, code, **parsed_opts)\n            except ClassNotFound as err:\n                if argns.g:\n                    try:\n                        lexer = guess_lexer(code, **parsed_opts)\n                    except ClassNotFound:\n                        lexer = TextLexer(**parsed_opts)\n                else:\n                    print('Error:', err, file=sys.stderr)\n                    return 1\n            except OptionError as err:\n                print('Error:', err, file=sys.stderr)\n                return 1\n\n    elif not argns.s:  # treat stdin as full file (-s support is later)\n        # read code from terminal, always in binary mode since we want to\n        # decode ourselves and be tolerant with it\n        code = sys.stdin.buffer.read()  # use .buffer to get a binary stream\n        if not inencoding:\n            code, inencoding = guess_decode_from_terminal(code, sys.stdin)\n            # else the lexer will do the decoding\n        if not lexer:\n            try:\n                lexer = guess_lexer(code, **parsed_opts)\n            except ClassNotFound:\n                lexer = TextLexer(**parsed_opts)\n\n    else:  # -s option needs a lexer with -l\n        if not lexer:\n            print('Error: when using -s a lexer has to be selected with -l',\n                  file=sys.stderr)\n            return 2\n\n    # process filters\n    for fname, fopts in F_opts:\n        try:\n            lexer.add_filter(fname, **fopts)\n        except ClassNotFound as err:\n            print('Error:', err, file=sys.stderr)\n            return 1\n\n    # select formatter\n    outfn = argns.o\n    fmter = argns.f\n    if fmter:\n        # custom formatter, located relative to user's cwd\n        if allow_custom_lexer_formatter and '.py' in fmter:\n            try:\n                filename = None\n                name = None\n                if ':' in fmter:\n                    # Same logic as above for custom lexer\n                    filename, name = fmter.rsplit(':', 1)\n\n                    if '.py' in name:\n                        name = None\n\n                if filename and name:\n                    fmter = load_formatter_from_file(filename, name,\n                                                     **parsed_opts)\n                else:\n                    fmter = load_formatter_from_file(fmter, **parsed_opts)\n            except ClassNotFound as err:\n                print('Error:', err, file=sys.stderr)\n                return 1\n        else:\n            try:\n                fmter = get_formatter_by_name(fmter, **parsed_opts)\n            except (OptionError, ClassNotFound) as err:\n                print('Error:', err, file=sys.stderr)\n                return 1\n\n    if outfn:\n        if not fmter:\n            try:\n                fmter = get_formatter_for_filename(outfn, **parsed_opts)\n            except (OptionError, ClassNotFound) as err:\n                print('Error:', err, file=sys.stderr)\n                return 1\n        try:\n            outfile = open(outfn, 'wb')\n        except Exception as err:\n            print('Error: cannot open outfile:', err, file=sys.stderr)\n            return 1\n    else:\n        if not fmter:\n            if os.environ.get('COLORTERM','') in ('truecolor', '24bit'):\n                fmter = TerminalTrueColorFormatter(**parsed_opts)\n            elif '256' in os.environ.get('TERM', ''):\n                fmter = Terminal256Formatter(**parsed_opts)\n            else:\n                fmter = TerminalFormatter(**parsed_opts)\n        outfile = sys.stdout.buffer\n\n    # determine output encoding if not explicitly selected\n    if not outencoding:\n        if outfn:\n            # output file? use lexer encoding for now (can still be None)\n            fmter.encoding = inencoding\n        else:\n            # else use terminal encoding\n            fmter.encoding = terminal_encoding(sys.stdout)\n\n    # provide coloring under Windows, if possible\n    if not outfn and sys.platform in ('win32', 'cygwin') and \\\n       fmter.name in ('Terminal', 'Terminal256'):  # pragma: no cover\n        # unfortunately colorama doesn't support binary streams on Py3\n        outfile = UnclosingTextIOWrapper(outfile, encoding=fmter.encoding)\n        fmter.encoding = None\n        try:\n            import pip._vendor.colorama.initialise as colorama_initialise\n        except ImportError:\n            pass\n        else:\n            outfile = colorama_initialise.wrap_stream(\n                outfile, convert=None, strip=None, autoreset=False, wrap=True)\n\n    # When using the LaTeX formatter and the option `escapeinside` is\n    # specified, we need a special lexer which collects escaped text\n    # before running the chosen language lexer.\n    escapeinside = parsed_opts.get('escapeinside', '')\n    if len(escapeinside) == 2 and isinstance(fmter, LatexFormatter):\n        left = escapeinside[0]\n        right = escapeinside[1]\n        lexer = LatexEmbeddedLexer(left, right, lexer)\n\n    # ... and do it!\n    if not argns.s:\n        # process whole input as per normal...\n        try:\n            highlight(code, lexer, fmter, outfile)\n        finally:\n            if outfn:\n                outfile.close()\n        return 0\n    else:\n        # line by line processing of stdin (eg: for 'tail -f')...\n        try:\n            while 1:\n                line = sys.stdin.buffer.readline()\n                if not line:\n                    break\n                if not inencoding:\n                    line = guess_decode_from_terminal(line, sys.stdin)[0]\n                highlight(line, lexer, fmter, outfile)\n                if hasattr(outfile, 'flush'):\n                    outfile.flush()\n            return 0\n        except KeyboardInterrupt:  # pragma: no cover\n            return 0\n        finally:\n            if outfn:\n                outfile.close()\n\n\nclass HelpFormatter(argparse.HelpFormatter):\n    def __init__(self, prog, indent_increment=2, max_help_position=16, width=None):\n        if width is None:\n            try:\n                width = shutil.get_terminal_size().columns - 2\n            except Exception:\n                pass\n        argparse.HelpFormatter.__init__(self, prog, indent_increment,\n                                        max_help_position, width)\n\n\ndef main(args=sys.argv):\n    \"\"\"\n    Main command line entry point.\n    \"\"\"\n    desc = \"Highlight an input file and write the result to an output file.\"\n    parser = argparse.ArgumentParser(description=desc, add_help=False,\n                                     formatter_class=HelpFormatter)\n\n    operation = parser.add_argument_group('Main operation')\n    lexersel = operation.add_mutually_exclusive_group()\n    lexersel.add_argument(\n        '-l', metavar='LEXER',\n        help='Specify the lexer to use.  (Query names with -L.)  If not '\n        'given and -g is not present, the lexer is guessed from the filename.')\n    lexersel.add_argument(\n        '-g', action='store_true',\n        help='Guess the lexer from the file contents, or pass through '\n        'as plain text if nothing can be guessed.')\n    operation.add_argument(\n        '-F', metavar='FILTER[:options]', action='append',\n        help='Add a filter to the token stream.  (Query names with -L.) '\n        'Filter options are given after a colon if necessary.')\n    operation.add_argument(\n        '-f', metavar='FORMATTER',\n        help='Specify the formatter to use.  (Query names with -L.) '\n        'If not given, the formatter is guessed from the output filename, '\n        'and defaults to the terminal formatter if the output is to the '\n        'terminal or an unknown file extension.')\n    operation.add_argument(\n        '-O', metavar='OPTION=value[,OPTION=value,...]', action='append',\n        help='Give options to the lexer and formatter as a comma-separated '\n        'list of key-value pairs. '\n        'Example: `-O bg=light,python=cool`.')\n    operation.add_argument(\n        '-P', metavar='OPTION=value', action='append',\n        help='Give a single option to the lexer and formatter - with this '\n        'you can pass options whose value contains commas and equal signs. '\n        'Example: `-P \"heading=Pygments, the Python highlighter\"`.')\n    operation.add_argument(\n        '-o', metavar='OUTPUTFILE',\n        help='Where to write the output.  Defaults to standard output.')\n\n    operation.add_argument(\n        'INPUTFILE', nargs='?',\n        help='Where to read the input.  Defaults to standard input.')\n\n    flags = parser.add_argument_group('Operation flags')\n    flags.add_argument(\n        '-v', action='store_true',\n        help='Print a detailed traceback on unhandled exceptions, which '\n        'is useful for debugging and bug reports.')\n    flags.add_argument(\n        '-s', action='store_true',\n        help='Process lines one at a time until EOF, rather than waiting to '\n        'process the entire file.  This only works for stdin, only for lexers '\n        'with no line-spanning constructs, and is intended for streaming '\n        'input such as you get from `tail -f`. '\n        'Example usage: `tail -f sql.log | pygmentize -s -l sql`.')\n    flags.add_argument(\n        '-x', action='store_true',\n        help='Allow custom lexers and formatters to be loaded from a .py file '\n        'relative to the current working directory. For example, '\n        '`-l ./customlexer.py -x`. By default, this option expects a file '\n        'with a class named CustomLexer or CustomFormatter; you can also '\n        'specify your own class name with a colon (`-l ./lexer.py:MyLexer`). '\n        'Users should be very careful not to use this option with untrusted '\n        'files, because it will import and run them.')\n    flags.add_argument('--json', help='Output as JSON. This can '\n        'be only used in conjunction with -L.',\n        default=False,\n        action='store_true')\n\n    special_modes_group = parser.add_argument_group(\n        'Special modes - do not do any highlighting')\n    special_modes = special_modes_group.add_mutually_exclusive_group()\n    special_modes.add_argument(\n        '-S', metavar='STYLE -f formatter',\n        help='Print style definitions for STYLE for a formatter '\n        'given with -f. The argument given by -a is formatter '\n        'dependent.')\n    special_modes.add_argument(\n        '-L', nargs='*', metavar='WHAT',\n        help='List lexers, formatters, styles or filters -- '\n        'give additional arguments for the thing(s) you want to list '\n        '(e.g. \"styles\"), or omit them to list everything.')\n    special_modes.add_argument(\n        '-N', metavar='FILENAME',\n        help='Guess and print out a lexer name based solely on the given '\n        'filename. Does not take input or highlight anything. If no specific '\n        'lexer can be determined, \"text\" is printed.')\n    special_modes.add_argument(\n        '-C', action='store_true',\n        help='Like -N, but print out a lexer name based solely on '\n        'a given content from standard input.')\n    special_modes.add_argument(\n        '-H', action='store', nargs=2, metavar=('NAME', 'TYPE'),\n        help='Print detailed help for the object <name> of type <type>, '\n        'where <type> is one of \"lexer\", \"formatter\" or \"filter\".')\n    special_modes.add_argument(\n        '-V', action='store_true',\n        help='Print the package version.')\n    special_modes.add_argument(\n        '-h', '--help', action='store_true',\n        help='Print this help.')\n    special_modes_group.add_argument(\n        '-a', metavar='ARG',\n        help='Formatter-specific additional argument for the -S (print '\n        'style sheet) mode.')\n\n    argns = parser.parse_args(args[1:])\n\n    try:\n        return main_inner(parser, argns)\n    except BrokenPipeError:\n        # someone closed our stdout, e.g. by quitting a pager.\n        return 0\n    except Exception:\n        if argns.v:\n            print(file=sys.stderr)\n            print('*' * 65, file=sys.stderr)\n            print('An unhandled exception occurred while highlighting.',\n                  file=sys.stderr)\n            print('Please report the whole traceback to the issue tracker at',\n                  file=sys.stderr)\n            print('<https://github.com/pygments/pygments/issues>.',\n                  file=sys.stderr)\n            print('*' * 65, file=sys.stderr)\n            print(file=sys.stderr)\n            raise\n        import traceback\n        info = traceback.format_exception(*sys.exc_info())\n        msg = info[-1].strip()\n        if len(info) >= 3:\n            # extract relevant file and position info\n            msg += '\\n   (f%s)' % info[-2].split('\\n')[0].strip()[1:]\n        print(file=sys.stderr)\n        print('*** Error while highlighting:', file=sys.stderr)\n        print(msg, file=sys.stderr)\n        print('*** If this is a bug you want to report, please rerun with -v.',\n              file=sys.stderr)\n        return 1\n"},"hash":"Bj5MVQuSoS"}