{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:rich:tree.py","body":"from typing import Iterator, List, Optional, Tuple\n\nfrom ._loop import loop_first, loop_last\nfrom .console import Console, ConsoleOptions, RenderableType, RenderResult\nfrom .jupyter import JupyterMixin\nfrom .measure import Measurement\nfrom .segment import Segment\nfrom .style import Style, StyleStack, StyleType\nfrom .styled import Styled\n\n\nclass Tree(JupyterMixin):\n    \"\"\"A renderable for a tree structure.\n\n    Args:\n        label (RenderableType): The renderable or str for the tree label.\n        style (StyleType, optional): Style of this tree. Defaults to \"tree\".\n        guide_style (StyleType, optional): Style of the guide lines. Defaults to \"tree.line\".\n        expanded (bool, optional): Also display children. Defaults to True.\n        highlight (bool, optional): Highlight renderable (if str). Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        label: RenderableType,\n        *,\n        style: StyleType = \"tree\",\n        guide_style: StyleType = \"tree.line\",\n        expanded: bool = True,\n        highlight: bool = False,\n        hide_root: bool = False,\n    ) -> None:\n        self.label = label\n        self.style = style\n        self.guide_style = guide_style\n        self.children: List[Tree] = []\n        self.expanded = expanded\n        self.highlight = highlight\n        self.hide_root = hide_root\n\n    def add(\n        self,\n        label: RenderableType,\n        *,\n        style: Optional[StyleType] = None,\n        guide_style: Optional[StyleType] = None,\n        expanded: bool = True,\n        highlight: Optional[bool] = False,\n    ) -> \"Tree\":\n        \"\"\"Add a child tree.\n\n        Args:\n            label (RenderableType): The renderable or str for the tree label.\n            style (StyleType, optional): Style of this tree. Defaults to \"tree\".\n            guide_style (StyleType, optional): Style of the guide lines. Defaults to \"tree.line\".\n            expanded (bool, optional): Also display children. Defaults to True.\n            highlight (Optional[bool], optional): Highlight renderable (if str). Defaults to False.\n\n        Returns:\n            Tree: A new child Tree, which may be further modified.\n        \"\"\"\n        node = Tree(\n            label,\n            style=self.style if style is None else style,\n            guide_style=self.guide_style if guide_style is None else guide_style,\n            expanded=expanded,\n            highlight=self.highlight if highlight is None else highlight,\n        )\n        self.children.append(node)\n        return node\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n\n        stack: List[Iterator[Tuple[bool, Tree]]] = []\n        pop = stack.pop\n        push = stack.append\n        new_line = Segment.line()\n\n        get_style = console.get_style\n        null_style = Style.null()\n        guide_style = get_style(self.guide_style, default=\"\") or null_style\n        SPACE, CONTINUE, FORK, END = range(4)\n\n        ASCII_GUIDES = (\"    \", \"|   \", \"+-- \", \"`-- \")\n        TREE_GUIDES = [\n            (\"    \", \"â”‚   \", \"â”œâ”€â”€ \", \"â””â”€â”€ \"),\n            (\"    \", \"â”ƒ   \", \"â”£â”â” \", \"â”—â”â” \"),\n            (\"    \", \"â•‘   \", \"â• â•â• \", \"â•šâ•â• \"),\n        ]\n        _Segment = Segment\n\n        def make_guide(index: int, style: Style) -> Segment:\n            \"\"\"Make a Segment for a level of the guide lines.\"\"\"\n            if options.ascii_only:\n                line = ASCII_GUIDES[index]\n            else:\n                guide = 1 if style.bold else (2 if style.underline2 else 0)\n                line = TREE_GUIDES[0 if options.legacy_windows else guide][index]\n            return _Segment(line, style)\n\n        levels: List[Segment] = [make_guide(CONTINUE, guide_style)]\n        push(iter(loop_last([self])))\n\n        guide_style_stack = StyleStack(get_style(self.guide_style))\n        style_stack = StyleStack(get_style(self.style))\n        remove_guide_styles = Style(bold=False, underline2=False)\n\n        depth = 0\n\n        while stack:\n            stack_node = pop()\n            try:\n                last, node = next(stack_node)\n            except StopIteration:\n                levels.pop()\n                if levels:\n                    guide_style = levels[-1].style or null_style\n                    levels[-1] = make_guide(FORK, guide_style)\n                    guide_style_stack.pop()\n                    style_stack.pop()\n                continue\n            push(stack_node)\n            if last:\n                levels[-1] = make_guide(END, levels[-1].style or null_style)\n\n            guide_style = guide_style_stack.current + get_style(node.guide_style)\n            style = style_stack.current + get_style(node.style)\n            prefix = levels[(2 if self.hide_root else 1) :]\n            renderable_lines = console.render_lines(\n                Styled(node.label, style),\n                options.update(\n                    width=options.max_width\n                    - sum(level.cell_length for level in prefix),\n                    highlight=self.highlight,\n                    height=None,\n                ),\n                pad=options.justify is not None,\n            )\n\n            if not (depth == 0 and self.hide_root):\n                for first, line in loop_first(renderable_lines):\n                    if prefix:\n                        yield from _Segment.apply_style(\n                            prefix,\n                            style.background_style,\n                            post_style=remove_guide_styles,\n                        )\n                    yield from line\n                    yield new_line\n                    if first and prefix:\n                        prefix[-1] = make_guide(\n                            SPACE if last else CONTINUE, prefix[-1].style or null_style\n                        )\n\n            if node.expanded and node.children:\n                levels[-1] = make_guide(\n                    SPACE if last else CONTINUE, levels[-1].style or null_style\n                )\n                levels.append(\n                    make_guide(END if len(node.children) == 1 else FORK, guide_style)\n                )\n                style_stack.push(get_style(node.style))\n                guide_style_stack.push(get_style(node.guide_style))\n                push(iter(loop_last(node.children)))\n                depth += 1\n\n    def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"Measurement\":\n        stack: List[Iterator[Tree]] = [iter([self])]\n        pop = stack.pop\n        push = stack.append\n        minimum = 0\n        maximum = 0\n        measure = Measurement.get\n        level = 0\n        while stack:\n            iter_tree = pop()\n            try:\n                tree = next(iter_tree)\n            except StopIteration:\n                level -= 1\n                continue\n            push(iter_tree)\n            min_measure, max_measure = measure(console, options, tree.label)\n            indent = level * 4\n            minimum = max(min_measure + indent, minimum)\n            maximum = max(max_measure + indent, maximum)\n            if tree.expanded and tree.children:\n                push(iter(tree.children))\n                level += 1\n        return Measurement(minimum, maximum)\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n\n    from pip._vendor.rich.console import Group\n    from pip._vendor.rich.markdown import Markdown\n    from pip._vendor.rich.panel import Panel\n    from pip._vendor.rich.syntax import Syntax\n    from pip._vendor.rich.table import Table\n\n    table = Table(row_styles=[\"\", \"dim\"])\n\n    table.add_column(\"Released\", style=\"cyan\", no_wrap=True)\n    table.add_column(\"Title\", style=\"magenta\")\n    table.add_column(\"Box Office\", justify=\"right\", style=\"green\")\n\n    table.add_row(\"Dec 20, 2019\", \"Star Wars: The Rise of Skywalker\", \"$952,110,690\")\n    table.add_row(\"May 25, 2018\", \"Solo: A Star Wars Story\", \"$393,151,347\")\n    table.add_row(\"Dec 15, 2017\", \"Star Wars Ep. V111: The Last Jedi\", \"$1,332,539,889\")\n    table.add_row(\"Dec 16, 2016\", \"Rogue One: A Star Wars Story\", \"$1,332,439,889\")\n\n    code = \"\"\"\\\nclass Segment(NamedTuple):\n    text: str = \"\"\n    style: Optional[Style] = None\n    is_control: bool = False\n\"\"\"\n    syntax = Syntax(code, \"python\", theme=\"monokai\", line_numbers=True)\n\n    markdown = Markdown(\n        \"\"\"\\\n### example.md\n> Hello, World!\n>\n> Markdown _all_ the things\n\"\"\"\n    )\n\n    root = Tree(\"ðŸŒ² [b green]Rich Tree\", highlight=True, hide_root=True)\n\n    node = root.add(\":file_folder: Renderables\", guide_style=\"red\")\n    simple_node = node.add(\":file_folder: [bold yellow]Atomic\", guide_style=\"uu green\")\n    simple_node.add(Group(\"ðŸ“„ Syntax\", syntax))\n    simple_node.add(Group(\"ðŸ“„ Markdown\", Panel(markdown, border_style=\"green\")))\n\n    containers_node = node.add(\n        \":file_folder: [bold magenta]Containers\", guide_style=\"bold magenta\"\n    )\n    containers_node.expanded = True\n    panel = Panel.fit(\"Just a panel\", border_style=\"red\")\n    containers_node.add(Group(\"ðŸ“„ Panels\", panel))\n\n    containers_node.add(Group(\"ðŸ“„ [b magenta]Table\", table))\n\n    console = Console()\n\n    console.print(root)\n"},"hash":"v5Jk4ti0Ac"}