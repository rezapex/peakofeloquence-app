{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:cachecontrol:heuristics.py","body":"# SPDX-FileCopyrightText: 2015 Eric Larson\n#\n# SPDX-License-Identifier: Apache-2.0\nfrom __future__ import annotations\n\nimport calendar\nimport time\nfrom datetime import datetime, timedelta, timezone\nfrom email.utils import formatdate, parsedate, parsedate_tz\nfrom typing import TYPE_CHECKING, Any, Mapping\n\nif TYPE_CHECKING:\n    from pip._vendor.urllib3 import HTTPResponse\n\nTIME_FMT = \"%a, %d %b %Y %H:%M:%S GMT\"\n\n\ndef expire_after(delta: timedelta, date: datetime | None = None) -> datetime:\n    date = date or datetime.now(timezone.utc)\n    return date + delta\n\n\ndef datetime_to_header(dt: datetime) -> str:\n    return formatdate(calendar.timegm(dt.timetuple()))\n\n\nclass BaseHeuristic:\n    def warning(self, response: HTTPResponse) -> str | None:\n        \"\"\"\n        Return a valid 1xx warning header value describing the cache\n        adjustments.\n\n        The response is provided too allow warnings like 113\n        http://tools.ietf.org/html/rfc7234#section-5.5.4 where we need\n        to explicitly say response is over 24 hours old.\n        \"\"\"\n        return '110 - \"Response is Stale\"'\n\n    def update_headers(self, response: HTTPResponse) -> dict[str, str]:\n        \"\"\"Update the response headers with any new headers.\n\n        NOTE: This SHOULD always include some Warning header to\n              signify that the response was cached by the client, not\n              by way of the provided headers.\n        \"\"\"\n        return {}\n\n    def apply(self, response: HTTPResponse) -> HTTPResponse:\n        updated_headers = self.update_headers(response)\n\n        if updated_headers:\n            response.headers.update(updated_headers)\n            warning_header_value = self.warning(response)\n            if warning_header_value is not None:\n                response.headers.update({\"Warning\": warning_header_value})\n\n        return response\n\n\nclass OneDayCache(BaseHeuristic):\n    \"\"\"\n    Cache the response by providing an expires 1 day in the\n    future.\n    \"\"\"\n\n    def update_headers(self, response: HTTPResponse) -> dict[str, str]:\n        headers = {}\n\n        if \"expires\" not in response.headers:\n            date = parsedate(response.headers[\"date\"])\n            expires = expire_after(timedelta(days=1), date=datetime(*date[:6], tzinfo=timezone.utc))  # type: ignore[misc]\n            headers[\"expires\"] = datetime_to_header(expires)\n            headers[\"cache-control\"] = \"public\"\n        return headers\n\n\nclass ExpiresAfter(BaseHeuristic):\n    \"\"\"\n    Cache **all** requests for a defined time period.\n    \"\"\"\n\n    def __init__(self, **kw: Any) -> None:\n        self.delta = timedelta(**kw)\n\n    def update_headers(self, response: HTTPResponse) -> dict[str, str]:\n        expires = expire_after(self.delta)\n        return {\"expires\": datetime_to_header(expires), \"cache-control\": \"public\"}\n\n    def warning(self, response: HTTPResponse) -> str | None:\n        tmpl = \"110 - Automatically cached for %s. Response might be stale\"\n        return tmpl % self.delta\n\n\nclass LastModified(BaseHeuristic):\n    \"\"\"\n    If there is no Expires header already, fall back on Last-Modified\n    using the heuristic from\n    http://tools.ietf.org/html/rfc7234#section-4.2.2\n    to calculate a reasonable value.\n\n    Firefox also does something like this per\n    https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching_FAQ\n    http://lxr.mozilla.org/mozilla-release/source/netwerk/protocol/http/nsHttpResponseHead.cpp#397\n    Unlike mozilla we limit this to 24-hr.\n    \"\"\"\n\n    cacheable_by_default_statuses = {\n        200,\n        203,\n        204,\n        206,\n        300,\n        301,\n        404,\n        405,\n        410,\n        414,\n        501,\n    }\n\n    def update_headers(self, resp: HTTPResponse) -> dict[str, str]:\n        headers: Mapping[str, str] = resp.headers\n\n        if \"expires\" in headers:\n            return {}\n\n        if \"cache-control\" in headers and headers[\"cache-control\"] != \"public\":\n            return {}\n\n        if resp.status not in self.cacheable_by_default_statuses:\n            return {}\n\n        if \"date\" not in headers or \"last-modified\" not in headers:\n            return {}\n\n        time_tuple = parsedate_tz(headers[\"date\"])\n        assert time_tuple is not None\n        date = calendar.timegm(time_tuple[:6])\n        last_modified = parsedate(headers[\"last-modified\"])\n        if last_modified is None:\n            return {}\n\n        now = time.time()\n        current_age = max(0, now - date)\n        delta = date - calendar.timegm(last_modified)\n        freshness_lifetime = max(0, min(delta / 10, 24 * 3600))\n        if freshness_lifetime <= current_age:\n            return {}\n\n        expires = date + freshness_lifetime\n        return {\"expires\": time.strftime(TIME_FMT, time.gmtime(expires))}\n\n    def warning(self, resp: HTTPResponse) -> str | None:\n        return None\n"},"hash":"VWmAxE30iK"}