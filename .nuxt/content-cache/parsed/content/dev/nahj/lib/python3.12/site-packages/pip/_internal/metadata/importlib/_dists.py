{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:metadata:importlib:_dists.py","body":"import email.message\nimport importlib.metadata\nimport os\nimport pathlib\nimport zipfile\nfrom typing import (\n    Collection,\n    Dict,\n    Iterable,\n    Iterator,\n    Mapping,\n    Optional,\n    Sequence,\n    cast,\n)\n\nfrom pip._vendor.packaging.requirements import Requirement\nfrom pip._vendor.packaging.utils import NormalizedName, canonicalize_name\nfrom pip._vendor.packaging.version import parse as parse_version\n\nfrom pip._internal.exceptions import InvalidWheel, UnsupportedWheel\nfrom pip._internal.metadata.base import (\n    BaseDistribution,\n    BaseEntryPoint,\n    DistributionVersion,\n    InfoPath,\n    Wheel,\n)\nfrom pip._internal.utils.misc import normalize_path\nfrom pip._internal.utils.temp_dir import TempDirectory\nfrom pip._internal.utils.wheel import parse_wheel, read_wheel_metadata_file\n\nfrom ._compat import BasePath, get_dist_name\n\n\nclass WheelDistribution(importlib.metadata.Distribution):\n    \"\"\"An ``importlib.metadata.Distribution`` read from a wheel.\n\n    Although ``importlib.metadata.PathDistribution`` accepts ``zipfile.Path``,\n    its implementation is too \"lazy\" for pip's needs (we can't keep the ZipFile\n    handle open for the entire lifetime of the distribution object).\n\n    This implementation eagerly reads the entire metadata directory into the\n    memory instead, and operates from that.\n    \"\"\"\n\n    def __init__(\n        self,\n        files: Mapping[pathlib.PurePosixPath, bytes],\n        info_location: pathlib.PurePosixPath,\n    ) -> None:\n        self._files = files\n        self.info_location = info_location\n\n    @classmethod\n    def from_zipfile(\n        cls,\n        zf: zipfile.ZipFile,\n        name: str,\n        location: str,\n    ) -> \"WheelDistribution\":\n        info_dir, _ = parse_wheel(zf, name)\n        paths = (\n            (name, pathlib.PurePosixPath(name.split(\"/\", 1)[-1]))\n            for name in zf.namelist()\n            if name.startswith(f\"{info_dir}/\")\n        )\n        files = {\n            relpath: read_wheel_metadata_file(zf, fullpath)\n            for fullpath, relpath in paths\n        }\n        info_location = pathlib.PurePosixPath(location, info_dir)\n        return cls(files, info_location)\n\n    def iterdir(self, path: InfoPath) -> Iterator[pathlib.PurePosixPath]:\n        # Only allow iterating through the metadata directory.\n        if pathlib.PurePosixPath(str(path)) in self._files:\n            return iter(self._files)\n        raise FileNotFoundError(path)\n\n    def read_text(self, filename: str) -> Optional[str]:\n        try:\n            data = self._files[pathlib.PurePosixPath(filename)]\n        except KeyError:\n            return None\n        try:\n            text = data.decode(\"utf-8\")\n        except UnicodeDecodeError as e:\n            wheel = self.info_location.parent\n            error = f\"Error decoding metadata for {wheel}: {e} in {filename} file\"\n            raise UnsupportedWheel(error)\n        return text\n\n\nclass Distribution(BaseDistribution):\n    def __init__(\n        self,\n        dist: importlib.metadata.Distribution,\n        info_location: Optional[BasePath],\n        installed_location: Optional[BasePath],\n    ) -> None:\n        self._dist = dist\n        self._info_location = info_location\n        self._installed_location = installed_location\n\n    @classmethod\n    def from_directory(cls, directory: str) -> BaseDistribution:\n        info_location = pathlib.Path(directory)\n        dist = importlib.metadata.Distribution.at(info_location)\n        return cls(dist, info_location, info_location.parent)\n\n    @classmethod\n    def from_metadata_file_contents(\n        cls,\n        metadata_contents: bytes,\n        filename: str,\n        project_name: str,\n    ) -> BaseDistribution:\n        # Generate temp dir to contain the metadata file, and write the file contents.\n        temp_dir = pathlib.Path(\n            TempDirectory(kind=\"metadata\", globally_managed=True).path\n        )\n        metadata_path = temp_dir / \"METADATA\"\n        metadata_path.write_bytes(metadata_contents)\n        # Construct dist pointing to the newly created directory.\n        dist = importlib.metadata.Distribution.at(metadata_path.parent)\n        return cls(dist, metadata_path.parent, None)\n\n    @classmethod\n    def from_wheel(cls, wheel: Wheel, name: str) -> BaseDistribution:\n        try:\n            with wheel.as_zipfile() as zf:\n                dist = WheelDistribution.from_zipfile(zf, name, wheel.location)\n        except zipfile.BadZipFile as e:\n            raise InvalidWheel(wheel.location, name) from e\n        except UnsupportedWheel as e:\n            raise UnsupportedWheel(f\"{name} has an invalid wheel, {e}\")\n        return cls(dist, dist.info_location, pathlib.PurePosixPath(wheel.location))\n\n    @property\n    def location(self) -> Optional[str]:\n        if self._info_location is None:\n            return None\n        return str(self._info_location.parent)\n\n    @property\n    def info_location(self) -> Optional[str]:\n        if self._info_location is None:\n            return None\n        return str(self._info_location)\n\n    @property\n    def installed_location(self) -> Optional[str]:\n        if self._installed_location is None:\n            return None\n        return normalize_path(str(self._installed_location))\n\n    def _get_dist_name_from_location(self) -> Optional[str]:\n        \"\"\"Try to get the name from the metadata directory name.\n\n        This is much faster than reading metadata.\n        \"\"\"\n        if self._info_location is None:\n            return None\n        stem, suffix = os.path.splitext(self._info_location.name)\n        if suffix not in (\".dist-info\", \".egg-info\"):\n            return None\n        return stem.split(\"-\", 1)[0]\n\n    @property\n    def canonical_name(self) -> NormalizedName:\n        name = self._get_dist_name_from_location() or get_dist_name(self._dist)\n        return canonicalize_name(name)\n\n    @property\n    def version(self) -> DistributionVersion:\n        return parse_version(self._dist.version)\n\n    def is_file(self, path: InfoPath) -> bool:\n        return self._dist.read_text(str(path)) is not None\n\n    def iter_distutils_script_names(self) -> Iterator[str]:\n        # A distutils installation is always \"flat\" (not in e.g. egg form), so\n        # if this distribution's info location is NOT a pathlib.Path (but e.g.\n        # zipfile.Path), it can never contain any distutils scripts.\n        if not isinstance(self._info_location, pathlib.Path):\n            return\n        for child in self._info_location.joinpath(\"scripts\").iterdir():\n            yield child.name\n\n    def read_text(self, path: InfoPath) -> str:\n        content = self._dist.read_text(str(path))\n        if content is None:\n            raise FileNotFoundError(path)\n        return content\n\n    def iter_entry_points(self) -> Iterable[BaseEntryPoint]:\n        # importlib.metadata's EntryPoint structure sasitfies BaseEntryPoint.\n        return self._dist.entry_points\n\n    def _metadata_impl(self) -> email.message.Message:\n        # From Python 3.10+, importlib.metadata declares PackageMetadata as the\n        # return type. This protocol is unfortunately a disaster now and misses\n        # a ton of fields that we need, including get() and get_payload(). We\n        # rely on the implementation that the object is actually a Message now,\n        # until upstream can improve the protocol. (python/cpython#94952)\n        return cast(email.message.Message, self._dist.metadata)\n\n    def iter_provided_extras(self) -> Iterable[str]:\n        return self.metadata.get_all(\"Provides-Extra\", [])\n\n    def is_extra_provided(self, extra: str) -> bool:\n        return any(\n            canonicalize_name(provided_extra) == canonicalize_name(extra)\n            for provided_extra in self.metadata.get_all(\"Provides-Extra\", [])\n        )\n\n    def iter_dependencies(self, extras: Collection[str] = ()) -> Iterable[Requirement]:\n        contexts: Sequence[Dict[str, str]] = [{\"extra\": e} for e in extras]\n        for req_string in self.metadata.get_all(\"Requires-Dist\", []):\n            req = Requirement(req_string)\n            if not req.marker:\n                yield req\n            elif not extras and req.marker.evaluate({\"extra\": \"\"}):\n                yield req\n            elif any(req.marker.evaluate(context) for context in contexts):\n                yield req\n"},"hash":"VGE9noUaOn"}