{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:pygments:formatters:img.py","body":"\"\"\"\n    pygments.formatters.img\n    ~~~~~~~~~~~~~~~~~~~~~~~\n\n    Formatter for Pixmap output.\n\n    :copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.\n    :license: BSD, see LICENSE for details.\n\"\"\"\n\nimport os\nimport sys\n\nfrom pip._vendor.pygments.formatter import Formatter\nfrom pip._vendor.pygments.util import get_bool_opt, get_int_opt, get_list_opt, \\\n    get_choice_opt\n\nimport subprocess\n\n# Import this carefully\ntry:\n    from PIL import Image, ImageDraw, ImageFont\n    pil_available = True\nexcept ImportError:\n    pil_available = False\n\ntry:\n    import _winreg\nexcept ImportError:\n    try:\n        import winreg as _winreg\n    except ImportError:\n        _winreg = None\n\n__all__ = ['ImageFormatter', 'GifImageFormatter', 'JpgImageFormatter',\n           'BmpImageFormatter']\n\n\n# For some unknown reason every font calls it something different\nSTYLES = {\n    'NORMAL':     ['', 'Roman', 'Book', 'Normal', 'Regular', 'Medium'],\n    'ITALIC':     ['Oblique', 'Italic'],\n    'BOLD':       ['Bold'],\n    'BOLDITALIC': ['Bold Oblique', 'Bold Italic'],\n}\n\n# A sane default for modern systems\nDEFAULT_FONT_NAME_NIX = 'DejaVu Sans Mono'\nDEFAULT_FONT_NAME_WIN = 'Courier New'\nDEFAULT_FONT_NAME_MAC = 'Menlo'\n\n\nclass PilNotAvailable(ImportError):\n    \"\"\"When Python imaging library is not available\"\"\"\n\n\nclass FontNotFound(Exception):\n    \"\"\"When there are no usable fonts specified\"\"\"\n\n\nclass FontManager:\n    \"\"\"\n    Manages a set of fonts: normal, italic, bold, etc...\n    \"\"\"\n\n    def __init__(self, font_name, font_size=14):\n        self.font_name = font_name\n        self.font_size = font_size\n        self.fonts = {}\n        self.encoding = None\n        if sys.platform.startswith('win'):\n            if not font_name:\n                self.font_name = DEFAULT_FONT_NAME_WIN\n            self._create_win()\n        elif sys.platform.startswith('darwin'):\n            if not font_name:\n                self.font_name = DEFAULT_FONT_NAME_MAC\n            self._create_mac()\n        else:\n            if not font_name:\n                self.font_name = DEFAULT_FONT_NAME_NIX\n            self._create_nix()\n\n    def _get_nix_font_path(self, name, style):\n        proc = subprocess.Popen(['fc-list', \"%s:style=%s\" % (name, style), 'file'],\n                                stdout=subprocess.PIPE, stderr=None)\n        stdout, _ = proc.communicate()\n        if proc.returncode == 0:\n            lines = stdout.splitlines()\n            for line in lines:\n                if line.startswith(b'Fontconfig warning:'):\n                    continue\n                path = line.decode().strip().strip(':')\n                if path:\n                    return path\n            return None\n\n    def _create_nix(self):\n        for name in STYLES['NORMAL']:\n            path = self._get_nix_font_path(self.font_name, name)\n            if path is not None:\n                self.fonts['NORMAL'] = ImageFont.truetype(path, self.font_size)\n                break\n        else:\n            raise FontNotFound('No usable fonts named: \"%s\"' %\n                               self.font_name)\n        for style in ('ITALIC', 'BOLD', 'BOLDITALIC'):\n            for stylename in STYLES[style]:\n                path = self._get_nix_font_path(self.font_name, stylename)\n                if path is not None:\n                    self.fonts[style] = ImageFont.truetype(path, self.font_size)\n                    break\n            else:\n                if style == 'BOLDITALIC':\n                    self.fonts[style] = self.fonts['BOLD']\n                else:\n                    self.fonts[style] = self.fonts['NORMAL']\n\n    def _get_mac_font_path(self, font_map, name, style):\n        return font_map.get((name + ' ' + style).strip().lower())\n\n    def _create_mac(self):\n        font_map = {}\n        for font_dir in (os.path.join(os.getenv(\"HOME\"), 'Library/Fonts/'),\n                         '/Library/Fonts/', '/System/Library/Fonts/'):\n            font_map.update(\n                (os.path.splitext(f)[0].lower(), os.path.join(font_dir, f))\n                for f in os.listdir(font_dir)\n                if f.lower().endswith(('ttf', 'ttc')))\n\n        for name in STYLES['NORMAL']:\n            path = self._get_mac_font_path(font_map, self.font_name, name)\n            if path is not None:\n                self.fonts['NORMAL'] = ImageFont.truetype(path, self.font_size)\n                break\n        else:\n            raise FontNotFound('No usable fonts named: \"%s\"' %\n                               self.font_name)\n        for style in ('ITALIC', 'BOLD', 'BOLDITALIC'):\n            for stylename in STYLES[style]:\n                path = self._get_mac_font_path(font_map, self.font_name, stylename)\n                if path is not None:\n                    self.fonts[style] = ImageFont.truetype(path, self.font_size)\n                    break\n            else:\n                if style == 'BOLDITALIC':\n                    self.fonts[style] = self.fonts['BOLD']\n                else:\n                    self.fonts[style] = self.fonts['NORMAL']\n\n    def _lookup_win(self, key, basename, styles, fail=False):\n        for suffix in ('', ' (TrueType)'):\n            for style in styles:\n                try:\n                    valname = '%s%s%s' % (basename, style and ' '+style, suffix)\n                    val, _ = _winreg.QueryValueEx(key, valname)\n                    return val\n                except OSError:\n                    continue\n        else:\n            if fail:\n                raise FontNotFound('Font %s (%s) not found in registry' %\n                                   (basename, styles[0]))\n            return None\n\n    def _create_win(self):\n        lookuperror = None\n        keynames = [ (_winreg.HKEY_CURRENT_USER, r'Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts'),\n                     (_winreg.HKEY_CURRENT_USER, r'Software\\Microsoft\\Windows\\CurrentVersion\\Fonts'),\n                     (_winreg.HKEY_LOCAL_MACHINE, r'Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts'),\n                     (_winreg.HKEY_LOCAL_MACHINE, r'Software\\Microsoft\\Windows\\CurrentVersion\\Fonts') ]\n        for keyname in keynames:\n            try:\n                key = _winreg.OpenKey(*keyname)\n                try:\n                    path = self._lookup_win(key, self.font_name, STYLES['NORMAL'], True)\n                    self.fonts['NORMAL'] = ImageFont.truetype(path, self.font_size)\n                    for style in ('ITALIC', 'BOLD', 'BOLDITALIC'):\n                        path = self._lookup_win(key, self.font_name, STYLES[style])\n                        if path:\n                            self.fonts[style] = ImageFont.truetype(path, self.font_size)\n                        else:\n                            if style == 'BOLDITALIC':\n                                self.fonts[style] = self.fonts['BOLD']\n                            else:\n                                self.fonts[style] = self.fonts['NORMAL']\n                    return\n                except FontNotFound as err:\n                    lookuperror = err\n                finally:\n                    _winreg.CloseKey(key)\n            except OSError:\n                pass\n        else:\n            # If we get here, we checked all registry keys and had no luck\n            # We can be in one of two situations now:\n            # * All key lookups failed. In this case lookuperror is None and we\n            #   will raise a generic error\n            # * At least one lookup failed with a FontNotFound error. In this\n            #   case, we will raise that as a more specific error\n            if lookuperror:\n                raise lookuperror\n            raise FontNotFound('Can\\'t open Windows font registry key')\n\n    def get_char_size(self):\n        \"\"\"\n        Get the character size.\n        \"\"\"\n        return self.get_text_size('M')\n\n    def get_text_size(self, text):\n        \"\"\"\n        Get the text size (width, height).\n        \"\"\"\n        font = self.fonts['NORMAL']\n        if hasattr(font, 'getbbox'):  # Pillow >= 9.2.0\n            return font.getbbox(text)[2:4]\n        else:\n            return font.getsize(text)\n\n    def get_font(self, bold, oblique):\n        \"\"\"\n        Get the font based on bold and italic flags.\n        \"\"\"\n        if bold and oblique:\n            return self.fonts['BOLDITALIC']\n        elif bold:\n            return self.fonts['BOLD']\n        elif oblique:\n            return self.fonts['ITALIC']\n        else:\n            return self.fonts['NORMAL']\n\n\nclass ImageFormatter(Formatter):\n    \"\"\"\n    Create a PNG image from source code. This uses the Python Imaging Library to\n    generate a pixmap from the source code.\n\n    .. versionadded:: 0.10\n\n    Additional options accepted:\n\n    `image_format`\n        An image format to output to that is recognised by PIL, these include:\n\n        * \"PNG\" (default)\n        * \"JPEG\"\n        * \"BMP\"\n        * \"GIF\"\n\n    `line_pad`\n        The extra spacing (in pixels) between each line of text.\n\n        Default: 2\n\n    `font_name`\n        The font name to be used as the base font from which others, such as\n        bold and italic fonts will be generated.  This really should be a\n        monospace font to look sane.\n\n        Default: \"Courier New\" on Windows, \"Menlo\" on Mac OS, and\n                 \"DejaVu Sans Mono\" on \\\\*nix\n\n    `font_size`\n        The font size in points to be used.\n\n        Default: 14\n\n    `image_pad`\n        The padding, in pixels to be used at each edge of the resulting image.\n\n        Default: 10\n\n    `line_numbers`\n        Whether line numbers should be shown: True/False\n\n        Default: True\n\n    `line_number_start`\n        The line number of the first line.\n\n        Default: 1\n\n    `line_number_step`\n        The step used when printing line numbers.\n\n        Default: 1\n\n    `line_number_bg`\n        The background colour (in \"#123456\" format) of the line number bar, or\n        None to use the style background color.\n\n        Default: \"#eed\"\n\n    `line_number_fg`\n        The text color of the line numbers (in \"#123456\"-like format).\n\n        Default: \"#886\"\n\n    `line_number_chars`\n        The number of columns of line numbers allowable in the line number\n        margin.\n\n        Default: 2\n\n    `line_number_bold`\n        Whether line numbers will be bold: True/False\n\n        Default: False\n\n    `line_number_italic`\n        Whether line numbers will be italicized: True/False\n\n        Default: False\n\n    `line_number_separator`\n        Whether a line will be drawn between the line number area and the\n        source code area: True/False\n\n        Default: True\n\n    `line_number_pad`\n        The horizontal padding (in pixels) between the line number margin, and\n        the source code area.\n\n        Default: 6\n\n    `hl_lines`\n        Specify a list of lines to be highlighted.\n\n        .. versionadded:: 1.2\n\n        Default: empty list\n\n    `hl_color`\n        Specify the color for highlighting lines.\n\n        .. versionadded:: 1.2\n\n        Default: highlight color of the selected style\n    \"\"\"\n\n    # Required by the pygments mapper\n    name = 'img'\n    aliases = ['img', 'IMG', 'png']\n    filenames = ['*.png']\n\n    unicodeoutput = False\n\n    default_image_format = 'png'\n\n    def __init__(self, **options):\n        \"\"\"\n        See the class docstring for explanation of options.\n        \"\"\"\n        if not pil_available:\n            raise PilNotAvailable(\n                'Python Imaging Library is required for this formatter')\n        Formatter.__init__(self, **options)\n        self.encoding = 'latin1'  # let pygments.format() do the right thing\n        # Read the style\n        self.styles = dict(self.style)\n        if self.style.background_color is None:\n            self.background_color = '#fff'\n        else:\n            self.background_color = self.style.background_color\n        # Image options\n        self.image_format = get_choice_opt(\n            options, 'image_format', ['png', 'jpeg', 'gif', 'bmp'],\n            self.default_image_format, normcase=True)\n        self.image_pad = get_int_opt(options, 'image_pad', 10)\n        self.line_pad = get_int_opt(options, 'line_pad', 2)\n        # The fonts\n        fontsize = get_int_opt(options, 'font_size', 14)\n        self.fonts = FontManager(options.get('font_name', ''), fontsize)\n        self.fontw, self.fonth = self.fonts.get_char_size()\n        # Line number options\n        self.line_number_fg = options.get('line_number_fg', '#886')\n        self.line_number_bg = options.get('line_number_bg', '#eed')\n        self.line_number_chars = get_int_opt(options,\n                                             'line_number_chars', 2)\n        self.line_number_bold = get_bool_opt(options,\n                                             'line_number_bold', False)\n        self.line_number_italic = get_bool_opt(options,\n                                               'line_number_italic', False)\n        self.line_number_pad = get_int_opt(options, 'line_number_pad', 6)\n        self.line_numbers = get_bool_opt(options, 'line_numbers', True)\n        self.line_number_separator = get_bool_opt(options,\n                                                  'line_number_separator', True)\n        self.line_number_step = get_int_opt(options, 'line_number_step', 1)\n        self.line_number_start = get_int_opt(options, 'line_number_start', 1)\n        if self.line_numbers:\n            self.line_number_width = (self.fontw * self.line_number_chars +\n                                      self.line_number_pad * 2)\n        else:\n            self.line_number_width = 0\n        self.hl_lines = []\n        hl_lines_str = get_list_opt(options, 'hl_lines', [])\n        for line in hl_lines_str:\n            try:\n                self.hl_lines.append(int(line))\n            except ValueError:\n                pass\n        self.hl_color = options.get('hl_color',\n                                    self.style.highlight_color) or '#f90'\n        self.drawables = []\n\n    def get_style_defs(self, arg=''):\n        raise NotImplementedError('The -S option is meaningless for the image '\n                                  'formatter. Use -O style=<stylename> instead.')\n\n    def _get_line_height(self):\n        \"\"\"\n        Get the height of a line.\n        \"\"\"\n        return self.fonth + self.line_pad\n\n    def _get_line_y(self, lineno):\n        \"\"\"\n        Get the Y coordinate of a line number.\n        \"\"\"\n        return lineno * self._get_line_height() + self.image_pad\n\n    def _get_char_width(self):\n        \"\"\"\n        Get the width of a character.\n        \"\"\"\n        return self.fontw\n\n    def _get_char_x(self, linelength):\n        \"\"\"\n        Get the X coordinate of a character position.\n        \"\"\"\n        return linelength + self.image_pad + self.line_number_width\n\n    def _get_text_pos(self, linelength, lineno):\n        \"\"\"\n        Get the actual position for a character and line position.\n        \"\"\"\n        return self._get_char_x(linelength), self._get_line_y(lineno)\n\n    def _get_linenumber_pos(self, lineno):\n        \"\"\"\n        Get the actual position for the start of a line number.\n        \"\"\"\n        return (self.image_pad, self._get_line_y(lineno))\n\n    def _get_text_color(self, style):\n        \"\"\"\n        Get the correct color for the token from the style.\n        \"\"\"\n        if style['color'] is not None:\n            fill = '#' + style['color']\n        else:\n            fill = '#000'\n        return fill\n\n    def _get_text_bg_color(self, style):\n        \"\"\"\n        Get the correct background color for the token from the style.\n        \"\"\"\n        if style['bgcolor'] is not None:\n            bg_color = '#' + style['bgcolor']\n        else:\n            bg_color = None\n        return bg_color\n\n    def _get_style_font(self, style):\n        \"\"\"\n        Get the correct font for the style.\n        \"\"\"\n        return self.fonts.get_font(style['bold'], style['italic'])\n\n    def _get_image_size(self, maxlinelength, maxlineno):\n        \"\"\"\n        Get the required image size.\n        \"\"\"\n        return (self._get_char_x(maxlinelength) + self.image_pad,\n                self._get_line_y(maxlineno + 0) + self.image_pad)\n\n    def _draw_linenumber(self, posno, lineno):\n        \"\"\"\n        Remember a line number drawable to paint later.\n        \"\"\"\n        self._draw_text(\n            self._get_linenumber_pos(posno),\n            str(lineno).rjust(self.line_number_chars),\n            font=self.fonts.get_font(self.line_number_bold,\n                                     self.line_number_italic),\n            text_fg=self.line_number_fg,\n            text_bg=None,\n        )\n\n    def _draw_text(self, pos, text, font, text_fg, text_bg):\n        \"\"\"\n        Remember a single drawable tuple to paint later.\n        \"\"\"\n        self.drawables.append((pos, text, font, text_fg, text_bg))\n\n    def _create_drawables(self, tokensource):\n        \"\"\"\n        Create drawables for the token content.\n        \"\"\"\n        lineno = charno = maxcharno = 0\n        maxlinelength = linelength = 0\n        for ttype, value in tokensource:\n            while ttype not in self.styles:\n                ttype = ttype.parent\n            style = self.styles[ttype]\n            # TODO: make sure tab expansion happens earlier in the chain.  It\n            # really ought to be done on the input, as to do it right here is\n            # quite complex.\n            value = value.expandtabs(4)\n            lines = value.splitlines(True)\n            # print lines\n            for i, line in enumerate(lines):\n                temp = line.rstrip('\\n')\n                if temp:\n                    self._draw_text(\n                        self._get_text_pos(linelength, lineno),\n                        temp,\n                        font = self._get_style_font(style),\n                        text_fg = self._get_text_color(style),\n                        text_bg = self._get_text_bg_color(style),\n                    )\n                    temp_width, _ = self.fonts.get_text_size(temp)\n                    linelength += temp_width\n                    maxlinelength = max(maxlinelength, linelength)\n                    charno += len(temp)\n                    maxcharno = max(maxcharno, charno)\n                if line.endswith('\\n'):\n                    # add a line for each extra line in the value\n                    linelength = 0\n                    charno = 0\n                    lineno += 1\n        self.maxlinelength = maxlinelength\n        self.maxcharno = maxcharno\n        self.maxlineno = lineno\n\n    def _draw_line_numbers(self):\n        \"\"\"\n        Create drawables for the line numbers.\n        \"\"\"\n        if not self.line_numbers:\n            return\n        for p in range(self.maxlineno):\n            n = p + self.line_number_start\n            if (n % self.line_number_step) == 0:\n                self._draw_linenumber(p, n)\n\n    def _paint_line_number_bg(self, im):\n        \"\"\"\n        Paint the line number background on the image.\n        \"\"\"\n        if not self.line_numbers:\n            return\n        if self.line_number_fg is None:\n            return\n        draw = ImageDraw.Draw(im)\n        recth = im.size[-1]\n        rectw = self.image_pad + self.line_number_width - self.line_number_pad\n        draw.rectangle([(0, 0), (rectw, recth)],\n                       fill=self.line_number_bg)\n        if self.line_number_separator:\n            draw.line([(rectw, 0), (rectw, recth)], fill=self.line_number_fg)\n        del draw\n\n    def format(self, tokensource, outfile):\n        \"\"\"\n        Format ``tokensource``, an iterable of ``(tokentype, tokenstring)``\n        tuples and write it into ``outfile``.\n\n        This implementation calculates where it should draw each token on the\n        pixmap, then calculates the required pixmap size and draws the items.\n        \"\"\"\n        self._create_drawables(tokensource)\n        self._draw_line_numbers()\n        im = Image.new(\n            'RGB',\n            self._get_image_size(self.maxlinelength, self.maxlineno),\n            self.background_color\n        )\n        self._paint_line_number_bg(im)\n        draw = ImageDraw.Draw(im)\n        # Highlight\n        if self.hl_lines:\n            x = self.image_pad + self.line_number_width - self.line_number_pad + 1\n            recth = self._get_line_height()\n            rectw = im.size[0] - x\n            for linenumber in self.hl_lines:\n                y = self._get_line_y(linenumber - 1)\n                draw.rectangle([(x, y), (x + rectw, y + recth)],\n                               fill=self.hl_color)\n        for pos, value, font, text_fg, text_bg in self.drawables:\n            if text_bg:\n                text_size = draw.textsize(text=value, font=font)\n                draw.rectangle([pos[0], pos[1], pos[0] + text_size[0], pos[1] + text_size[1]], fill=text_bg)\n            draw.text(pos, value, font=font, fill=text_fg)\n        im.save(outfile, self.image_format.upper())\n\n\n# Add one formatter per format, so that the \"-f gif\" option gives the correct result\n# when used in pygmentize.\n\nclass GifImageFormatter(ImageFormatter):\n    \"\"\"\n    Create a GIF image from source code. This uses the Python Imaging Library to\n    generate a pixmap from the source code.\n\n    .. versionadded:: 1.0\n    \"\"\"\n\n    name = 'img_gif'\n    aliases = ['gif']\n    filenames = ['*.gif']\n    default_image_format = 'gif'\n\n\nclass JpgImageFormatter(ImageFormatter):\n    \"\"\"\n    Create a JPEG image from source code. This uses the Python Imaging Library to\n    generate a pixmap from the source code.\n\n    .. versionadded:: 1.0\n    \"\"\"\n\n    name = 'img_jpg'\n    aliases = ['jpg', 'jpeg']\n    filenames = ['*.jpg']\n    default_image_format = 'jpeg'\n\n\nclass BmpImageFormatter(ImageFormatter):\n    \"\"\"\n    Create a bitmap image from source code. This uses the Python Imaging Library to\n    generate a pixmap from the source code.\n\n    .. versionadded:: 1.0\n    \"\"\"\n\n    name = 'img_bmp'\n    aliases = ['bmp', 'bitmap']\n    filenames = ['*.bmp']\n    default_image_format = 'bmp'\n"},"hash":"O4yiXfrTaK"}