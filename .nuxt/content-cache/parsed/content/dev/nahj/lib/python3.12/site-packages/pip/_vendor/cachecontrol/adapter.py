{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:cachecontrol:adapter.py","body":"# SPDX-FileCopyrightText: 2015 Eric Larson\n#\n# SPDX-License-Identifier: Apache-2.0\nfrom __future__ import annotations\n\nimport functools\nimport types\nimport zlib\nfrom typing import TYPE_CHECKING, Any, Collection, Mapping\n\nfrom pip._vendor.requests.adapters import HTTPAdapter\n\nfrom pip._vendor.cachecontrol.cache import DictCache\nfrom pip._vendor.cachecontrol.controller import PERMANENT_REDIRECT_STATUSES, CacheController\nfrom pip._vendor.cachecontrol.filewrapper import CallbackFileWrapper\n\nif TYPE_CHECKING:\n    from pip._vendor.requests import PreparedRequest, Response\n    from pip._vendor.urllib3 import HTTPResponse\n\n    from pip._vendor.cachecontrol.cache import BaseCache\n    from pip._vendor.cachecontrol.heuristics import BaseHeuristic\n    from pip._vendor.cachecontrol.serialize import Serializer\n\n\nclass CacheControlAdapter(HTTPAdapter):\n    invalidating_methods = {\"PUT\", \"PATCH\", \"DELETE\"}\n\n    def __init__(\n        self,\n        cache: BaseCache | None = None,\n        cache_etags: bool = True,\n        controller_class: type[CacheController] | None = None,\n        serializer: Serializer | None = None,\n        heuristic: BaseHeuristic | None = None,\n        cacheable_methods: Collection[str] | None = None,\n        *args: Any,\n        **kw: Any,\n    ) -> None:\n        super().__init__(*args, **kw)\n        self.cache = DictCache() if cache is None else cache\n        self.heuristic = heuristic\n        self.cacheable_methods = cacheable_methods or (\"GET\",)\n\n        controller_factory = controller_class or CacheController\n        self.controller = controller_factory(\n            self.cache, cache_etags=cache_etags, serializer=serializer\n        )\n\n    def send(\n        self,\n        request: PreparedRequest,\n        stream: bool = False,\n        timeout: None | float | tuple[float, float] | tuple[float, None] = None,\n        verify: bool | str = True,\n        cert: (None | bytes | str | tuple[bytes | str, bytes | str]) = None,\n        proxies: Mapping[str, str] | None = None,\n        cacheable_methods: Collection[str] | None = None,\n    ) -> Response:\n        \"\"\"\n        Send a request. Use the request information to see if it\n        exists in the cache and cache the response if we need to and can.\n        \"\"\"\n        cacheable = cacheable_methods or self.cacheable_methods\n        if request.method in cacheable:\n            try:\n                cached_response = self.controller.cached_request(request)\n            except zlib.error:\n                cached_response = None\n            if cached_response:\n                return self.build_response(request, cached_response, from_cache=True)\n\n            # check for etags and add headers if appropriate\n            request.headers.update(self.controller.conditional_headers(request))\n\n        resp = super().send(request, stream, timeout, verify, cert, proxies)\n\n        return resp\n\n    def build_response(\n        self,\n        request: PreparedRequest,\n        response: HTTPResponse,\n        from_cache: bool = False,\n        cacheable_methods: Collection[str] | None = None,\n    ) -> Response:\n        \"\"\"\n        Build a response by making a request or using the cache.\n\n        This will end up calling send and returning a potentially\n        cached response\n        \"\"\"\n        cacheable = cacheable_methods or self.cacheable_methods\n        if not from_cache and request.method in cacheable:\n            # Check for any heuristics that might update headers\n            # before trying to cache.\n            if self.heuristic:\n                response = self.heuristic.apply(response)\n\n            # apply any expiration heuristics\n            if response.status == 304:\n                # We must have sent an ETag request. This could mean\n                # that we've been expired already or that we simply\n                # have an etag. In either case, we want to try and\n                # update the cache if that is the case.\n                cached_response = self.controller.update_cached_response(\n                    request, response\n                )\n\n                if cached_response is not response:\n                    from_cache = True\n\n                # We are done with the server response, read a\n                # possible response body (compliant servers will\n                # not return one, but we cannot be 100% sure) and\n                # release the connection back to the pool.\n                response.read(decode_content=False)\n                response.release_conn()\n\n                response = cached_response\n\n            # We always cache the 301 responses\n            elif int(response.status) in PERMANENT_REDIRECT_STATUSES:\n                self.controller.cache_response(request, response)\n            else:\n                # Wrap the response file with a wrapper that will cache the\n                #   response when the stream has been consumed.\n                response._fp = CallbackFileWrapper(  # type: ignore[attr-defined]\n                    response._fp,  # type: ignore[attr-defined]\n                    functools.partial(\n                        self.controller.cache_response, request, response\n                    ),\n                )\n                if response.chunked:\n                    super_update_chunk_length = response._update_chunk_length  # type: ignore[attr-defined]\n\n                    def _update_chunk_length(self: HTTPResponse) -> None:\n                        super_update_chunk_length()\n                        if self.chunk_left == 0:\n                            self._fp._close()  # type: ignore[attr-defined]\n\n                    response._update_chunk_length = types.MethodType(  # type: ignore[attr-defined]\n                        _update_chunk_length, response\n                    )\n\n        resp: Response = super().build_response(request, response)  # type: ignore[no-untyped-call]\n\n        # See if we should invalidate the cache.\n        if request.method in self.invalidating_methods and resp.ok:\n            assert request.url is not None\n            cache_url = self.controller.cache_url(request.url)\n            self.cache.delete(cache_url)\n\n        # Give the request a from_cache attr to let people use it\n        resp.from_cache = from_cache  # type: ignore[attr-defined]\n\n        return resp\n\n    def close(self) -> None:\n        self.cache.close()\n        super().close()  # type: ignore[no-untyped-call]\n"},"hash":"4vmSot9HlI"}