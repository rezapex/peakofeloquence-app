{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:bs4:builder:_html5lib.py","body":"# Use of this source code is governed by the MIT license.\n__license__ = \"MIT\"\n\n__all__ = [\n    'HTML5TreeBuilder',\n    ]\n\nimport warnings\nimport re\nfrom bs4.builder import (\n    DetectsXMLParsedAsHTML,\n    PERMISSIVE,\n    HTML,\n    HTML_5,\n    HTMLTreeBuilder,\n    )\nfrom bs4.element import (\n    NamespacedAttribute,\n    nonwhitespace_re,\n)\nimport html5lib\nfrom html5lib.constants import (\n    namespaces,\n    prefixes,\n    )\nfrom bs4.element import (\n    Comment,\n    Doctype,\n    NavigableString,\n    Tag,\n    )\n\ntry:\n    # Pre-0.99999999\n    from html5lib.treebuilders import _base as treebuilder_base\n    new_html5lib = False\nexcept ImportError as e:\n    # 0.99999999 and up\n    from html5lib.treebuilders import base as treebuilder_base\n    new_html5lib = True\n\nclass HTML5TreeBuilder(HTMLTreeBuilder):\n    \"\"\"Use html5lib to build a tree.\n\n    Note that this TreeBuilder does not support some features common\n    to HTML TreeBuilders. Some of these features could theoretically\n    be implemented, but at the very least it's quite difficult,\n    because html5lib moves the parse tree around as it's being built.\n\n    * This TreeBuilder doesn't use different subclasses of NavigableString\n      based on the name of the tag in which the string was found.\n\n    * You can't use a SoupStrainer to parse only part of a document.\n    \"\"\"\n\n    NAME = \"html5lib\"\n\n    features = [NAME, PERMISSIVE, HTML_5, HTML]\n\n    # html5lib can tell us which line number and position in the\n    # original file is the source of an element.\n    TRACKS_LINE_NUMBERS = True\n    \n    def prepare_markup(self, markup, user_specified_encoding,\n                       document_declared_encoding=None, exclude_encodings=None):\n        # Store the user-specified encoding for use later on.\n        self.user_specified_encoding = user_specified_encoding\n\n        # document_declared_encoding and exclude_encodings aren't used\n        # ATM because the html5lib TreeBuilder doesn't use\n        # UnicodeDammit.\n        if exclude_encodings:\n            warnings.warn(\n                \"You provided a value for exclude_encoding, but the html5lib tree builder doesn't support exclude_encoding.\",\n                stacklevel=3\n            )\n\n        # html5lib only parses HTML, so if it's given XML that's worth\n        # noting.\n        DetectsXMLParsedAsHTML.warn_if_markup_looks_like_xml(\n            markup, stacklevel=3\n        )\n\n        yield (markup, None, None, False)\n\n    # These methods are defined by Beautiful Soup.\n    def feed(self, markup):\n        if self.soup.parse_only is not None:\n            warnings.warn(\n                \"You provided a value for parse_only, but the html5lib tree builder doesn't support parse_only. The entire document will be parsed.\",\n                stacklevel=4\n            )\n        parser = html5lib.HTMLParser(tree=self.create_treebuilder)\n        self.underlying_builder.parser = parser\n        extra_kwargs = dict()\n        if not isinstance(markup, str):\n            if new_html5lib:\n                extra_kwargs['override_encoding'] = self.user_specified_encoding\n            else:\n                extra_kwargs['encoding'] = self.user_specified_encoding\n        doc = parser.parse(markup, **extra_kwargs)\n        \n        # Set the character encoding detected by the tokenizer.\n        if isinstance(markup, str):\n            # We need to special-case this because html5lib sets\n            # charEncoding to UTF-8 if it gets Unicode input.\n            doc.original_encoding = None\n        else:\n            original_encoding = parser.tokenizer.stream.charEncoding[0]\n            if not isinstance(original_encoding, str):\n                # In 0.99999999 and up, the encoding is an html5lib\n                # Encoding object. We want to use a string for compatibility\n                # with other tree builders.\n                original_encoding = original_encoding.name\n            doc.original_encoding = original_encoding\n        self.underlying_builder.parser = None\n            \n    def create_treebuilder(self, namespaceHTMLElements):\n        self.underlying_builder = TreeBuilderForHtml5lib(\n            namespaceHTMLElements, self.soup,\n            store_line_numbers=self.store_line_numbers\n        )\n        return self.underlying_builder\n\n    def test_fragment_to_document(self, fragment):\n        \"\"\"See `TreeBuilder`.\"\"\"\n        return '<html><head></head><body>%s</body></html>' % fragment\n\n\nclass TreeBuilderForHtml5lib(treebuilder_base.TreeBuilder):\n    \n    def __init__(self, namespaceHTMLElements, soup=None,\n                 store_line_numbers=True, **kwargs):\n        if soup:\n            self.soup = soup\n        else:\n            from bs4 import BeautifulSoup\n            # TODO: Why is the parser 'html.parser' here? To avoid an\n            # infinite loop?\n            self.soup = BeautifulSoup(\n                \"\", \"html.parser\", store_line_numbers=store_line_numbers,\n                **kwargs\n            )\n        # TODO: What are **kwargs exactly? Should they be passed in\n        # here in addition to/instead of being passed to the BeautifulSoup\n        # constructor?\n        super(TreeBuilderForHtml5lib, self).__init__(namespaceHTMLElements)\n\n        # This will be set later to an html5lib.html5parser.HTMLParser\n        # object, which we can use to track the current line number.\n        self.parser = None\n        self.store_line_numbers = store_line_numbers\n        \n    def documentClass(self):\n        self.soup.reset()\n        return Element(self.soup, self.soup, None)\n\n    def insertDoctype(self, token):\n        name = token[\"name\"]\n        publicId = token[\"publicId\"]\n        systemId = token[\"systemId\"]\n\n        doctype = Doctype.for_name_and_ids(name, publicId, systemId)\n        self.soup.object_was_parsed(doctype)\n\n    def elementClass(self, name, namespace):\n        kwargs = {}\n        if self.parser and self.store_line_numbers:\n            # This represents the point immediately after the end of the\n            # tag. We don't know when the tag started, but we do know\n            # where it ended -- the character just before this one.\n            sourceline, sourcepos = self.parser.tokenizer.stream.position()\n            kwargs['sourceline'] = sourceline\n            kwargs['sourcepos'] = sourcepos-1\n        tag = self.soup.new_tag(name, namespace, **kwargs)\n\n        return Element(tag, self.soup, namespace)\n\n    def commentClass(self, data):\n        return TextNode(Comment(data), self.soup)\n\n    def fragmentClass(self):\n        from bs4 import BeautifulSoup\n        # TODO: Why is the parser 'html.parser' here? To avoid an\n        # infinite loop?\n        self.soup = BeautifulSoup(\"\", \"html.parser\")\n        self.soup.name = \"[document_fragment]\"\n        return Element(self.soup, self.soup, None)\n\n    def appendChild(self, node):\n        # XXX This code is not covered by the BS4 tests.\n        self.soup.append(node.element)\n\n    def getDocument(self):\n        return self.soup\n\n    def getFragment(self):\n        return treebuilder_base.TreeBuilder.getFragment(self).element\n\n    def testSerializer(self, element):\n        from bs4 import BeautifulSoup\n        rv = []\n        doctype_re = re.compile(r'^(.*?)(?: PUBLIC \"(.*?)\"(?: \"(.*?)\")?| SYSTEM \"(.*?)\")?$')\n\n        def serializeElement(element, indent=0):\n            if isinstance(element, BeautifulSoup):\n                pass\n            if isinstance(element, Doctype):\n                m = doctype_re.match(element)\n                if m:\n                    name = m.group(1)\n                    if m.lastindex > 1:\n                        publicId = m.group(2) or \"\"\n                        systemId = m.group(3) or m.group(4) or \"\"\n                        rv.append(\"\"\"|%s<!DOCTYPE %s \"%s\" \"%s\">\"\"\" %\n                                  (' ' * indent, name, publicId, systemId))\n                    else:\n                        rv.append(\"|%s<!DOCTYPE %s>\" % (' ' * indent, name))\n                else:\n                    rv.append(\"|%s<!DOCTYPE >\" % (' ' * indent,))\n            elif isinstance(element, Comment):\n                rv.append(\"|%s<!-- %s -->\" % (' ' * indent, element))\n            elif isinstance(element, NavigableString):\n                rv.append(\"|%s\\\"%s\\\"\" % (' ' * indent, element))\n            else:\n                if element.namespace:\n                    name = \"%s %s\" % (prefixes[element.namespace],\n                                      element.name)\n                else:\n                    name = element.name\n                rv.append(\"|%s<%s>\" % (' ' * indent, name))\n                if element.attrs:\n                    attributes = []\n                    for name, value in list(element.attrs.items()):\n                        if isinstance(name, NamespacedAttribute):\n                            name = \"%s %s\" % (prefixes[name.namespace], name.name)\n                        if isinstance(value, list):\n                            value = \" \".join(value)\n                        attributes.append((name, value))\n\n                    for name, value in sorted(attributes):\n                        rv.append('|%s%s=\"%s\"' % (' ' * (indent + 2), name, value))\n                indent += 2\n                for child in element.children:\n                    serializeElement(child, indent)\n        serializeElement(element, 0)\n\n        return \"\\n\".join(rv)\n\nclass AttrList(object):\n    def __init__(self, element):\n        self.element = element\n        self.attrs = dict(self.element.attrs)\n    def __iter__(self):\n        return list(self.attrs.items()).__iter__()\n    def __setitem__(self, name, value):\n        # If this attribute is a multi-valued attribute for this element,\n        # turn its value into a list.\n        list_attr = self.element.cdata_list_attributes or {}\n        if (name in list_attr.get('*', [])\n            or (self.element.name in list_attr\n                and name in list_attr.get(self.element.name, []))):\n            # A node that is being cloned may have already undergone\n            # this procedure.\n            if not isinstance(value, list):\n                value = nonwhitespace_re.findall(value)\n        self.element[name] = value\n    def items(self):\n        return list(self.attrs.items())\n    def keys(self):\n        return list(self.attrs.keys())\n    def __len__(self):\n        return len(self.attrs)\n    def __getitem__(self, name):\n        return self.attrs[name]\n    def __contains__(self, name):\n        return name in list(self.attrs.keys())\n\n\nclass Element(treebuilder_base.Node):\n    def __init__(self, element, soup, namespace):\n        treebuilder_base.Node.__init__(self, element.name)\n        self.element = element\n        self.soup = soup\n        self.namespace = namespace\n\n    def appendChild(self, node):\n        string_child = child = None\n        if isinstance(node, str):\n            # Some other piece of code decided to pass in a string\n            # instead of creating a TextElement object to contain the\n            # string.\n            string_child = child = node\n        elif isinstance(node, Tag):\n            # Some other piece of code decided to pass in a Tag\n            # instead of creating an Element object to contain the\n            # Tag.\n            child = node\n        elif node.element.__class__ == NavigableString:\n            string_child = child = node.element\n            node.parent = self\n        else:\n            child = node.element\n            node.parent = self\n\n        if not isinstance(child, str) and child.parent is not None:\n            node.element.extract()\n\n        if (string_child is not None and self.element.contents\n            and self.element.contents[-1].__class__ == NavigableString):\n            # We are appending a string onto another string.\n            # TODO This has O(n^2) performance, for input like\n            # \"a</a>a</a>a</a>...\"\n            old_element = self.element.contents[-1]\n            new_element = self.soup.new_string(old_element + string_child)\n            old_element.replace_with(new_element)\n            self.soup._most_recent_element = new_element\n        else:\n            if isinstance(node, str):\n                # Create a brand new NavigableString from this string.\n                child = self.soup.new_string(node)\n\n            # Tell Beautiful Soup to act as if it parsed this element\n            # immediately after the parent's last descendant. (Or\n            # immediately after the parent, if it has no children.)\n            if self.element.contents:\n                most_recent_element = self.element._last_descendant(False)\n            elif self.element.next_element is not None:\n                # Something from further ahead in the parse tree is\n                # being inserted into this earlier element. This is\n                # very annoying because it means an expensive search\n                # for the last element in the tree.\n                most_recent_element = self.soup._last_descendant()\n            else:\n                most_recent_element = self.element\n\n            self.soup.object_was_parsed(\n                child, parent=self.element,\n                most_recent_element=most_recent_element)\n\n    def getAttributes(self):\n        if isinstance(self.element, Comment):\n            return {}\n        return AttrList(self.element)\n\n    def setAttributes(self, attributes):\n        if attributes is not None and len(attributes) > 0:\n            converted_attributes = []\n            for name, value in list(attributes.items()):\n                if isinstance(name, tuple):\n                    new_name = NamespacedAttribute(*name)\n                    del attributes[name]\n                    attributes[new_name] = value\n\n            self.soup.builder._replace_cdata_list_attribute_values(\n                self.name, attributes)\n            for name, value in list(attributes.items()):\n                self.element[name] = value\n\n            # The attributes may contain variables that need substitution.\n            # Call set_up_substitutions manually.\n            #\n            # The Tag constructor called this method when the Tag was created,\n            # but we just set/changed the attributes, so call it again.\n            self.soup.builder.set_up_substitutions(self.element)\n    attributes = property(getAttributes, setAttributes)\n\n    def insertText(self, data, insertBefore=None):\n        text = TextNode(self.soup.new_string(data), self.soup)\n        if insertBefore:\n            self.insertBefore(text, insertBefore)\n        else:\n            self.appendChild(text)\n\n    def insertBefore(self, node, refNode):\n        index = self.element.index(refNode.element)\n        if (node.element.__class__ == NavigableString and self.element.contents\n            and self.element.contents[index-1].__class__ == NavigableString):\n            # (See comments in appendChild)\n            old_node = self.element.contents[index-1]\n            new_str = self.soup.new_string(old_node + node.element)\n            old_node.replace_with(new_str)\n        else:\n            self.element.insert(index, node.element)\n            node.parent = self\n\n    def removeChild(self, node):\n        node.element.extract()\n\n    def reparentChildren(self, new_parent):\n        \"\"\"Move all of this tag's children into another tag.\"\"\"\n        # print(\"MOVE\", self.element.contents)\n        # print(\"FROM\", self.element)\n        # print(\"TO\", new_parent.element)\n\n        element = self.element\n        new_parent_element = new_parent.element\n        # Determine what this tag's next_element will be once all the children\n        # are removed.\n        final_next_element = element.next_sibling\n\n        new_parents_last_descendant = new_parent_element._last_descendant(False, False)\n        if len(new_parent_element.contents) > 0:\n            # The new parent already contains children. We will be\n            # appending this tag's children to the end.\n            new_parents_last_child = new_parent_element.contents[-1]\n            new_parents_last_descendant_next_element = new_parents_last_descendant.next_element\n        else:\n            # The new parent contains no children.\n            new_parents_last_child = None\n            new_parents_last_descendant_next_element = new_parent_element.next_element\n\n        to_append = element.contents\n        if len(to_append) > 0:\n            # Set the first child's previous_element and previous_sibling\n            # to elements within the new parent\n            first_child = to_append[0]\n            if new_parents_last_descendant is not None:\n                first_child.previous_element = new_parents_last_descendant\n            else:\n                first_child.previous_element = new_parent_element\n            first_child.previous_sibling = new_parents_last_child\n            if new_parents_last_descendant is not None:\n                new_parents_last_descendant.next_element = first_child\n            else:\n                new_parent_element.next_element = first_child\n            if new_parents_last_child is not None:\n                new_parents_last_child.next_sibling = first_child\n\n            # Find the very last element being moved. It is now the\n            # parent's last descendant. It has no .next_sibling and\n            # its .next_element is whatever the previous last\n            # descendant had.\n            last_childs_last_descendant = to_append[-1]._last_descendant(False, True)\n\n            last_childs_last_descendant.next_element = new_parents_last_descendant_next_element\n            if new_parents_last_descendant_next_element is not None:\n                # TODO: This code has no test coverage and I'm not sure\n                # how to get html5lib to go through this path, but it's\n                # just the other side of the previous line.\n                new_parents_last_descendant_next_element.previous_element = last_childs_last_descendant\n            last_childs_last_descendant.next_sibling = None\n\n        for child in to_append:\n            child.parent = new_parent_element\n            new_parent_element.contents.append(child)\n\n        # Now that this element has no children, change its .next_element.\n        element.contents = []\n        element.next_element = final_next_element\n\n        # print(\"DONE WITH MOVE\")\n        # print(\"FROM\", self.element)\n        # print(\"TO\", new_parent_element)\n\n    def cloneNode(self):\n        tag = self.soup.new_tag(self.element.name, self.namespace)\n        node = Element(tag, self.soup, self.namespace)\n        for key,value in self.attributes:\n            node.attributes[key] = value\n        return node\n\n    def hasContent(self):\n        return self.element.contents\n\n    def getNameTuple(self):\n        if self.namespace == None:\n            return namespaces[\"html\"], self.name\n        else:\n            return self.namespace, self.name\n\n    nameTuple = property(getNameTuple)\n\nclass TextNode(Element):\n    def __init__(self, element, soup):\n        treebuilder_base.Node.__init__(self, None)\n        self.element = element\n        self.soup = soup\n\n    def cloneNode(self):\n        raise NotImplementedError\n"},"hash":"vmRA8S8XpM"}