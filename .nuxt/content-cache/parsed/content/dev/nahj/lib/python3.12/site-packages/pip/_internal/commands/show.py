{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:commands:show.py","body":"import logging\nfrom optparse import Values\nfrom typing import Generator, Iterable, Iterator, List, NamedTuple, Optional\n\nfrom pip._vendor.packaging.utils import canonicalize_name\n\nfrom pip._internal.cli.base_command import Command\nfrom pip._internal.cli.status_codes import ERROR, SUCCESS\nfrom pip._internal.metadata import BaseDistribution, get_default_environment\nfrom pip._internal.utils.misc import write_output\n\nlogger = logging.getLogger(__name__)\n\n\nclass ShowCommand(Command):\n    \"\"\"\n    Show information about one or more installed packages.\n\n    The output is in RFC-compliant mail header format.\n    \"\"\"\n\n    usage = \"\"\"\n      %prog [options] <package> ...\"\"\"\n    ignore_require_venv = True\n\n    def add_options(self) -> None:\n        self.cmd_opts.add_option(\n            \"-f\",\n            \"--files\",\n            dest=\"files\",\n            action=\"store_true\",\n            default=False,\n            help=\"Show the full list of installed files for each package.\",\n        )\n\n        self.parser.insert_option_group(0, self.cmd_opts)\n\n    def run(self, options: Values, args: List[str]) -> int:\n        if not args:\n            logger.warning(\"ERROR: Please provide a package name or names.\")\n            return ERROR\n        query = args\n\n        results = search_packages_info(query)\n        if not print_results(\n            results, list_files=options.files, verbose=options.verbose\n        ):\n            return ERROR\n        return SUCCESS\n\n\nclass _PackageInfo(NamedTuple):\n    name: str\n    version: str\n    location: str\n    editable_project_location: Optional[str]\n    requires: List[str]\n    required_by: List[str]\n    installer: str\n    metadata_version: str\n    classifiers: List[str]\n    summary: str\n    homepage: str\n    project_urls: List[str]\n    author: str\n    author_email: str\n    license: str\n    entry_points: List[str]\n    files: Optional[List[str]]\n\n\ndef search_packages_info(query: List[str]) -> Generator[_PackageInfo, None, None]:\n    \"\"\"\n    Gather details from installed distributions. Print distribution name,\n    version, location, and installed files. Installed files requires a\n    pip generated 'installed-files.txt' in the distributions '.egg-info'\n    directory.\n    \"\"\"\n    env = get_default_environment()\n\n    installed = {dist.canonical_name: dist for dist in env.iter_all_distributions()}\n    query_names = [canonicalize_name(name) for name in query]\n    missing = sorted(\n        [name for name, pkg in zip(query, query_names) if pkg not in installed]\n    )\n    if missing:\n        logger.warning(\"Package(s) not found: %s\", \", \".join(missing))\n\n    def _get_requiring_packages(current_dist: BaseDistribution) -> Iterator[str]:\n        return (\n            dist.metadata[\"Name\"] or \"UNKNOWN\"\n            for dist in installed.values()\n            if current_dist.canonical_name\n            in {canonicalize_name(d.name) for d in dist.iter_dependencies()}\n        )\n\n    for query_name in query_names:\n        try:\n            dist = installed[query_name]\n        except KeyError:\n            continue\n\n        requires = sorted((req.name for req in dist.iter_dependencies()), key=str.lower)\n        required_by = sorted(_get_requiring_packages(dist), key=str.lower)\n\n        try:\n            entry_points_text = dist.read_text(\"entry_points.txt\")\n            entry_points = entry_points_text.splitlines(keepends=False)\n        except FileNotFoundError:\n            entry_points = []\n\n        files_iter = dist.iter_declared_entries()\n        if files_iter is None:\n            files: Optional[List[str]] = None\n        else:\n            files = sorted(files_iter)\n\n        metadata = dist.metadata\n\n        yield _PackageInfo(\n            name=dist.raw_name,\n            version=str(dist.version),\n            location=dist.location or \"\",\n            editable_project_location=dist.editable_project_location,\n            requires=requires,\n            required_by=required_by,\n            installer=dist.installer,\n            metadata_version=dist.metadata_version or \"\",\n            classifiers=metadata.get_all(\"Classifier\", []),\n            summary=metadata.get(\"Summary\", \"\"),\n            homepage=metadata.get(\"Home-page\", \"\"),\n            project_urls=metadata.get_all(\"Project-URL\", []),\n            author=metadata.get(\"Author\", \"\"),\n            author_email=metadata.get(\"Author-email\", \"\"),\n            license=metadata.get(\"License\", \"\"),\n            entry_points=entry_points,\n            files=files,\n        )\n\n\ndef print_results(\n    distributions: Iterable[_PackageInfo],\n    list_files: bool,\n    verbose: bool,\n) -> bool:\n    \"\"\"\n    Print the information from installed distributions found.\n    \"\"\"\n    results_printed = False\n    for i, dist in enumerate(distributions):\n        results_printed = True\n        if i > 0:\n            write_output(\"---\")\n\n        write_output(\"Name: %s\", dist.name)\n        write_output(\"Version: %s\", dist.version)\n        write_output(\"Summary: %s\", dist.summary)\n        write_output(\"Home-page: %s\", dist.homepage)\n        write_output(\"Author: %s\", dist.author)\n        write_output(\"Author-email: %s\", dist.author_email)\n        write_output(\"License: %s\", dist.license)\n        write_output(\"Location: %s\", dist.location)\n        if dist.editable_project_location is not None:\n            write_output(\n                \"Editable project location: %s\", dist.editable_project_location\n            )\n        write_output(\"Requires: %s\", \", \".join(dist.requires))\n        write_output(\"Required-by: %s\", \", \".join(dist.required_by))\n\n        if verbose:\n            write_output(\"Metadata-Version: %s\", dist.metadata_version)\n            write_output(\"Installer: %s\", dist.installer)\n            write_output(\"Classifiers:\")\n            for classifier in dist.classifiers:\n                write_output(\"  %s\", classifier)\n            write_output(\"Entry-points:\")\n            for entry in dist.entry_points:\n                write_output(\"  %s\", entry.strip())\n            write_output(\"Project-URLs:\")\n            for project_url in dist.project_urls:\n                write_output(\"  %s\", project_url)\n        if list_files:\n            write_output(\"Files:\")\n            if dist.files is None:\n                write_output(\"Cannot locate RECORD or installed-files.txt\")\n            else:\n                for line in dist.files:\n                    write_output(\"  %s\", line.strip())\n    return results_printed\n"},"hash":"MNGxq2v8Bc"}