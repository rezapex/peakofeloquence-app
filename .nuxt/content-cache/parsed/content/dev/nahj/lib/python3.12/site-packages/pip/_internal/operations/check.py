{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:operations:check.py","body":"\"\"\"Validation of dependencies of packages\n\"\"\"\n\nimport logging\nfrom typing import Callable, Dict, List, NamedTuple, Optional, Set, Tuple\n\nfrom pip._vendor.packaging.requirements import Requirement\nfrom pip._vendor.packaging.specifiers import LegacySpecifier\nfrom pip._vendor.packaging.utils import NormalizedName, canonicalize_name\nfrom pip._vendor.packaging.version import LegacyVersion\n\nfrom pip._internal.distributions import make_distribution_for_install_requirement\nfrom pip._internal.metadata import get_default_environment\nfrom pip._internal.metadata.base import DistributionVersion\nfrom pip._internal.req.req_install import InstallRequirement\nfrom pip._internal.utils.deprecation import deprecated\n\nlogger = logging.getLogger(__name__)\n\n\nclass PackageDetails(NamedTuple):\n    version: DistributionVersion\n    dependencies: List[Requirement]\n\n\n# Shorthands\nPackageSet = Dict[NormalizedName, PackageDetails]\nMissing = Tuple[NormalizedName, Requirement]\nConflicting = Tuple[NormalizedName, DistributionVersion, Requirement]\n\nMissingDict = Dict[NormalizedName, List[Missing]]\nConflictingDict = Dict[NormalizedName, List[Conflicting]]\nCheckResult = Tuple[MissingDict, ConflictingDict]\nConflictDetails = Tuple[PackageSet, CheckResult]\n\n\ndef create_package_set_from_installed() -> Tuple[PackageSet, bool]:\n    \"\"\"Converts a list of distributions into a PackageSet.\"\"\"\n    package_set = {}\n    problems = False\n    env = get_default_environment()\n    for dist in env.iter_installed_distributions(local_only=False, skip=()):\n        name = dist.canonical_name\n        try:\n            dependencies = list(dist.iter_dependencies())\n            package_set[name] = PackageDetails(dist.version, dependencies)\n        except (OSError, ValueError) as e:\n            # Don't crash on unreadable or broken metadata.\n            logger.warning(\"Error parsing requirements for %s: %s\", name, e)\n            problems = True\n    return package_set, problems\n\n\ndef check_package_set(\n    package_set: PackageSet, should_ignore: Optional[Callable[[str], bool]] = None\n) -> CheckResult:\n    \"\"\"Check if a package set is consistent\n\n    If should_ignore is passed, it should be a callable that takes a\n    package name and returns a boolean.\n    \"\"\"\n\n    warn_legacy_versions_and_specifiers(package_set)\n\n    missing = {}\n    conflicting = {}\n\n    for package_name, package_detail in package_set.items():\n        # Info about dependencies of package_name\n        missing_deps: Set[Missing] = set()\n        conflicting_deps: Set[Conflicting] = set()\n\n        if should_ignore and should_ignore(package_name):\n            continue\n\n        for req in package_detail.dependencies:\n            name = canonicalize_name(req.name)\n\n            # Check if it's missing\n            if name not in package_set:\n                missed = True\n                if req.marker is not None:\n                    missed = req.marker.evaluate({\"extra\": \"\"})\n                if missed:\n                    missing_deps.add((name, req))\n                continue\n\n            # Check if there's a conflict\n            version = package_set[name].version\n            if not req.specifier.contains(version, prereleases=True):\n                conflicting_deps.add((name, version, req))\n\n        if missing_deps:\n            missing[package_name] = sorted(missing_deps, key=str)\n        if conflicting_deps:\n            conflicting[package_name] = sorted(conflicting_deps, key=str)\n\n    return missing, conflicting\n\n\ndef check_install_conflicts(to_install: List[InstallRequirement]) -> ConflictDetails:\n    \"\"\"For checking if the dependency graph would be consistent after \\\n    installing given requirements\n    \"\"\"\n    # Start from the current state\n    package_set, _ = create_package_set_from_installed()\n    # Install packages\n    would_be_installed = _simulate_installation_of(to_install, package_set)\n\n    # Only warn about directly-dependent packages; create a whitelist of them\n    whitelist = _create_whitelist(would_be_installed, package_set)\n\n    return (\n        package_set,\n        check_package_set(\n            package_set, should_ignore=lambda name: name not in whitelist\n        ),\n    )\n\n\ndef _simulate_installation_of(\n    to_install: List[InstallRequirement], package_set: PackageSet\n) -> Set[NormalizedName]:\n    \"\"\"Computes the version of packages after installing to_install.\"\"\"\n    # Keep track of packages that were installed\n    installed = set()\n\n    # Modify it as installing requirement_set would (assuming no errors)\n    for inst_req in to_install:\n        abstract_dist = make_distribution_for_install_requirement(inst_req)\n        dist = abstract_dist.get_metadata_distribution()\n        name = dist.canonical_name\n        package_set[name] = PackageDetails(dist.version, list(dist.iter_dependencies()))\n\n        installed.add(name)\n\n    return installed\n\n\ndef _create_whitelist(\n    would_be_installed: Set[NormalizedName], package_set: PackageSet\n) -> Set[NormalizedName]:\n    packages_affected = set(would_be_installed)\n\n    for package_name in package_set:\n        if package_name in packages_affected:\n            continue\n\n        for req in package_set[package_name].dependencies:\n            if canonicalize_name(req.name) in packages_affected:\n                packages_affected.add(package_name)\n                break\n\n    return packages_affected\n\n\ndef warn_legacy_versions_and_specifiers(package_set: PackageSet) -> None:\n    for project_name, package_details in package_set.items():\n        if isinstance(package_details.version, LegacyVersion):\n            deprecated(\n                reason=(\n                    f\"{project_name} {package_details.version} \"\n                    f\"has a non-standard version number.\"\n                ),\n                replacement=(\n                    f\"to upgrade to a newer version of {project_name} \"\n                    f\"or contact the author to suggest that they \"\n                    f\"release a version with a conforming version number\"\n                ),\n                issue=12063,\n                gone_in=\"24.1\",\n            )\n        for dep in package_details.dependencies:\n            if any(isinstance(spec, LegacySpecifier) for spec in dep.specifier):\n                deprecated(\n                    reason=(\n                        f\"{project_name} {package_details.version} \"\n                        f\"has a non-standard dependency specifier {dep}.\"\n                    ),\n                    replacement=(\n                        f\"to upgrade to a newer version of {project_name} \"\n                        f\"or contact the author to suggest that they \"\n                        f\"release a version with a conforming dependency specifiers\"\n                    ),\n                    issue=12063,\n                    gone_in=\"24.1\",\n                )\n"},"hash":"Qx3NuGPfut"}