{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:utils:entrypoints.py","body":"import itertools\nimport os\nimport shutil\nimport sys\nfrom typing import List, Optional\n\nfrom pip._internal.cli.main import main\nfrom pip._internal.utils.compat import WINDOWS\n\n_EXECUTABLE_NAMES = [\n    \"pip\",\n    f\"pip{sys.version_info.major}\",\n    f\"pip{sys.version_info.major}.{sys.version_info.minor}\",\n]\nif WINDOWS:\n    _allowed_extensions = {\"\", \".exe\"}\n    _EXECUTABLE_NAMES = [\n        \"\".join(parts)\n        for parts in itertools.product(_EXECUTABLE_NAMES, _allowed_extensions)\n    ]\n\n\ndef _wrapper(args: Optional[List[str]] = None) -> int:\n    \"\"\"Central wrapper for all old entrypoints.\n\n    Historically pip has had several entrypoints defined. Because of issues\n    arising from PATH, sys.path, multiple Pythons, their interactions, and most\n    of them having a pip installed, users suffer every time an entrypoint gets\n    moved.\n\n    To alleviate this pain, and provide a mechanism for warning users and\n    directing them to an appropriate place for help, we now define all of\n    our old entrypoints as wrappers for the current one.\n    \"\"\"\n    sys.stderr.write(\n        \"WARNING: pip is being invoked by an old script wrapper. This will \"\n        \"fail in a future version of pip.\\n\"\n        \"Please see https://github.com/pypa/pip/issues/5599 for advice on \"\n        \"fixing the underlying issue.\\n\"\n        \"To avoid this problem you can invoke Python with '-m pip' instead of \"\n        \"running pip directly.\\n\"\n    )\n    return main(args)\n\n\ndef get_best_invocation_for_this_pip() -> str:\n    \"\"\"Try to figure out the best way to invoke pip in the current environment.\"\"\"\n    binary_directory = \"Scripts\" if WINDOWS else \"bin\"\n    binary_prefix = os.path.join(sys.prefix, binary_directory)\n\n    # Try to use pip[X[.Y]] names, if those executables for this environment are\n    # the first on PATH with that name.\n    path_parts = os.path.normcase(os.environ.get(\"PATH\", \"\")).split(os.pathsep)\n    exe_are_in_PATH = os.path.normcase(binary_prefix) in path_parts\n    if exe_are_in_PATH:\n        for exe_name in _EXECUTABLE_NAMES:\n            found_executable = shutil.which(exe_name)\n            binary_executable = os.path.join(binary_prefix, exe_name)\n            if (\n                found_executable\n                and os.path.exists(binary_executable)\n                and os.path.samefile(\n                    found_executable,\n                    binary_executable,\n                )\n            ):\n                return exe_name\n\n    # Use the `-m` invocation, if there's no \"nice\" invocation.\n    return f\"{get_best_invocation_for_this_python()} -m pip\"\n\n\ndef get_best_invocation_for_this_python() -> str:\n    \"\"\"Try to figure out the best way to invoke the current Python.\"\"\"\n    exe = sys.executable\n    exe_name = os.path.basename(exe)\n\n    # Try to use the basename, if it's the first executable.\n    found_executable = shutil.which(exe_name)\n    if found_executable and os.path.samefile(found_executable, exe):\n        return exe_name\n\n    # Use the full executable name, because we couldn't find something simpler.\n    return exe\n"},"hash":"0LQQOGutqK"}