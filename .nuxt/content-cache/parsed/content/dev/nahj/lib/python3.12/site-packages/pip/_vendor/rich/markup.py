{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:rich:markup.py","body":"import re\nfrom ast import literal_eval\nfrom operator import attrgetter\nfrom typing import Callable, Iterable, List, Match, NamedTuple, Optional, Tuple, Union\n\nfrom ._emoji_replace import _emoji_replace\nfrom .emoji import EmojiVariant\nfrom .errors import MarkupError\nfrom .style import Style\nfrom .text import Span, Text\n\nRE_TAGS = re.compile(\n    r\"\"\"((\\\\*)\\[([a-z#/@][^[]*?)])\"\"\",\n    re.VERBOSE,\n)\n\nRE_HANDLER = re.compile(r\"^([\\w.]*?)(\\(.*?\\))?$\")\n\n\nclass Tag(NamedTuple):\n    \"\"\"A tag in console markup.\"\"\"\n\n    name: str\n    \"\"\"The tag name. e.g. 'bold'.\"\"\"\n    parameters: Optional[str]\n    \"\"\"Any additional parameters after the name.\"\"\"\n\n    def __str__(self) -> str:\n        return (\n            self.name if self.parameters is None else f\"{self.name} {self.parameters}\"\n        )\n\n    @property\n    def markup(self) -> str:\n        \"\"\"Get the string representation of this tag.\"\"\"\n        return (\n            f\"[{self.name}]\"\n            if self.parameters is None\n            else f\"[{self.name}={self.parameters}]\"\n        )\n\n\n_ReStringMatch = Match[str]  # regex match object\n_ReSubCallable = Callable[[_ReStringMatch], str]  # Callable invoked by re.sub\n_EscapeSubMethod = Callable[[_ReSubCallable, str], str]  # Sub method of a compiled re\n\n\ndef escape(\n    markup: str,\n    _escape: _EscapeSubMethod = re.compile(r\"(\\\\*)(\\[[a-z#/@][^[]*?])\").sub,\n) -> str:\n    \"\"\"Escapes text so that it won't be interpreted as markup.\n\n    Args:\n        markup (str): Content to be inserted in to markup.\n\n    Returns:\n        str: Markup with square brackets escaped.\n    \"\"\"\n\n    def escape_backslashes(match: Match[str]) -> str:\n        \"\"\"Called by re.sub replace matches.\"\"\"\n        backslashes, text = match.groups()\n        return f\"{backslashes}{backslashes}\\\\{text}\"\n\n    markup = _escape(escape_backslashes, markup)\n    return markup\n\n\ndef _parse(markup: str) -> Iterable[Tuple[int, Optional[str], Optional[Tag]]]:\n    \"\"\"Parse markup in to an iterable of tuples of (position, text, tag).\n\n    Args:\n        markup (str): A string containing console markup\n\n    \"\"\"\n    position = 0\n    _divmod = divmod\n    _Tag = Tag\n    for match in RE_TAGS.finditer(markup):\n        full_text, escapes, tag_text = match.groups()\n        start, end = match.span()\n        if start > position:\n            yield start, markup[position:start], None\n        if escapes:\n            backslashes, escaped = _divmod(len(escapes), 2)\n            if backslashes:\n                # Literal backslashes\n                yield start, \"\\\\\" * backslashes, None\n                start += backslashes * 2\n            if escaped:\n                # Escape of tag\n                yield start, full_text[len(escapes) :], None\n                position = end\n                continue\n        text, equals, parameters = tag_text.partition(\"=\")\n        yield start, None, _Tag(text, parameters if equals else None)\n        position = end\n    if position < len(markup):\n        yield position, markup[position:], None\n\n\ndef render(\n    markup: str,\n    style: Union[str, Style] = \"\",\n    emoji: bool = True,\n    emoji_variant: Optional[EmojiVariant] = None,\n) -> Text:\n    \"\"\"Render console markup in to a Text instance.\n\n    Args:\n        markup (str): A string containing console markup.\n        emoji (bool, optional): Also render emoji code. Defaults to True.\n\n    Raises:\n        MarkupError: If there is a syntax error in the markup.\n\n    Returns:\n        Text: A test instance.\n    \"\"\"\n    emoji_replace = _emoji_replace\n    if \"[\" not in markup:\n        return Text(\n            emoji_replace(markup, default_variant=emoji_variant) if emoji else markup,\n            style=style,\n        )\n    text = Text(style=style)\n    append = text.append\n    normalize = Style.normalize\n\n    style_stack: List[Tuple[int, Tag]] = []\n    pop = style_stack.pop\n\n    spans: List[Span] = []\n    append_span = spans.append\n\n    _Span = Span\n    _Tag = Tag\n\n    def pop_style(style_name: str) -> Tuple[int, Tag]:\n        \"\"\"Pop tag matching given style name.\"\"\"\n        for index, (_, tag) in enumerate(reversed(style_stack), 1):\n            if tag.name == style_name:\n                return pop(-index)\n        raise KeyError(style_name)\n\n    for position, plain_text, tag in _parse(markup):\n        if plain_text is not None:\n            # Handle open brace escapes, where the brace is not part of a tag.\n            plain_text = plain_text.replace(\"\\\\[\", \"[\")\n            append(emoji_replace(plain_text) if emoji else plain_text)\n        elif tag is not None:\n            if tag.name.startswith(\"/\"):  # Closing tag\n                style_name = tag.name[1:].strip()\n\n                if style_name:  # explicit close\n                    style_name = normalize(style_name)\n                    try:\n                        start, open_tag = pop_style(style_name)\n                    except KeyError:\n                        raise MarkupError(\n                            f\"closing tag '{tag.markup}' at position {position} doesn't match any open tag\"\n                        ) from None\n                else:  # implicit close\n                    try:\n                        start, open_tag = pop()\n                    except IndexError:\n                        raise MarkupError(\n                            f\"closing tag '[/]' at position {position} has nothing to close\"\n                        ) from None\n\n                if open_tag.name.startswith(\"@\"):\n                    if open_tag.parameters:\n                        handler_name = \"\"\n                        parameters = open_tag.parameters.strip()\n                        handler_match = RE_HANDLER.match(parameters)\n                        if handler_match is not None:\n                            handler_name, match_parameters = handler_match.groups()\n                            parameters = (\n                                \"()\" if match_parameters is None else match_parameters\n                            )\n\n                        try:\n                            meta_params = literal_eval(parameters)\n                        except SyntaxError as error:\n                            raise MarkupError(\n                                f\"error parsing {parameters!r} in {open_tag.parameters!r}; {error.msg}\"\n                            )\n                        except Exception as error:\n                            raise MarkupError(\n                                f\"error parsing {open_tag.parameters!r}; {error}\"\n                            ) from None\n\n                        if handler_name:\n                            meta_params = (\n                                handler_name,\n                                meta_params\n                                if isinstance(meta_params, tuple)\n                                else (meta_params,),\n                            )\n\n                    else:\n                        meta_params = ()\n\n                    append_span(\n                        _Span(\n                            start, len(text), Style(meta={open_tag.name: meta_params})\n                        )\n                    )\n                else:\n                    append_span(_Span(start, len(text), str(open_tag)))\n\n            else:  # Opening tag\n                normalized_tag = _Tag(normalize(tag.name), tag.parameters)\n                style_stack.append((len(text), normalized_tag))\n\n    text_length = len(text)\n    while style_stack:\n        start, tag = style_stack.pop()\n        style = str(tag)\n        if style:\n            append_span(_Span(start, text_length, style))\n\n    text.spans = sorted(spans[::-1], key=attrgetter(\"start\"))\n    return text\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n\n    MARKUP = [\n        \"[red]Hello World[/red]\",\n        \"[magenta]Hello [b]World[/b]\",\n        \"[bold]Bold[italic] bold and italic [/bold]italic[/italic]\",\n        \"Click [link=https://www.willmcgugan.com]here[/link] to visit my Blog\",\n        \":warning-emoji: [bold red blink] DANGER![/]\",\n    ]\n\n    from pip._vendor.rich import print\n    from pip._vendor.rich.table import Table\n\n    grid = Table(\"Markup\", \"Result\", padding=(0, 1))\n\n    for markup in MARKUP:\n        grid.add_row(Text(markup), markup)\n\n    print(grid)\n"},"hash":"tawkIysDkg"}