{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:soupsieve:css_types.py","body":"\"\"\"CSS selector structure items.\"\"\"\nfrom __future__ import annotations\nimport copyreg\nfrom .pretty import pretty\nfrom typing import Any, Iterator, Hashable, Pattern, Iterable, Mapping\n\n__all__ = (\n    'Selector',\n    'SelectorNull',\n    'SelectorTag',\n    'SelectorAttribute',\n    'SelectorContains',\n    'SelectorNth',\n    'SelectorLang',\n    'SelectorList',\n    'Namespaces',\n    'CustomSelectors'\n)\n\n\nSEL_EMPTY = 0x1\nSEL_ROOT = 0x2\nSEL_DEFAULT = 0x4\nSEL_INDETERMINATE = 0x8\nSEL_SCOPE = 0x10\nSEL_DIR_LTR = 0x20\nSEL_DIR_RTL = 0x40\nSEL_IN_RANGE = 0x80\nSEL_OUT_OF_RANGE = 0x100\nSEL_DEFINED = 0x200\nSEL_PLACEHOLDER_SHOWN = 0x400\n\n\nclass Immutable:\n    \"\"\"Immutable.\"\"\"\n\n    __slots__: tuple[str, ...] = ('_hash',)\n\n    _hash: int\n\n    def __init__(self, **kwargs: Any) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        temp = []\n        for k, v in kwargs.items():\n            temp.append(type(v))\n            temp.append(v)\n            super().__setattr__(k, v)\n        super().__setattr__('_hash', hash(tuple(temp)))\n\n    @classmethod\n    def __base__(cls) -> type[Immutable]:\n        \"\"\"Get base class.\"\"\"\n\n        return cls\n\n    def __eq__(self, other: Any) -> bool:\n        \"\"\"Equal.\"\"\"\n\n        return (\n            isinstance(other, self.__base__()) and\n            all(getattr(other, key) == getattr(self, key) for key in self.__slots__ if key != '_hash')\n        )\n\n    def __ne__(self, other: Any) -> bool:\n        \"\"\"Equal.\"\"\"\n\n        return (\n            not isinstance(other, self.__base__()) or\n            any(getattr(other, key) != getattr(self, key) for key in self.__slots__ if key != '_hash')\n        )\n\n    def __hash__(self) -> int:\n        \"\"\"Hash.\"\"\"\n\n        return self._hash\n\n    def __setattr__(self, name: str, value: Any) -> None:\n        \"\"\"Prevent mutability.\"\"\"\n\n        raise AttributeError(f\"'{self.__class__.__name__}' is immutable\")\n\n    def __repr__(self) -> str:  # pragma: no cover\n        \"\"\"Representation.\"\"\"\n\n        r = ', '.join([f\"{k}={getattr(self, k)!r}\" for k in self.__slots__[:-1]])\n        return f\"{self.__class__.__name__}({r})\"\n\n    __str__ = __repr__\n\n    def pretty(self) -> None:  # pragma: no cover\n        \"\"\"Pretty print.\"\"\"\n\n        print(pretty(self))\n\n\nclass ImmutableDict(Mapping[Any, Any]):\n    \"\"\"Hashable, immutable dictionary.\"\"\"\n\n    def __init__(\n        self,\n        arg: dict[Any, Any] | Iterable[tuple[Any, Any]]\n    ) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self._validate(arg)\n        self._d = dict(arg)\n        self._hash = hash(tuple([(type(x), x, type(y), y) for x, y in sorted(self._d.items())]))\n\n    def _validate(self, arg: dict[Any, Any] | Iterable[tuple[Any, Any]]) -> None:\n        \"\"\"Validate arguments.\"\"\"\n\n        if isinstance(arg, dict):\n            if not all(isinstance(v, Hashable) for v in arg.values()):\n                raise TypeError(f'{self.__class__.__name__} values must be hashable')\n        elif not all(isinstance(k, Hashable) and isinstance(v, Hashable) for k, v in arg):\n            raise TypeError(f'{self.__class__.__name__} values must be hashable')\n\n    def __iter__(self) -> Iterator[Any]:\n        \"\"\"Iterator.\"\"\"\n\n        return iter(self._d)\n\n    def __len__(self) -> int:\n        \"\"\"Length.\"\"\"\n\n        return len(self._d)\n\n    def __getitem__(self, key: Any) -> Any:\n        \"\"\"Get item: `namespace['key']`.\"\"\"\n\n        return self._d[key]\n\n    def __hash__(self) -> int:\n        \"\"\"Hash.\"\"\"\n\n        return self._hash\n\n    def __repr__(self) -> str:  # pragma: no cover\n        \"\"\"Representation.\"\"\"\n\n        return f\"{self._d!r}\"\n\n    __str__ = __repr__\n\n\nclass Namespaces(ImmutableDict):\n    \"\"\"Namespaces.\"\"\"\n\n    def __init__(self, arg: dict[str, str] | Iterable[tuple[str, str]]) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(arg)\n\n    def _validate(self, arg: dict[str, str] | Iterable[tuple[str, str]]) -> None:\n        \"\"\"Validate arguments.\"\"\"\n\n        if isinstance(arg, dict):\n            if not all(isinstance(v, str) for v in arg.values()):\n                raise TypeError(f'{self.__class__.__name__} values must be hashable')\n        elif not all(isinstance(k, str) and isinstance(v, str) for k, v in arg):\n            raise TypeError(f'{self.__class__.__name__} keys and values must be Unicode strings')\n\n\nclass CustomSelectors(ImmutableDict):\n    \"\"\"Custom selectors.\"\"\"\n\n    def __init__(self, arg: dict[str, str] | Iterable[tuple[str, str]]) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(arg)\n\n    def _validate(self, arg: dict[str, str] | Iterable[tuple[str, str]]) -> None:\n        \"\"\"Validate arguments.\"\"\"\n\n        if isinstance(arg, dict):\n            if not all(isinstance(v, str) for v in arg.values()):\n                raise TypeError(f'{self.__class__.__name__} values must be hashable')\n        elif not all(isinstance(k, str) and isinstance(v, str) for k, v in arg):\n            raise TypeError(f'{self.__class__.__name__} keys and values must be Unicode strings')\n\n\nclass Selector(Immutable):\n    \"\"\"Selector.\"\"\"\n\n    __slots__ = (\n        'tag', 'ids', 'classes', 'attributes', 'nth', 'selectors',\n        'relation', 'rel_type', 'contains', 'lang', 'flags', '_hash'\n    )\n\n    tag: SelectorTag | None\n    ids: tuple[str, ...]\n    classes: tuple[str, ...]\n    attributes: tuple[SelectorAttribute, ...]\n    nth: tuple[SelectorNth, ...]\n    selectors: tuple[SelectorList, ...]\n    relation: SelectorList\n    rel_type: str | None\n    contains: tuple[SelectorContains, ...]\n    lang: tuple[SelectorLang, ...]\n    flags: int\n\n    def __init__(\n        self,\n        tag: SelectorTag | None,\n        ids: tuple[str, ...],\n        classes: tuple[str, ...],\n        attributes: tuple[SelectorAttribute, ...],\n        nth: tuple[SelectorNth, ...],\n        selectors: tuple[SelectorList, ...],\n        relation: SelectorList,\n        rel_type: str | None,\n        contains: tuple[SelectorContains, ...],\n        lang: tuple[SelectorLang, ...],\n        flags: int\n    ):\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(\n            tag=tag,\n            ids=ids,\n            classes=classes,\n            attributes=attributes,\n            nth=nth,\n            selectors=selectors,\n            relation=relation,\n            rel_type=rel_type,\n            contains=contains,\n            lang=lang,\n            flags=flags\n        )\n\n\nclass SelectorNull(Immutable):\n    \"\"\"Null Selector.\"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__()\n\n\nclass SelectorTag(Immutable):\n    \"\"\"Selector tag.\"\"\"\n\n    __slots__ = (\"name\", \"prefix\", \"_hash\")\n\n    name: str\n    prefix: str | None\n\n    def __init__(self, name: str, prefix: str | None) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(name=name, prefix=prefix)\n\n\nclass SelectorAttribute(Immutable):\n    \"\"\"Selector attribute rule.\"\"\"\n\n    __slots__ = (\"attribute\", \"prefix\", \"pattern\", \"xml_type_pattern\", \"_hash\")\n\n    attribute: str\n    prefix: str\n    pattern: Pattern[str] | None\n    xml_type_pattern: Pattern[str] | None\n\n    def __init__(\n        self,\n        attribute: str,\n        prefix: str,\n        pattern: Pattern[str] | None,\n        xml_type_pattern: Pattern[str] | None\n    ) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(\n            attribute=attribute,\n            prefix=prefix,\n            pattern=pattern,\n            xml_type_pattern=xml_type_pattern\n        )\n\n\nclass SelectorContains(Immutable):\n    \"\"\"Selector contains rule.\"\"\"\n\n    __slots__ = (\"text\", \"own\", \"_hash\")\n\n    text: tuple[str, ...]\n    own: bool\n\n    def __init__(self, text: Iterable[str], own: bool) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(text=tuple(text), own=own)\n\n\nclass SelectorNth(Immutable):\n    \"\"\"Selector nth type.\"\"\"\n\n    __slots__ = (\"a\", \"n\", \"b\", \"of_type\", \"last\", \"selectors\", \"_hash\")\n\n    a: int\n    n: bool\n    b: int\n    of_type: bool\n    last: bool\n    selectors: SelectorList\n\n    def __init__(self, a: int, n: bool, b: int, of_type: bool, last: bool, selectors: SelectorList) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(\n            a=a,\n            n=n,\n            b=b,\n            of_type=of_type,\n            last=last,\n            selectors=selectors\n        )\n\n\nclass SelectorLang(Immutable):\n    \"\"\"Selector language rules.\"\"\"\n\n    __slots__ = (\"languages\", \"_hash\",)\n\n    languages: tuple[str, ...]\n\n    def __init__(self, languages: Iterable[str]):\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(languages=tuple(languages))\n\n    def __iter__(self) -> Iterator[str]:\n        \"\"\"Iterator.\"\"\"\n\n        return iter(self.languages)\n\n    def __len__(self) -> int:  # pragma: no cover\n        \"\"\"Length.\"\"\"\n\n        return len(self.languages)\n\n    def __getitem__(self, index: int) -> str:  # pragma: no cover\n        \"\"\"Get item.\"\"\"\n\n        return self.languages[index]\n\n\nclass SelectorList(Immutable):\n    \"\"\"Selector list.\"\"\"\n\n    __slots__ = (\"selectors\", \"is_not\", \"is_html\", \"_hash\")\n\n    selectors: tuple[Selector | SelectorNull, ...]\n    is_not: bool\n    is_html: bool\n\n    def __init__(\n        self,\n        selectors: Iterable[Selector | SelectorNull] | None = None,\n        is_not: bool = False,\n        is_html: bool = False\n    ) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(\n            selectors=tuple(selectors) if selectors is not None else (),\n            is_not=is_not,\n            is_html=is_html\n        )\n\n    def __iter__(self) -> Iterator[Selector | SelectorNull]:\n        \"\"\"Iterator.\"\"\"\n\n        return iter(self.selectors)\n\n    def __len__(self) -> int:\n        \"\"\"Length.\"\"\"\n\n        return len(self.selectors)\n\n    def __getitem__(self, index: int) -> Selector | SelectorNull:\n        \"\"\"Get item.\"\"\"\n\n        return self.selectors[index]\n\n\ndef _pickle(p: Any) -> Any:\n    return p.__base__(), tuple([getattr(p, s) for s in p.__slots__[:-1]])\n\n\ndef pickle_register(obj: Any) -> None:\n    \"\"\"Allow object to be pickled.\"\"\"\n\n    copyreg.pickle(obj, _pickle)\n\n\npickle_register(Selector)\npickle_register(SelectorNull)\npickle_register(SelectorTag)\npickle_register(SelectorAttribute)\npickle_register(SelectorContains)\npickle_register(SelectorNth)\npickle_register(SelectorLang)\npickle_register(SelectorList)\n"},"hash":"eyMqWmk7vB"}