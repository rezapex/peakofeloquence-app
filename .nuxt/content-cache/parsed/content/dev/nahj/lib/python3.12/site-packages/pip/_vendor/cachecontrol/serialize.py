{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:cachecontrol:serialize.py","body":"# SPDX-FileCopyrightText: 2015 Eric Larson\n#\n# SPDX-License-Identifier: Apache-2.0\nfrom __future__ import annotations\n\nimport io\nfrom typing import IO, TYPE_CHECKING, Any, Mapping, cast\n\nfrom pip._vendor import msgpack\nfrom pip._vendor.requests.structures import CaseInsensitiveDict\nfrom pip._vendor.urllib3 import HTTPResponse\n\nif TYPE_CHECKING:\n    from pip._vendor.requests import PreparedRequest\n\n\nclass Serializer:\n    serde_version = \"4\"\n\n    def dumps(\n        self,\n        request: PreparedRequest,\n        response: HTTPResponse,\n        body: bytes | None = None,\n    ) -> bytes:\n        response_headers: CaseInsensitiveDict[str] = CaseInsensitiveDict(\n            response.headers\n        )\n\n        if body is None:\n            # When a body isn't passed in, we'll read the response. We\n            # also update the response with a new file handler to be\n            # sure it acts as though it was never read.\n            body = response.read(decode_content=False)\n            response._fp = io.BytesIO(body)  # type: ignore[attr-defined]\n            response.length_remaining = len(body)\n\n        data = {\n            \"response\": {\n                \"body\": body,  # Empty bytestring if body is stored separately\n                \"headers\": {str(k): str(v) for k, v in response.headers.items()},  # type: ignore[no-untyped-call]\n                \"status\": response.status,\n                \"version\": response.version,\n                \"reason\": str(response.reason),\n                \"decode_content\": response.decode_content,\n            }\n        }\n\n        # Construct our vary headers\n        data[\"vary\"] = {}\n        if \"vary\" in response_headers:\n            varied_headers = response_headers[\"vary\"].split(\",\")\n            for header in varied_headers:\n                header = str(header).strip()\n                header_value = request.headers.get(header, None)\n                if header_value is not None:\n                    header_value = str(header_value)\n                data[\"vary\"][header] = header_value\n\n        return b\",\".join([f\"cc={self.serde_version}\".encode(), self.serialize(data)])\n\n    def serialize(self, data: dict[str, Any]) -> bytes:\n        return cast(bytes, msgpack.dumps(data, use_bin_type=True))\n\n    def loads(\n        self,\n        request: PreparedRequest,\n        data: bytes,\n        body_file: IO[bytes] | None = None,\n    ) -> HTTPResponse | None:\n        # Short circuit if we've been given an empty set of data\n        if not data:\n            return None\n\n        # Determine what version of the serializer the data was serialized\n        # with\n        try:\n            ver, data = data.split(b\",\", 1)\n        except ValueError:\n            ver = b\"cc=0\"\n\n        # Make sure that our \"ver\" is actually a version and isn't a false\n        # positive from a , being in the data stream.\n        if ver[:3] != b\"cc=\":\n            data = ver + data\n            ver = b\"cc=0\"\n\n        # Get the version number out of the cc=N\n        verstr = ver.split(b\"=\", 1)[-1].decode(\"ascii\")\n\n        # Dispatch to the actual load method for the given version\n        try:\n            return getattr(self, f\"_loads_v{verstr}\")(request, data, body_file)  # type: ignore[no-any-return]\n\n        except AttributeError:\n            # This is a version we don't have a loads function for, so we'll\n            # just treat it as a miss and return None\n            return None\n\n    def prepare_response(\n        self,\n        request: PreparedRequest,\n        cached: Mapping[str, Any],\n        body_file: IO[bytes] | None = None,\n    ) -> HTTPResponse | None:\n        \"\"\"Verify our vary headers match and construct a real urllib3\n        HTTPResponse object.\n        \"\"\"\n        # Special case the '*' Vary value as it means we cannot actually\n        # determine if the cached response is suitable for this request.\n        # This case is also handled in the controller code when creating\n        # a cache entry, but is left here for backwards compatibility.\n        if \"*\" in cached.get(\"vary\", {}):\n            return None\n\n        # Ensure that the Vary headers for the cached response match our\n        # request\n        for header, value in cached.get(\"vary\", {}).items():\n            if request.headers.get(header, None) != value:\n                return None\n\n        body_raw = cached[\"response\"].pop(\"body\")\n\n        headers: CaseInsensitiveDict[str] = CaseInsensitiveDict(\n            data=cached[\"response\"][\"headers\"]\n        )\n        if headers.get(\"transfer-encoding\", \"\") == \"chunked\":\n            headers.pop(\"transfer-encoding\")\n\n        cached[\"response\"][\"headers\"] = headers\n\n        try:\n            body: IO[bytes]\n            if body_file is None:\n                body = io.BytesIO(body_raw)\n            else:\n                body = body_file\n        except TypeError:\n            # This can happen if cachecontrol serialized to v1 format (pickle)\n            # using Python 2. A Python 2 str(byte string) will be unpickled as\n            # a Python 3 str (unicode string), which will cause the above to\n            # fail with:\n            #\n            #     TypeError: 'str' does not support the buffer interface\n            body = io.BytesIO(body_raw.encode(\"utf8\"))\n\n        # Discard any `strict` parameter serialized by older version of cachecontrol.\n        cached[\"response\"].pop(\"strict\", None)\n\n        return HTTPResponse(body=body, preload_content=False, **cached[\"response\"])\n\n    def _loads_v0(\n        self,\n        request: PreparedRequest,\n        data: bytes,\n        body_file: IO[bytes] | None = None,\n    ) -> None:\n        # The original legacy cache data. This doesn't contain enough\n        # information to construct everything we need, so we'll treat this as\n        # a miss.\n        return None\n\n    def _loads_v1(\n        self,\n        request: PreparedRequest,\n        data: bytes,\n        body_file: IO[bytes] | None = None,\n    ) -> HTTPResponse | None:\n        # The \"v1\" pickled cache format. This is no longer supported\n        # for security reasons, so we treat it as a miss.\n        return None\n\n    def _loads_v2(\n        self,\n        request: PreparedRequest,\n        data: bytes,\n        body_file: IO[bytes] | None = None,\n    ) -> HTTPResponse | None:\n        # The \"v2\" compressed base64 cache format.\n        # This has been removed due to age and poor size/performance\n        # characteristics, so we treat it as a miss.\n        return None\n\n    def _loads_v3(\n        self,\n        request: PreparedRequest,\n        data: bytes,\n        body_file: IO[bytes] | None = None,\n    ) -> None:\n        # Due to Python 2 encoding issues, it's impossible to know for sure\n        # exactly how to load v3 entries, thus we'll treat these as a miss so\n        # that they get rewritten out as v4 entries.\n        return None\n\n    def _loads_v4(\n        self,\n        request: PreparedRequest,\n        data: bytes,\n        body_file: IO[bytes] | None = None,\n    ) -> HTTPResponse | None:\n        try:\n            cached = msgpack.loads(data, raw=False)\n        except ValueError:\n            return None\n\n        return self.prepare_response(request, cached, body_file)\n"},"hash":"9rC8NSnush"}