{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:cache.py","body":"\"\"\"Cache Management\n\"\"\"\n\nimport hashlib\nimport json\nimport logging\nimport os\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional\n\nfrom pip._vendor.packaging.tags import Tag, interpreter_name, interpreter_version\nfrom pip._vendor.packaging.utils import canonicalize_name\n\nfrom pip._internal.exceptions import InvalidWheelFilename\nfrom pip._internal.models.direct_url import DirectUrl\nfrom pip._internal.models.link import Link\nfrom pip._internal.models.wheel import Wheel\nfrom pip._internal.utils.temp_dir import TempDirectory, tempdir_kinds\nfrom pip._internal.utils.urls import path_to_url\n\nlogger = logging.getLogger(__name__)\n\nORIGIN_JSON_NAME = \"origin.json\"\n\n\ndef _hash_dict(d: Dict[str, str]) -> str:\n    \"\"\"Return a stable sha224 of a dictionary.\"\"\"\n    s = json.dumps(d, sort_keys=True, separators=(\",\", \":\"), ensure_ascii=True)\n    return hashlib.sha224(s.encode(\"ascii\")).hexdigest()\n\n\nclass Cache:\n    \"\"\"An abstract class - provides cache directories for data from links\n\n    :param cache_dir: The root of the cache.\n    \"\"\"\n\n    def __init__(self, cache_dir: str) -> None:\n        super().__init__()\n        assert not cache_dir or os.path.isabs(cache_dir)\n        self.cache_dir = cache_dir or None\n\n    def _get_cache_path_parts(self, link: Link) -> List[str]:\n        \"\"\"Get parts of part that must be os.path.joined with cache_dir\"\"\"\n\n        # We want to generate an url to use as our cache key, we don't want to\n        # just re-use the URL because it might have other items in the fragment\n        # and we don't care about those.\n        key_parts = {\"url\": link.url_without_fragment}\n        if link.hash_name is not None and link.hash is not None:\n            key_parts[link.hash_name] = link.hash\n        if link.subdirectory_fragment:\n            key_parts[\"subdirectory\"] = link.subdirectory_fragment\n\n        # Include interpreter name, major and minor version in cache key\n        # to cope with ill-behaved sdists that build a different wheel\n        # depending on the python version their setup.py is being run on,\n        # and don't encode the difference in compatibility tags.\n        # https://github.com/pypa/pip/issues/7296\n        key_parts[\"interpreter_name\"] = interpreter_name()\n        key_parts[\"interpreter_version\"] = interpreter_version()\n\n        # Encode our key url with sha224, we'll use this because it has similar\n        # security properties to sha256, but with a shorter total output (and\n        # thus less secure). However the differences don't make a lot of\n        # difference for our use case here.\n        hashed = _hash_dict(key_parts)\n\n        # We want to nest the directories some to prevent having a ton of top\n        # level directories where we might run out of sub directories on some\n        # FS.\n        parts = [hashed[:2], hashed[2:4], hashed[4:6], hashed[6:]]\n\n        return parts\n\n    def _get_candidates(self, link: Link, canonical_package_name: str) -> List[Any]:\n        can_not_cache = not self.cache_dir or not canonical_package_name or not link\n        if can_not_cache:\n            return []\n\n        path = self.get_path_for_link(link)\n        if os.path.isdir(path):\n            return [(candidate, path) for candidate in os.listdir(path)]\n        return []\n\n    def get_path_for_link(self, link: Link) -> str:\n        \"\"\"Return a directory to store cached items in for link.\"\"\"\n        raise NotImplementedError()\n\n    def get(\n        self,\n        link: Link,\n        package_name: Optional[str],\n        supported_tags: List[Tag],\n    ) -> Link:\n        \"\"\"Returns a link to a cached item if it exists, otherwise returns the\n        passed link.\n        \"\"\"\n        raise NotImplementedError()\n\n\nclass SimpleWheelCache(Cache):\n    \"\"\"A cache of wheels for future installs.\"\"\"\n\n    def __init__(self, cache_dir: str) -> None:\n        super().__init__(cache_dir)\n\n    def get_path_for_link(self, link: Link) -> str:\n        \"\"\"Return a directory to store cached wheels for link\n\n        Because there are M wheels for any one sdist, we provide a directory\n        to cache them in, and then consult that directory when looking up\n        cache hits.\n\n        We only insert things into the cache if they have plausible version\n        numbers, so that we don't contaminate the cache with things that were\n        not unique. E.g. ./package might have dozens of installs done for it\n        and build a version of 0.0...and if we built and cached a wheel, we'd\n        end up using the same wheel even if the source has been edited.\n\n        :param link: The link of the sdist for which this will cache wheels.\n        \"\"\"\n        parts = self._get_cache_path_parts(link)\n        assert self.cache_dir\n        # Store wheels within the root cache_dir\n        return os.path.join(self.cache_dir, \"wheels\", *parts)\n\n    def get(\n        self,\n        link: Link,\n        package_name: Optional[str],\n        supported_tags: List[Tag],\n    ) -> Link:\n        candidates = []\n\n        if not package_name:\n            return link\n\n        canonical_package_name = canonicalize_name(package_name)\n        for wheel_name, wheel_dir in self._get_candidates(link, canonical_package_name):\n            try:\n                wheel = Wheel(wheel_name)\n            except InvalidWheelFilename:\n                continue\n            if canonicalize_name(wheel.name) != canonical_package_name:\n                logger.debug(\n                    \"Ignoring cached wheel %s for %s as it \"\n                    \"does not match the expected distribution name %s.\",\n                    wheel_name,\n                    link,\n                    package_name,\n                )\n                continue\n            if not wheel.supported(supported_tags):\n                # Built for a different python/arch/etc\n                continue\n            candidates.append(\n                (\n                    wheel.support_index_min(supported_tags),\n                    wheel_name,\n                    wheel_dir,\n                )\n            )\n\n        if not candidates:\n            return link\n\n        _, wheel_name, wheel_dir = min(candidates)\n        return Link(path_to_url(os.path.join(wheel_dir, wheel_name)))\n\n\nclass EphemWheelCache(SimpleWheelCache):\n    \"\"\"A SimpleWheelCache that creates it's own temporary cache directory\"\"\"\n\n    def __init__(self) -> None:\n        self._temp_dir = TempDirectory(\n            kind=tempdir_kinds.EPHEM_WHEEL_CACHE,\n            globally_managed=True,\n        )\n\n        super().__init__(self._temp_dir.path)\n\n\nclass CacheEntry:\n    def __init__(\n        self,\n        link: Link,\n        persistent: bool,\n    ):\n        self.link = link\n        self.persistent = persistent\n        self.origin: Optional[DirectUrl] = None\n        origin_direct_url_path = Path(self.link.file_path).parent / ORIGIN_JSON_NAME\n        if origin_direct_url_path.exists():\n            try:\n                self.origin = DirectUrl.from_json(\n                    origin_direct_url_path.read_text(encoding=\"utf-8\")\n                )\n            except Exception as e:\n                logger.warning(\n                    \"Ignoring invalid cache entry origin file %s for %s (%s)\",\n                    origin_direct_url_path,\n                    link.filename,\n                    e,\n                )\n\n\nclass WheelCache(Cache):\n    \"\"\"Wraps EphemWheelCache and SimpleWheelCache into a single Cache\n\n    This Cache allows for gracefully degradation, using the ephem wheel cache\n    when a certain link is not found in the simple wheel cache first.\n    \"\"\"\n\n    def __init__(self, cache_dir: str) -> None:\n        super().__init__(cache_dir)\n        self._wheel_cache = SimpleWheelCache(cache_dir)\n        self._ephem_cache = EphemWheelCache()\n\n    def get_path_for_link(self, link: Link) -> str:\n        return self._wheel_cache.get_path_for_link(link)\n\n    def get_ephem_path_for_link(self, link: Link) -> str:\n        return self._ephem_cache.get_path_for_link(link)\n\n    def get(\n        self,\n        link: Link,\n        package_name: Optional[str],\n        supported_tags: List[Tag],\n    ) -> Link:\n        cache_entry = self.get_cache_entry(link, package_name, supported_tags)\n        if cache_entry is None:\n            return link\n        return cache_entry.link\n\n    def get_cache_entry(\n        self,\n        link: Link,\n        package_name: Optional[str],\n        supported_tags: List[Tag],\n    ) -> Optional[CacheEntry]:\n        \"\"\"Returns a CacheEntry with a link to a cached item if it exists or\n        None. The cache entry indicates if the item was found in the persistent\n        or ephemeral cache.\n        \"\"\"\n        retval = self._wheel_cache.get(\n            link=link,\n            package_name=package_name,\n            supported_tags=supported_tags,\n        )\n        if retval is not link:\n            return CacheEntry(retval, persistent=True)\n\n        retval = self._ephem_cache.get(\n            link=link,\n            package_name=package_name,\n            supported_tags=supported_tags,\n        )\n        if retval is not link:\n            return CacheEntry(retval, persistent=False)\n\n        return None\n\n    @staticmethod\n    def record_download_origin(cache_dir: str, download_info: DirectUrl) -> None:\n        origin_path = Path(cache_dir) / ORIGIN_JSON_NAME\n        if origin_path.exists():\n            try:\n                origin = DirectUrl.from_json(origin_path.read_text(encoding=\"utf-8\"))\n            except Exception as e:\n                logger.warning(\n                    \"Could not read origin file %s in cache entry (%s). \"\n                    \"Will attempt to overwrite it.\",\n                    origin_path,\n                    e,\n                )\n            else:\n                # TODO: use DirectUrl.equivalent when\n                # https://github.com/pypa/pip/pull/10564 is merged.\n                if origin.url != download_info.url:\n                    logger.warning(\n                        \"Origin URL %s in cache entry %s does not match download URL \"\n                        \"%s. This is likely a pip bug or a cache corruption issue. \"\n                        \"Will overwrite it with the new value.\",\n                        origin.url,\n                        cache_dir,\n                        download_info.url,\n                    )\n        origin_path.write_text(download_info.to_json(), encoding=\"utf-8\")\n"},"hash":"P5UuVy8W8z"}