{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:pyparsing:__init__.py","body":"# module pyparsing.py\n#\n# Copyright (c) 2003-2022  Paul T. McGuire\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n#\n\n__doc__ = \"\"\"\npyparsing module - Classes and methods to define and execute parsing grammars\n=============================================================================\n\nThe pyparsing module is an alternative approach to creating and\nexecuting simple grammars, vs. the traditional lex/yacc approach, or the\nuse of regular expressions.  With pyparsing, you don't need to learn\na new syntax for defining grammars or matching expressions - the parsing\nmodule provides a library of classes that you use to construct the\ngrammar directly in Python.\n\nHere is a program to parse \"Hello, World!\" (or any greeting of the form\n``\"<salutation>, <addressee>!\"``), built up using :class:`Word`,\n:class:`Literal`, and :class:`And` elements\n(the :meth:`'+'<ParserElement.__add__>` operators create :class:`And` expressions,\nand the strings are auto-converted to :class:`Literal` expressions)::\n\n    from pip._vendor.pyparsing import Word, alphas\n\n    # define grammar of a greeting\n    greet = Word(alphas) + \",\" + Word(alphas) + \"!\"\n\n    hello = \"Hello, World!\"\n    print(hello, \"->\", greet.parse_string(hello))\n\nThe program outputs the following::\n\n    Hello, World! -> ['Hello', ',', 'World', '!']\n\nThe Python representation of the grammar is quite readable, owing to the\nself-explanatory class names, and the use of :class:`'+'<And>`,\n:class:`'|'<MatchFirst>`, :class:`'^'<Or>` and :class:`'&'<Each>` operators.\n\nThe :class:`ParseResults` object returned from\n:class:`ParserElement.parse_string` can be\naccessed as a nested list, a dictionary, or an object with named\nattributes.\n\nThe pyparsing module handles some of the problems that are typically\nvexing when writing text parsers:\n\n  - extra or missing whitespace (the above program will also handle\n    \"Hello,World!\", \"Hello  ,  World  !\", etc.)\n  - quoted strings\n  - embedded comments\n\n\nGetting Started -\n-----------------\nVisit the classes :class:`ParserElement` and :class:`ParseResults` to\nsee the base classes that most other pyparsing\nclasses inherit from. Use the docstrings for examples of how to:\n\n - construct literal match expressions from :class:`Literal` and\n   :class:`CaselessLiteral` classes\n - construct character word-group expressions using the :class:`Word`\n   class\n - see how to create repetitive expressions using :class:`ZeroOrMore`\n   and :class:`OneOrMore` classes\n - use :class:`'+'<And>`, :class:`'|'<MatchFirst>`, :class:`'^'<Or>`,\n   and :class:`'&'<Each>` operators to combine simple expressions into\n   more complex ones\n - associate names with your parsed results using\n   :class:`ParserElement.set_results_name`\n - access the parsed data, which is returned as a :class:`ParseResults`\n   object\n - find some helpful expression short-cuts like :class:`DelimitedList`\n   and :class:`one_of`\n - find more useful common expressions in the :class:`pyparsing_common`\n   namespace class\n\"\"\"\nfrom typing import NamedTuple\n\n\nclass version_info(NamedTuple):\n    major: int\n    minor: int\n    micro: int\n    releaselevel: str\n    serial: int\n\n    @property\n    def __version__(self):\n        return (\n            f\"{self.major}.{self.minor}.{self.micro}\"\n            + (\n                f\"{'r' if self.releaselevel[0] == 'c' else ''}{self.releaselevel[0]}{self.serial}\",\n                \"\",\n            )[self.releaselevel == \"final\"]\n        )\n\n    def __str__(self):\n        return f\"{__name__} {self.__version__} / {__version_time__}\"\n\n    def __repr__(self):\n        return f\"{__name__}.{type(self).__name__}({', '.join('{}={!r}'.format(*nv) for nv in zip(self._fields, self))})\"\n\n\n__version_info__ = version_info(3, 1, 0, \"final\", 1)\n__version_time__ = \"18 Jun 2023 14:05 UTC\"\n__version__ = __version_info__.__version__\n__versionTime__ = __version_time__\n__author__ = \"Paul McGuire <ptmcg.gm+pyparsing@gmail.com>\"\n\nfrom .util import *\nfrom .exceptions import *\nfrom .actions import *\nfrom .core import __diag__, __compat__\nfrom .results import *\nfrom .core import *  # type: ignore[misc, assignment]\nfrom .core import _builtin_exprs as core_builtin_exprs\nfrom .helpers import *  # type: ignore[misc, assignment]\nfrom .helpers import _builtin_exprs as helper_builtin_exprs\n\nfrom .unicode import unicode_set, UnicodeRangeList, pyparsing_unicode as unicode\nfrom .testing import pyparsing_test as testing\nfrom .common import (\n    pyparsing_common as common,\n    _builtin_exprs as common_builtin_exprs,\n)\n\n# define backward compat synonyms\nif \"pyparsing_unicode\" not in globals():\n    pyparsing_unicode = unicode  # type: ignore[misc]\nif \"pyparsing_common\" not in globals():\n    pyparsing_common = common  # type: ignore[misc]\nif \"pyparsing_test\" not in globals():\n    pyparsing_test = testing  # type: ignore[misc]\n\ncore_builtin_exprs += common_builtin_exprs + helper_builtin_exprs\n\n\n__all__ = [\n    \"__version__\",\n    \"__version_time__\",\n    \"__author__\",\n    \"__compat__\",\n    \"__diag__\",\n    \"And\",\n    \"AtLineStart\",\n    \"AtStringStart\",\n    \"CaselessKeyword\",\n    \"CaselessLiteral\",\n    \"CharsNotIn\",\n    \"CloseMatch\",\n    \"Combine\",\n    \"DelimitedList\",\n    \"Dict\",\n    \"Each\",\n    \"Empty\",\n    \"FollowedBy\",\n    \"Forward\",\n    \"GoToColumn\",\n    \"Group\",\n    \"IndentedBlock\",\n    \"Keyword\",\n    \"LineEnd\",\n    \"LineStart\",\n    \"Literal\",\n    \"Located\",\n    \"PrecededBy\",\n    \"MatchFirst\",\n    \"NoMatch\",\n    \"NotAny\",\n    \"OneOrMore\",\n    \"OnlyOnce\",\n    \"OpAssoc\",\n    \"Opt\",\n    \"Optional\",\n    \"Or\",\n    \"ParseBaseException\",\n    \"ParseElementEnhance\",\n    \"ParseException\",\n    \"ParseExpression\",\n    \"ParseFatalException\",\n    \"ParseResults\",\n    \"ParseSyntaxException\",\n    \"ParserElement\",\n    \"PositionToken\",\n    \"QuotedString\",\n    \"RecursiveGrammarException\",\n    \"Regex\",\n    \"SkipTo\",\n    \"StringEnd\",\n    \"StringStart\",\n    \"Suppress\",\n    \"Token\",\n    \"TokenConverter\",\n    \"White\",\n    \"Word\",\n    \"WordEnd\",\n    \"WordStart\",\n    \"ZeroOrMore\",\n    \"Char\",\n    \"alphanums\",\n    \"alphas\",\n    \"alphas8bit\",\n    \"any_close_tag\",\n    \"any_open_tag\",\n    \"autoname_elements\",\n    \"c_style_comment\",\n    \"col\",\n    \"common_html_entity\",\n    \"condition_as_parse_action\",\n    \"counted_array\",\n    \"cpp_style_comment\",\n    \"dbl_quoted_string\",\n    \"dbl_slash_comment\",\n    \"delimited_list\",\n    \"dict_of\",\n    \"empty\",\n    \"hexnums\",\n    \"html_comment\",\n    \"identchars\",\n    \"identbodychars\",\n    \"infix_notation\",\n    \"java_style_comment\",\n    \"line\",\n    \"line_end\",\n    \"line_start\",\n    \"lineno\",\n    \"make_html_tags\",\n    \"make_xml_tags\",\n    \"match_only_at_col\",\n    \"match_previous_expr\",\n    \"match_previous_literal\",\n    \"nested_expr\",\n    \"null_debug_action\",\n    \"nums\",\n    \"one_of\",\n    \"original_text_for\",\n    \"printables\",\n    \"punc8bit\",\n    \"pyparsing_common\",\n    \"pyparsing_test\",\n    \"pyparsing_unicode\",\n    \"python_style_comment\",\n    \"quoted_string\",\n    \"remove_quotes\",\n    \"replace_with\",\n    \"replace_html_entity\",\n    \"rest_of_line\",\n    \"sgl_quoted_string\",\n    \"srange\",\n    \"string_end\",\n    \"string_start\",\n    \"token_map\",\n    \"trace_parse_action\",\n    \"ungroup\",\n    \"unicode_set\",\n    \"unicode_string\",\n    \"with_attribute\",\n    \"with_class\",\n    # pre-PEP8 compatibility names\n    \"__versionTime__\",\n    \"anyCloseTag\",\n    \"anyOpenTag\",\n    \"cStyleComment\",\n    \"commonHTMLEntity\",\n    \"conditionAsParseAction\",\n    \"countedArray\",\n    \"cppStyleComment\",\n    \"dblQuotedString\",\n    \"dblSlashComment\",\n    \"delimitedList\",\n    \"dictOf\",\n    \"htmlComment\",\n    \"indentedBlock\",\n    \"infixNotation\",\n    \"javaStyleComment\",\n    \"lineEnd\",\n    \"lineStart\",\n    \"locatedExpr\",\n    \"makeHTMLTags\",\n    \"makeXMLTags\",\n    \"matchOnlyAtCol\",\n    \"matchPreviousExpr\",\n    \"matchPreviousLiteral\",\n    \"nestedExpr\",\n    \"nullDebugAction\",\n    \"oneOf\",\n    \"opAssoc\",\n    \"originalTextFor\",\n    \"pythonStyleComment\",\n    \"quotedString\",\n    \"removeQuotes\",\n    \"replaceHTMLEntity\",\n    \"replaceWith\",\n    \"restOfLine\",\n    \"sglQuotedString\",\n    \"stringEnd\",\n    \"stringStart\",\n    \"tokenMap\",\n    \"traceParseAction\",\n    \"unicodeString\",\n    \"withAttribute\",\n    \"withClass\",\n]\n"},"hash":"sUObgm3YRy"}