{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:resolution:resolvelib:requirements.py","body":"from pip._vendor.packaging.specifiers import SpecifierSet\nfrom pip._vendor.packaging.utils import NormalizedName, canonicalize_name\n\nfrom pip._internal.req.constructors import install_req_drop_extras\nfrom pip._internal.req.req_install import InstallRequirement\n\nfrom .base import Candidate, CandidateLookup, Requirement, format_name\n\n\nclass ExplicitRequirement(Requirement):\n    def __init__(self, candidate: Candidate) -> None:\n        self.candidate = candidate\n\n    def __str__(self) -> str:\n        return str(self.candidate)\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({self.candidate!r})\"\n\n    @property\n    def project_name(self) -> NormalizedName:\n        # No need to canonicalize - the candidate did this\n        return self.candidate.project_name\n\n    @property\n    def name(self) -> str:\n        # No need to canonicalize - the candidate did this\n        return self.candidate.name\n\n    def format_for_error(self) -> str:\n        return self.candidate.format_for_error()\n\n    def get_candidate_lookup(self) -> CandidateLookup:\n        return self.candidate, None\n\n    def is_satisfied_by(self, candidate: Candidate) -> bool:\n        return candidate == self.candidate\n\n\nclass SpecifierRequirement(Requirement):\n    def __init__(self, ireq: InstallRequirement) -> None:\n        assert ireq.link is None, \"This is a link, not a specifier\"\n        self._ireq = ireq\n        self._extras = frozenset(canonicalize_name(e) for e in self._ireq.extras)\n\n    def __str__(self) -> str:\n        return str(self._ireq.req)\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({str(self._ireq.req)!r})\"\n\n    @property\n    def project_name(self) -> NormalizedName:\n        assert self._ireq.req, \"Specifier-backed ireq is always PEP 508\"\n        return canonicalize_name(self._ireq.req.name)\n\n    @property\n    def name(self) -> str:\n        return format_name(self.project_name, self._extras)\n\n    def format_for_error(self) -> str:\n        # Convert comma-separated specifiers into \"A, B, ..., F and G\"\n        # This makes the specifier a bit more \"human readable\", without\n        # risking a change in meaning. (Hopefully! Not all edge cases have\n        # been checked)\n        parts = [s.strip() for s in str(self).split(\",\")]\n        if len(parts) == 0:\n            return \"\"\n        elif len(parts) == 1:\n            return parts[0]\n\n        return \", \".join(parts[:-1]) + \" and \" + parts[-1]\n\n    def get_candidate_lookup(self) -> CandidateLookup:\n        return None, self._ireq\n\n    def is_satisfied_by(self, candidate: Candidate) -> bool:\n        assert candidate.name == self.name, (\n            f\"Internal issue: Candidate is not for this requirement \"\n            f\"{candidate.name} vs {self.name}\"\n        )\n        # We can safely always allow prereleases here since PackageFinder\n        # already implements the prerelease logic, and would have filtered out\n        # prerelease candidates if the user does not expect them.\n        assert self._ireq.req, \"Specifier-backed ireq is always PEP 508\"\n        spec = self._ireq.req.specifier\n        return spec.contains(candidate.version, prereleases=True)\n\n\nclass SpecifierWithoutExtrasRequirement(SpecifierRequirement):\n    \"\"\"\n    Requirement backed by an install requirement on a base package.\n    Trims extras from its install requirement if there are any.\n    \"\"\"\n\n    def __init__(self, ireq: InstallRequirement) -> None:\n        assert ireq.link is None, \"This is a link, not a specifier\"\n        self._ireq = install_req_drop_extras(ireq)\n        self._extras = frozenset(canonicalize_name(e) for e in self._ireq.extras)\n\n\nclass RequiresPythonRequirement(Requirement):\n    \"\"\"A requirement representing Requires-Python metadata.\"\"\"\n\n    def __init__(self, specifier: SpecifierSet, match: Candidate) -> None:\n        self.specifier = specifier\n        self._candidate = match\n\n    def __str__(self) -> str:\n        return f\"Python {self.specifier}\"\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({str(self.specifier)!r})\"\n\n    @property\n    def project_name(self) -> NormalizedName:\n        return self._candidate.project_name\n\n    @property\n    def name(self) -> str:\n        return self._candidate.name\n\n    def format_for_error(self) -> str:\n        return str(self)\n\n    def get_candidate_lookup(self) -> CandidateLookup:\n        if self.specifier.contains(self._candidate.version, prereleases=True):\n            return self._candidate, None\n        return None, None\n\n    def is_satisfied_by(self, candidate: Candidate) -> bool:\n        assert candidate.name == self._candidate.name, \"Not Python candidate\"\n        # We can safely always allow prereleases here since PackageFinder\n        # already implements the prerelease logic, and would have filtered out\n        # prerelease candidates if the user does not expect them.\n        return self.specifier.contains(candidate.version, prereleases=True)\n\n\nclass UnsatisfiableRequirement(Requirement):\n    \"\"\"A requirement that cannot be satisfied.\"\"\"\n\n    def __init__(self, name: NormalizedName) -> None:\n        self._name = name\n\n    def __str__(self) -> str:\n        return f\"{self._name} (unavailable)\"\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({str(self._name)!r})\"\n\n    @property\n    def project_name(self) -> NormalizedName:\n        return self._name\n\n    @property\n    def name(self) -> str:\n        return self._name\n\n    def format_for_error(self) -> str:\n        return str(self)\n\n    def get_candidate_lookup(self) -> CandidateLookup:\n        return None, None\n\n    def is_satisfied_by(self, candidate: Candidate) -> bool:\n        return False\n"},"hash":"nrWwoPWYyj"}