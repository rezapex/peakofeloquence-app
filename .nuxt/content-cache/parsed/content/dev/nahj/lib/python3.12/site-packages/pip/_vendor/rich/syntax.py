{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:rich:syntax.py","body":"import os.path\nimport platform\nimport re\nimport sys\nimport textwrap\nfrom abc import ABC, abstractmethod\nfrom pathlib import Path\nfrom typing import (\n    Any,\n    Dict,\n    Iterable,\n    List,\n    NamedTuple,\n    Optional,\n    Sequence,\n    Set,\n    Tuple,\n    Type,\n    Union,\n)\n\nfrom pip._vendor.pygments.lexer import Lexer\nfrom pip._vendor.pygments.lexers import get_lexer_by_name, guess_lexer_for_filename\nfrom pip._vendor.pygments.style import Style as PygmentsStyle\nfrom pip._vendor.pygments.styles import get_style_by_name\nfrom pip._vendor.pygments.token import (\n    Comment,\n    Error,\n    Generic,\n    Keyword,\n    Name,\n    Number,\n    Operator,\n    String,\n    Token,\n    Whitespace,\n)\nfrom pip._vendor.pygments.util import ClassNotFound\n\nfrom pip._vendor.rich.containers import Lines\nfrom pip._vendor.rich.padding import Padding, PaddingDimensions\n\nfrom ._loop import loop_first\nfrom .cells import cell_len\nfrom .color import Color, blend_rgb\nfrom .console import Console, ConsoleOptions, JustifyMethod, RenderResult\nfrom .jupyter import JupyterMixin\nfrom .measure import Measurement\nfrom .segment import Segment, Segments\nfrom .style import Style, StyleType\nfrom .text import Text\n\nTokenType = Tuple[str, ...]\n\nWINDOWS = platform.system() == \"Windows\"\nDEFAULT_THEME = \"monokai\"\n\n# The following styles are based on https://github.com/pygments/pygments/blob/master/pygments/formatters/terminal.py\n# A few modifications were made\n\nANSI_LIGHT: Dict[TokenType, Style] = {\n    Token: Style(),\n    Whitespace: Style(color=\"white\"),\n    Comment: Style(dim=True),\n    Comment.Preproc: Style(color=\"cyan\"),\n    Keyword: Style(color=\"blue\"),\n    Keyword.Type: Style(color=\"cyan\"),\n    Operator.Word: Style(color=\"magenta\"),\n    Name.Builtin: Style(color=\"cyan\"),\n    Name.Function: Style(color=\"green\"),\n    Name.Namespace: Style(color=\"cyan\", underline=True),\n    Name.Class: Style(color=\"green\", underline=True),\n    Name.Exception: Style(color=\"cyan\"),\n    Name.Decorator: Style(color=\"magenta\", bold=True),\n    Name.Variable: Style(color=\"red\"),\n    Name.Constant: Style(color=\"red\"),\n    Name.Attribute: Style(color=\"cyan\"),\n    Name.Tag: Style(color=\"bright_blue\"),\n    String: Style(color=\"yellow\"),\n    Number: Style(color=\"blue\"),\n    Generic.Deleted: Style(color=\"bright_red\"),\n    Generic.Inserted: Style(color=\"green\"),\n    Generic.Heading: Style(bold=True),\n    Generic.Subheading: Style(color=\"magenta\", bold=True),\n    Generic.Prompt: Style(bold=True),\n    Generic.Error: Style(color=\"bright_red\"),\n    Error: Style(color=\"red\", underline=True),\n}\n\nANSI_DARK: Dict[TokenType, Style] = {\n    Token: Style(),\n    Whitespace: Style(color=\"bright_black\"),\n    Comment: Style(dim=True),\n    Comment.Preproc: Style(color=\"bright_cyan\"),\n    Keyword: Style(color=\"bright_blue\"),\n    Keyword.Type: Style(color=\"bright_cyan\"),\n    Operator.Word: Style(color=\"bright_magenta\"),\n    Name.Builtin: Style(color=\"bright_cyan\"),\n    Name.Function: Style(color=\"bright_green\"),\n    Name.Namespace: Style(color=\"bright_cyan\", underline=True),\n    Name.Class: Style(color=\"bright_green\", underline=True),\n    Name.Exception: Style(color=\"bright_cyan\"),\n    Name.Decorator: Style(color=\"bright_magenta\", bold=True),\n    Name.Variable: Style(color=\"bright_red\"),\n    Name.Constant: Style(color=\"bright_red\"),\n    Name.Attribute: Style(color=\"bright_cyan\"),\n    Name.Tag: Style(color=\"bright_blue\"),\n    String: Style(color=\"yellow\"),\n    Number: Style(color=\"bright_blue\"),\n    Generic.Deleted: Style(color=\"bright_red\"),\n    Generic.Inserted: Style(color=\"bright_green\"),\n    Generic.Heading: Style(bold=True),\n    Generic.Subheading: Style(color=\"bright_magenta\", bold=True),\n    Generic.Prompt: Style(bold=True),\n    Generic.Error: Style(color=\"bright_red\"),\n    Error: Style(color=\"red\", underline=True),\n}\n\nRICH_SYNTAX_THEMES = {\"ansi_light\": ANSI_LIGHT, \"ansi_dark\": ANSI_DARK}\nNUMBERS_COLUMN_DEFAULT_PADDING = 2\n\n\nclass SyntaxTheme(ABC):\n    \"\"\"Base class for a syntax theme.\"\"\"\n\n    @abstractmethod\n    def get_style_for_token(self, token_type: TokenType) -> Style:\n        \"\"\"Get a style for a given Pygments token.\"\"\"\n        raise NotImplementedError  # pragma: no cover\n\n    @abstractmethod\n    def get_background_style(self) -> Style:\n        \"\"\"Get the background color.\"\"\"\n        raise NotImplementedError  # pragma: no cover\n\n\nclass PygmentsSyntaxTheme(SyntaxTheme):\n    \"\"\"Syntax theme that delegates to Pygments theme.\"\"\"\n\n    def __init__(self, theme: Union[str, Type[PygmentsStyle]]) -> None:\n        self._style_cache: Dict[TokenType, Style] = {}\n        if isinstance(theme, str):\n            try:\n                self._pygments_style_class = get_style_by_name(theme)\n            except ClassNotFound:\n                self._pygments_style_class = get_style_by_name(\"default\")\n        else:\n            self._pygments_style_class = theme\n\n        self._background_color = self._pygments_style_class.background_color\n        self._background_style = Style(bgcolor=self._background_color)\n\n    def get_style_for_token(self, token_type: TokenType) -> Style:\n        \"\"\"Get a style from a Pygments class.\"\"\"\n        try:\n            return self._style_cache[token_type]\n        except KeyError:\n            try:\n                pygments_style = self._pygments_style_class.style_for_token(token_type)\n            except KeyError:\n                style = Style.null()\n            else:\n                color = pygments_style[\"color\"]\n                bgcolor = pygments_style[\"bgcolor\"]\n                style = Style(\n                    color=\"#\" + color if color else \"#000000\",\n                    bgcolor=\"#\" + bgcolor if bgcolor else self._background_color,\n                    bold=pygments_style[\"bold\"],\n                    italic=pygments_style[\"italic\"],\n                    underline=pygments_style[\"underline\"],\n                )\n            self._style_cache[token_type] = style\n        return style\n\n    def get_background_style(self) -> Style:\n        return self._background_style\n\n\nclass ANSISyntaxTheme(SyntaxTheme):\n    \"\"\"Syntax theme to use standard colors.\"\"\"\n\n    def __init__(self, style_map: Dict[TokenType, Style]) -> None:\n        self.style_map = style_map\n        self._missing_style = Style.null()\n        self._background_style = Style.null()\n        self._style_cache: Dict[TokenType, Style] = {}\n\n    def get_style_for_token(self, token_type: TokenType) -> Style:\n        \"\"\"Look up style in the style map.\"\"\"\n        try:\n            return self._style_cache[token_type]\n        except KeyError:\n            # Styles form a hierarchy\n            # We need to go from most to least specific\n            # e.g. (\"foo\", \"bar\", \"baz\") to (\"foo\", \"bar\")  to (\"foo\",)\n            get_style = self.style_map.get\n            token = tuple(token_type)\n            style = self._missing_style\n            while token:\n                _style = get_style(token)\n                if _style is not None:\n                    style = _style\n                    break\n                token = token[:-1]\n            self._style_cache[token_type] = style\n            return style\n\n    def get_background_style(self) -> Style:\n        return self._background_style\n\n\nSyntaxPosition = Tuple[int, int]\n\n\nclass _SyntaxHighlightRange(NamedTuple):\n    \"\"\"\n    A range to highlight in a Syntax object.\n    `start` and `end` are 2-integers tuples, where the first integer is the line number\n    (starting from 1) and the second integer is the column index (starting from 0).\n    \"\"\"\n\n    style: StyleType\n    start: SyntaxPosition\n    end: SyntaxPosition\n\n\nclass Syntax(JupyterMixin):\n    \"\"\"Construct a Syntax object to render syntax highlighted code.\n\n    Args:\n        code (str): Code to highlight.\n        lexer (Lexer | str): Lexer to use (see https://pygments.org/docs/lexers/)\n        theme (str, optional): Color theme, aka Pygments style (see https://pygments.org/docs/styles/#getting-a-list-of-available-styles). Defaults to \"monokai\".\n        dedent (bool, optional): Enable stripping of initial whitespace. Defaults to False.\n        line_numbers (bool, optional): Enable rendering of line numbers. Defaults to False.\n        start_line (int, optional): Starting number for line numbers. Defaults to 1.\n        line_range (Tuple[int | None, int | None], optional): If given should be a tuple of the start and end line to render.\n            A value of None in the tuple indicates the range is open in that direction.\n        highlight_lines (Set[int]): A set of line numbers to highlight.\n        code_width: Width of code to render (not including line numbers), or ``None`` to use all available width.\n        tab_size (int, optional): Size of tabs. Defaults to 4.\n        word_wrap (bool, optional): Enable word wrapping.\n        background_color (str, optional): Optional background color, or None to use theme color. Defaults to None.\n        indent_guides (bool, optional): Show indent guides. Defaults to False.\n        padding (PaddingDimensions): Padding to apply around the syntax. Defaults to 0 (no padding).\n    \"\"\"\n\n    _pygments_style_class: Type[PygmentsStyle]\n    _theme: SyntaxTheme\n\n    @classmethod\n    def get_theme(cls, name: Union[str, SyntaxTheme]) -> SyntaxTheme:\n        \"\"\"Get a syntax theme instance.\"\"\"\n        if isinstance(name, SyntaxTheme):\n            return name\n        theme: SyntaxTheme\n        if name in RICH_SYNTAX_THEMES:\n            theme = ANSISyntaxTheme(RICH_SYNTAX_THEMES[name])\n        else:\n            theme = PygmentsSyntaxTheme(name)\n        return theme\n\n    def __init__(\n        self,\n        code: str,\n        lexer: Union[Lexer, str],\n        *,\n        theme: Union[str, SyntaxTheme] = DEFAULT_THEME,\n        dedent: bool = False,\n        line_numbers: bool = False,\n        start_line: int = 1,\n        line_range: Optional[Tuple[Optional[int], Optional[int]]] = None,\n        highlight_lines: Optional[Set[int]] = None,\n        code_width: Optional[int] = None,\n        tab_size: int = 4,\n        word_wrap: bool = False,\n        background_color: Optional[str] = None,\n        indent_guides: bool = False,\n        padding: PaddingDimensions = 0,\n    ) -> None:\n        self.code = code\n        self._lexer = lexer\n        self.dedent = dedent\n        self.line_numbers = line_numbers\n        self.start_line = start_line\n        self.line_range = line_range\n        self.highlight_lines = highlight_lines or set()\n        self.code_width = code_width\n        self.tab_size = tab_size\n        self.word_wrap = word_wrap\n        self.background_color = background_color\n        self.background_style = (\n            Style(bgcolor=background_color) if background_color else Style()\n        )\n        self.indent_guides = indent_guides\n        self.padding = padding\n\n        self._theme = self.get_theme(theme)\n        self._stylized_ranges: List[_SyntaxHighlightRange] = []\n\n    @classmethod\n    def from_path(\n        cls,\n        path: str,\n        encoding: str = \"utf-8\",\n        lexer: Optional[Union[Lexer, str]] = None,\n        theme: Union[str, SyntaxTheme] = DEFAULT_THEME,\n        dedent: bool = False,\n        line_numbers: bool = False,\n        line_range: Optional[Tuple[int, int]] = None,\n        start_line: int = 1,\n        highlight_lines: Optional[Set[int]] = None,\n        code_width: Optional[int] = None,\n        tab_size: int = 4,\n        word_wrap: bool = False,\n        background_color: Optional[str] = None,\n        indent_guides: bool = False,\n        padding: PaddingDimensions = 0,\n    ) -> \"Syntax\":\n        \"\"\"Construct a Syntax object from a file.\n\n        Args:\n            path (str): Path to file to highlight.\n            encoding (str): Encoding of file.\n            lexer (str | Lexer, optional): Lexer to use. If None, lexer will be auto-detected from path/file content.\n            theme (str, optional): Color theme, aka Pygments style (see https://pygments.org/docs/styles/#getting-a-list-of-available-styles). Defaults to \"emacs\".\n            dedent (bool, optional): Enable stripping of initial whitespace. Defaults to True.\n            line_numbers (bool, optional): Enable rendering of line numbers. Defaults to False.\n            start_line (int, optional): Starting number for line numbers. Defaults to 1.\n            line_range (Tuple[int, int], optional): If given should be a tuple of the start and end line to render.\n            highlight_lines (Set[int]): A set of line numbers to highlight.\n            code_width: Width of code to render (not including line numbers), or ``None`` to use all available width.\n            tab_size (int, optional): Size of tabs. Defaults to 4.\n            word_wrap (bool, optional): Enable word wrapping of code.\n            background_color (str, optional): Optional background color, or None to use theme color. Defaults to None.\n            indent_guides (bool, optional): Show indent guides. Defaults to False.\n            padding (PaddingDimensions): Padding to apply around the syntax. Defaults to 0 (no padding).\n\n        Returns:\n            [Syntax]: A Syntax object that may be printed to the console\n        \"\"\"\n        code = Path(path).read_text(encoding=encoding)\n\n        if not lexer:\n            lexer = cls.guess_lexer(path, code=code)\n\n        return cls(\n            code,\n            lexer,\n            theme=theme,\n            dedent=dedent,\n            line_numbers=line_numbers,\n            line_range=line_range,\n            start_line=start_line,\n            highlight_lines=highlight_lines,\n            code_width=code_width,\n            tab_size=tab_size,\n            word_wrap=word_wrap,\n            background_color=background_color,\n            indent_guides=indent_guides,\n            padding=padding,\n        )\n\n    @classmethod\n    def guess_lexer(cls, path: str, code: Optional[str] = None) -> str:\n        \"\"\"Guess the alias of the Pygments lexer to use based on a path and an optional string of code.\n        If code is supplied, it will use a combination of the code and the filename to determine the\n        best lexer to use. For example, if the file is ``index.html`` and the file contains Django\n        templating syntax, then \"html+django\" will be returned. If the file is ``index.html``, and no\n        templating language is used, the \"html\" lexer will be used. If no string of code\n        is supplied, the lexer will be chosen based on the file extension..\n\n        Args:\n             path (AnyStr): The path to the file containing the code you wish to know the lexer for.\n             code (str, optional): Optional string of code that will be used as a fallback if no lexer\n                is found for the supplied path.\n\n        Returns:\n            str: The name of the Pygments lexer that best matches the supplied path/code.\n        \"\"\"\n        lexer: Optional[Lexer] = None\n        lexer_name = \"default\"\n        if code:\n            try:\n                lexer = guess_lexer_for_filename(path, code)\n            except ClassNotFound:\n                pass\n\n        if not lexer:\n            try:\n                _, ext = os.path.splitext(path)\n                if ext:\n                    extension = ext.lstrip(\".\").lower()\n                    lexer = get_lexer_by_name(extension)\n            except ClassNotFound:\n                pass\n\n        if lexer:\n            if lexer.aliases:\n                lexer_name = lexer.aliases[0]\n            else:\n                lexer_name = lexer.name\n\n        return lexer_name\n\n    def _get_base_style(self) -> Style:\n        \"\"\"Get the base style.\"\"\"\n        default_style = self._theme.get_background_style() + self.background_style\n        return default_style\n\n    def _get_token_color(self, token_type: TokenType) -> Optional[Color]:\n        \"\"\"Get a color (if any) for the given token.\n\n        Args:\n            token_type (TokenType): A token type tuple from Pygments.\n\n        Returns:\n            Optional[Color]: Color from theme, or None for no color.\n        \"\"\"\n        style = self._theme.get_style_for_token(token_type)\n        return style.color\n\n    @property\n    def lexer(self) -> Optional[Lexer]:\n        \"\"\"The lexer for this syntax, or None if no lexer was found.\n\n        Tries to find the lexer by name if a string was passed to the constructor.\n        \"\"\"\n\n        if isinstance(self._lexer, Lexer):\n            return self._lexer\n        try:\n            return get_lexer_by_name(\n                self._lexer,\n                stripnl=False,\n                ensurenl=True,\n                tabsize=self.tab_size,\n            )\n        except ClassNotFound:\n            return None\n\n    def highlight(\n        self,\n        code: str,\n        line_range: Optional[Tuple[Optional[int], Optional[int]]] = None,\n    ) -> Text:\n        \"\"\"Highlight code and return a Text instance.\n\n        Args:\n            code (str): Code to highlight.\n            line_range(Tuple[int, int], optional): Optional line range to highlight.\n\n        Returns:\n            Text: A text instance containing highlighted syntax.\n        \"\"\"\n\n        base_style = self._get_base_style()\n        justify: JustifyMethod = (\n            \"default\" if base_style.transparent_background else \"left\"\n        )\n\n        text = Text(\n            justify=justify,\n            style=base_style,\n            tab_size=self.tab_size,\n            no_wrap=not self.word_wrap,\n        )\n        _get_theme_style = self._theme.get_style_for_token\n\n        lexer = self.lexer\n\n        if lexer is None:\n            text.append(code)\n        else:\n            if line_range:\n                # More complicated path to only stylize a portion of the code\n                # This speeds up further operations as there are less spans to process\n                line_start, line_end = line_range\n\n                def line_tokenize() -> Iterable[Tuple[Any, str]]:\n                    \"\"\"Split tokens to one per line.\"\"\"\n                    assert lexer  # required to make MyPy happy - we know lexer is not None at this point\n\n                    for token_type, token in lexer.get_tokens(code):\n                        while token:\n                            line_token, new_line, token = token.partition(\"\\n\")\n                            yield token_type, line_token + new_line\n\n                def tokens_to_spans() -> Iterable[Tuple[str, Optional[Style]]]:\n                    \"\"\"Convert tokens to spans.\"\"\"\n                    tokens = iter(line_tokenize())\n                    line_no = 0\n                    _line_start = line_start - 1 if line_start else 0\n\n                    # Skip over tokens until line start\n                    while line_no < _line_start:\n                        try:\n                            _token_type, token = next(tokens)\n                        except StopIteration:\n                            break\n                        yield (token, None)\n                        if token.endswith(\"\\n\"):\n                            line_no += 1\n                    # Generate spans until line end\n                    for token_type, token in tokens:\n                        yield (token, _get_theme_style(token_type))\n                        if token.endswith(\"\\n\"):\n                            line_no += 1\n                            if line_end and line_no >= line_end:\n                                break\n\n                text.append_tokens(tokens_to_spans())\n\n            else:\n                text.append_tokens(\n                    (token, _get_theme_style(token_type))\n                    for token_type, token in lexer.get_tokens(code)\n                )\n            if self.background_color is not None:\n                text.stylize(f\"on {self.background_color}\")\n\n        if self._stylized_ranges:\n            self._apply_stylized_ranges(text)\n\n        return text\n\n    def stylize_range(\n        self, style: StyleType, start: SyntaxPosition, end: SyntaxPosition\n    ) -> None:\n        \"\"\"\n        Adds a custom style on a part of the code, that will be applied to the syntax display when it's rendered.\n        Line numbers are 1-based, while column indexes are 0-based.\n\n        Args:\n            style (StyleType): The style to apply.\n            start (Tuple[int, int]): The start of the range, in the form `[line number, column index]`.\n            end (Tuple[int, int]): The end of the range, in the form `[line number, column index]`.\n        \"\"\"\n        self._stylized_ranges.append(_SyntaxHighlightRange(style, start, end))\n\n    def _get_line_numbers_color(self, blend: float = 0.3) -> Color:\n        background_style = self._theme.get_background_style() + self.background_style\n        background_color = background_style.bgcolor\n        if background_color is None or background_color.is_system_defined:\n            return Color.default()\n        foreground_color = self._get_token_color(Token.Text)\n        if foreground_color is None or foreground_color.is_system_defined:\n            return foreground_color or Color.default()\n        new_color = blend_rgb(\n            background_color.get_truecolor(),\n            foreground_color.get_truecolor(),\n            cross_fade=blend,\n        )\n        return Color.from_triplet(new_color)\n\n    @property\n    def _numbers_column_width(self) -> int:\n        \"\"\"Get the number of characters used to render the numbers column.\"\"\"\n        column_width = 0\n        if self.line_numbers:\n            column_width = (\n                len(str(self.start_line + self.code.count(\"\\n\")))\n                + NUMBERS_COLUMN_DEFAULT_PADDING\n            )\n        return column_width\n\n    def _get_number_styles(self, console: Console) -> Tuple[Style, Style, Style]:\n        \"\"\"Get background, number, and highlight styles for line numbers.\"\"\"\n        background_style = self._get_base_style()\n        if background_style.transparent_background:\n            return Style.null(), Style(dim=True), Style.null()\n        if console.color_system in (\"256\", \"truecolor\"):\n            number_style = Style.chain(\n                background_style,\n                self._theme.get_style_for_token(Token.Text),\n                Style(color=self._get_line_numbers_color()),\n                self.background_style,\n            )\n            highlight_number_style = Style.chain(\n                background_style,\n                self._theme.get_style_for_token(Token.Text),\n                Style(bold=True, color=self._get_line_numbers_color(0.9)),\n                self.background_style,\n            )\n        else:\n            number_style = background_style + Style(dim=True)\n            highlight_number_style = background_style + Style(dim=False)\n        return background_style, number_style, highlight_number_style\n\n    def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"Measurement\":\n        _, right, _, left = Padding.unpack(self.padding)\n        padding = left + right\n        if self.code_width is not None:\n            width = self.code_width + self._numbers_column_width + padding + 1\n            return Measurement(self._numbers_column_width, width)\n        lines = self.code.splitlines()\n        width = (\n            self._numbers_column_width\n            + padding\n            + (max(cell_len(line) for line in lines) if lines else 0)\n        )\n        if self.line_numbers:\n            width += 1\n        return Measurement(self._numbers_column_width, width)\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        segments = Segments(self._get_syntax(console, options))\n        if self.padding:\n            yield Padding(\n                segments, style=self._theme.get_background_style(), pad=self.padding\n            )\n        else:\n            yield segments\n\n    def _get_syntax(\n        self,\n        console: Console,\n        options: ConsoleOptions,\n    ) -> Iterable[Segment]:\n        \"\"\"\n        Get the Segments for the Syntax object, excluding any vertical/horizontal padding\n        \"\"\"\n        transparent_background = self._get_base_style().transparent_background\n        code_width = (\n            (\n                (options.max_width - self._numbers_column_width - 1)\n                if self.line_numbers\n                else options.max_width\n            )\n            if self.code_width is None\n            else self.code_width\n        )\n\n        ends_on_nl, processed_code = self._process_code(self.code)\n        text = self.highlight(processed_code, self.line_range)\n\n        if not self.line_numbers and not self.word_wrap and not self.line_range:\n            if not ends_on_nl:\n                text.remove_suffix(\"\\n\")\n            # Simple case of just rendering text\n            style = (\n                self._get_base_style()\n                + self._theme.get_style_for_token(Comment)\n                + Style(dim=True)\n                + self.background_style\n            )\n            if self.indent_guides and not options.ascii_only:\n                text = text.with_indent_guides(self.tab_size, style=style)\n                text.overflow = \"crop\"\n            if style.transparent_background:\n                yield from console.render(\n                    text, options=options.update(width=code_width)\n                )\n            else:\n                syntax_lines = console.render_lines(\n                    text,\n                    options.update(width=code_width, height=None, justify=\"left\"),\n                    style=self.background_style,\n                    pad=True,\n                    new_lines=True,\n                )\n                for syntax_line in syntax_lines:\n                    yield from syntax_line\n            return\n\n        start_line, end_line = self.line_range or (None, None)\n        line_offset = 0\n        if start_line:\n            line_offset = max(0, start_line - 1)\n        lines: Union[List[Text], Lines] = text.split(\"\\n\", allow_blank=ends_on_nl)\n        if self.line_range:\n            if line_offset > len(lines):\n                return\n            lines = lines[line_offset:end_line]\n\n        if self.indent_guides and not options.ascii_only:\n            style = (\n                self._get_base_style()\n                + self._theme.get_style_for_token(Comment)\n                + Style(dim=True)\n                + self.background_style\n            )\n            lines = (\n                Text(\"\\n\")\n                .join(lines)\n                .with_indent_guides(self.tab_size, style=style + Style(italic=False))\n                .split(\"\\n\", allow_blank=True)\n            )\n\n        numbers_column_width = self._numbers_column_width\n        render_options = options.update(width=code_width)\n\n        highlight_line = self.highlight_lines.__contains__\n        _Segment = Segment\n        new_line = _Segment(\"\\n\")\n\n        line_pointer = \"> \" if options.legacy_windows else \"❱ \"\n\n        (\n            background_style,\n            number_style,\n            highlight_number_style,\n        ) = self._get_number_styles(console)\n\n        for line_no, line in enumerate(lines, self.start_line + line_offset):\n            if self.word_wrap:\n                wrapped_lines = console.render_lines(\n                    line,\n                    render_options.update(height=None, justify=\"left\"),\n                    style=background_style,\n                    pad=not transparent_background,\n                )\n            else:\n                segments = list(line.render(console, end=\"\"))\n                if options.no_wrap:\n                    wrapped_lines = [segments]\n                else:\n                    wrapped_lines = [\n                        _Segment.adjust_line_length(\n                            segments,\n                            render_options.max_width,\n                            style=background_style,\n                            pad=not transparent_background,\n                        )\n                    ]\n\n            if self.line_numbers:\n                wrapped_line_left_pad = _Segment(\n                    \" \" * numbers_column_width + \" \", background_style\n                )\n                for first, wrapped_line in loop_first(wrapped_lines):\n                    if first:\n                        line_column = str(line_no).rjust(numbers_column_width - 2) + \" \"\n                        if highlight_line(line_no):\n                            yield _Segment(line_pointer, Style(color=\"red\"))\n                            yield _Segment(line_column, highlight_number_style)\n                        else:\n                            yield _Segment(\"  \", highlight_number_style)\n                            yield _Segment(line_column, number_style)\n                    else:\n                        yield wrapped_line_left_pad\n                    yield from wrapped_line\n                    yield new_line\n            else:\n                for wrapped_line in wrapped_lines:\n                    yield from wrapped_line\n                    yield new_line\n\n    def _apply_stylized_ranges(self, text: Text) -> None:\n        \"\"\"\n        Apply stylized ranges to a text instance,\n        using the given code to determine the right portion to apply the style to.\n\n        Args:\n            text (Text): Text instance to apply the style to.\n        \"\"\"\n        code = text.plain\n        newlines_offsets = [\n            # Let's add outer boundaries at each side of the list:\n            0,\n            # N.B. using \"\\n\" here is much faster than using metacharacters such as \"^\" or \"\\Z\":\n            *[\n                match.start() + 1\n                for match in re.finditer(\"\\n\", code, flags=re.MULTILINE)\n            ],\n            len(code) + 1,\n        ]\n\n        for stylized_range in self._stylized_ranges:\n            start = _get_code_index_for_syntax_position(\n                newlines_offsets, stylized_range.start\n            )\n            end = _get_code_index_for_syntax_position(\n                newlines_offsets, stylized_range.end\n            )\n            if start is not None and end is not None:\n                text.stylize(stylized_range.style, start, end)\n\n    def _process_code(self, code: str) -> Tuple[bool, str]:\n        \"\"\"\n        Applies various processing to a raw code string\n        (normalises it so it always ends with a line return, dedents it if necessary, etc.)\n\n        Args:\n            code (str): The raw code string to process\n\n        Returns:\n            Tuple[bool, str]: the boolean indicates whether the raw code ends with a line return,\n                while the string is the processed code.\n        \"\"\"\n        ends_on_nl = code.endswith(\"\\n\")\n        processed_code = code if ends_on_nl else code + \"\\n\"\n        processed_code = (\n            textwrap.dedent(processed_code) if self.dedent else processed_code\n        )\n        processed_code = processed_code.expandtabs(self.tab_size)\n        return ends_on_nl, processed_code\n\n\ndef _get_code_index_for_syntax_position(\n    newlines_offsets: Sequence[int], position: SyntaxPosition\n) -> Optional[int]:\n    \"\"\"\n    Returns the index of the code string for the given positions.\n\n    Args:\n        newlines_offsets (Sequence[int]): The offset of each newline character found in the code snippet.\n        position (SyntaxPosition): The position to search for.\n\n    Returns:\n        Optional[int]: The index of the code string for this position, or `None`\n            if the given position's line number is out of range (if it's the column that is out of range\n            we silently clamp its value so that it reaches the end of the line)\n    \"\"\"\n    lines_count = len(newlines_offsets)\n\n    line_number, column_index = position\n    if line_number > lines_count or len(newlines_offsets) < (line_number + 1):\n        return None  # `line_number` is out of range\n    line_index = line_number - 1\n    line_length = newlines_offsets[line_index + 1] - newlines_offsets[line_index] - 1\n    # If `column_index` is out of range: let's silently clamp it:\n    column_index = min(line_length, column_index)\n    return newlines_offsets[line_index] + column_index\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    import argparse\n    import sys\n\n    parser = argparse.ArgumentParser(\n        description=\"Render syntax to the console with Rich\"\n    )\n    parser.add_argument(\n        \"path\",\n        metavar=\"PATH\",\n        help=\"path to file, or - for stdin\",\n    )\n    parser.add_argument(\n        \"-c\",\n        \"--force-color\",\n        dest=\"force_color\",\n        action=\"store_true\",\n        default=None,\n        help=\"force color for non-terminals\",\n    )\n    parser.add_argument(\n        \"-i\",\n        \"--indent-guides\",\n        dest=\"indent_guides\",\n        action=\"store_true\",\n        default=False,\n        help=\"display indent guides\",\n    )\n    parser.add_argument(\n        \"-l\",\n        \"--line-numbers\",\n        dest=\"line_numbers\",\n        action=\"store_true\",\n        help=\"render line numbers\",\n    )\n    parser.add_argument(\n        \"-w\",\n        \"--width\",\n        type=int,\n        dest=\"width\",\n        default=None,\n        help=\"width of output (default will auto-detect)\",\n    )\n    parser.add_argument(\n        \"-r\",\n        \"--wrap\",\n        dest=\"word_wrap\",\n        action=\"store_true\",\n        default=False,\n        help=\"word wrap long lines\",\n    )\n    parser.add_argument(\n        \"-s\",\n        \"--soft-wrap\",\n        action=\"store_true\",\n        dest=\"soft_wrap\",\n        default=False,\n        help=\"enable soft wrapping mode\",\n    )\n    parser.add_argument(\n        \"-t\", \"--theme\", dest=\"theme\", default=\"monokai\", help=\"pygments theme\"\n    )\n    parser.add_argument(\n        \"-b\",\n        \"--background-color\",\n        dest=\"background_color\",\n        default=None,\n        help=\"Override background color\",\n    )\n    parser.add_argument(\n        \"-x\",\n        \"--lexer\",\n        default=None,\n        dest=\"lexer_name\",\n        help=\"Lexer name\",\n    )\n    parser.add_argument(\n        \"-p\", \"--padding\", type=int, default=0, dest=\"padding\", help=\"Padding\"\n    )\n    parser.add_argument(\n        \"--highlight-line\",\n        type=int,\n        default=None,\n        dest=\"highlight_line\",\n        help=\"The line number (not index!) to highlight\",\n    )\n    args = parser.parse_args()\n\n    from pip._vendor.rich.console import Console\n\n    console = Console(force_terminal=args.force_color, width=args.width)\n\n    if args.path == \"-\":\n        code = sys.stdin.read()\n        syntax = Syntax(\n            code=code,\n            lexer=args.lexer_name,\n            line_numbers=args.line_numbers,\n            word_wrap=args.word_wrap,\n            theme=args.theme,\n            background_color=args.background_color,\n            indent_guides=args.indent_guides,\n            padding=args.padding,\n            highlight_lines={args.highlight_line},\n        )\n    else:\n        syntax = Syntax.from_path(\n            args.path,\n            lexer=args.lexer_name,\n            line_numbers=args.line_numbers,\n            word_wrap=args.word_wrap,\n            theme=args.theme,\n            background_color=args.background_color,\n            indent_guides=args.indent_guides,\n            padding=args.padding,\n            highlight_lines={args.highlight_line},\n        )\n    console.print(syntax, soft_wrap=args.soft_wrap)\n"},"hash":"NjP3rWzEAU"}