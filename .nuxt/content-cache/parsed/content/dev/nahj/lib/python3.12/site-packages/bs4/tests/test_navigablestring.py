{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:bs4:tests:test_navigablestring.py","body":"import pytest\n\nfrom bs4.element import (\n    CData,\n    Comment,\n    Declaration,\n    Doctype,\n    NavigableString,\n    RubyParenthesisString,\n    RubyTextString,\n    Script,\n    Stylesheet,\n    TemplateString,\n)\n\nfrom . import SoupTest\n\nclass TestNavigableString(SoupTest):\n\n    def test_text_acquisition_methods(self):\n        # These methods are intended for use against Tag, but they\n        # work on NavigableString as well,\n        \n        s = NavigableString(\"fee \")\n        cdata = CData(\"fie \")\n        comment = Comment(\"foe \")\n\n        assert \"fee \" == s.get_text()\n        assert \"fee\" == s.get_text(strip=True)\n        assert [\"fee \"] == list(s.strings)\n        assert [\"fee\"] == list(s.stripped_strings)\n        assert [\"fee \"] == list(s._all_strings())\n\n        assert \"fie \" == cdata.get_text()\n        assert \"fie\" == cdata.get_text(strip=True)\n        assert [\"fie \"] == list(cdata.strings)\n        assert [\"fie\"] == list(cdata.stripped_strings)\n        assert [\"fie \"] == list(cdata._all_strings())\n        \n        # Since a Comment isn't normally considered 'text',\n        # these methods generally do nothing.\n        assert \"\" == comment.get_text()\n        assert [] == list(comment.strings)\n        assert [] == list(comment.stripped_strings)\n        assert [] == list(comment._all_strings())\n\n        # Unless you specifically say that comments are okay.\n        assert \"foe\" == comment.get_text(strip=True, types=Comment)\n        assert \"foe \" == comment.get_text(types=(Comment, NavigableString))\n\n    def test_string_has_immutable_name_property(self):\n        # string.name is defined as None and can't be modified\n        string = self.soup(\"s\").string\n        assert None == string.name\n        with pytest.raises(AttributeError):\n            string.name = 'foo'\n\nclass TestNavigableStringSubclasses(SoupTest):\n\n    def test_cdata(self):\n        # None of the current builders turn CDATA sections into CData\n        # objects, but you can create them manually.\n        soup = self.soup(\"\")\n        cdata = CData(\"foo\")\n        soup.insert(1, cdata)\n        assert str(soup) == \"<![CDATA[foo]]>\"\n        assert soup.find(string=\"foo\") == \"foo\"\n        assert soup.contents[0] == \"foo\"\n\n    def test_cdata_is_never_formatted(self):\n        \"\"\"Text inside a CData object is passed into the formatter.\n\n        But the return value is ignored.\n        \"\"\"\n\n        self.count = 0\n        def increment(*args):\n            self.count += 1\n            return \"BITTER FAILURE\"\n\n        soup = self.soup(\"\")\n        cdata = CData(\"<><><>\")\n        soup.insert(1, cdata)\n        assert b\"<![CDATA[<><><>]]>\" == soup.encode(formatter=increment)\n        assert 1 == self.count\n\n    def test_doctype_ends_in_newline(self):\n        # Unlike other NavigableString subclasses, a DOCTYPE always ends\n        # in a newline.\n        doctype = Doctype(\"foo\")\n        soup = self.soup(\"\")\n        soup.insert(1, doctype)\n        assert soup.encode() == b\"<!DOCTYPE foo>\\n\"\n\n    def test_declaration(self):\n        d = Declaration(\"foo\")\n        assert \"<?foo?>\" == d.output_ready()\n\n    def test_default_string_containers(self):\n        # In some cases, we use different NavigableString subclasses for\n        # the same text in different tags.\n        soup = self.soup(\n            \"<div>text</div><script>text</script><style>text</style>\"\n        )\n        assert [NavigableString, Script, Stylesheet] == [\n            x.__class__ for x in soup.find_all(string=True)\n        ]\n\n        # The TemplateString is a little unusual because it's generally found\n        # _inside_ children of a <template> element, not a direct child of the\n        # <template> element.\n        soup = self.soup(\n            \"<template>Some text<p>In a tag</p></template>Some text outside\"\n        )\n        assert all(\n            isinstance(x, TemplateString)\n            for x in soup.template._all_strings(types=None)\n        )\n        \n        # Once the <template> tag closed, we went back to using\n        # NavigableString.\n        outside = soup.template.next_sibling\n        assert isinstance(outside, NavigableString)\n        assert not isinstance(outside, TemplateString)\n\n        # The TemplateString is also unusual because it can contain\n        # NavigableString subclasses of _other_ types, such as\n        # Comment.\n        markup = b\"<template>Some text<p>In a tag</p><!--with a comment--></template>\"\n        soup = self.soup(markup)\n        assert markup == soup.template.encode(\"utf8\")\n\n    def test_ruby_strings(self):\n        markup = \"<ruby>漢 <rp>(</rp><rt>kan</rt><rp>)</rp> 字 <rp>(</rp><rt>ji</rt><rp>)</rp></ruby>\"\n        soup = self.soup(markup)\n        assert isinstance(soup.rp.string, RubyParenthesisString)\n        assert isinstance(soup.rt.string, RubyTextString)\n\n        # Just as a demo, here's what this means for get_text usage.\n        assert \"漢字\" == soup.get_text(strip=True)\n        assert \"漢(kan)字(ji)\" == soup.get_text(\n            strip=True,\n            types=(NavigableString, RubyTextString, RubyParenthesisString)\n        )\n"},"hash":"Mgt4oAAHV8"}