{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:rich:columns.py","body":"from collections import defaultdict\nfrom itertools import chain\nfrom operator import itemgetter\nfrom typing import Dict, Iterable, List, Optional, Tuple\n\nfrom .align import Align, AlignMethod\nfrom .console import Console, ConsoleOptions, RenderableType, RenderResult\nfrom .constrain import Constrain\nfrom .measure import Measurement\nfrom .padding import Padding, PaddingDimensions\nfrom .table import Table\nfrom .text import TextType\nfrom .jupyter import JupyterMixin\n\n\nclass Columns(JupyterMixin):\n    \"\"\"Display renderables in neat columns.\n\n    Args:\n        renderables (Iterable[RenderableType]): Any number of Rich renderables (including str).\n        width (int, optional): The desired width of the columns, or None to auto detect. Defaults to None.\n        padding (PaddingDimensions, optional): Optional padding around cells. Defaults to (0, 1).\n        expand (bool, optional): Expand columns to full width. Defaults to False.\n        equal (bool, optional): Arrange in to equal sized columns. Defaults to False.\n        column_first (bool, optional): Align items from top to bottom (rather than left to right). Defaults to False.\n        right_to_left (bool, optional): Start column from right hand side. Defaults to False.\n        align (str, optional): Align value (\"left\", \"right\", or \"center\") or None for default. Defaults to None.\n        title (TextType, optional): Optional title for Columns.\n    \"\"\"\n\n    def __init__(\n        self,\n        renderables: Optional[Iterable[RenderableType]] = None,\n        padding: PaddingDimensions = (0, 1),\n        *,\n        width: Optional[int] = None,\n        expand: bool = False,\n        equal: bool = False,\n        column_first: bool = False,\n        right_to_left: bool = False,\n        align: Optional[AlignMethod] = None,\n        title: Optional[TextType] = None,\n    ) -> None:\n        self.renderables = list(renderables or [])\n        self.width = width\n        self.padding = padding\n        self.expand = expand\n        self.equal = equal\n        self.column_first = column_first\n        self.right_to_left = right_to_left\n        self.align: Optional[AlignMethod] = align\n        self.title = title\n\n    def add_renderable(self, renderable: RenderableType) -> None:\n        \"\"\"Add a renderable to the columns.\n\n        Args:\n            renderable (RenderableType): Any renderable object.\n        \"\"\"\n        self.renderables.append(renderable)\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        render_str = console.render_str\n        renderables = [\n            render_str(renderable) if isinstance(renderable, str) else renderable\n            for renderable in self.renderables\n        ]\n        if not renderables:\n            return\n        _top, right, _bottom, left = Padding.unpack(self.padding)\n        width_padding = max(left, right)\n        max_width = options.max_width\n        widths: Dict[int, int] = defaultdict(int)\n        column_count = len(renderables)\n\n        get_measurement = Measurement.get\n        renderable_widths = [\n            get_measurement(console, options, renderable).maximum\n            for renderable in renderables\n        ]\n        if self.equal:\n            renderable_widths = [max(renderable_widths)] * len(renderable_widths)\n\n        def iter_renderables(\n            column_count: int,\n        ) -> Iterable[Tuple[int, Optional[RenderableType]]]:\n            item_count = len(renderables)\n            if self.column_first:\n                width_renderables = list(zip(renderable_widths, renderables))\n\n                column_lengths: List[int] = [item_count // column_count] * column_count\n                for col_no in range(item_count % column_count):\n                    column_lengths[col_no] += 1\n\n                row_count = (item_count + column_count - 1) // column_count\n                cells = [[-1] * column_count for _ in range(row_count)]\n                row = col = 0\n                for index in range(item_count):\n                    cells[row][col] = index\n                    column_lengths[col] -= 1\n                    if column_lengths[col]:\n                        row += 1\n                    else:\n                        col += 1\n                        row = 0\n                for index in chain.from_iterable(cells):\n                    if index == -1:\n                        break\n                    yield width_renderables[index]\n            else:\n                yield from zip(renderable_widths, renderables)\n            # Pad odd elements with spaces\n            if item_count % column_count:\n                for _ in range(column_count - (item_count % column_count)):\n                    yield 0, None\n\n        table = Table.grid(padding=self.padding, collapse_padding=True, pad_edge=False)\n        table.expand = self.expand\n        table.title = self.title\n\n        if self.width is not None:\n            column_count = (max_width) // (self.width + width_padding)\n            for _ in range(column_count):\n                table.add_column(width=self.width)\n        else:\n            while column_count > 1:\n                widths.clear()\n                column_no = 0\n                for renderable_width, _ in iter_renderables(column_count):\n                    widths[column_no] = max(widths[column_no], renderable_width)\n                    total_width = sum(widths.values()) + width_padding * (\n                        len(widths) - 1\n                    )\n                    if total_width > max_width:\n                        column_count = len(widths) - 1\n                        break\n                    else:\n                        column_no = (column_no + 1) % column_count\n                else:\n                    break\n\n        get_renderable = itemgetter(1)\n        _renderables = [\n            get_renderable(_renderable)\n            for _renderable in iter_renderables(column_count)\n        ]\n        if self.equal:\n            _renderables = [\n                None\n                if renderable is None\n                else Constrain(renderable, renderable_widths[0])\n                for renderable in _renderables\n            ]\n        if self.align:\n            align = self.align\n            _Align = Align\n            _renderables = [\n                None if renderable is None else _Align(renderable, align)\n                for renderable in _renderables\n            ]\n\n        right_to_left = self.right_to_left\n        add_row = table.add_row\n        for start in range(0, len(_renderables), column_count):\n            row = _renderables[start : start + column_count]\n            if right_to_left:\n                row = row[::-1]\n            add_row(*row)\n        yield table\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    import os\n\n    console = Console()\n\n    files = [f\"{i} {s}\" for i, s in enumerate(sorted(os.listdir()))]\n    columns = Columns(files, padding=(0, 1), expand=False, equal=False)\n    console.print(columns)\n    console.rule()\n    columns.column_first = True\n    console.print(columns)\n    columns.right_to_left = True\n    console.rule()\n    console.print(columns)\n"},"hash":"put0yGwidY"}