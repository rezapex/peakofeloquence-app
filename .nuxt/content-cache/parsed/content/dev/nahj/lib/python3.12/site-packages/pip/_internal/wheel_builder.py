{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:wheel_builder.py","body":"\"\"\"Orchestrator for building wheels from InstallRequirements.\n\"\"\"\n\nimport logging\nimport os.path\nimport re\nimport shutil\nfrom typing import Iterable, List, Optional, Tuple\n\nfrom pip._vendor.packaging.utils import canonicalize_name, canonicalize_version\nfrom pip._vendor.packaging.version import InvalidVersion, Version\n\nfrom pip._internal.cache import WheelCache\nfrom pip._internal.exceptions import InvalidWheelFilename, UnsupportedWheel\nfrom pip._internal.metadata import FilesystemWheel, get_wheel_distribution\nfrom pip._internal.models.link import Link\nfrom pip._internal.models.wheel import Wheel\nfrom pip._internal.operations.build.wheel import build_wheel_pep517\nfrom pip._internal.operations.build.wheel_editable import build_wheel_editable\nfrom pip._internal.operations.build.wheel_legacy import build_wheel_legacy\nfrom pip._internal.req.req_install import InstallRequirement\nfrom pip._internal.utils.logging import indent_log\nfrom pip._internal.utils.misc import ensure_dir, hash_file\nfrom pip._internal.utils.setuptools_build import make_setuptools_clean_args\nfrom pip._internal.utils.subprocess import call_subprocess\nfrom pip._internal.utils.temp_dir import TempDirectory\nfrom pip._internal.utils.urls import path_to_url\nfrom pip._internal.vcs import vcs\n\nlogger = logging.getLogger(__name__)\n\n_egg_info_re = re.compile(r\"([a-z0-9_.]+)-([a-z0-9_.!+-]+)\", re.IGNORECASE)\n\nBuildResult = Tuple[List[InstallRequirement], List[InstallRequirement]]\n\n\ndef _contains_egg_info(s: str) -> bool:\n    \"\"\"Determine whether the string looks like an egg_info.\n\n    :param s: The string to parse. E.g. foo-2.1\n    \"\"\"\n    return bool(_egg_info_re.search(s))\n\n\ndef _should_build(\n    req: InstallRequirement,\n    need_wheel: bool,\n) -> bool:\n    \"\"\"Return whether an InstallRequirement should be built into a wheel.\"\"\"\n    if req.constraint:\n        # never build requirements that are merely constraints\n        return False\n    if req.is_wheel:\n        if need_wheel:\n            logger.info(\n                \"Skipping %s, due to already being wheel.\",\n                req.name,\n            )\n        return False\n\n    if need_wheel:\n        # i.e. pip wheel, not pip install\n        return True\n\n    # From this point, this concerns the pip install command only\n    # (need_wheel=False).\n\n    if not req.source_dir:\n        return False\n\n    if req.editable:\n        # we only build PEP 660 editable requirements\n        return req.supports_pyproject_editable()\n\n    return True\n\n\ndef should_build_for_wheel_command(\n    req: InstallRequirement,\n) -> bool:\n    return _should_build(req, need_wheel=True)\n\n\ndef should_build_for_install_command(\n    req: InstallRequirement,\n) -> bool:\n    return _should_build(req, need_wheel=False)\n\n\ndef _should_cache(\n    req: InstallRequirement,\n) -> Optional[bool]:\n    \"\"\"\n    Return whether a built InstallRequirement can be stored in the persistent\n    wheel cache, assuming the wheel cache is available, and _should_build()\n    has determined a wheel needs to be built.\n    \"\"\"\n    if req.editable or not req.source_dir:\n        # never cache editable requirements\n        return False\n\n    if req.link and req.link.is_vcs:\n        # VCS checkout. Do not cache\n        # unless it points to an immutable commit hash.\n        assert not req.editable\n        assert req.source_dir\n        vcs_backend = vcs.get_backend_for_scheme(req.link.scheme)\n        assert vcs_backend\n        if vcs_backend.is_immutable_rev_checkout(req.link.url, req.source_dir):\n            return True\n        return False\n\n    assert req.link\n    base, ext = req.link.splitext()\n    if _contains_egg_info(base):\n        return True\n\n    # Otherwise, do not cache.\n    return False\n\n\ndef _get_cache_dir(\n    req: InstallRequirement,\n    wheel_cache: WheelCache,\n) -> str:\n    \"\"\"Return the persistent or temporary cache directory where the built\n    wheel need to be stored.\n    \"\"\"\n    cache_available = bool(wheel_cache.cache_dir)\n    assert req.link\n    if cache_available and _should_cache(req):\n        cache_dir = wheel_cache.get_path_for_link(req.link)\n    else:\n        cache_dir = wheel_cache.get_ephem_path_for_link(req.link)\n    return cache_dir\n\n\ndef _verify_one(req: InstallRequirement, wheel_path: str) -> None:\n    canonical_name = canonicalize_name(req.name or \"\")\n    w = Wheel(os.path.basename(wheel_path))\n    if canonicalize_name(w.name) != canonical_name:\n        raise InvalidWheelFilename(\n            f\"Wheel has unexpected file name: expected {canonical_name!r}, \"\n            f\"got {w.name!r}\",\n        )\n    dist = get_wheel_distribution(FilesystemWheel(wheel_path), canonical_name)\n    dist_verstr = str(dist.version)\n    if canonicalize_version(dist_verstr) != canonicalize_version(w.version):\n        raise InvalidWheelFilename(\n            f\"Wheel has unexpected file name: expected {dist_verstr!r}, \"\n            f\"got {w.version!r}\",\n        )\n    metadata_version_value = dist.metadata_version\n    if metadata_version_value is None:\n        raise UnsupportedWheel(\"Missing Metadata-Version\")\n    try:\n        metadata_version = Version(metadata_version_value)\n    except InvalidVersion:\n        msg = f\"Invalid Metadata-Version: {metadata_version_value}\"\n        raise UnsupportedWheel(msg)\n    if metadata_version >= Version(\"1.2\") and not isinstance(dist.version, Version):\n        raise UnsupportedWheel(\n            f\"Metadata 1.2 mandates PEP 440 version, but {dist_verstr!r} is not\"\n        )\n\n\ndef _build_one(\n    req: InstallRequirement,\n    output_dir: str,\n    verify: bool,\n    build_options: List[str],\n    global_options: List[str],\n    editable: bool,\n) -> Optional[str]:\n    \"\"\"Build one wheel.\n\n    :return: The filename of the built wheel, or None if the build failed.\n    \"\"\"\n    artifact = \"editable\" if editable else \"wheel\"\n    try:\n        ensure_dir(output_dir)\n    except OSError as e:\n        logger.warning(\n            \"Building %s for %s failed: %s\",\n            artifact,\n            req.name,\n            e,\n        )\n        return None\n\n    # Install build deps into temporary directory (PEP 518)\n    with req.build_env:\n        wheel_path = _build_one_inside_env(\n            req, output_dir, build_options, global_options, editable\n        )\n    if wheel_path and verify:\n        try:\n            _verify_one(req, wheel_path)\n        except (InvalidWheelFilename, UnsupportedWheel) as e:\n            logger.warning(\"Built %s for %s is invalid: %s\", artifact, req.name, e)\n            return None\n    return wheel_path\n\n\ndef _build_one_inside_env(\n    req: InstallRequirement,\n    output_dir: str,\n    build_options: List[str],\n    global_options: List[str],\n    editable: bool,\n) -> Optional[str]:\n    with TempDirectory(kind=\"wheel\") as temp_dir:\n        assert req.name\n        if req.use_pep517:\n            assert req.metadata_directory\n            assert req.pep517_backend\n            if global_options:\n                logger.warning(\n                    \"Ignoring --global-option when building %s using PEP 517\", req.name\n                )\n            if build_options:\n                logger.warning(\n                    \"Ignoring --build-option when building %s using PEP 517\", req.name\n                )\n            if editable:\n                wheel_path = build_wheel_editable(\n                    name=req.name,\n                    backend=req.pep517_backend,\n                    metadata_directory=req.metadata_directory,\n                    tempd=temp_dir.path,\n                )\n            else:\n                wheel_path = build_wheel_pep517(\n                    name=req.name,\n                    backend=req.pep517_backend,\n                    metadata_directory=req.metadata_directory,\n                    tempd=temp_dir.path,\n                )\n        else:\n            wheel_path = build_wheel_legacy(\n                name=req.name,\n                setup_py_path=req.setup_py_path,\n                source_dir=req.unpacked_source_directory,\n                global_options=global_options,\n                build_options=build_options,\n                tempd=temp_dir.path,\n            )\n\n        if wheel_path is not None:\n            wheel_name = os.path.basename(wheel_path)\n            dest_path = os.path.join(output_dir, wheel_name)\n            try:\n                wheel_hash, length = hash_file(wheel_path)\n                shutil.move(wheel_path, dest_path)\n                logger.info(\n                    \"Created wheel for %s: filename=%s size=%d sha256=%s\",\n                    req.name,\n                    wheel_name,\n                    length,\n                    wheel_hash.hexdigest(),\n                )\n                logger.info(\"Stored in directory: %s\", output_dir)\n                return dest_path\n            except Exception as e:\n                logger.warning(\n                    \"Building wheel for %s failed: %s\",\n                    req.name,\n                    e,\n                )\n        # Ignore return, we can't do anything else useful.\n        if not req.use_pep517:\n            _clean_one_legacy(req, global_options)\n        return None\n\n\ndef _clean_one_legacy(req: InstallRequirement, global_options: List[str]) -> bool:\n    clean_args = make_setuptools_clean_args(\n        req.setup_py_path,\n        global_options=global_options,\n    )\n\n    logger.info(\"Running setup.py clean for %s\", req.name)\n    try:\n        call_subprocess(\n            clean_args, command_desc=\"python setup.py clean\", cwd=req.source_dir\n        )\n        return True\n    except Exception:\n        logger.error(\"Failed cleaning build dir for %s\", req.name)\n        return False\n\n\ndef build(\n    requirements: Iterable[InstallRequirement],\n    wheel_cache: WheelCache,\n    verify: bool,\n    build_options: List[str],\n    global_options: List[str],\n) -> BuildResult:\n    \"\"\"Build wheels.\n\n    :return: The list of InstallRequirement that succeeded to build and\n        the list of InstallRequirement that failed to build.\n    \"\"\"\n    if not requirements:\n        return [], []\n\n    # Build the wheels.\n    logger.info(\n        \"Building wheels for collected packages: %s\",\n        \", \".join(req.name for req in requirements),  # type: ignore\n    )\n\n    with indent_log():\n        build_successes, build_failures = [], []\n        for req in requirements:\n            assert req.name\n            cache_dir = _get_cache_dir(req, wheel_cache)\n            wheel_file = _build_one(\n                req,\n                cache_dir,\n                verify,\n                build_options,\n                global_options,\n                req.editable and req.permit_editable_wheels,\n            )\n            if wheel_file:\n                # Record the download origin in the cache\n                if req.download_info is not None:\n                    # download_info is guaranteed to be set because when we build an\n                    # InstallRequirement it has been through the preparer before, but\n                    # let's be cautious.\n                    wheel_cache.record_download_origin(cache_dir, req.download_info)\n                # Update the link for this.\n                req.link = Link(path_to_url(wheel_file))\n                req.local_file_path = req.link.file_path\n                assert req.link.is_wheel\n                build_successes.append(req)\n            else:\n                build_failures.append(req)\n\n    # notify success/failure\n    if build_successes:\n        logger.info(\n            \"Successfully built %s\",\n            \" \".join([req.name for req in build_successes]),  # type: ignore\n        )\n    if build_failures:\n        logger.info(\n            \"Failed to build %s\",\n            \" \".join([req.name for req in build_failures]),  # type: ignore\n        )\n    # Return a list of requirements that failed to build\n    return build_successes, build_failures\n"},"hash":"HPzoqt8qD6"}