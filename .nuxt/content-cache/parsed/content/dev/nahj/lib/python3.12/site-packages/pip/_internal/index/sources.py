{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:index:sources.py","body":"import logging\nimport mimetypes\nimport os\nfrom collections import defaultdict\nfrom typing import Callable, Dict, Iterable, List, Optional, Tuple\n\nfrom pip._vendor.packaging.utils import (\n    InvalidSdistFilename,\n    InvalidVersion,\n    InvalidWheelFilename,\n    canonicalize_name,\n    parse_sdist_filename,\n    parse_wheel_filename,\n)\n\nfrom pip._internal.models.candidate import InstallationCandidate\nfrom pip._internal.models.link import Link\nfrom pip._internal.utils.urls import path_to_url, url_to_path\nfrom pip._internal.vcs import is_url\n\nlogger = logging.getLogger(__name__)\n\nFoundCandidates = Iterable[InstallationCandidate]\nFoundLinks = Iterable[Link]\nCandidatesFromPage = Callable[[Link], Iterable[InstallationCandidate]]\nPageValidator = Callable[[Link], bool]\n\n\nclass LinkSource:\n    @property\n    def link(self) -> Optional[Link]:\n        \"\"\"Returns the underlying link, if there's one.\"\"\"\n        raise NotImplementedError()\n\n    def page_candidates(self) -> FoundCandidates:\n        \"\"\"Candidates found by parsing an archive listing HTML file.\"\"\"\n        raise NotImplementedError()\n\n    def file_links(self) -> FoundLinks:\n        \"\"\"Links found by specifying archives directly.\"\"\"\n        raise NotImplementedError()\n\n\ndef _is_html_file(file_url: str) -> bool:\n    return mimetypes.guess_type(file_url, strict=False)[0] == \"text/html\"\n\n\nclass _FlatDirectoryToUrls:\n    \"\"\"Scans directory and caches results\"\"\"\n\n    def __init__(self, path: str) -> None:\n        self._path = path\n        self._page_candidates: List[str] = []\n        self._project_name_to_urls: Dict[str, List[str]] = defaultdict(list)\n        self._scanned_directory = False\n\n    def _scan_directory(self) -> None:\n        \"\"\"Scans directory once and populates both page_candidates\n        and project_name_to_urls at the same time\n        \"\"\"\n        for entry in os.scandir(self._path):\n            url = path_to_url(entry.path)\n            if _is_html_file(url):\n                self._page_candidates.append(url)\n                continue\n\n            # File must have a valid wheel or sdist name,\n            # otherwise not worth considering as a package\n            try:\n                project_filename = parse_wheel_filename(entry.name)[0]\n            except (InvalidWheelFilename, InvalidVersion):\n                try:\n                    project_filename = parse_sdist_filename(entry.name)[0]\n                except (InvalidSdistFilename, InvalidVersion):\n                    continue\n\n            self._project_name_to_urls[project_filename].append(url)\n        self._scanned_directory = True\n\n    @property\n    def page_candidates(self) -> List[str]:\n        if not self._scanned_directory:\n            self._scan_directory()\n\n        return self._page_candidates\n\n    @property\n    def project_name_to_urls(self) -> Dict[str, List[str]]:\n        if not self._scanned_directory:\n            self._scan_directory()\n\n        return self._project_name_to_urls\n\n\nclass _FlatDirectorySource(LinkSource):\n    \"\"\"Link source specified by ``--find-links=<path-to-dir>``.\n\n    This looks the content of the directory, and returns:\n\n    * ``page_candidates``: Links listed on each HTML file in the directory.\n    * ``file_candidates``: Archives in the directory.\n    \"\"\"\n\n    _paths_to_urls: Dict[str, _FlatDirectoryToUrls] = {}\n\n    def __init__(\n        self,\n        candidates_from_page: CandidatesFromPage,\n        path: str,\n        project_name: str,\n    ) -> None:\n        self._candidates_from_page = candidates_from_page\n        self._project_name = canonicalize_name(project_name)\n\n        # Get existing instance of _FlatDirectoryToUrls if it exists\n        if path in self._paths_to_urls:\n            self._path_to_urls = self._paths_to_urls[path]\n        else:\n            self._path_to_urls = _FlatDirectoryToUrls(path=path)\n            self._paths_to_urls[path] = self._path_to_urls\n\n    @property\n    def link(self) -> Optional[Link]:\n        return None\n\n    def page_candidates(self) -> FoundCandidates:\n        for url in self._path_to_urls.page_candidates:\n            yield from self._candidates_from_page(Link(url))\n\n    def file_links(self) -> FoundLinks:\n        for url in self._path_to_urls.project_name_to_urls[self._project_name]:\n            yield Link(url)\n\n\nclass _LocalFileSource(LinkSource):\n    \"\"\"``--find-links=<path-or-url>`` or ``--[extra-]index-url=<path-or-url>``.\n\n    If a URL is supplied, it must be a ``file:`` URL. If a path is supplied to\n    the option, it is converted to a URL first. This returns:\n\n    * ``page_candidates``: Links listed on an HTML file.\n    * ``file_candidates``: The non-HTML file.\n    \"\"\"\n\n    def __init__(\n        self,\n        candidates_from_page: CandidatesFromPage,\n        link: Link,\n    ) -> None:\n        self._candidates_from_page = candidates_from_page\n        self._link = link\n\n    @property\n    def link(self) -> Optional[Link]:\n        return self._link\n\n    def page_candidates(self) -> FoundCandidates:\n        if not _is_html_file(self._link.url):\n            return\n        yield from self._candidates_from_page(self._link)\n\n    def file_links(self) -> FoundLinks:\n        if _is_html_file(self._link.url):\n            return\n        yield self._link\n\n\nclass _RemoteFileSource(LinkSource):\n    \"\"\"``--find-links=<url>`` or ``--[extra-]index-url=<url>``.\n\n    This returns:\n\n    * ``page_candidates``: Links listed on an HTML file.\n    * ``file_candidates``: The non-HTML file.\n    \"\"\"\n\n    def __init__(\n        self,\n        candidates_from_page: CandidatesFromPage,\n        page_validator: PageValidator,\n        link: Link,\n    ) -> None:\n        self._candidates_from_page = candidates_from_page\n        self._page_validator = page_validator\n        self._link = link\n\n    @property\n    def link(self) -> Optional[Link]:\n        return self._link\n\n    def page_candidates(self) -> FoundCandidates:\n        if not self._page_validator(self._link):\n            return\n        yield from self._candidates_from_page(self._link)\n\n    def file_links(self) -> FoundLinks:\n        yield self._link\n\n\nclass _IndexDirectorySource(LinkSource):\n    \"\"\"``--[extra-]index-url=<path-to-directory>``.\n\n    This is treated like a remote URL; ``candidates_from_page`` contains logic\n    for this by appending ``index.html`` to the link.\n    \"\"\"\n\n    def __init__(\n        self,\n        candidates_from_page: CandidatesFromPage,\n        link: Link,\n    ) -> None:\n        self._candidates_from_page = candidates_from_page\n        self._link = link\n\n    @property\n    def link(self) -> Optional[Link]:\n        return self._link\n\n    def page_candidates(self) -> FoundCandidates:\n        yield from self._candidates_from_page(self._link)\n\n    def file_links(self) -> FoundLinks:\n        return ()\n\n\ndef build_source(\n    location: str,\n    *,\n    candidates_from_page: CandidatesFromPage,\n    page_validator: PageValidator,\n    expand_dir: bool,\n    cache_link_parsing: bool,\n    project_name: str,\n) -> Tuple[Optional[str], Optional[LinkSource]]:\n    path: Optional[str] = None\n    url: Optional[str] = None\n    if os.path.exists(location):  # Is a local path.\n        url = path_to_url(location)\n        path = location\n    elif location.startswith(\"file:\"):  # A file: URL.\n        url = location\n        path = url_to_path(location)\n    elif is_url(location):\n        url = location\n\n    if url is None:\n        msg = (\n            \"Location '%s' is ignored: \"\n            \"it is either a non-existing path or lacks a specific scheme.\"\n        )\n        logger.warning(msg, location)\n        return (None, None)\n\n    if path is None:\n        source: LinkSource = _RemoteFileSource(\n            candidates_from_page=candidates_from_page,\n            page_validator=page_validator,\n            link=Link(url, cache_link_parsing=cache_link_parsing),\n        )\n        return (url, source)\n\n    if os.path.isdir(path):\n        if expand_dir:\n            source = _FlatDirectorySource(\n                candidates_from_page=candidates_from_page,\n                path=path,\n                project_name=project_name,\n            )\n        else:\n            source = _IndexDirectorySource(\n                candidates_from_page=candidates_from_page,\n                link=Link(url, cache_link_parsing=cache_link_parsing),\n            )\n        return (url, source)\n    elif os.path.isfile(path):\n        source = _LocalFileSource(\n            candidates_from_page=candidates_from_page,\n            link=Link(url, cache_link_parsing=cache_link_parsing),\n        )\n        return (url, source)\n    logger.warning(\n        \"Location '%s' is ignored: it is neither a file nor a directory.\",\n        location,\n    )\n    return (url, None)\n"},"hash":"sa7oIk91Rb"}