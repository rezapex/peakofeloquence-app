{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:commands:download.py","body":"import logging\nimport os\nfrom optparse import Values\nfrom typing import List\n\nfrom pip._internal.cli import cmdoptions\nfrom pip._internal.cli.cmdoptions import make_target_python\nfrom pip._internal.cli.req_command import RequirementCommand, with_cleanup\nfrom pip._internal.cli.status_codes import SUCCESS\nfrom pip._internal.operations.build.build_tracker import get_build_tracker\nfrom pip._internal.req.req_install import check_legacy_setup_py_options\nfrom pip._internal.utils.misc import ensure_dir, normalize_path, write_output\nfrom pip._internal.utils.temp_dir import TempDirectory\n\nlogger = logging.getLogger(__name__)\n\n\nclass DownloadCommand(RequirementCommand):\n    \"\"\"\n    Download packages from:\n\n    - PyPI (and other indexes) using requirement specifiers.\n    - VCS project urls.\n    - Local project directories.\n    - Local or remote source archives.\n\n    pip also supports downloading from \"requirements files\", which provide\n    an easy way to specify a whole environment to be downloaded.\n    \"\"\"\n\n    usage = \"\"\"\n      %prog [options] <requirement specifier> [package-index-options] ...\n      %prog [options] -r <requirements file> [package-index-options] ...\n      %prog [options] <vcs project url> ...\n      %prog [options] <local project path> ...\n      %prog [options] <archive url/path> ...\"\"\"\n\n    def add_options(self) -> None:\n        self.cmd_opts.add_option(cmdoptions.constraints())\n        self.cmd_opts.add_option(cmdoptions.requirements())\n        self.cmd_opts.add_option(cmdoptions.no_deps())\n        self.cmd_opts.add_option(cmdoptions.global_options())\n        self.cmd_opts.add_option(cmdoptions.no_binary())\n        self.cmd_opts.add_option(cmdoptions.only_binary())\n        self.cmd_opts.add_option(cmdoptions.prefer_binary())\n        self.cmd_opts.add_option(cmdoptions.src())\n        self.cmd_opts.add_option(cmdoptions.pre())\n        self.cmd_opts.add_option(cmdoptions.require_hashes())\n        self.cmd_opts.add_option(cmdoptions.progress_bar())\n        self.cmd_opts.add_option(cmdoptions.no_build_isolation())\n        self.cmd_opts.add_option(cmdoptions.use_pep517())\n        self.cmd_opts.add_option(cmdoptions.no_use_pep517())\n        self.cmd_opts.add_option(cmdoptions.check_build_deps())\n        self.cmd_opts.add_option(cmdoptions.ignore_requires_python())\n\n        self.cmd_opts.add_option(\n            \"-d\",\n            \"--dest\",\n            \"--destination-dir\",\n            \"--destination-directory\",\n            dest=\"download_dir\",\n            metavar=\"dir\",\n            default=os.curdir,\n            help=\"Download packages into <dir>.\",\n        )\n\n        cmdoptions.add_target_python_options(self.cmd_opts)\n\n        index_opts = cmdoptions.make_option_group(\n            cmdoptions.index_group,\n            self.parser,\n        )\n\n        self.parser.insert_option_group(0, index_opts)\n        self.parser.insert_option_group(0, self.cmd_opts)\n\n    @with_cleanup\n    def run(self, options: Values, args: List[str]) -> int:\n        options.ignore_installed = True\n        # editable doesn't really make sense for `pip download`, but the bowels\n        # of the RequirementSet code require that property.\n        options.editables = []\n\n        cmdoptions.check_dist_restriction(options)\n\n        options.download_dir = normalize_path(options.download_dir)\n        ensure_dir(options.download_dir)\n\n        session = self.get_default_session(options)\n\n        target_python = make_target_python(options)\n        finder = self._build_package_finder(\n            options=options,\n            session=session,\n            target_python=target_python,\n            ignore_requires_python=options.ignore_requires_python,\n        )\n\n        build_tracker = self.enter_context(get_build_tracker())\n\n        directory = TempDirectory(\n            delete=not options.no_clean,\n            kind=\"download\",\n            globally_managed=True,\n        )\n\n        reqs = self.get_requirements(args, options, finder, session)\n        check_legacy_setup_py_options(options, reqs)\n\n        preparer = self.make_requirement_preparer(\n            temp_build_dir=directory,\n            options=options,\n            build_tracker=build_tracker,\n            session=session,\n            finder=finder,\n            download_dir=options.download_dir,\n            use_user_site=False,\n            verbosity=self.verbosity,\n        )\n\n        resolver = self.make_resolver(\n            preparer=preparer,\n            finder=finder,\n            options=options,\n            ignore_requires_python=options.ignore_requires_python,\n            use_pep517=options.use_pep517,\n            py_version_info=options.python_version,\n        )\n\n        self.trace_basic_info(finder)\n\n        requirement_set = resolver.resolve(reqs, check_supported_wheels=True)\n\n        downloaded: List[str] = []\n        for req in requirement_set.requirements.values():\n            if req.satisfied_by is None:\n                assert req.name is not None\n                preparer.save_linked_requirement(req)\n                downloaded.append(req.name)\n\n        preparer.prepare_linked_requirements_more(requirement_set.requirements.values())\n        requirement_set.warn_legacy_versions_and_specifiers()\n\n        if downloaded:\n            write_output(\"Successfully downloaded %s\", \" \".join(downloaded))\n\n        return SUCCESS\n"},"hash":"14UQ1bNsGF"}