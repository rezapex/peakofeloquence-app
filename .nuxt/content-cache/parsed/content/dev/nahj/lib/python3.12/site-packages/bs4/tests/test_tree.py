{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:bs4:tests:test_tree.py","body":"# -*- coding: utf-8 -*-\n\"\"\"Tests for Beautiful Soup's tree traversal methods.\n\nThe tree traversal methods are the main advantage of using Beautiful\nSoup over just using a parser.\n\nDifferent parsers will build different Beautiful Soup trees given the\nsame markup, but all Beautiful Soup trees can be traversed with the\nmethods tested here.\n\"\"\"\n\nfrom pdb import set_trace\nimport pytest\nimport re\nimport warnings\nfrom bs4 import BeautifulSoup\nfrom bs4.builder import (\n    builder_registry,\n    HTMLParserTreeBuilder,\n)\nfrom bs4.element import (\n    CData,\n    Comment,\n    Declaration,\n    Doctype,\n    Formatter,\n    NavigableString,\n    Script,\n    SoupStrainer,\n    Stylesheet,\n    Tag,\n    TemplateString,\n)\nfrom . import (\n    SoupTest,\n)\n\nclass TestFind(SoupTest):\n    \"\"\"Basic tests of the find() method.\n\n    find() just calls find_all() with limit=1, so it's not tested all\n    that thouroughly here.\n    \"\"\"\n\n    def test_find_tag(self):\n        soup = self.soup(\"<a>1</a><b>2</b><a>3</a><b>4</b>\")\n        assert soup.find(\"b\").string == \"2\"\n\n    def test_unicode_text_find(self):\n        soup = self.soup('<h1>Räksmörgås</h1>')\n        assert soup.find(string='Räksmörgås') == 'Räksmörgås'\n\n    def test_unicode_attribute_find(self):\n        soup = self.soup('<h1 id=\"Räksmörgås\">here it is</h1>')\n        str(soup)\n        assert \"here it is\" == soup.find(id='Räksmörgås').text\n\n\n    def test_find_everything(self):\n        \"\"\"Test an optimization that finds all tags.\"\"\"\n        soup = self.soup(\"<a>foo</a><b>bar</b>\")\n        assert 2 == len(soup.find_all())\n\n    def test_find_everything_with_name(self):\n        \"\"\"Test an optimization that finds all tags with a given name.\"\"\"\n        soup = self.soup(\"<a>foo</a><b>bar</b><a>baz</a>\")\n        assert 2 == len(soup.find_all('a'))\n\nclass TestFindAll(SoupTest):\n    \"\"\"Basic tests of the find_all() method.\"\"\"\n\n    def test_find_all_text_nodes(self):\n        \"\"\"You can search the tree for text nodes.\"\"\"\n        soup = self.soup(\"<html>Foo<b>bar</b>\\xbb</html>\")\n        # Exact match.\n        assert soup.find_all(string=\"bar\") == [\"bar\"]\n\n       \n        # Match any of a number of strings.\n        assert soup.find_all(string=[\"Foo\", \"bar\"]) == [\"Foo\", \"bar\"]\n        # Match a regular expression.\n        assert soup.find_all(string=re.compile('.*')) == [\"Foo\", \"bar\", '\\xbb']\n        # Match anything.\n        assert soup.find_all(string=True) == [\"Foo\", \"bar\", '\\xbb']\n\n    def test_find_all_limit(self):\n        \"\"\"You can limit the number of items returned by find_all.\"\"\"\n        soup = self.soup(\"<a>1</a><a>2</a><a>3</a><a>4</a><a>5</a>\")\n        self.assert_selects(soup.find_all('a', limit=3), [\"1\", \"2\", \"3\"])\n        self.assert_selects(soup.find_all('a', limit=1), [\"1\"])\n        self.assert_selects(\n            soup.find_all('a', limit=10), [\"1\", \"2\", \"3\", \"4\", \"5\"])\n\n        # A limit of 0 means no limit.\n        self.assert_selects(\n            soup.find_all('a', limit=0), [\"1\", \"2\", \"3\", \"4\", \"5\"])\n\n    def test_calling_a_tag_is_calling_findall(self):\n        soup = self.soup(\"<a>1</a><b>2<a id='foo'>3</a></b>\")\n        self.assert_selects(soup('a', limit=1), [\"1\"])\n        self.assert_selects(soup.b(id=\"foo\"), [\"3\"])\n\n    def test_find_all_with_self_referential_data_structure_does_not_cause_infinite_recursion(self):\n        soup = self.soup(\"<a></a>\")\n        # Create a self-referential list.\n        l = []\n        l.append(l)\n\n        # Without special code in _normalize_search_value, this would cause infinite\n        # recursion.\n        assert [] == soup.find_all(l)\n\n    def test_find_all_resultset(self):\n        \"\"\"All find_all calls return a ResultSet\"\"\"\n        soup = self.soup(\"<a></a>\")\n        result = soup.find_all(\"a\")\n        assert hasattr(result, \"source\")\n\n        result = soup.find_all(True)\n        assert hasattr(result, \"source\")\n\n        result = soup.find_all(string=\"foo\")\n        assert hasattr(result, \"source\")\n\n\nclass TestFindAllBasicNamespaces(SoupTest):\n\n    def test_find_by_namespaced_name(self):\n        soup = self.soup('<mathml:msqrt>4</mathml:msqrt><a svg:fill=\"red\">')\n        assert \"4\" == soup.find(\"mathml:msqrt\").string\n        assert \"a\" == soup.find(attrs= { \"svg:fill\" : \"red\" }).name\n\n\nclass TestFindAllByName(SoupTest):\n    \"\"\"Test ways of finding tags by tag name.\"\"\"\n\n    def setup_method(self):\n        self.tree =  self.soup(\"\"\"<a>First tag.</a>\n                                  <b>Second tag.</b>\n                                  <c>Third <a>Nested tag.</a> tag.</c>\"\"\")\n\n    def test_find_all_by_tag_name(self):\n        # Find all the <a> tags.\n        self.assert_selects(\n            self.tree.find_all('a'), ['First tag.', 'Nested tag.'])\n\n    def test_find_all_by_name_and_text(self):\n        self.assert_selects(\n            self.tree.find_all('a', string='First tag.'), ['First tag.'])\n\n        self.assert_selects(\n            self.tree.find_all('a', string=True), ['First tag.', 'Nested tag.'])\n\n        self.assert_selects(\n            self.tree.find_all('a', string=re.compile(\"tag\")),\n            ['First tag.', 'Nested tag.'])\n\n\n    def test_find_all_on_non_root_element(self):\n        # You can call find_all on any node, not just the root.\n        self.assert_selects(self.tree.c.find_all('a'), ['Nested tag.'])\n\n    def test_calling_element_invokes_find_all(self):\n        self.assert_selects(self.tree('a'), ['First tag.', 'Nested tag.'])\n\n    def test_find_all_by_tag_strainer(self):\n        self.assert_selects(\n            self.tree.find_all(SoupStrainer('a')),\n            ['First tag.', 'Nested tag.'])\n\n    def test_find_all_by_tag_names(self):\n        self.assert_selects(\n            self.tree.find_all(['a', 'b']),\n            ['First tag.', 'Second tag.', 'Nested tag.'])\n\n    def test_find_all_by_tag_dict(self):\n        self.assert_selects(\n            self.tree.find_all({'a' : True, 'b' : True}),\n            ['First tag.', 'Second tag.', 'Nested tag.'])\n\n    def test_find_all_by_tag_re(self):\n        self.assert_selects(\n            self.tree.find_all(re.compile('^[ab]$')),\n            ['First tag.', 'Second tag.', 'Nested tag.'])\n\n    def test_find_all_with_tags_matching_method(self):\n        # You can define an oracle method that determines whether\n        # a tag matches the search.\n        def id_matches_name(tag):\n            return tag.name == tag.get('id')\n\n        tree = self.soup(\"\"\"<a id=\"a\">Match 1.</a>\n                            <a id=\"1\">Does not match.</a>\n                            <b id=\"b\">Match 2.</a>\"\"\")\n\n        self.assert_selects(\n            tree.find_all(id_matches_name), [\"Match 1.\", \"Match 2.\"])\n\n    def test_find_with_multi_valued_attribute(self):\n        soup = self.soup(\n            \"<div class='a b'>1</div><div class='a c'>2</div><div class='a d'>3</div>\"\n        )\n        r1 = soup.find('div', 'a d');\n        r2 = soup.find('div', re.compile(r'a d'));\n        r3, r4 = soup.find_all('div', ['a b', 'a d']);\n        assert '3' == r1.string\n        assert '3' == r2.string\n        assert '1' == r3.string\n        assert '3' == r4.string\n\n        \nclass TestFindAllByAttribute(SoupTest):\n\n    def test_find_all_by_attribute_name(self):\n        # You can pass in keyword arguments to find_all to search by\n        # attribute.\n        tree = self.soup(\"\"\"\n                         <a id=\"first\">Matching a.</a>\n                         <a id=\"second\">\n                          Non-matching <b id=\"first\">Matching b.</b>a.\n                         </a>\"\"\")\n        self.assert_selects(tree.find_all(id='first'),\n                           [\"Matching a.\", \"Matching b.\"])\n\n    def test_find_all_by_utf8_attribute_value(self):\n        peace = \"םולש\".encode(\"utf8\")\n        data = '<a title=\"םולש\"></a>'.encode(\"utf8\")\n        soup = self.soup(data)\n        assert [soup.a] == soup.find_all(title=peace)\n        assert [soup.a] == soup.find_all(title=peace.decode(\"utf8\"))\n        assert [soup.a], soup.find_all(title=[peace, \"something else\"])\n\n    def test_find_all_by_attribute_dict(self):\n        # You can pass in a dictionary as the argument 'attrs'. This\n        # lets you search for attributes like 'name' (a fixed argument\n        # to find_all) and 'class' (a reserved word in Python.)\n        tree = self.soup(\"\"\"\n                         <a name=\"name1\" class=\"class1\">Name match.</a>\n                         <a name=\"name2\" class=\"class2\">Class match.</a>\n                         <a name=\"name3\" class=\"class3\">Non-match.</a>\n                         <name1>A tag called 'name1'.</name1>\n                         \"\"\")\n\n        # This doesn't do what you want.\n        self.assert_selects(tree.find_all(name='name1'),\n                           [\"A tag called 'name1'.\"])\n        # This does what you want.\n        self.assert_selects(tree.find_all(attrs={'name' : 'name1'}),\n                           [\"Name match.\"])\n\n        self.assert_selects(tree.find_all(attrs={'class' : 'class2'}),\n                           [\"Class match.\"])\n\n    def test_find_all_by_class(self):\n        tree = self.soup(\"\"\"\n                         <a class=\"1\">Class 1.</a>\n                         <a class=\"2\">Class 2.</a>\n                         <b class=\"1\">Class 1.</b>\n                         <c class=\"3 4\">Class 3 and 4.</c>\n                         \"\"\")\n\n        # Passing in the class_ keyword argument will search against\n        # the 'class' attribute.\n        self.assert_selects(tree.find_all('a', class_='1'), ['Class 1.'])\n        self.assert_selects(tree.find_all('c', class_='3'), ['Class 3 and 4.'])\n        self.assert_selects(tree.find_all('c', class_='4'), ['Class 3 and 4.'])\n\n        # Passing in a string to 'attrs' will also search the CSS class.\n        self.assert_selects(tree.find_all('a', '1'), ['Class 1.'])\n        self.assert_selects(tree.find_all(attrs='1'), ['Class 1.', 'Class 1.'])\n        self.assert_selects(tree.find_all('c', '3'), ['Class 3 and 4.'])\n        self.assert_selects(tree.find_all('c', '4'), ['Class 3 and 4.'])\n\n    def test_find_by_class_when_multiple_classes_present(self):\n        tree = self.soup(\"<gar class='foo bar'>Found it</gar>\")\n\n        f = tree.find_all(\"gar\", class_=re.compile(\"o\"))\n        self.assert_selects(f, [\"Found it\"])\n\n        f = tree.find_all(\"gar\", class_=re.compile(\"a\"))\n        self.assert_selects(f, [\"Found it\"])\n\n        # If the search fails to match the individual strings \"foo\" and \"bar\",\n        # it will be tried against the combined string \"foo bar\".\n        f = tree.find_all(\"gar\", class_=re.compile(\"o b\"))\n        self.assert_selects(f, [\"Found it\"])\n\n    def test_find_all_with_non_dictionary_for_attrs_finds_by_class(self):\n        soup = self.soup(\"<a class='bar'>Found it</a>\")\n\n        self.assert_selects(soup.find_all(\"a\", re.compile(\"ba\")), [\"Found it\"])\n\n        def big_attribute_value(value):\n            return len(value) > 3\n\n        self.assert_selects(soup.find_all(\"a\", big_attribute_value), [])\n\n        def small_attribute_value(value):\n            return len(value) <= 3\n\n        self.assert_selects(\n            soup.find_all(\"a\", small_attribute_value), [\"Found it\"])\n\n    def test_find_all_with_string_for_attrs_finds_multiple_classes(self):\n        soup = self.soup('<a class=\"foo bar\"></a><a class=\"foo\"></a>')\n        a, a2 = soup.find_all(\"a\")\n        assert [a, a2], soup.find_all(\"a\", \"foo\")\n        assert [a], soup.find_all(\"a\", \"bar\")\n\n        # If you specify the class as a string that contains a\n        # space, only that specific value will be found.\n        assert [a] == soup.find_all(\"a\", class_=\"foo bar\")\n        assert [a] == soup.find_all(\"a\", \"foo bar\")\n        assert [] == soup.find_all(\"a\", \"bar foo\")\n\n    def test_find_all_by_attribute_soupstrainer(self):\n        tree = self.soup(\"\"\"\n                         <a id=\"first\">Match.</a>\n                         <a id=\"second\">Non-match.</a>\"\"\")\n\n        strainer = SoupStrainer(attrs={'id' : 'first'})\n        self.assert_selects(tree.find_all(strainer), ['Match.'])\n\n    def test_find_all_with_missing_attribute(self):\n        # You can pass in None as the value of an attribute to find_all.\n        # This will match tags that do not have that attribute set.\n        tree = self.soup(\"\"\"<a id=\"1\">ID present.</a>\n                            <a>No ID present.</a>\n                            <a id=\"\">ID is empty.</a>\"\"\")\n        self.assert_selects(tree.find_all('a', id=None), [\"No ID present.\"])\n\n    def test_find_all_with_defined_attribute(self):\n        # You can pass in None as the value of an attribute to find_all.\n        # This will match tags that have that attribute set to any value.\n        tree = self.soup(\"\"\"<a id=\"1\">ID present.</a>\n                            <a>No ID present.</a>\n                            <a id=\"\">ID is empty.</a>\"\"\")\n        self.assert_selects(\n            tree.find_all(id=True), [\"ID present.\", \"ID is empty.\"])\n\n    def test_find_all_with_numeric_attribute(self):\n        # If you search for a number, it's treated as a string.\n        tree = self.soup(\"\"\"<a id=1>Unquoted attribute.</a>\n                            <a id=\"1\">Quoted attribute.</a>\"\"\")\n\n        expected = [\"Unquoted attribute.\", \"Quoted attribute.\"]\n        self.assert_selects(tree.find_all(id=1), expected)\n        self.assert_selects(tree.find_all(id=\"1\"), expected)\n\n    def test_find_all_with_list_attribute_values(self):\n        # You can pass a list of attribute values instead of just one,\n        # and you'll get tags that match any of the values.\n        tree = self.soup(\"\"\"<a id=\"1\">1</a>\n                            <a id=\"2\">2</a>\n                            <a id=\"3\">3</a>\n                            <a>No ID.</a>\"\"\")\n        self.assert_selects(tree.find_all(id=[\"1\", \"3\", \"4\"]),\n                           [\"1\", \"3\"])\n\n    def test_find_all_with_regular_expression_attribute_value(self):\n        # You can pass a regular expression as an attribute value, and\n        # you'll get tags whose values for that attribute match the\n        # regular expression.\n        tree = self.soup(\"\"\"<a id=\"a\">One a.</a>\n                            <a id=\"aa\">Two as.</a>\n                            <a id=\"ab\">Mixed as and bs.</a>\n                            <a id=\"b\">One b.</a>\n                            <a>No ID.</a>\"\"\")\n\n        self.assert_selects(tree.find_all(id=re.compile(\"^a+$\")),\n                           [\"One a.\", \"Two as.\"])\n\n    def test_find_by_name_and_containing_string(self):\n        soup = self.soup(\"<b>foo</b><b>bar</b><a>foo</a>\")\n        a = soup.a\n\n        assert [a] == soup.find_all(\"a\", string=\"foo\")\n        assert [] == soup.find_all(\"a\", string=\"bar\")\n\n    def test_find_by_name_and_containing_string_when_string_is_buried(self):\n        soup = self.soup(\"<a>foo</a><a><b><c>foo</c></b></a>\")\n        assert soup.find_all(\"a\") == soup.find_all(\"a\", string=\"foo\")\n\n    def test_find_by_attribute_and_containing_string(self):\n        soup = self.soup('<b id=\"1\">foo</b><a id=\"2\">foo</a>')\n        a = soup.a\n\n        assert [a] == soup.find_all(id=2, string=\"foo\")\n        assert [] == soup.find_all(id=1, string=\"bar\")\n\n\nclass TestSmooth(SoupTest):\n    \"\"\"Test Tag.smooth.\"\"\"\n\n    def test_smooth(self):\n        soup = self.soup(\"<div>a</div>\")\n        div = soup.div\n        div.append(\"b\")\n        div.append(\"c\")\n        div.append(Comment(\"Comment 1\"))\n        div.append(Comment(\"Comment 2\"))\n        div.append(\"d\")\n        builder = self.default_builder()\n        span = Tag(soup, builder, 'span')\n        span.append('1')\n        span.append('2')\n        div.append(span)\n\n        # At this point the tree has a bunch of adjacent\n        # NavigableStrings. This is normal, but it has no meaning in\n        # terms of HTML, so we may want to smooth things out for\n        # output.\n\n        # Since the <span> tag has two children, its .string is None.\n        assert None == div.span.string\n\n        assert 7 == len(div.contents)\n        div.smooth()\n        assert 5 == len(div.contents)\n\n        # The three strings at the beginning of div.contents have been\n        # merged into on string.\n        #\n        assert 'abc' == div.contents[0]\n\n        # The call is recursive -- the <span> tag was also smoothed.\n        assert '12' == div.span.string\n\n        # The two comments have _not_ been merged, even though\n        # comments are strings. Merging comments would change the\n        # meaning of the HTML.\n        assert 'Comment 1' == div.contents[1]\n        assert 'Comment 2' == div.contents[2]\n\n\nclass TestIndex(SoupTest):\n    \"\"\"Test Tag.index\"\"\"\n    def test_index(self):\n        tree = self.soup(\"\"\"<div>\n                            <a>Identical</a>\n                            <b>Not identical</b>\n                            <a>Identical</a>\n\n                            <c><d>Identical with child</d></c>\n                            <b>Also not identical</b>\n                            <c><d>Identical with child</d></c>\n                            </div>\"\"\")\n        div = tree.div\n        for i, element in enumerate(div.contents):\n            assert i == div.index(element)\n        with pytest.raises(ValueError):\n            tree.index(1)\n\n\nclass TestParentOperations(SoupTest):\n    \"\"\"Test navigation and searching through an element's parents.\"\"\"\n\n    def setup_method(self):\n        self.tree = self.soup('''<ul id=\"empty\"></ul>\n                                 <ul id=\"top\">\n                                  <ul id=\"middle\">\n                                   <ul id=\"bottom\">\n                                    <b>Start here</b>\n                                   </ul>\n                                  </ul>''')\n        self.start = self.tree.b\n\n\n    def test_parent(self):\n        assert self.start.parent['id'] == 'bottom'\n        assert self.start.parent.parent['id'] == 'middle'\n        assert self.start.parent.parent.parent['id'] == 'top'\n\n    def test_parent_of_top_tag_is_soup_object(self):\n        top_tag = self.tree.contents[0]\n        assert top_tag.parent == self.tree\n\n    def test_soup_object_has_no_parent(self):\n        assert None == self.tree.parent\n\n    def test_find_parents(self):\n        self.assert_selects_ids(\n            self.start.find_parents('ul'), ['bottom', 'middle', 'top'])\n        self.assert_selects_ids(\n            self.start.find_parents('ul', id=\"middle\"), ['middle'])\n\n    def test_find_parent(self):\n        assert self.start.find_parent('ul')['id'] == 'bottom'\n        assert self.start.find_parent('ul', id='top')['id'] == 'top'\n\n    def test_parent_of_text_element(self):\n        text = self.tree.find(string=\"Start here\")\n        assert text.parent.name == 'b'\n\n    def test_text_element_find_parent(self):\n        text = self.tree.find(string=\"Start here\")\n        assert text.find_parent('ul')['id'] == 'bottom'\n\n    def test_parent_generator(self):\n        parents = [parent['id'] for parent in self.start.parents\n                   if parent is not None and 'id' in parent.attrs]\n        assert parents, ['bottom', 'middle' == 'top']\n\n\nclass ProximityTest(SoupTest):\n\n    def setup_method(self):\n        self.tree = self.soup(\n            '<html id=\"start\"><head></head><body><b id=\"1\">One</b><b id=\"2\">Two</b><b id=\"3\">Three</b></body></html>')\n\n\nclass TestNextOperations(ProximityTest):\n\n    def setup_method(self):\n        super(TestNextOperations, self).setup_method()\n        self.start = self.tree.b\n\n    def test_next(self):\n        assert self.start.next_element == \"One\"\n        assert self.start.next_element.next_element['id'] == \"2\"\n\n    def test_next_of_last_item_is_none(self):\n        last = self.tree.find(string=\"Three\")\n        assert last.next_element == None\n\n    def test_next_of_root_is_none(self):\n        # The document root is outside the next/previous chain.\n        assert self.tree.next_element == None\n\n    def test_find_all_next(self):\n        self.assert_selects(self.start.find_all_next('b'), [\"Two\", \"Three\"])\n        self.start.find_all_next(id=3)\n        self.assert_selects(self.start.find_all_next(id=3), [\"Three\"])\n\n    def test_find_next(self):\n        assert self.start.find_next('b')['id'] == '2'\n        assert self.start.find_next(string=\"Three\") == \"Three\"\n\n    def test_find_next_for_text_element(self):\n        text = self.tree.find(string=\"One\")\n        assert text.find_next(\"b\").string == \"Two\"\n        self.assert_selects(text.find_all_next(\"b\"), [\"Two\", \"Three\"])\n\n    def test_next_generator(self):\n        start = self.tree.find(string=\"Two\")\n        successors = [node for node in start.next_elements]\n        # There are two successors: the final <b> tag and its text contents.\n        tag, contents = successors\n        assert tag['id'] == '3'\n        assert contents == \"Three\"\n\nclass TestPreviousOperations(ProximityTest):\n\n    def setup_method(self):\n        super(TestPreviousOperations, self).setup_method()\n        self.end = self.tree.find(string=\"Three\")\n\n    def test_previous(self):\n        assert self.end.previous_element['id'] == \"3\"\n        assert self.end.previous_element.previous_element == \"Two\"\n\n    def test_previous_of_first_item_is_none(self):\n        first = self.tree.find('html')\n        assert first.previous_element == None\n\n    def test_previous_of_root_is_none(self):\n        # The document root is outside the next/previous chain.\n        assert self.tree.previous_element == None\n\n    def test_find_all_previous(self):\n        # The <b> tag containing the \"Three\" node is the predecessor\n        # of the \"Three\" node itself, which is why \"Three\" shows up\n        # here.\n        self.assert_selects(\n            self.end.find_all_previous('b'), [\"Three\", \"Two\", \"One\"])\n        self.assert_selects(self.end.find_all_previous(id=1), [\"One\"])\n\n    def test_find_previous(self):\n        assert self.end.find_previous('b')['id'] == '3'\n        assert self.end.find_previous(string=\"One\") == \"One\"\n\n    def test_find_previous_for_text_element(self):\n        text = self.tree.find(string=\"Three\")\n        assert text.find_previous(\"b\").string == \"Three\"\n        self.assert_selects(\n            text.find_all_previous(\"b\"), [\"Three\", \"Two\", \"One\"])\n\n    def test_previous_generator(self):\n        start = self.tree.find(string=\"One\")\n        predecessors = [node for node in start.previous_elements]\n\n        # There are four predecessors: the <b> tag containing \"One\"\n        # the <body> tag, the <head> tag, and the <html> tag.\n        b, body, head, html = predecessors\n        assert b['id'] == '1'\n        assert body.name == \"body\"\n        assert head.name == \"head\"\n        assert html.name == \"html\"\n\n\nclass SiblingTest(SoupTest):\n\n    def setup_method(self):\n        markup = '''<html>\n                    <span id=\"1\">\n                     <span id=\"1.1\"></span>\n                    </span>\n                    <span id=\"2\">\n                     <span id=\"2.1\"></span>\n                    </span>\n                    <span id=\"3\">\n                     <span id=\"3.1\"></span>\n                    </span>\n                    <span id=\"4\"></span>\n                    </html>'''\n        # All that whitespace looks good but makes the tests more\n        # difficult. Get rid of it.\n        markup = re.compile(r\"\\n\\s*\").sub(\"\", markup)\n        self.tree = self.soup(markup)\n\n\nclass TestNextSibling(SiblingTest):\n\n    def setup_method(self):\n        super(TestNextSibling, self).setup_method()\n        self.start = self.tree.find(id=\"1\")\n\n    def test_next_sibling_of_root_is_none(self):\n        assert self.tree.next_sibling == None\n\n    def test_next_sibling(self):\n        assert self.start.next_sibling['id'] == '2'\n        assert self.start.next_sibling.next_sibling['id'] == '3'\n\n        # Note the difference between next_sibling and next_element.\n        assert self.start.next_element['id'] == '1.1'\n\n    def test_next_sibling_may_not_exist(self):\n        assert self.tree.html.next_sibling == None\n\n        nested_span = self.tree.find(id=\"1.1\")\n        assert nested_span.next_sibling == None\n\n        last_span = self.tree.find(id=\"4\")\n        assert last_span.next_sibling == None\n\n    def test_find_next_sibling(self):\n        assert self.start.find_next_sibling('span')['id'] == '2'\n\n    def test_next_siblings(self):\n        self.assert_selects_ids(self.start.find_next_siblings(\"span\"),\n                              ['2', '3', '4'])\n\n        self.assert_selects_ids(self.start.find_next_siblings(id='3'), ['3'])\n\n    def test_next_sibling_for_text_element(self):\n        soup = self.soup(\"Foo<b>bar</b>baz\")\n        start = soup.find(string=\"Foo\")\n        assert start.next_sibling.name == 'b'\n        assert start.next_sibling.next_sibling == 'baz'\n\n        self.assert_selects(start.find_next_siblings('b'), ['bar'])\n        assert start.find_next_sibling(string=\"baz\") == \"baz\"\n        assert start.find_next_sibling(string=\"nonesuch\") == None\n\n\nclass TestPreviousSibling(SiblingTest):\n\n    def setup_method(self):\n        super(TestPreviousSibling, self).setup_method()\n        self.end = self.tree.find(id=\"4\")\n\n    def test_previous_sibling_of_root_is_none(self):\n        assert self.tree.previous_sibling == None\n\n    def test_previous_sibling(self):\n        assert self.end.previous_sibling['id'] == '3'\n        assert self.end.previous_sibling.previous_sibling['id'] == '2'\n\n        # Note the difference between previous_sibling and previous_element.\n        assert self.end.previous_element['id'] == '3.1'\n\n    def test_previous_sibling_may_not_exist(self):\n        assert self.tree.html.previous_sibling == None\n\n        nested_span = self.tree.find(id=\"1.1\")\n        assert nested_span.previous_sibling == None\n\n        first_span = self.tree.find(id=\"1\")\n        assert first_span.previous_sibling == None\n\n    def test_find_previous_sibling(self):\n        assert self.end.find_previous_sibling('span')['id'] == '3'\n\n    def test_previous_siblings(self):\n        self.assert_selects_ids(self.end.find_previous_siblings(\"span\"),\n                              ['3', '2', '1'])\n\n        self.assert_selects_ids(self.end.find_previous_siblings(id='1'), ['1'])\n\n    def test_previous_sibling_for_text_element(self):\n        soup = self.soup(\"Foo<b>bar</b>baz\")\n        start = soup.find(string=\"baz\")\n        assert start.previous_sibling.name == 'b'\n        assert start.previous_sibling.previous_sibling == 'Foo'\n\n        self.assert_selects(start.find_previous_siblings('b'), ['bar'])\n        assert start.find_previous_sibling(string=\"Foo\") == \"Foo\"\n        assert start.find_previous_sibling(string=\"nonesuch\") == None\n\n\nclass TestTreeModification(SoupTest):\n\n    def test_attribute_modification(self):\n        soup = self.soup('<a id=\"1\"></a>')\n        soup.a['id'] = 2\n        assert soup.decode() == self.document_for('<a id=\"2\"></a>')\n        del(soup.a['id'])\n        assert soup.decode() == self.document_for('<a></a>')\n        soup.a['id2'] = 'foo'\n        assert soup.decode() == self.document_for('<a id2=\"foo\"></a>')\n\n    def test_new_tag_creation(self):\n        builder = builder_registry.lookup('html')()\n        soup = self.soup(\"<body></body>\", builder=builder)\n        a = Tag(soup, builder, 'a')\n        ol = Tag(soup, builder, 'ol')\n        a['href'] = 'http://foo.com/'\n        soup.body.insert(0, a)\n        soup.body.insert(1, ol)\n        assert soup.body.encode() == b'<body><a href=\"http://foo.com/\"></a><ol></ol></body>'\n\n    def test_append_to_contents_moves_tag(self):\n        doc = \"\"\"<p id=\"1\">Don't leave me <b>here</b>.</p>\n                <p id=\"2\">Don\\'t leave!</p>\"\"\"\n        soup = self.soup(doc)\n        second_para = soup.find(id='2')\n        bold = soup.b\n\n        # Move the <b> tag to the end of the second paragraph.\n        soup.find(id='2').append(soup.b)\n\n        # The <b> tag is now a child of the second paragraph.\n        assert bold.parent == second_para\n\n        assert soup.decode() == self.document_for(\n                '<p id=\"1\">Don\\'t leave me .</p>\\n'\n                '<p id=\"2\">Don\\'t leave!<b>here</b></p>'\n        )\n\n    def test_replace_with_returns_thing_that_was_replaced(self):\n        text = \"<a></a><b><c></c></b>\"\n        soup = self.soup(text)\n        a = soup.a\n        new_a = a.replace_with(soup.c)\n        assert a == new_a\n\n    def test_unwrap_returns_thing_that_was_replaced(self):\n        text = \"<a><b></b><c></c></a>\"\n        soup = self.soup(text)\n        a = soup.a\n        new_a = a.unwrap()\n        assert a == new_a\n\n    def test_replace_with_and_unwrap_give_useful_exception_when_tag_has_no_parent(self):\n        soup = self.soup(\"<a><b>Foo</b></a><c>Bar</c>\")\n        a = soup.a\n        a.extract()\n        assert None == a.parent\n        with pytest.raises(ValueError):\n            a.unwrap()\n        with pytest.raises(ValueError):\n            a.replace_with(soup.c)\n\n    def test_replace_tag_with_itself(self):\n        text = \"<a><b></b><c>Foo<d></d></c></a><a><e></e></a>\"\n        soup = self.soup(text)\n        c = soup.c\n        soup.c.replace_with(c)\n        assert soup.decode() == self.document_for(text)\n\n    def test_replace_tag_with_its_parent_raises_exception(self):\n        text = \"<a><b></b></a>\"\n        soup = self.soup(text)\n        with pytest.raises(ValueError):\n            soup.b.replace_with(soup.a)\n\n    def test_insert_tag_into_itself_raises_exception(self):\n        text = \"<a><b></b></a>\"\n        soup = self.soup(text)\n        with pytest.raises(ValueError):\n            soup.a.insert(0, soup.a)\n\n    def test_insert_beautifulsoup_object_inserts_children(self):\n        \"\"\"Inserting one BeautifulSoup object into another actually inserts all\n        of its children -- you'll never combine BeautifulSoup objects.\n        \"\"\"\n        soup = self.soup(\"<p>And now, a word:</p><p>And we're back.</p>\")\n        \n        text = \"<p>p2</p><p>p3</p>\"\n        to_insert = self.soup(text)\n        soup.insert(1, to_insert)\n\n        for i in soup.descendants:\n            assert not isinstance(i, BeautifulSoup)\n        \n        p1, p2, p3, p4 = list(soup.children)\n        assert \"And now, a word:\" == p1.string\n        assert \"p2\" == p2.string\n        assert \"p3\" == p3.string\n        assert \"And we're back.\" == p4.string\n        \n        \n    def test_replace_with_maintains_next_element_throughout(self):\n        soup = self.soup('<p><a>one</a><b>three</b></p>')\n        a = soup.a\n        b = a.contents[0]\n        # Make it so the <a> tag has two text children.\n        a.insert(1, \"two\")\n\n        # Now replace each one with the empty string.\n        left, right = a.contents\n        left.replaceWith('')\n        right.replaceWith('')\n\n        # The <b> tag is still connected to the tree.\n        assert \"three\" == soup.b.string\n\n    def test_replace_final_node(self):\n        soup = self.soup(\"<b>Argh!</b>\")\n        soup.find(string=\"Argh!\").replace_with(\"Hooray!\")\n        new_text = soup.find(string=\"Hooray!\")\n        b = soup.b\n        assert new_text.previous_element == b\n        assert new_text.parent == b\n        assert new_text.previous_element.next_element == new_text\n        assert new_text.next_element == None\n\n    def test_consecutive_text_nodes(self):\n        # A builder should never create two consecutive text nodes,\n        # but if you insert one next to another, Beautiful Soup will\n        # handle it correctly.\n        soup = self.soup(\"<a><b>Argh!</b><c></c></a>\")\n        soup.b.insert(1, \"Hooray!\")\n\n        assert soup.decode() == self.document_for(\n            \"<a><b>Argh!Hooray!</b><c></c></a>\"\n        )\n\n        new_text = soup.find(string=\"Hooray!\")\n        assert new_text.previous_element == \"Argh!\"\n        assert new_text.previous_element.next_element == new_text\n\n        assert new_text.previous_sibling == \"Argh!\"\n        assert new_text.previous_sibling.next_sibling == new_text\n\n        assert new_text.next_sibling == None\n        assert new_text.next_element == soup.c\n\n    def test_insert_string(self):\n        soup = self.soup(\"<a></a>\")\n        soup.a.insert(0, \"bar\")\n        soup.a.insert(0, \"foo\")\n        # The string were added to the tag.\n        assert [\"foo\", \"bar\"] == soup.a.contents\n        # And they were converted to NavigableStrings.\n        assert soup.a.contents[0].next_element == \"bar\"\n\n    def test_insert_tag(self):\n        builder = self.default_builder()\n        soup = self.soup(\n            \"<a><b>Find</b><c>lady!</c><d></d></a>\", builder=builder)\n        magic_tag = Tag(soup, builder, 'magictag')\n        magic_tag.insert(0, \"the\")\n        soup.a.insert(1, magic_tag)\n\n        assert soup.decode() == self.document_for(\n                \"<a><b>Find</b><magictag>the</magictag><c>lady!</c><d></d></a>\"\n        )\n\n        # Make sure all the relationships are hooked up correctly.\n        b_tag = soup.b\n        assert b_tag.next_sibling == magic_tag\n        assert magic_tag.previous_sibling == b_tag\n\n        find = b_tag.find(string=\"Find\")\n        assert find.next_element == magic_tag\n        assert magic_tag.previous_element == find\n\n        c_tag = soup.c\n        assert magic_tag.next_sibling == c_tag\n        assert c_tag.previous_sibling == magic_tag\n\n        the = magic_tag.find(string=\"the\")\n        assert the.parent == magic_tag\n        assert the.next_element == c_tag\n        assert c_tag.previous_element == the\n\n    def test_append_child_thats_already_at_the_end(self):\n        data = \"<a><b></b></a>\"\n        soup = self.soup(data)\n        soup.a.append(soup.b)\n        assert data == soup.decode()\n\n    def test_extend(self):\n        data = \"<a><b><c><d><e><f><g></g></f></e></d></c></b></a>\"\n        soup = self.soup(data)\n        l = [soup.g, soup.f, soup.e, soup.d, soup.c, soup.b]\n        soup.a.extend(l)\n        assert \"<a><g></g><f></f><e></e><d></d><c></c><b></b></a>\" == soup.decode()\n\n    @pytest.mark.parametrize(\n        \"get_tags\", [lambda tag: tag, lambda tag: tag.contents]\n    )\n    def test_extend_with_another_tags_contents(self, get_tags):\n        data = '<body><div id=\"d1\"><a>1</a><a>2</a><a>3</a><a>4</a></div><div id=\"d2\"></div></body>'\n        soup = self.soup(data)\n        d1 = soup.find('div', id='d1')\n        d2 = soup.find('div', id='d2')\n        tags = get_tags(d1)\n        d2.extend(tags)\n        assert '<div id=\"d1\"></div>' == d1.decode()\n        assert '<div id=\"d2\"><a>1</a><a>2</a><a>3</a><a>4</a></div>' == d2.decode()\n        \n    def test_move_tag_to_beginning_of_parent(self):\n        data = \"<a><b></b><c></c><d></d></a>\"\n        soup = self.soup(data)\n        soup.a.insert(0, soup.d)\n        assert \"<a><d></d><b></b><c></c></a>\" == soup.decode()\n\n    def test_insert_works_on_empty_element_tag(self):\n        # This is a little strange, since most HTML parsers don't allow\n        # markup like this to come through. But in general, we don't\n        # know what the parser would or wouldn't have allowed, so\n        # I'm letting this succeed for now.\n        soup = self.soup(\"<br/>\")\n        soup.br.insert(1, \"Contents\")\n        assert str(soup.br) == \"<br>Contents</br>\"\n\n    def test_insert_before(self):\n        soup = self.soup(\"<a>foo</a><b>bar</b>\")\n        soup.b.insert_before(\"BAZ\")\n        soup.a.insert_before(\"QUUX\")\n        assert soup.decode() == self.document_for(\n            \"QUUX<a>foo</a>BAZ<b>bar</b>\"\n        )\n\n        soup.a.insert_before(soup.b)\n        assert soup.decode() == self.document_for(\"QUUX<b>bar</b><a>foo</a>BAZ\")\n\n        # Can't insert an element before itself.\n        b = soup.b\n        with pytest.raises(ValueError):\n            b.insert_before(b)\n\n        # Can't insert before if an element has no parent.\n        b.extract()\n        with pytest.raises(ValueError):\n            b.insert_before(\"nope\")\n\n        # Can insert an identical element\n        soup = self.soup(\"<a>\")\n        soup.a.insert_before(soup.new_tag(\"a\"))\n\n        # TODO: OK but what happens?\n        \n    def test_insert_multiple_before(self):\n        soup = self.soup(\"<a>foo</a><b>bar</b>\")\n        soup.b.insert_before(\"BAZ\", \" \", \"QUUX\")\n        soup.a.insert_before(\"QUUX\", \" \", \"BAZ\")\n        assert soup.decode() == self.document_for(\n            \"QUUX BAZ<a>foo</a>BAZ QUUX<b>bar</b>\"\n        )\n\n        soup.a.insert_before(soup.b, \"FOO\")\n        assert soup.decode() == self.document_for(\n            \"QUUX BAZ<b>bar</b>FOO<a>foo</a>BAZ QUUX\"\n        )\n\n    def test_insert_after(self):\n        soup = self.soup(\"<a>foo</a><b>bar</b>\")\n        soup.b.insert_after(\"BAZ\")\n        soup.a.insert_after(\"QUUX\")\n        assert soup.decode() == self.document_for(\n            \"<a>foo</a>QUUX<b>bar</b>BAZ\"\n        )\n        soup.b.insert_after(soup.a)\n        assert soup.decode() == self.document_for(\"QUUX<b>bar</b><a>foo</a>BAZ\")\n\n        # Can't insert an element after itself.\n        b = soup.b\n        with pytest.raises(ValueError):\n            b.insert_after(b)\n\n        # Can't insert after if an element has no parent.\n        b.extract()\n        with pytest.raises(ValueError):\n            b.insert_after(\"nope\")\n\n        # Can insert an identical element\n        soup = self.soup(\"<a>\")\n        soup.a.insert_before(soup.new_tag(\"a\"))\n\n        # TODO: OK but what does it look like?\n        \n    def test_insert_multiple_after(self):\n        soup = self.soup(\"<a>foo</a><b>bar</b>\")\n        soup.b.insert_after(\"BAZ\", \" \", \"QUUX\")\n        soup.a.insert_after(\"QUUX\", \" \", \"BAZ\")\n        assert soup.decode() == self.document_for(\n            \"<a>foo</a>QUUX BAZ<b>bar</b>BAZ QUUX\"\n        )\n        soup.b.insert_after(soup.a, \"FOO \")\n        assert soup.decode() == self.document_for(\n            \"QUUX BAZ<b>bar</b><a>foo</a>FOO BAZ QUUX\"\n        )\n\n    def test_insert_after_raises_exception_if_after_has_no_meaning(self):\n        soup = self.soup(\"\")\n        tag = soup.new_tag(\"a\")\n        string = soup.new_string(\"\")\n        with pytest.raises(ValueError):\n            string.insert_after(tag)\n        with pytest.raises(NotImplementedError):\n            soup.insert_after(tag)\n        with pytest.raises(ValueError):\n            tag.insert_after(tag)\n\n    def test_insert_before_raises_notimplementederror_if_before_has_no_meaning(self):\n        soup = self.soup(\"\")\n        tag = soup.new_tag(\"a\")\n        string = soup.new_string(\"\")\n        with pytest.raises(ValueError):\n            string.insert_before(tag)\n        with pytest.raises(NotImplementedError):\n            soup.insert_before(tag)\n        with pytest.raises(ValueError):\n            tag.insert_before(tag)\n\n    def test_replace_with(self):\n        soup = self.soup(\n                \"<p>There's <b>no</b> business like <b>show</b> business</p>\")\n        no, show = soup.find_all('b')\n        show.replace_with(no)\n        assert soup.decode() == self.document_for(\n            \"<p>There's  business like <b>no</b> business</p>\"\n        )\n\n        assert show.parent == None\n        assert no.parent == soup.p\n        assert no.next_element == \"no\"\n        assert no.next_sibling == \" business\"\n\n    def test_replace_with_errors(self):\n        # Can't replace a tag that's not part of a tree.\n        a_tag = Tag(name=\"a\")\n        with pytest.raises(ValueError):\n            a_tag.replace_with(\"won't work\")\n\n        # Can't replace a tag with its parent.\n        a_tag = self.soup(\"<a><b></b></a>\").a\n        with pytest.raises(ValueError):\n            a_tag.b.replace_with(a_tag)\n\n        # Or with a list that includes its parent.\n        with pytest.raises(ValueError):\n            a_tag.b.replace_with(\"string1\", a_tag, \"string2\")\n        \n    def test_replace_with_multiple(self):\n        data = \"<a><b></b><c></c></a>\"\n        soup = self.soup(data)\n        d_tag = soup.new_tag(\"d\")\n        d_tag.string = \"Text In D Tag\"\n        e_tag = soup.new_tag(\"e\")\n        f_tag = soup.new_tag(\"f\")\n        a_string = \"Random Text\"\n        soup.c.replace_with(d_tag, e_tag, a_string, f_tag)\n        assert soup.decode() == \"<a><b></b><d>Text In D Tag</d><e></e>Random Text<f></f></a>\"\n        assert soup.b.next_element == d_tag\n        assert d_tag.string.next_element==e_tag\n        assert e_tag.next_element.string == a_string\n        assert e_tag.next_element.next_element == f_tag\n        \n    def test_replace_first_child(self):\n        data = \"<a><b></b><c></c></a>\"\n        soup = self.soup(data)\n        soup.b.replace_with(soup.c)\n        assert \"<a><c></c></a>\" == soup.decode()\n\n    def test_replace_last_child(self):\n        data = \"<a><b></b><c></c></a>\"\n        soup = self.soup(data)\n        soup.c.replace_with(soup.b)\n        assert \"<a><b></b></a>\" == soup.decode()\n\n    def test_nested_tag_replace_with(self):\n        soup = self.soup(\n            \"\"\"<a>We<b>reserve<c>the</c><d>right</d></b></a><e>to<f>refuse</f><g>service</g></e>\"\"\")\n\n        # Replace the entire <b> tag and its contents (\"reserve the\n        # right\") with the <f> tag (\"refuse\").\n        remove_tag = soup.b\n        move_tag = soup.f\n        remove_tag.replace_with(move_tag)\n\n        assert soup.decode() == self.document_for(\n            \"<a>We<f>refuse</f></a><e>to<g>service</g></e>\"\n        )\n\n        # The <b> tag is now an orphan.\n        assert remove_tag.parent == None\n        assert remove_tag.find(string=\"right\").next_element == None\n        assert remove_tag.previous_element == None\n        assert remove_tag.next_sibling == None\n        assert remove_tag.previous_sibling == None\n\n        # The <f> tag is now connected to the <a> tag.\n        assert move_tag.parent == soup.a\n        assert move_tag.previous_element == \"We\"\n        assert move_tag.next_element.next_element == soup.e\n        assert move_tag.next_sibling == None\n\n        # The gap where the <f> tag used to be has been mended, and\n        # the word \"to\" is now connected to the <g> tag.\n        to_text = soup.find(string=\"to\")\n        g_tag = soup.g\n        assert to_text.next_element == g_tag\n        assert to_text.next_sibling == g_tag\n        assert g_tag.previous_element == to_text\n        assert g_tag.previous_sibling == to_text\n\n    def test_unwrap(self):\n        tree = self.soup(\"\"\"\n            <p>Unneeded <em>formatting</em> is unneeded</p>\n            \"\"\")\n        tree.em.unwrap()\n        assert tree.em == None\n        assert tree.p.text == \"Unneeded formatting is unneeded\"\n\n    def test_wrap(self):\n        soup = self.soup(\"I wish I was bold.\")\n        value = soup.string.wrap(soup.new_tag(\"b\"))\n        assert value.decode() == \"<b>I wish I was bold.</b>\"\n        assert soup.decode() == self.document_for(\"<b>I wish I was bold.</b>\")\n\n    def test_wrap_extracts_tag_from_elsewhere(self):\n        soup = self.soup(\"<b></b>I wish I was bold.\")\n        soup.b.next_sibling.wrap(soup.b)\n        assert soup.decode() == self.document_for(\"<b>I wish I was bold.</b>\")\n\n    def test_wrap_puts_new_contents_at_the_end(self):\n        soup = self.soup(\"<b>I like being bold.</b>I wish I was bold.\")\n        soup.b.next_sibling.wrap(soup.b)\n        assert 2 == len(soup.b.contents)\n        assert soup.decode() == self.document_for(\n            \"<b>I like being bold.I wish I was bold.</b>\"\n        )\n\n    def test_extract(self):\n        soup = self.soup(\n            '<html><body>Some content. <div id=\"nav\">Nav crap</div> More content.</body></html>')\n\n        assert len(soup.body.contents) == 3\n        extracted = soup.find(id=\"nav\").extract()\n\n        assert soup.decode() == \"<html><body>Some content.  More content.</body></html>\"\n        assert extracted.decode() == '<div id=\"nav\">Nav crap</div>'\n\n        # The extracted tag is now an orphan.\n        assert len(soup.body.contents) == 2\n        assert extracted.parent == None\n        assert extracted.previous_element == None\n        assert extracted.next_element.next_element == None\n\n        # The gap where the extracted tag used to be has been mended.\n        content_1 = soup.find(string=\"Some content. \")\n        content_2 = soup.find(string=\" More content.\")\n        assert content_1.next_element == content_2\n        assert content_1.next_sibling == content_2\n        assert content_2.previous_element == content_1\n        assert content_2.previous_sibling == content_1\n\n    def test_extract_distinguishes_between_identical_strings(self):\n        soup = self.soup(\"<a>foo</a><b>bar</b>\")\n        foo_1 = soup.a.string\n        bar_1 = soup.b.string\n        foo_2 = soup.new_string(\"foo\")\n        bar_2 = soup.new_string(\"bar\")\n        soup.a.append(foo_2)\n        soup.b.append(bar_2)\n\n        # Now there are two identical strings in the <a> tag, and two\n        # in the <b> tag. Let's remove the first \"foo\" and the second\n        # \"bar\".\n        foo_1.extract()\n        bar_2.extract()\n        assert foo_2 == soup.a.string\n        assert bar_2 == soup.b.string\n\n    def test_extract_multiples_of_same_tag(self):\n        soup = self.soup(\"\"\"\n<html>\n<head>\n<script>foo</script>\n</head>\n<body>\n <script>bar</script>\n <a></a>\n</body>\n<script>baz</script>\n</html>\"\"\")\n        [soup.script.extract() for i in soup.find_all(\"script\")]\n        assert \"<body>\\n\\n<a></a>\\n</body>\" == str(soup.body)\n\n\n    def test_extract_works_when_element_is_surrounded_by_identical_strings(self):\n        soup = self.soup(\n '<html>\\n'\n '<body>hi</body>\\n'\n '</html>')\n        soup.find('body').extract()\n        assert None == soup.find('body')\n\n\n    def test_clear(self):\n        \"\"\"Tag.clear()\"\"\"\n        soup = self.soup(\"<p><a>String <em>Italicized</em></a> and another</p>\")\n        # clear using extract()\n        a = soup.a\n        soup.p.clear()\n        assert len(soup.p.contents) == 0\n        assert hasattr(a, \"contents\")\n\n        # clear using decompose()\n        em = a.em\n        a.clear(decompose=True)\n        assert 0 == len(em.contents)\n\n       \n    def test_decompose(self):\n        # Test PageElement.decompose() and PageElement.decomposed\n        soup = self.soup(\"<p><a>String <em>Italicized</em></a></p><p>Another para</p>\")\n        p1, p2 = soup.find_all('p')\n        a = p1.a\n        text = p1.em.string\n        for i in [p1, p2, a, text]:\n            assert False == i.decomposed\n\n        # This sets p1 and everything beneath it to decomposed.\n        p1.decompose()\n        for i in [p1, a, text]:\n            assert True == i.decomposed\n        # p2 is unaffected.\n        assert False == p2.decomposed\n            \n    def test_string_set(self):\n        \"\"\"Tag.string = 'string'\"\"\"\n        soup = self.soup(\"<a></a> <b><c></c></b>\")\n        soup.a.string = \"foo\"\n        assert soup.a.contents == [\"foo\"]\n        soup.b.string = \"bar\"\n        assert soup.b.contents == [\"bar\"]\n\n    def test_string_set_does_not_affect_original_string(self):\n        soup = self.soup(\"<a><b>foo</b><c>bar</c>\")\n        soup.b.string = soup.c.string\n        assert soup.a.encode() == b\"<a><b>bar</b><c>bar</c></a>\"\n\n    def test_set_string_preserves_class_of_string(self):\n        soup = self.soup(\"<a></a>\")\n        cdata = CData(\"foo\")\n        soup.a.string = cdata\n        assert isinstance(soup.a.string, CData)\n\n\nclass TestDeprecatedArguments(SoupTest):\n\n    @pytest.mark.parametrize(\n        \"method_name\", [\n            \"find\", \"find_all\", \"find_parent\", \"find_parents\",\n            \"find_next\", \"find_all_next\", \"find_previous\",\n            \"find_all_previous\", \"find_next_sibling\", \"find_next_siblings\",\n            \"find_previous_sibling\", \"find_previous_siblings\",\n        ]\n    )\n    def test_find_type_method_string(self, method_name):\n        soup = self.soup(\"<a>some</a><b>markup</b>\")\n        method = getattr(soup.b, method_name)\n        with warnings.catch_warnings(record=True) as w:\n            method(text='markup')\n            [warning] = w\n            assert warning.filename == __file__\n            msg = str(warning.message)\n            assert msg == \"The 'text' argument to find()-type methods is deprecated. Use 'string' instead.\"\n\n    def test_soupstrainer_constructor_string(self):\n        with warnings.catch_warnings(record=True) as w:\n            strainer = SoupStrainer(text=\"text\")\n            assert strainer.text == 'text'\n            [warning] = w\n            msg = str(warning.message)\n            assert warning.filename == __file__\n            assert msg == \"The 'text' argument to the SoupStrainer constructor is deprecated. Use 'string' instead.\"\n\n"},"hash":"Mf51IuxsZp"}