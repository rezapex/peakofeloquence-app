{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:certifi:core.py","body":"\"\"\"\ncertifi.py\n~~~~~~~~~~\n\nThis module returns the installation location of cacert.pem or its contents.\n\"\"\"\nimport sys\n\n\nif sys.version_info >= (3, 11):\n\n    from importlib.resources import as_file, files\n\n    _CACERT_CTX = None\n    _CACERT_PATH = None\n\n    def where() -> str:\n        # This is slightly terrible, but we want to delay extracting the file\n        # in cases where we're inside of a zipimport situation until someone\n        # actually calls where(), but we don't want to re-extract the file\n        # on every call of where(), so we'll do it once then store it in a\n        # global variable.\n        global _CACERT_CTX\n        global _CACERT_PATH\n        if _CACERT_PATH is None:\n            # This is slightly janky, the importlib.resources API wants you to\n            # manage the cleanup of this file, so it doesn't actually return a\n            # path, it returns a context manager that will give you the path\n            # when you enter it and will do any cleanup when you leave it. In\n            # the common case of not needing a temporary file, it will just\n            # return the file system location and the __exit__() is a no-op.\n            #\n            # We also have to hold onto the actual context manager, because\n            # it will do the cleanup whenever it gets garbage collected, so\n            # we will also store that at the global level as well.\n            _CACERT_CTX = as_file(files(\"pip._vendor.certifi\").joinpath(\"cacert.pem\"))\n            _CACERT_PATH = str(_CACERT_CTX.__enter__())\n\n        return _CACERT_PATH\n\n    def contents() -> str:\n        return files(\"pip._vendor.certifi\").joinpath(\"cacert.pem\").read_text(encoding=\"ascii\")\n\nelif sys.version_info >= (3, 7):\n\n    from importlib.resources import path as get_path, read_text\n\n    _CACERT_CTX = None\n    _CACERT_PATH = None\n\n    def where() -> str:\n        # This is slightly terrible, but we want to delay extracting the\n        # file in cases where we're inside of a zipimport situation until\n        # someone actually calls where(), but we don't want to re-extract\n        # the file on every call of where(), so we'll do it once then store\n        # it in a global variable.\n        global _CACERT_CTX\n        global _CACERT_PATH\n        if _CACERT_PATH is None:\n            # This is slightly janky, the importlib.resources API wants you\n            # to manage the cleanup of this file, so it doesn't actually\n            # return a path, it returns a context manager that will give\n            # you the path when you enter it and will do any cleanup when\n            # you leave it. In the common case of not needing a temporary\n            # file, it will just return the file system location and the\n            # __exit__() is a no-op.\n            #\n            # We also have to hold onto the actual context manager, because\n            # it will do the cleanup whenever it gets garbage collected, so\n            # we will also store that at the global level as well.\n            _CACERT_CTX = get_path(\"pip._vendor.certifi\", \"cacert.pem\")\n            _CACERT_PATH = str(_CACERT_CTX.__enter__())\n\n        return _CACERT_PATH\n\n    def contents() -> str:\n        return read_text(\"pip._vendor.certifi\", \"cacert.pem\", encoding=\"ascii\")\n\nelse:\n    import os\n    import types\n    from typing import Union\n\n    Package = Union[types.ModuleType, str]\n    Resource = Union[str, \"os.PathLike\"]\n\n    # This fallback will work for Python versions prior to 3.7 that lack the\n    # importlib.resources module but relies on the existing `where` function\n    # so won't address issues with environments like PyOxidizer that don't set\n    # __file__ on modules.\n    def read_text(\n        package: Package,\n        resource: Resource,\n        encoding: str = 'utf-8',\n        errors: str = 'strict'\n    ) -> str:\n        with open(where(), encoding=encoding) as data:\n            return data.read()\n\n    # If we don't have importlib.resources, then we will just do the old logic\n    # of assuming we're on the filesystem and munge the path directly.\n    def where() -> str:\n        f = os.path.dirname(__file__)\n\n        return os.path.join(f, \"cacert.pem\")\n\n    def contents() -> str:\n        return read_text(\"pip._vendor.certifi\", \"cacert.pem\", encoding=\"ascii\")\n"},"hash":"g1veBvnuwM"}