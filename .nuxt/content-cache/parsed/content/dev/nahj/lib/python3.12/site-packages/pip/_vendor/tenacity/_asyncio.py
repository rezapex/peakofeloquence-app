{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:tenacity:_asyncio.py","body":"# Copyright 2016 Ã‰tienne Bersac\n# Copyright 2016 Julien Danjou\n# Copyright 2016 Joshua Harlow\n# Copyright 2013-2014 Ray Holder\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport functools\nimport sys\nimport typing as t\nfrom asyncio import sleep\n\nfrom pip._vendor.tenacity import AttemptManager\nfrom pip._vendor.tenacity import BaseRetrying\nfrom pip._vendor.tenacity import DoAttempt\nfrom pip._vendor.tenacity import DoSleep\nfrom pip._vendor.tenacity import RetryCallState\n\nWrappedFnReturnT = t.TypeVar(\"WrappedFnReturnT\")\nWrappedFn = t.TypeVar(\"WrappedFn\", bound=t.Callable[..., t.Awaitable[t.Any]])\n\n\nclass AsyncRetrying(BaseRetrying):\n    sleep: t.Callable[[float], t.Awaitable[t.Any]]\n\n    def __init__(self, sleep: t.Callable[[float], t.Awaitable[t.Any]] = sleep, **kwargs: t.Any) -> None:\n        super().__init__(**kwargs)\n        self.sleep = sleep\n\n    async def __call__(  # type: ignore[override]\n        self, fn: WrappedFn, *args: t.Any, **kwargs: t.Any\n    ) -> WrappedFnReturnT:\n        self.begin()\n\n        retry_state = RetryCallState(retry_object=self, fn=fn, args=args, kwargs=kwargs)\n        while True:\n            do = self.iter(retry_state=retry_state)\n            if isinstance(do, DoAttempt):\n                try:\n                    result = await fn(*args, **kwargs)\n                except BaseException:  # noqa: B902\n                    retry_state.set_exception(sys.exc_info())  # type: ignore[arg-type]\n                else:\n                    retry_state.set_result(result)\n            elif isinstance(do, DoSleep):\n                retry_state.prepare_for_next_attempt()\n                await self.sleep(do)\n            else:\n                return do  # type: ignore[no-any-return]\n\n    def __iter__(self) -> t.Generator[AttemptManager, None, None]:\n        raise TypeError(\"AsyncRetrying object is not iterable\")\n\n    def __aiter__(self) -> \"AsyncRetrying\":\n        self.begin()\n        self._retry_state = RetryCallState(self, fn=None, args=(), kwargs={})\n        return self\n\n    async def __anext__(self) -> AttemptManager:\n        while True:\n            do = self.iter(retry_state=self._retry_state)\n            if do is None:\n                raise StopAsyncIteration\n            elif isinstance(do, DoAttempt):\n                return AttemptManager(retry_state=self._retry_state)\n            elif isinstance(do, DoSleep):\n                self._retry_state.prepare_for_next_attempt()\n                await self.sleep(do)\n            else:\n                raise StopAsyncIteration\n\n    def wraps(self, fn: WrappedFn) -> WrappedFn:\n        fn = super().wraps(fn)\n        # Ensure wrapper is recognized as a coroutine function.\n\n        @functools.wraps(fn)\n        async def async_wrapped(*args: t.Any, **kwargs: t.Any) -> t.Any:\n            return await fn(*args, **kwargs)\n\n        # Preserve attributes\n        async_wrapped.retry = fn.retry  # type: ignore[attr-defined]\n        async_wrapped.retry_with = fn.retry_with  # type: ignore[attr-defined]\n\n        return async_wrapped  # type: ignore[return-value]\n"},"hash":"1TErymHpIx"}