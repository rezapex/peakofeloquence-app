{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:bs4:builder:_lxml.py","body":"# Use of this source code is governed by the MIT license.\n__license__ = \"MIT\"\n\n__all__ = [\n    'LXMLTreeBuilderForXML',\n    'LXMLTreeBuilder',\n    ]\n\ntry:\n    from collections.abc import Callable # Python 3.6\nexcept ImportError as e:\n    from collections import Callable\n\nfrom io import BytesIO\nfrom io import StringIO\nfrom lxml import etree\nfrom bs4.element import (\n    Comment,\n    Doctype,\n    NamespacedAttribute,\n    ProcessingInstruction,\n    XMLProcessingInstruction,\n)\nfrom bs4.builder import (\n    DetectsXMLParsedAsHTML,\n    FAST,\n    HTML,\n    HTMLTreeBuilder,\n    PERMISSIVE,\n    ParserRejectedMarkup,\n    TreeBuilder,\n    XML)\nfrom bs4.dammit import EncodingDetector\n\nLXML = 'lxml'\n\ndef _invert(d):\n    \"Invert a dictionary.\"\n    return dict((v,k) for k, v in list(d.items()))\n\nclass LXMLTreeBuilderForXML(TreeBuilder):\n    DEFAULT_PARSER_CLASS = etree.XMLParser\n\n    is_xml = True\n    processing_instruction_class = XMLProcessingInstruction\n\n    NAME = \"lxml-xml\"\n    ALTERNATE_NAMES = [\"xml\"]\n\n    # Well, it's permissive by XML parser standards.\n    features = [NAME, LXML, XML, FAST, PERMISSIVE]\n\n    CHUNK_SIZE = 512\n\n    # This namespace mapping is specified in the XML Namespace\n    # standard.\n    DEFAULT_NSMAPS = dict(xml='http://www.w3.org/XML/1998/namespace')\n\n    DEFAULT_NSMAPS_INVERTED = _invert(DEFAULT_NSMAPS)\n\n    # NOTE: If we parsed Element objects and looked at .sourceline,\n    # we'd be able to see the line numbers from the original document.\n    # But instead we build an XMLParser or HTMLParser object to serve\n    # as the target of parse messages, and those messages don't include\n    # line numbers.\n    # See: https://bugs.launchpad.net/lxml/+bug/1846906\n    \n    def initialize_soup(self, soup):\n        \"\"\"Let the BeautifulSoup object know about the standard namespace\n        mapping.\n\n        :param soup: A `BeautifulSoup`.\n        \"\"\"\n        super(LXMLTreeBuilderForXML, self).initialize_soup(soup)\n        self._register_namespaces(self.DEFAULT_NSMAPS)\n\n    def _register_namespaces(self, mapping):\n        \"\"\"Let the BeautifulSoup object know about namespaces encountered\n        while parsing the document.\n\n        This might be useful later on when creating CSS selectors.\n\n        This will track (almost) all namespaces, even ones that were\n        only in scope for part of the document. If two namespaces have\n        the same prefix, only the first one encountered will be\n        tracked. Un-prefixed namespaces are not tracked.\n\n        :param mapping: A dictionary mapping namespace prefixes to URIs.\n        \"\"\"\n        for key, value in list(mapping.items()):\n            # This is 'if key' and not 'if key is not None' because we\n            # don't track un-prefixed namespaces. Soupselect will\n            # treat an un-prefixed namespace as the default, which\n            # causes confusion in some cases.\n            if key and key not in self.soup._namespaces:\n                # Let the BeautifulSoup object know about a new namespace.\n                # If there are multiple namespaces defined with the same\n                # prefix, the first one in the document takes precedence.\n                self.soup._namespaces[key] = value\n                \n    def default_parser(self, encoding):\n        \"\"\"Find the default parser for the given encoding.\n\n        :param encoding: A string.\n        :return: Either a parser object or a class, which\n          will be instantiated with default arguments.\n        \"\"\"\n        if self._default_parser is not None:\n            return self._default_parser\n        return etree.XMLParser(\n            target=self, strip_cdata=False, recover=True, encoding=encoding)\n\n    def parser_for(self, encoding):\n        \"\"\"Instantiate an appropriate parser for the given encoding.\n\n        :param encoding: A string.\n        :return: A parser object such as an `etree.XMLParser`.\n        \"\"\"\n        # Use the default parser.\n        parser = self.default_parser(encoding)\n\n        if isinstance(parser, Callable):\n            # Instantiate the parser with default arguments\n            parser = parser(\n                target=self, strip_cdata=False, recover=True, encoding=encoding\n            )\n        return parser\n\n    def __init__(self, parser=None, empty_element_tags=None, **kwargs):\n        # TODO: Issue a warning if parser is present but not a\n        # callable, since that means there's no way to create new\n        # parsers for different encodings.\n        self._default_parser = parser\n        if empty_element_tags is not None:\n            self.empty_element_tags = set(empty_element_tags)\n        self.soup = None\n        self.nsmaps = [self.DEFAULT_NSMAPS_INVERTED]\n        self.active_namespace_prefixes = [dict(self.DEFAULT_NSMAPS)]\n        super(LXMLTreeBuilderForXML, self).__init__(**kwargs)\n        \n    def _getNsTag(self, tag):\n        # Split the namespace URL out of a fully-qualified lxml tag\n        # name. Copied from lxml's src/lxml/sax.py.\n        if tag[0] == '{':\n            return tuple(tag[1:].split('}', 1))\n        else:\n            return (None, tag)\n\n    def prepare_markup(self, markup, user_specified_encoding=None,\n                       exclude_encodings=None,\n                       document_declared_encoding=None):\n        \"\"\"Run any preliminary steps necessary to make incoming markup\n        acceptable to the parser.\n\n        lxml really wants to get a bytestring and convert it to\n        Unicode itself. So instead of using UnicodeDammit to convert\n        the bytestring to Unicode using different encodings, this\n        implementation uses EncodingDetector to iterate over the\n        encodings, and tell lxml to try to parse the document as each\n        one in turn.\n\n        :param markup: Some markup -- hopefully a bytestring.\n        :param user_specified_encoding: The user asked to try this encoding.\n        :param document_declared_encoding: The markup itself claims to be\n            in this encoding.\n        :param exclude_encodings: The user asked _not_ to try any of\n            these encodings.\n\n        :yield: A series of 4-tuples:\n         (markup, encoding, declared encoding,\n          has undergone character replacement)\n\n         Each 4-tuple represents a strategy for converting the\n         document to Unicode and parsing it. Each strategy will be tried \n         in turn.\n        \"\"\"\n        is_html = not self.is_xml\n        if is_html:\n            self.processing_instruction_class = ProcessingInstruction\n            # We're in HTML mode, so if we're given XML, that's worth\n            # noting.\n            DetectsXMLParsedAsHTML.warn_if_markup_looks_like_xml(\n                markup, stacklevel=3\n            )\n        else:\n            self.processing_instruction_class = XMLProcessingInstruction\n\n        if isinstance(markup, str):\n            # We were given Unicode. Maybe lxml can parse Unicode on\n            # this system?\n\n            # TODO: This is a workaround for\n            # https://bugs.launchpad.net/lxml/+bug/1948551.\n            # We can remove it once the upstream issue is fixed.\n            if len(markup) > 0 and markup[0] == u'\\N{BYTE ORDER MARK}':\n                markup = markup[1:]\n            yield markup, None, document_declared_encoding, False\n\n        if isinstance(markup, str):\n            # No, apparently not. Convert the Unicode to UTF-8 and\n            # tell lxml to parse it as UTF-8.\n            yield (markup.encode(\"utf8\"), \"utf8\",\n                   document_declared_encoding, False)\n\n        # This was provided by the end-user; treat it as a known\n        # definite encoding per the algorithm laid out in the HTML5\n        # spec.  (See the EncodingDetector class for details.)\n        known_definite_encodings = [user_specified_encoding]\n\n        # This was found in the document; treat it as a slightly lower-priority\n        # user encoding.\n        user_encodings = [document_declared_encoding]\n        detector = EncodingDetector(\n            markup, known_definite_encodings=known_definite_encodings,\n            user_encodings=user_encodings, is_html=is_html,\n            exclude_encodings=exclude_encodings\n        )\n        for encoding in detector.encodings:\n            yield (detector.markup, encoding, document_declared_encoding, False)\n\n    def feed(self, markup):\n        if isinstance(markup, bytes):\n            markup = BytesIO(markup)\n        elif isinstance(markup, str):\n            markup = StringIO(markup)\n\n        # Call feed() at least once, even if the markup is empty,\n        # or the parser won't be initialized.\n        data = markup.read(self.CHUNK_SIZE)\n        try:\n            self.parser = self.parser_for(self.soup.original_encoding)\n            self.parser.feed(data)\n            while len(data) != 0:\n                # Now call feed() on the rest of the data, chunk by chunk.\n                data = markup.read(self.CHUNK_SIZE)\n                if len(data) != 0:\n                    self.parser.feed(data)\n            self.parser.close()\n        except (UnicodeDecodeError, LookupError, etree.ParserError) as e:\n            raise ParserRejectedMarkup(e)\n\n    def close(self):\n        self.nsmaps = [self.DEFAULT_NSMAPS_INVERTED]\n\n    def start(self, name, attrs, nsmap={}):\n        # Make sure attrs is a mutable dict--lxml may send an immutable dictproxy.\n        attrs = dict(attrs)\n        nsprefix = None\n        # Invert each namespace map as it comes in.\n        if len(nsmap) == 0 and len(self.nsmaps) > 1:\n                # There are no new namespaces for this tag, but\n                # non-default namespaces are in play, so we need a\n                # separate tag stack to know when they end.\n                self.nsmaps.append(None)\n        elif len(nsmap) > 0:\n            # A new namespace mapping has come into play.\n\n            # First, Let the BeautifulSoup object know about it.\n            self._register_namespaces(nsmap)\n\n            # Then, add it to our running list of inverted namespace\n            # mappings.\n            self.nsmaps.append(_invert(nsmap))\n\n            # The currently active namespace prefixes have\n            # changed. Calculate the new mapping so it can be stored\n            # with all Tag objects created while these prefixes are in\n            # scope.\n            current_mapping = dict(self.active_namespace_prefixes[-1])\n            current_mapping.update(nsmap)\n\n            # We should not track un-prefixed namespaces as we can only hold one\n            # and it will be recognized as the default namespace by soupsieve,\n            # which may be confusing in some situations.\n            if '' in current_mapping:\n                del current_mapping['']\n            self.active_namespace_prefixes.append(current_mapping)\n            \n            # Also treat the namespace mapping as a set of attributes on the\n            # tag, so we can recreate it later.\n            attrs = attrs.copy()\n            for prefix, namespace in list(nsmap.items()):\n                attribute = NamespacedAttribute(\n                    \"xmlns\", prefix, \"http://www.w3.org/2000/xmlns/\")\n                attrs[attribute] = namespace\n\n        # Namespaces are in play. Find any attributes that came in\n        # from lxml with namespaces attached to their names, and\n        # turn then into NamespacedAttribute objects.\n        new_attrs = {}\n        for attr, value in list(attrs.items()):\n            namespace, attr = self._getNsTag(attr)\n            if namespace is None:\n                new_attrs[attr] = value\n            else:\n                nsprefix = self._prefix_for_namespace(namespace)\n                attr = NamespacedAttribute(nsprefix, attr, namespace)\n                new_attrs[attr] = value\n        attrs = new_attrs\n\n        namespace, name = self._getNsTag(name)\n        nsprefix = self._prefix_for_namespace(namespace)\n        self.soup.handle_starttag(\n            name, namespace, nsprefix, attrs,\n            namespaces=self.active_namespace_prefixes[-1]\n        )\n        \n    def _prefix_for_namespace(self, namespace):\n        \"\"\"Find the currently active prefix for the given namespace.\"\"\"\n        if namespace is None:\n            return None\n        for inverted_nsmap in reversed(self.nsmaps):\n            if inverted_nsmap is not None and namespace in inverted_nsmap:\n                return inverted_nsmap[namespace]\n        return None\n\n    def end(self, name):\n        self.soup.endData()\n        completed_tag = self.soup.tagStack[-1]\n        namespace, name = self._getNsTag(name)\n        nsprefix = None\n        if namespace is not None:\n            for inverted_nsmap in reversed(self.nsmaps):\n                if inverted_nsmap is not None and namespace in inverted_nsmap:\n                    nsprefix = inverted_nsmap[namespace]\n                    break\n        self.soup.handle_endtag(name, nsprefix)\n        if len(self.nsmaps) > 1:\n            # This tag, or one of its parents, introduced a namespace\n            # mapping, so pop it off the stack.\n            out_of_scope_nsmap = self.nsmaps.pop()\n\n            if out_of_scope_nsmap is not None:\n                # This tag introduced a namespace mapping which is no\n                # longer in scope. Recalculate the currently active\n                # namespace prefixes.\n                self.active_namespace_prefixes.pop()\n            \n    def pi(self, target, data):\n        self.soup.endData()\n        data = target + ' ' + data\n        self.soup.handle_data(data)\n        self.soup.endData(self.processing_instruction_class)\n        \n    def data(self, content):\n        self.soup.handle_data(content)\n\n    def doctype(self, name, pubid, system):\n        self.soup.endData()\n        doctype = Doctype.for_name_and_ids(name, pubid, system)\n        self.soup.object_was_parsed(doctype)\n\n    def comment(self, content):\n        \"Handle comments as Comment objects.\"\n        self.soup.endData()\n        self.soup.handle_data(content)\n        self.soup.endData(Comment)\n\n    def test_fragment_to_document(self, fragment):\n        \"\"\"See `TreeBuilder`.\"\"\"\n        return '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n%s' % fragment\n\n\nclass LXMLTreeBuilder(HTMLTreeBuilder, LXMLTreeBuilderForXML):\n\n    NAME = LXML\n    ALTERNATE_NAMES = [\"lxml-html\"]\n\n    features = ALTERNATE_NAMES + [NAME, HTML, FAST, PERMISSIVE]\n    is_xml = False\n    processing_instruction_class = ProcessingInstruction\n\n    def default_parser(self, encoding):\n        return etree.HTMLParser\n\n    def feed(self, markup):\n        encoding = self.soup.original_encoding\n        try:\n            self.parser = self.parser_for(encoding)\n            self.parser.feed(markup)\n            self.parser.close()\n        except (UnicodeDecodeError, LookupError, etree.ParserError) as e:\n            raise ParserRejectedMarkup(e)\n\n\n    def test_fragment_to_document(self, fragment):\n        \"\"\"See `TreeBuilder`.\"\"\"\n        return '<html><body>%s</body></html>' % fragment\n"},"hash":"CNBSEN4sdb"}