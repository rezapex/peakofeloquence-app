{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:locations:_sysconfig.py","body":"import logging\nimport os\nimport sys\nimport sysconfig\nimport typing\n\nfrom pip._internal.exceptions import InvalidSchemeCombination, UserInstallationInvalid\nfrom pip._internal.models.scheme import SCHEME_KEYS, Scheme\nfrom pip._internal.utils.virtualenv import running_under_virtualenv\n\nfrom .base import change_root, get_major_minor_version, is_osx_framework\n\nlogger = logging.getLogger(__name__)\n\n\n# Notes on _infer_* functions.\n# Unfortunately ``get_default_scheme()`` didn't exist before 3.10, so there's no\n# way to ask things like \"what is the '_prefix' scheme on this platform\". These\n# functions try to answer that with some heuristics while accounting for ad-hoc\n# platforms not covered by CPython's default sysconfig implementation. If the\n# ad-hoc implementation does not fully implement sysconfig, we'll fall back to\n# a POSIX scheme.\n\n_AVAILABLE_SCHEMES = set(sysconfig.get_scheme_names())\n\n_PREFERRED_SCHEME_API = getattr(sysconfig, \"get_preferred_scheme\", None)\n\n\ndef _should_use_osx_framework_prefix() -> bool:\n    \"\"\"Check for Apple's ``osx_framework_library`` scheme.\n\n    Python distributed by Apple's Command Line Tools has this special scheme\n    that's used when:\n\n    * This is a framework build.\n    * We are installing into the system prefix.\n\n    This does not account for ``pip install --prefix`` (also means we're not\n    installing to the system prefix), which should use ``posix_prefix``, but\n    logic here means ``_infer_prefix()`` outputs ``osx_framework_library``. But\n    since ``prefix`` is not available for ``sysconfig.get_default_scheme()``,\n    which is the stdlib replacement for ``_infer_prefix()``, presumably Apple\n    wouldn't be able to magically switch between ``osx_framework_library`` and\n    ``posix_prefix``. ``_infer_prefix()`` returning ``osx_framework_library``\n    means its behavior is consistent whether we use the stdlib implementation\n    or our own, and we deal with this special case in ``get_scheme()`` instead.\n    \"\"\"\n    return (\n        \"osx_framework_library\" in _AVAILABLE_SCHEMES\n        and not running_under_virtualenv()\n        and is_osx_framework()\n    )\n\n\ndef _infer_prefix() -> str:\n    \"\"\"Try to find a prefix scheme for the current platform.\n\n    This tries:\n\n    * A special ``osx_framework_library`` for Python distributed by Apple's\n      Command Line Tools, when not running in a virtual environment.\n    * Implementation + OS, used by PyPy on Windows (``pypy_nt``).\n    * Implementation without OS, used by PyPy on POSIX (``pypy``).\n    * OS + \"prefix\", used by CPython on POSIX (``posix_prefix``).\n    * Just the OS name, used by CPython on Windows (``nt``).\n\n    If none of the above works, fall back to ``posix_prefix``.\n    \"\"\"\n    if _PREFERRED_SCHEME_API:\n        return _PREFERRED_SCHEME_API(\"prefix\")\n    if _should_use_osx_framework_prefix():\n        return \"osx_framework_library\"\n    implementation_suffixed = f\"{sys.implementation.name}_{os.name}\"\n    if implementation_suffixed in _AVAILABLE_SCHEMES:\n        return implementation_suffixed\n    if sys.implementation.name in _AVAILABLE_SCHEMES:\n        return sys.implementation.name\n    suffixed = f\"{os.name}_prefix\"\n    if suffixed in _AVAILABLE_SCHEMES:\n        return suffixed\n    if os.name in _AVAILABLE_SCHEMES:  # On Windows, prefx is just called \"nt\".\n        return os.name\n    return \"posix_prefix\"\n\n\ndef _infer_user() -> str:\n    \"\"\"Try to find a user scheme for the current platform.\"\"\"\n    if _PREFERRED_SCHEME_API:\n        return _PREFERRED_SCHEME_API(\"user\")\n    if is_osx_framework() and not running_under_virtualenv():\n        suffixed = \"osx_framework_user\"\n    else:\n        suffixed = f\"{os.name}_user\"\n    if suffixed in _AVAILABLE_SCHEMES:\n        return suffixed\n    if \"posix_user\" not in _AVAILABLE_SCHEMES:  # User scheme unavailable.\n        raise UserInstallationInvalid()\n    return \"posix_user\"\n\n\ndef _infer_home() -> str:\n    \"\"\"Try to find a home for the current platform.\"\"\"\n    if _PREFERRED_SCHEME_API:\n        return _PREFERRED_SCHEME_API(\"home\")\n    suffixed = f\"{os.name}_home\"\n    if suffixed in _AVAILABLE_SCHEMES:\n        return suffixed\n    return \"posix_home\"\n\n\n# Update these keys if the user sets a custom home.\n_HOME_KEYS = [\n    \"installed_base\",\n    \"base\",\n    \"installed_platbase\",\n    \"platbase\",\n    \"prefix\",\n    \"exec_prefix\",\n]\nif sysconfig.get_config_var(\"userbase\") is not None:\n    _HOME_KEYS.append(\"userbase\")\n\n\ndef get_scheme(\n    dist_name: str,\n    user: bool = False,\n    home: typing.Optional[str] = None,\n    root: typing.Optional[str] = None,\n    isolated: bool = False,\n    prefix: typing.Optional[str] = None,\n) -> Scheme:\n    \"\"\"\n    Get the \"scheme\" corresponding to the input parameters.\n\n    :param dist_name: the name of the package to retrieve the scheme for, used\n        in the headers scheme path\n    :param user: indicates to use the \"user\" scheme\n    :param home: indicates to use the \"home\" scheme\n    :param root: root under which other directories are re-based\n    :param isolated: ignored, but kept for distutils compatibility (where\n        this controls whether the user-site pydistutils.cfg is honored)\n    :param prefix: indicates to use the \"prefix\" scheme and provides the\n        base directory for the same\n    \"\"\"\n    if user and prefix:\n        raise InvalidSchemeCombination(\"--user\", \"--prefix\")\n    if home and prefix:\n        raise InvalidSchemeCombination(\"--home\", \"--prefix\")\n\n    if home is not None:\n        scheme_name = _infer_home()\n    elif user:\n        scheme_name = _infer_user()\n    else:\n        scheme_name = _infer_prefix()\n\n    # Special case: When installing into a custom prefix, use posix_prefix\n    # instead of osx_framework_library. See _should_use_osx_framework_prefix()\n    # docstring for details.\n    if prefix is not None and scheme_name == \"osx_framework_library\":\n        scheme_name = \"posix_prefix\"\n\n    if home is not None:\n        variables = {k: home for k in _HOME_KEYS}\n    elif prefix is not None:\n        variables = {k: prefix for k in _HOME_KEYS}\n    else:\n        variables = {}\n\n    paths = sysconfig.get_paths(scheme=scheme_name, vars=variables)\n\n    # Logic here is very arbitrary, we're doing it for compatibility, don't ask.\n    # 1. Pip historically uses a special header path in virtual environments.\n    # 2. If the distribution name is not known, distutils uses 'UNKNOWN'. We\n    #    only do the same when not running in a virtual environment because\n    #    pip's historical header path logic (see point 1) did not do this.\n    if running_under_virtualenv():\n        if user:\n            base = variables.get(\"userbase\", sys.prefix)\n        else:\n            base = variables.get(\"base\", sys.prefix)\n        python_xy = f\"python{get_major_minor_version()}\"\n        paths[\"include\"] = os.path.join(base, \"include\", \"site\", python_xy)\n    elif not dist_name:\n        dist_name = \"UNKNOWN\"\n\n    scheme = Scheme(\n        platlib=paths[\"platlib\"],\n        purelib=paths[\"purelib\"],\n        headers=os.path.join(paths[\"include\"], dist_name),\n        scripts=paths[\"scripts\"],\n        data=paths[\"data\"],\n    )\n    if root is not None:\n        for key in SCHEME_KEYS:\n            value = change_root(root, getattr(scheme, key))\n            setattr(scheme, key, value)\n    return scheme\n\n\ndef get_bin_prefix() -> str:\n    # Forcing to use /usr/local/bin for standard macOS framework installs.\n    if sys.platform[:6] == \"darwin\" and sys.prefix[:16] == \"/System/Library/\":\n        return \"/usr/local/bin\"\n    return sysconfig.get_paths()[\"scripts\"]\n\n\ndef get_purelib() -> str:\n    return sysconfig.get_paths()[\"purelib\"]\n\n\ndef get_platlib() -> str:\n    return sysconfig.get_paths()[\"platlib\"]\n"},"hash":"IJwRqR1Mez"}