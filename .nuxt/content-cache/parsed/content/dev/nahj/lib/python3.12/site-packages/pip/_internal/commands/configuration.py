{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:commands:configuration.py","body":"import logging\nimport os\nimport subprocess\nfrom optparse import Values\nfrom typing import Any, List, Optional\n\nfrom pip._internal.cli.base_command import Command\nfrom pip._internal.cli.status_codes import ERROR, SUCCESS\nfrom pip._internal.configuration import (\n    Configuration,\n    Kind,\n    get_configuration_files,\n    kinds,\n)\nfrom pip._internal.exceptions import PipError\nfrom pip._internal.utils.logging import indent_log\nfrom pip._internal.utils.misc import get_prog, write_output\n\nlogger = logging.getLogger(__name__)\n\n\nclass ConfigurationCommand(Command):\n    \"\"\"\n    Manage local and global configuration.\n\n    Subcommands:\n\n    - list: List the active configuration (or from the file specified)\n    - edit: Edit the configuration file in an editor\n    - get: Get the value associated with command.option\n    - set: Set the command.option=value\n    - unset: Unset the value associated with command.option\n    - debug: List the configuration files and values defined under them\n\n    Configuration keys should be dot separated command and option name,\n    with the special prefix \"global\" affecting any command. For example,\n    \"pip config set global.index-url https://example.org/\" would configure\n    the index url for all commands, but \"pip config set download.timeout 10\"\n    would configure a 10 second timeout only for \"pip download\" commands.\n\n    If none of --user, --global and --site are passed, a virtual\n    environment configuration file is used if one is active and the file\n    exists. Otherwise, all modifications happen to the user file by\n    default.\n    \"\"\"\n\n    ignore_require_venv = True\n    usage = \"\"\"\n        %prog [<file-option>] list\n        %prog [<file-option>] [--editor <editor-path>] edit\n\n        %prog [<file-option>] get command.option\n        %prog [<file-option>] set command.option value\n        %prog [<file-option>] unset command.option\n        %prog [<file-option>] debug\n    \"\"\"\n\n    def add_options(self) -> None:\n        self.cmd_opts.add_option(\n            \"--editor\",\n            dest=\"editor\",\n            action=\"store\",\n            default=None,\n            help=(\n                \"Editor to use to edit the file. Uses VISUAL or EDITOR \"\n                \"environment variables if not provided.\"\n            ),\n        )\n\n        self.cmd_opts.add_option(\n            \"--global\",\n            dest=\"global_file\",\n            action=\"store_true\",\n            default=False,\n            help=\"Use the system-wide configuration file only\",\n        )\n\n        self.cmd_opts.add_option(\n            \"--user\",\n            dest=\"user_file\",\n            action=\"store_true\",\n            default=False,\n            help=\"Use the user configuration file only\",\n        )\n\n        self.cmd_opts.add_option(\n            \"--site\",\n            dest=\"site_file\",\n            action=\"store_true\",\n            default=False,\n            help=\"Use the current environment configuration file only\",\n        )\n\n        self.parser.insert_option_group(0, self.cmd_opts)\n\n    def run(self, options: Values, args: List[str]) -> int:\n        handlers = {\n            \"list\": self.list_values,\n            \"edit\": self.open_in_editor,\n            \"get\": self.get_name,\n            \"set\": self.set_name_value,\n            \"unset\": self.unset_name,\n            \"debug\": self.list_config_values,\n        }\n\n        # Determine action\n        if not args or args[0] not in handlers:\n            logger.error(\n                \"Need an action (%s) to perform.\",\n                \", \".join(sorted(handlers)),\n            )\n            return ERROR\n\n        action = args[0]\n\n        # Determine which configuration files are to be loaded\n        #    Depends on whether the command is modifying.\n        try:\n            load_only = self._determine_file(\n                options, need_value=(action in [\"get\", \"set\", \"unset\", \"edit\"])\n            )\n        except PipError as e:\n            logger.error(e.args[0])\n            return ERROR\n\n        # Load a new configuration\n        self.configuration = Configuration(\n            isolated=options.isolated_mode, load_only=load_only\n        )\n        self.configuration.load()\n\n        # Error handling happens here, not in the action-handlers.\n        try:\n            handlers[action](options, args[1:])\n        except PipError as e:\n            logger.error(e.args[0])\n            return ERROR\n\n        return SUCCESS\n\n    def _determine_file(self, options: Values, need_value: bool) -> Optional[Kind]:\n        file_options = [\n            key\n            for key, value in (\n                (kinds.USER, options.user_file),\n                (kinds.GLOBAL, options.global_file),\n                (kinds.SITE, options.site_file),\n            )\n            if value\n        ]\n\n        if not file_options:\n            if not need_value:\n                return None\n            # Default to user, unless there's a site file.\n            elif any(\n                os.path.exists(site_config_file)\n                for site_config_file in get_configuration_files()[kinds.SITE]\n            ):\n                return kinds.SITE\n            else:\n                return kinds.USER\n        elif len(file_options) == 1:\n            return file_options[0]\n\n        raise PipError(\n            \"Need exactly one file to operate upon \"\n            \"(--user, --site, --global) to perform.\"\n        )\n\n    def list_values(self, options: Values, args: List[str]) -> None:\n        self._get_n_args(args, \"list\", n=0)\n\n        for key, value in sorted(self.configuration.items()):\n            write_output(\"%s=%r\", key, value)\n\n    def get_name(self, options: Values, args: List[str]) -> None:\n        key = self._get_n_args(args, \"get [name]\", n=1)\n        value = self.configuration.get_value(key)\n\n        write_output(\"%s\", value)\n\n    def set_name_value(self, options: Values, args: List[str]) -> None:\n        key, value = self._get_n_args(args, \"set [name] [value]\", n=2)\n        self.configuration.set_value(key, value)\n\n        self._save_configuration()\n\n    def unset_name(self, options: Values, args: List[str]) -> None:\n        key = self._get_n_args(args, \"unset [name]\", n=1)\n        self.configuration.unset_value(key)\n\n        self._save_configuration()\n\n    def list_config_values(self, options: Values, args: List[str]) -> None:\n        \"\"\"List config key-value pairs across different config files\"\"\"\n        self._get_n_args(args, \"debug\", n=0)\n\n        self.print_env_var_values()\n        # Iterate over config files and print if they exist, and the\n        # key-value pairs present in them if they do\n        for variant, files in sorted(self.configuration.iter_config_files()):\n            write_output(\"%s:\", variant)\n            for fname in files:\n                with indent_log():\n                    file_exists = os.path.exists(fname)\n                    write_output(\"%s, exists: %r\", fname, file_exists)\n                    if file_exists:\n                        self.print_config_file_values(variant)\n\n    def print_config_file_values(self, variant: Kind) -> None:\n        \"\"\"Get key-value pairs from the file of a variant\"\"\"\n        for name, value in self.configuration.get_values_in_config(variant).items():\n            with indent_log():\n                write_output(\"%s: %s\", name, value)\n\n    def print_env_var_values(self) -> None:\n        \"\"\"Get key-values pairs present as environment variables\"\"\"\n        write_output(\"%s:\", \"env_var\")\n        with indent_log():\n            for key, value in sorted(self.configuration.get_environ_vars()):\n                env_var = f\"PIP_{key.upper()}\"\n                write_output(\"%s=%r\", env_var, value)\n\n    def open_in_editor(self, options: Values, args: List[str]) -> None:\n        editor = self._determine_editor(options)\n\n        fname = self.configuration.get_file_to_edit()\n        if fname is None:\n            raise PipError(\"Could not determine appropriate file.\")\n        elif '\"' in fname:\n            # This shouldn't happen, unless we see a username like that.\n            # If that happens, we'd appreciate a pull request fixing this.\n            raise PipError(\n                f'Can not open an editor for a file name containing \"\\n{fname}'\n            )\n\n        try:\n            subprocess.check_call(f'{editor} \"{fname}\"', shell=True)\n        except FileNotFoundError as e:\n            if not e.filename:\n                e.filename = editor\n            raise\n        except subprocess.CalledProcessError as e:\n            raise PipError(f\"Editor Subprocess exited with exit code {e.returncode}\")\n\n    def _get_n_args(self, args: List[str], example: str, n: int) -> Any:\n        \"\"\"Helper to make sure the command got the right number of arguments\"\"\"\n        if len(args) != n:\n            msg = (\n                f\"Got unexpected number of arguments, expected {n}. \"\n                f'(example: \"{get_prog()} config {example}\")'\n            )\n            raise PipError(msg)\n\n        if n == 1:\n            return args[0]\n        else:\n            return args\n\n    def _save_configuration(self) -> None:\n        # We successfully ran a modifying command. Need to save the\n        # configuration.\n        try:\n            self.configuration.save()\n        except Exception:\n            logger.exception(\n                \"Unable to save configuration. Please report this as a bug.\"\n            )\n            raise PipError(\"Internal Error.\")\n\n    def _determine_editor(self, options: Values) -> str:\n        if options.editor is not None:\n            return options.editor\n        elif \"VISUAL\" in os.environ:\n            return os.environ[\"VISUAL\"]\n        elif \"EDITOR\" in os.environ:\n            return os.environ[\"EDITOR\"]\n        else:\n            raise PipError(\"Could not determine editor to use.\")\n"},"hash":"1VmOYrhHBz"}