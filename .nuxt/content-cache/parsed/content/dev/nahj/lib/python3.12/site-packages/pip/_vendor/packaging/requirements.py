{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:packaging:requirements.py","body":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport re\nimport string\nimport urllib.parse\nfrom typing import List, Optional as TOptional, Set\n\nfrom pip._vendor.pyparsing import (  # noqa\n    Combine,\n    Literal as L,\n    Optional,\n    ParseException,\n    Regex,\n    Word,\n    ZeroOrMore,\n    originalTextFor,\n    stringEnd,\n    stringStart,\n)\n\nfrom .markers import MARKER_EXPR, Marker\nfrom .specifiers import LegacySpecifier, Specifier, SpecifierSet\n\n\nclass InvalidRequirement(ValueError):\n    \"\"\"\n    An invalid requirement was found, users should refer to PEP 508.\n    \"\"\"\n\n\nALPHANUM = Word(string.ascii_letters + string.digits)\n\nLBRACKET = L(\"[\").suppress()\nRBRACKET = L(\"]\").suppress()\nLPAREN = L(\"(\").suppress()\nRPAREN = L(\")\").suppress()\nCOMMA = L(\",\").suppress()\nSEMICOLON = L(\";\").suppress()\nAT = L(\"@\").suppress()\n\nPUNCTUATION = Word(\"-_.\")\nIDENTIFIER_END = ALPHANUM | (ZeroOrMore(PUNCTUATION) + ALPHANUM)\nIDENTIFIER = Combine(ALPHANUM + ZeroOrMore(IDENTIFIER_END))\n\nNAME = IDENTIFIER(\"name\")\nEXTRA = IDENTIFIER\n\nURI = Regex(r\"[^ ]+\")(\"url\")\nURL = AT + URI\n\nEXTRAS_LIST = EXTRA + ZeroOrMore(COMMA + EXTRA)\nEXTRAS = (LBRACKET + Optional(EXTRAS_LIST) + RBRACKET)(\"extras\")\n\nVERSION_PEP440 = Regex(Specifier._regex_str, re.VERBOSE | re.IGNORECASE)\nVERSION_LEGACY = Regex(LegacySpecifier._regex_str, re.VERBOSE | re.IGNORECASE)\n\nVERSION_ONE = VERSION_PEP440 ^ VERSION_LEGACY\nVERSION_MANY = Combine(\n    VERSION_ONE + ZeroOrMore(COMMA + VERSION_ONE), joinString=\",\", adjacent=False\n)(\"_raw_spec\")\n_VERSION_SPEC = Optional((LPAREN + VERSION_MANY + RPAREN) | VERSION_MANY)\n_VERSION_SPEC.setParseAction(lambda s, l, t: t._raw_spec or \"\")\n\nVERSION_SPEC = originalTextFor(_VERSION_SPEC)(\"specifier\")\nVERSION_SPEC.setParseAction(lambda s, l, t: t[1])\n\nMARKER_EXPR = originalTextFor(MARKER_EXPR())(\"marker\")\nMARKER_EXPR.setParseAction(\n    lambda s, l, t: Marker(s[t._original_start : t._original_end])\n)\nMARKER_SEPARATOR = SEMICOLON\nMARKER = MARKER_SEPARATOR + MARKER_EXPR\n\nVERSION_AND_MARKER = VERSION_SPEC + Optional(MARKER)\nURL_AND_MARKER = URL + Optional(MARKER)\n\nNAMED_REQUIREMENT = NAME + Optional(EXTRAS) + (URL_AND_MARKER | VERSION_AND_MARKER)\n\nREQUIREMENT = stringStart + NAMED_REQUIREMENT + stringEnd\n# pyparsing isn't thread safe during initialization, so we do it eagerly, see\n# issue #104\nREQUIREMENT.parseString(\"x[]\")\n\n\nclass Requirement:\n    \"\"\"Parse a requirement.\n\n    Parse a given requirement string into its parts, such as name, specifier,\n    URL, and extras. Raises InvalidRequirement on a badly-formed requirement\n    string.\n    \"\"\"\n\n    # TODO: Can we test whether something is contained within a requirement?\n    #       If so how do we do that? Do we need to test against the _name_ of\n    #       the thing as well as the version? What about the markers?\n    # TODO: Can we normalize the name and extra name?\n\n    def __init__(self, requirement_string: str) -> None:\n        try:\n            req = REQUIREMENT.parseString(requirement_string)\n        except ParseException as e:\n            raise InvalidRequirement(\n                f'Parse error at \"{ requirement_string[e.loc : e.loc + 8]!r}\": {e.msg}'\n            )\n\n        self.name: str = req.name\n        if req.url:\n            parsed_url = urllib.parse.urlparse(req.url)\n            if parsed_url.scheme == \"file\":\n                if urllib.parse.urlunparse(parsed_url) != req.url:\n                    raise InvalidRequirement(\"Invalid URL given\")\n            elif not (parsed_url.scheme and parsed_url.netloc) or (\n                not parsed_url.scheme and not parsed_url.netloc\n            ):\n                raise InvalidRequirement(f\"Invalid URL: {req.url}\")\n            self.url: TOptional[str] = req.url\n        else:\n            self.url = None\n        self.extras: Set[str] = set(req.extras.asList() if req.extras else [])\n        self.specifier: SpecifierSet = SpecifierSet(req.specifier)\n        self.marker: TOptional[Marker] = req.marker if req.marker else None\n\n    def __str__(self) -> str:\n        parts: List[str] = [self.name]\n\n        if self.extras:\n            formatted_extras = \",\".join(sorted(self.extras))\n            parts.append(f\"[{formatted_extras}]\")\n\n        if self.specifier:\n            parts.append(str(self.specifier))\n\n        if self.url:\n            parts.append(f\"@ {self.url}\")\n            if self.marker:\n                parts.append(\" \")\n\n        if self.marker:\n            parts.append(f\"; {self.marker}\")\n\n        return \"\".join(parts)\n\n    def __repr__(self) -> str:\n        return f\"<Requirement('{self}')>\"\n"},"hash":"ObId82iFOW"}