{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:bs4:builder:__init__.py","body":"# Use of this source code is governed by the MIT license.\n__license__ = \"MIT\"\n\nfrom collections import defaultdict\nimport itertools\nimport re\nimport warnings\nimport sys\nfrom bs4.element import (\n    CharsetMetaAttributeValue,\n    ContentMetaAttributeValue,\n    RubyParenthesisString,\n    RubyTextString,\n    Stylesheet,\n    Script,\n    TemplateString,\n    nonwhitespace_re\n)\n\n__all__ = [\n    'HTMLTreeBuilder',\n    'SAXTreeBuilder',\n    'TreeBuilder',\n    'TreeBuilderRegistry',\n    ]\n\n# Some useful features for a TreeBuilder to have.\nFAST = 'fast'\nPERMISSIVE = 'permissive'\nSTRICT = 'strict'\nXML = 'xml'\nHTML = 'html'\nHTML_5 = 'html5'\n\nclass XMLParsedAsHTMLWarning(UserWarning):\n    \"\"\"The warning issued when an HTML parser is used to parse\n    XML that is not XHTML.\n    \"\"\"\n    MESSAGE = \"\"\"It looks like you're parsing an XML document using an HTML parser. If this really is an HTML document (maybe it's XHTML?), you can ignore or filter this warning. If it's XML, you should know that using an XML parser will be more reliable. To parse this document as XML, make sure you have the lxml package installed, and pass the keyword argument `features=\"xml\"` into the BeautifulSoup constructor.\"\"\"\n\n\nclass TreeBuilderRegistry(object):\n    \"\"\"A way of looking up TreeBuilder subclasses by their name or by desired\n    features.\n    \"\"\"\n    \n    def __init__(self):\n        self.builders_for_feature = defaultdict(list)\n        self.builders = []\n\n    def register(self, treebuilder_class):\n        \"\"\"Register a treebuilder based on its advertised features.\n\n        :param treebuilder_class: A subclass of Treebuilder. its .features\n           attribute should list its features.\n        \"\"\"\n        for feature in treebuilder_class.features:\n            self.builders_for_feature[feature].insert(0, treebuilder_class)\n        self.builders.insert(0, treebuilder_class)\n\n    def lookup(self, *features):\n        \"\"\"Look up a TreeBuilder subclass with the desired features.\n\n        :param features: A list of features to look for. If none are\n            provided, the most recently registered TreeBuilder subclass\n            will be used.\n        :return: A TreeBuilder subclass, or None if there's no\n            registered subclass with all the requested features.\n        \"\"\"\n        if len(self.builders) == 0:\n            # There are no builders at all.\n            return None\n\n        if len(features) == 0:\n            # They didn't ask for any features. Give them the most\n            # recently registered builder.\n            return self.builders[0]\n\n        # Go down the list of features in order, and eliminate any builders\n        # that don't match every feature.\n        features = list(features)\n        features.reverse()\n        candidates = None\n        candidate_set = None\n        while len(features) > 0:\n            feature = features.pop()\n            we_have_the_feature = self.builders_for_feature.get(feature, [])\n            if len(we_have_the_feature) > 0:\n                if candidates is None:\n                    candidates = we_have_the_feature\n                    candidate_set = set(candidates)\n                else:\n                    # Eliminate any candidates that don't have this feature.\n                    candidate_set = candidate_set.intersection(\n                        set(we_have_the_feature))\n\n        # The only valid candidates are the ones in candidate_set.\n        # Go through the original list of candidates and pick the first one\n        # that's in candidate_set.\n        if candidate_set is None:\n            return None\n        for candidate in candidates:\n            if candidate in candidate_set:\n                return candidate\n        return None\n\n# The BeautifulSoup class will take feature lists from developers and use them\n# to look up builders in this registry.\nbuilder_registry = TreeBuilderRegistry()\n\nclass TreeBuilder(object):\n    \"\"\"Turn a textual document into a Beautiful Soup object tree.\"\"\"\n\n    NAME = \"[Unknown tree builder]\"\n    ALTERNATE_NAMES = []\n    features = []\n\n    is_xml = False\n    picklable = False\n    empty_element_tags = None # A tag will be considered an empty-element\n                              # tag when and only when it has no contents.\n    \n    # A value for these tag/attribute combinations is a space- or\n    # comma-separated list of CDATA, rather than a single CDATA.\n    DEFAULT_CDATA_LIST_ATTRIBUTES = defaultdict(list)\n\n    # Whitespace should be preserved inside these tags.\n    DEFAULT_PRESERVE_WHITESPACE_TAGS = set()\n\n    # The textual contents of tags with these names should be\n    # instantiated with some class other than NavigableString.\n    DEFAULT_STRING_CONTAINERS = {}\n    \n    USE_DEFAULT = object()\n\n    # Most parsers don't keep track of line numbers.\n    TRACKS_LINE_NUMBERS = False\n    \n    def __init__(self, multi_valued_attributes=USE_DEFAULT,\n                 preserve_whitespace_tags=USE_DEFAULT,\n                 store_line_numbers=USE_DEFAULT,\n                 string_containers=USE_DEFAULT,\n    ):\n        \"\"\"Constructor.\n\n        :param multi_valued_attributes: If this is set to None, the\n         TreeBuilder will not turn any values for attributes like\n         'class' into lists. Setting this to a dictionary will\n         customize this behavior; look at DEFAULT_CDATA_LIST_ATTRIBUTES\n         for an example.\n\n         Internally, these are called \"CDATA list attributes\", but that\n         probably doesn't make sense to an end-user, so the argument name\n         is `multi_valued_attributes`.\n\n        :param preserve_whitespace_tags: A list of tags to treat\n         the way <pre> tags are treated in HTML. Tags in this list\n         are immune from pretty-printing; their contents will always be\n         output as-is.\n\n        :param string_containers: A dictionary mapping tag names to\n        the classes that should be instantiated to contain the textual\n        contents of those tags. The default is to use NavigableString\n        for every tag, no matter what the name. You can override the\n        default by changing DEFAULT_STRING_CONTAINERS.\n\n        :param store_line_numbers: If the parser keeps track of the\n         line numbers and positions of the original markup, that\n         information will, by default, be stored in each corresponding\n         `Tag` object. You can turn this off by passing\n         store_line_numbers=False. If the parser you're using doesn't \n         keep track of this information, then setting store_line_numbers=True\n         will do nothing.\n        \"\"\"\n        self.soup = None\n        if multi_valued_attributes is self.USE_DEFAULT:\n            multi_valued_attributes = self.DEFAULT_CDATA_LIST_ATTRIBUTES\n        self.cdata_list_attributes = multi_valued_attributes\n        if preserve_whitespace_tags is self.USE_DEFAULT:\n            preserve_whitespace_tags = self.DEFAULT_PRESERVE_WHITESPACE_TAGS\n        self.preserve_whitespace_tags = preserve_whitespace_tags\n        if store_line_numbers == self.USE_DEFAULT:\n            store_line_numbers = self.TRACKS_LINE_NUMBERS\n        self.store_line_numbers = store_line_numbers \n        if string_containers == self.USE_DEFAULT:\n            string_containers = self.DEFAULT_STRING_CONTAINERS\n        self.string_containers = string_containers\n        \n    def initialize_soup(self, soup):\n        \"\"\"The BeautifulSoup object has been initialized and is now\n        being associated with the TreeBuilder.\n\n        :param soup: A BeautifulSoup object.\n        \"\"\"\n        self.soup = soup\n        \n    def reset(self):\n        \"\"\"Do any work necessary to reset the underlying parser\n        for a new document.\n\n        By default, this does nothing.\n        \"\"\"\n        pass\n\n    def can_be_empty_element(self, tag_name):\n        \"\"\"Might a tag with this name be an empty-element tag?\n\n        The final markup may or may not actually present this tag as\n        self-closing.\n\n        For instance: an HTMLBuilder does not consider a <p> tag to be\n        an empty-element tag (it's not in\n        HTMLBuilder.empty_element_tags). This means an empty <p> tag\n        will be presented as \"<p></p>\", not \"<p/>\" or \"<p>\".\n\n        The default implementation has no opinion about which tags are\n        empty-element tags, so a tag will be presented as an\n        empty-element tag if and only if it has no children.\n        \"<foo></foo>\" will become \"<foo/>\", and \"<foo>bar</foo>\" will\n        be left alone.\n\n        :param tag_name: The name of a markup tag.\n        \"\"\"\n        if self.empty_element_tags is None:\n            return True\n        return tag_name in self.empty_element_tags\n    \n    def feed(self, markup):\n        \"\"\"Run some incoming markup through some parsing process,\n        populating the `BeautifulSoup` object in self.soup.\n\n        This method is not implemented in TreeBuilder; it must be\n        implemented in subclasses.\n\n        :return: None.\n        \"\"\"\n        raise NotImplementedError()\n\n    def prepare_markup(self, markup, user_specified_encoding=None,\n                       document_declared_encoding=None, exclude_encodings=None):\n        \"\"\"Run any preliminary steps necessary to make incoming markup\n        acceptable to the parser.\n\n        :param markup: Some markup -- probably a bytestring.\n        :param user_specified_encoding: The user asked to try this encoding.\n        :param document_declared_encoding: The markup itself claims to be\n            in this encoding. NOTE: This argument is not used by the\n            calling code and can probably be removed.\n        :param exclude_encodings: The user asked _not_ to try any of\n            these encodings.\n\n        :yield: A series of 4-tuples:\n         (markup, encoding, declared encoding,\n          has undergone character replacement)\n\n         Each 4-tuple represents a strategy for converting the\n         document to Unicode and parsing it. Each strategy will be tried \n         in turn.\n\n         By default, the only strategy is to parse the markup\n         as-is. See `LXMLTreeBuilderForXML` and\n         `HTMLParserTreeBuilder` for implementations that take into\n         account the quirks of particular parsers.\n        \"\"\"\n        yield markup, None, None, False\n\n    def test_fragment_to_document(self, fragment):\n        \"\"\"Wrap an HTML fragment to make it look like a document.\n\n        Different parsers do this differently. For instance, lxml\n        introduces an empty <head> tag, and html5lib\n        doesn't. Abstracting this away lets us write simple tests\n        which run HTML fragments through the parser and compare the\n        results against other HTML fragments.\n\n        This method should not be used outside of tests.\n\n        :param fragment: A string -- fragment of HTML.\n        :return: A string -- a full HTML document.\n        \"\"\"\n        return fragment\n\n    def set_up_substitutions(self, tag):\n        \"\"\"Set up any substitutions that will need to be performed on \n        a `Tag` when it's output as a string.\n\n        By default, this does nothing. See `HTMLTreeBuilder` for a\n        case where this is used.\n\n        :param tag: A `Tag`\n        :return: Whether or not a substitution was performed.\n        \"\"\"\n        return False\n\n    def _replace_cdata_list_attribute_values(self, tag_name, attrs):\n        \"\"\"When an attribute value is associated with a tag that can\n        have multiple values for that attribute, convert the string\n        value to a list of strings.\n\n        Basically, replaces class=\"foo bar\" with class=[\"foo\", \"bar\"]\n\n        NOTE: This method modifies its input in place.\n\n        :param tag_name: The name of a tag.\n        :param attrs: A dictionary containing the tag's attributes.\n           Any appropriate attribute values will be modified in place.\n        \"\"\"\n        if not attrs:\n            return attrs\n        if self.cdata_list_attributes:\n            universal = self.cdata_list_attributes.get('*', [])\n            tag_specific = self.cdata_list_attributes.get(\n                tag_name.lower(), None)\n            for attr in list(attrs.keys()):\n                if attr in universal or (tag_specific and attr in tag_specific):\n                    # We have a \"class\"-type attribute whose string\n                    # value is a whitespace-separated list of\n                    # values. Split it into a list.\n                    value = attrs[attr]\n                    if isinstance(value, str):\n                        values = nonwhitespace_re.findall(value)\n                    else:\n                        # html5lib sometimes calls setAttributes twice\n                        # for the same tag when rearranging the parse\n                        # tree. On the second call the attribute value\n                        # here is already a list.  If this happens,\n                        # leave the value alone rather than trying to\n                        # split it again.\n                        values = value\n                    attrs[attr] = values\n        return attrs\n    \nclass SAXTreeBuilder(TreeBuilder):\n    \"\"\"A Beautiful Soup treebuilder that listens for SAX events.\n\n    This is not currently used for anything, but it demonstrates\n    how a simple TreeBuilder would work.\n    \"\"\"\n\n    def feed(self, markup):\n        raise NotImplementedError()\n\n    def close(self):\n        pass\n\n    def startElement(self, name, attrs):\n        attrs = dict((key[1], value) for key, value in list(attrs.items()))\n        #print(\"Start %s, %r\" % (name, attrs))\n        self.soup.handle_starttag(name, attrs)\n\n    def endElement(self, name):\n        #print(\"End %s\" % name)\n        self.soup.handle_endtag(name)\n\n    def startElementNS(self, nsTuple, nodeName, attrs):\n        # Throw away (ns, nodeName) for now.\n        self.startElement(nodeName, attrs)\n\n    def endElementNS(self, nsTuple, nodeName):\n        # Throw away (ns, nodeName) for now.\n        self.endElement(nodeName)\n        #handler.endElementNS((ns, node.nodeName), node.nodeName)\n\n    def startPrefixMapping(self, prefix, nodeValue):\n        # Ignore the prefix for now.\n        pass\n\n    def endPrefixMapping(self, prefix):\n        # Ignore the prefix for now.\n        # handler.endPrefixMapping(prefix)\n        pass\n\n    def characters(self, content):\n        self.soup.handle_data(content)\n\n    def startDocument(self):\n        pass\n\n    def endDocument(self):\n        pass\n\n\nclass HTMLTreeBuilder(TreeBuilder):\n    \"\"\"This TreeBuilder knows facts about HTML.\n\n    Such as which tags are empty-element tags.\n    \"\"\"\n\n    empty_element_tags = set([\n        # These are from HTML5.\n        'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr',\n        \n        # These are from earlier versions of HTML and are removed in HTML5.\n        'basefont', 'bgsound', 'command', 'frame', 'image', 'isindex', 'nextid', 'spacer'\n    ])\n\n    # The HTML standard defines these as block-level elements. Beautiful\n    # Soup does not treat these elements differently from other elements,\n    # but it may do so eventually, and this information is available if\n    # you need to use it.\n    block_elements = set([\"address\", \"article\", \"aside\", \"blockquote\", \"canvas\", \"dd\", \"div\", \"dl\", \"dt\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"header\", \"hr\", \"li\", \"main\", \"nav\", \"noscript\", \"ol\", \"output\", \"p\", \"pre\", \"section\", \"table\", \"tfoot\", \"ul\", \"video\"])\n\n    # These HTML tags need special treatment so they can be\n    # represented by a string class other than NavigableString.\n    #\n    # For some of these tags, it's because the HTML standard defines\n    # an unusual content model for them. I made this list by going\n    # through the HTML spec\n    # (https://html.spec.whatwg.org/#metadata-content) and looking for\n    # \"metadata content\" elements that can contain strings.\n    #\n    # The Ruby tags (<rt> and <rp>) are here despite being normal\n    # \"phrasing content\" tags, because the content they contain is\n    # qualitatively different from other text in the document, and it\n    # can be useful to be able to distinguish it.\n    #\n    # TODO: Arguably <noscript> could go here but it seems\n    # qualitatively different from the other tags.\n    DEFAULT_STRING_CONTAINERS = {\n        'rt' : RubyTextString,\n        'rp' : RubyParenthesisString,\n        'style': Stylesheet,\n        'script': Script,\n        'template': TemplateString,\n    }    \n    \n    # The HTML standard defines these attributes as containing a\n    # space-separated list of values, not a single value. That is,\n    # class=\"foo bar\" means that the 'class' attribute has two values,\n    # 'foo' and 'bar', not the single value 'foo bar'.  When we\n    # encounter one of these attributes, we will parse its value into\n    # a list of values if possible. Upon output, the list will be\n    # converted back into a string.\n    DEFAULT_CDATA_LIST_ATTRIBUTES = {\n        \"*\" : ['class', 'accesskey', 'dropzone'],\n        \"a\" : ['rel', 'rev'],\n        \"link\" :  ['rel', 'rev'],\n        \"td\" : [\"headers\"],\n        \"th\" : [\"headers\"],\n        \"td\" : [\"headers\"],\n        \"form\" : [\"accept-charset\"],\n        \"object\" : [\"archive\"],\n\n        # These are HTML5 specific, as are *.accesskey and *.dropzone above.\n        \"area\" : [\"rel\"],\n        \"icon\" : [\"sizes\"],\n        \"iframe\" : [\"sandbox\"],\n        \"output\" : [\"for\"],\n        }\n\n    DEFAULT_PRESERVE_WHITESPACE_TAGS = set(['pre', 'textarea'])\n\n    def set_up_substitutions(self, tag):\n        \"\"\"Replace the declared encoding in a <meta> tag with a placeholder,\n        to be substituted when the tag is output to a string.\n\n        An HTML document may come in to Beautiful Soup as one\n        encoding, but exit in a different encoding, and the <meta> tag\n        needs to be changed to reflect this.\n\n        :param tag: A `Tag`\n        :return: Whether or not a substitution was performed.\n        \"\"\"\n        # We are only interested in <meta> tags\n        if tag.name != 'meta':\n            return False\n\n        http_equiv = tag.get('http-equiv')\n        content = tag.get('content')\n        charset = tag.get('charset')\n\n        # We are interested in <meta> tags that say what encoding the\n        # document was originally in. This means HTML 5-style <meta>\n        # tags that provide the \"charset\" attribute. It also means\n        # HTML 4-style <meta> tags that provide the \"content\"\n        # attribute and have \"http-equiv\" set to \"content-type\".\n        #\n        # In both cases we will replace the value of the appropriate\n        # attribute with a standin object that can take on any\n        # encoding.\n        meta_encoding = None\n        if charset is not None:\n            # HTML 5 style:\n            # <meta charset=\"utf8\">\n            meta_encoding = charset\n            tag['charset'] = CharsetMetaAttributeValue(charset)\n\n        elif (content is not None and http_equiv is not None\n              and http_equiv.lower() == 'content-type'):\n            # HTML 4 style:\n            # <meta http-equiv=\"content-type\" content=\"text/html; charset=utf8\">\n            tag['content'] = ContentMetaAttributeValue(content)\n\n        return (meta_encoding is not None)\n\nclass DetectsXMLParsedAsHTML(object):\n    \"\"\"A mixin class for any class (a TreeBuilder, or some class used by a\n    TreeBuilder) that's in a position to detect whether an XML\n    document is being incorrectly parsed as HTML, and issue an\n    appropriate warning.\n\n    This requires being able to observe an incoming processing\n    instruction that might be an XML declaration, and also able to\n    observe tags as they're opened. If you can't do that for a given\n    TreeBuilder, there's a less reliable implementation based on\n    examining the raw markup.\n    \"\"\"\n\n    # Regular expression for seeing if markup has an <html> tag.\n    LOOKS_LIKE_HTML = re.compile(\"<[^ +]html\", re.I)\n    LOOKS_LIKE_HTML_B = re.compile(b\"<[^ +]html\", re.I)\n\n    XML_PREFIX = '<?xml'\n    XML_PREFIX_B = b'<?xml'\n    \n    @classmethod\n    def warn_if_markup_looks_like_xml(cls, markup, stacklevel=3):\n        \"\"\"Perform a check on some markup to see if it looks like XML\n        that's not XHTML. If so, issue a warning.\n\n        This is much less reliable than doing the check while parsing,\n        but some of the tree builders can't do that.\n\n        :param stacklevel: The stacklevel of the code calling this\n        function.\n\n        :return: True if the markup looks like non-XHTML XML, False\n        otherwise.\n\n        \"\"\"\n        if isinstance(markup, bytes):\n            prefix = cls.XML_PREFIX_B\n            looks_like_html = cls.LOOKS_LIKE_HTML_B\n        else:\n            prefix = cls.XML_PREFIX\n            looks_like_html = cls.LOOKS_LIKE_HTML\n        \n        if (markup is not None\n            and markup.startswith(prefix)\n            and not looks_like_html.search(markup[:500])\n        ):\n            cls._warn(stacklevel=stacklevel+2)\n            return True\n        return False\n\n    @classmethod\n    def _warn(cls, stacklevel=5):\n        \"\"\"Issue a warning about XML being parsed as HTML.\"\"\"\n        warnings.warn(\n            XMLParsedAsHTMLWarning.MESSAGE, XMLParsedAsHTMLWarning,\n            stacklevel=stacklevel\n        )\n        \n    def _initialize_xml_detector(self):\n        \"\"\"Call this method before parsing a document.\"\"\"\n        self._first_processing_instruction = None\n        self._root_tag = None\n       \n    def _document_might_be_xml(self, processing_instruction):\n        \"\"\"Call this method when encountering an XML declaration, or a\n        \"processing instruction\" that might be an XML declaration.\n        \"\"\"\n        if (self._first_processing_instruction is not None\n            or self._root_tag is not None):\n            # The document has already started. Don't bother checking\n            # anymore.\n            return\n\n        self._first_processing_instruction = processing_instruction\n\n        # We won't know until we encounter the first tag whether or\n        # not this is actually a problem.\n        \n    def _root_tag_encountered(self, name):\n        \"\"\"Call this when you encounter the document's root tag.\n\n        This is where we actually check whether an XML document is\n        being incorrectly parsed as HTML, and issue the warning.\n        \"\"\"\n        if self._root_tag is not None:\n            # This method was incorrectly called multiple times. Do\n            # nothing.\n            return\n\n        self._root_tag = name\n        if (name != 'html' and self._first_processing_instruction is not None\n            and self._first_processing_instruction.lower().startswith('xml ')):\n            # We encountered an XML declaration and then a tag other\n            # than 'html'. This is a reliable indicator that a\n            # non-XHTML document is being parsed as XML.\n            self._warn()\n\n    \ndef register_treebuilders_from(module):\n    \"\"\"Copy TreeBuilders from the given module into this module.\"\"\"\n    this_module = sys.modules[__name__]\n    for name in module.__all__:\n        obj = getattr(module, name)\n\n        if issubclass(obj, TreeBuilder):\n            setattr(this_module, name, obj)\n            this_module.__all__.append(name)\n            # Register the builder while we're at it.\n            this_module.builder_registry.register(obj)\n\nclass ParserRejectedMarkup(Exception):\n    \"\"\"An Exception to be raised when the underlying parser simply\n    refuses to parse the given markup.\n    \"\"\"\n    def __init__(self, message_or_exception):\n        \"\"\"Explain why the parser rejected the given markup, either\n        with a textual explanation or another exception.\n        \"\"\"\n        if isinstance(message_or_exception, Exception):\n            e = message_or_exception\n            message_or_exception = \"%s: %s\" % (e.__class__.__name__, str(e))\n        super(ParserRejectedMarkup, self).__init__(message_or_exception)\n            \n# Builders are registered in reverse order of priority, so that custom\n# builder registrations will take precedence. In general, we want lxml\n# to take precedence over html5lib, because it's faster. And we only\n# want to use HTMLParser as a last resort.\nfrom . import _htmlparser\nregister_treebuilders_from(_htmlparser)\ntry:\n    from . import _html5lib\n    register_treebuilders_from(_html5lib)\nexcept ImportError:\n    # They don't have html5lib installed.\n    pass\ntry:\n    from . import _lxml\n    register_treebuilders_from(_lxml)\nexcept ImportError:\n    # They don't have lxml installed.\n    pass\n"},"hash":"kGKq1DRtV8"}