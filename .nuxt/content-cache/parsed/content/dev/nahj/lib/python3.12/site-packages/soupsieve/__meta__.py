{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:soupsieve:__meta__.py","body":"\"\"\"Meta related things.\"\"\"\nfrom __future__ import annotations\nfrom collections import namedtuple\nimport re\n\nRE_VER = re.compile(\n    r'''(?x)\n    (?P<major>\\d+)(?:\\.(?P<minor>\\d+))?(?:\\.(?P<micro>\\d+))?\n    (?:(?P<type>a|b|rc)(?P<pre>\\d+))?\n    (?:\\.post(?P<post>\\d+))?\n    (?:\\.dev(?P<dev>\\d+))?\n    '''\n)\n\nREL_MAP = {\n    \".dev\": \"\",\n    \".dev-alpha\": \"a\",\n    \".dev-beta\": \"b\",\n    \".dev-candidate\": \"rc\",\n    \"alpha\": \"a\",\n    \"beta\": \"b\",\n    \"candidate\": \"rc\",\n    \"final\": \"\"\n}\n\nDEV_STATUS = {\n    \".dev\": \"2 - Pre-Alpha\",\n    \".dev-alpha\": \"2 - Pre-Alpha\",\n    \".dev-beta\": \"2 - Pre-Alpha\",\n    \".dev-candidate\": \"2 - Pre-Alpha\",\n    \"alpha\": \"3 - Alpha\",\n    \"beta\": \"4 - Beta\",\n    \"candidate\": \"4 - Beta\",\n    \"final\": \"5 - Production/Stable\"\n}\n\nPRE_REL_MAP = {\"a\": 'alpha', \"b\": 'beta', \"rc\": 'candidate'}\n\n\nclass Version(namedtuple(\"Version\", [\"major\", \"minor\", \"micro\", \"release\", \"pre\", \"post\", \"dev\"])):\n    \"\"\"\n    Get the version (PEP 440).\n\n    A biased approach to the PEP 440 semantic version.\n\n    Provides a tuple structure which is sorted for comparisons `v1 > v2` etc.\n      (major, minor, micro, release type, pre-release build, post-release build, development release build)\n    Release types are named in is such a way they are comparable with ease.\n    Accessors to check if a development, pre-release, or post-release build. Also provides accessor to get\n    development status for setup files.\n\n    How it works (currently):\n\n    - You must specify a release type as either `final`, `alpha`, `beta`, or `candidate`.\n    - To define a development release, you can use either `.dev`, `.dev-alpha`, `.dev-beta`, or `.dev-candidate`.\n      The dot is used to ensure all development specifiers are sorted before `alpha`.\n      You can specify a `dev` number for development builds, but do not have to as implicit development releases\n      are allowed.\n    - You must specify a `pre` value greater than zero if using a prerelease as this project (not PEP 440) does not\n      allow implicit prereleases.\n    - You can optionally set `post` to a value greater than zero to make the build a post release. While post releases\n      are technically allowed in prereleases, it is strongly discouraged, so we are rejecting them. It should be\n      noted that we do not allow `post0` even though PEP 440 does not restrict this. This project specifically\n      does not allow implicit post releases.\n    - It should be noted that we do not support epochs `1!` or local versions `+some-custom.version-1`.\n\n    Acceptable version releases:\n\n    ```\n    Version(1, 0, 0, \"final\")                    1.0\n    Version(1, 2, 0, \"final\")                    1.2\n    Version(1, 2, 3, \"final\")                    1.2.3\n    Version(1, 2, 0, \".dev-alpha\", pre=4)        1.2a4\n    Version(1, 2, 0, \".dev-beta\", pre=4)         1.2b4\n    Version(1, 2, 0, \".dev-candidate\", pre=4)    1.2rc4\n    Version(1, 2, 0, \"final\", post=1)            1.2.post1\n    Version(1, 2, 3, \".dev\")                     1.2.3.dev0\n    Version(1, 2, 3, \".dev\", dev=1)              1.2.3.dev1\n    ```\n\n    \"\"\"\n\n    def __new__(\n        cls,\n        major: int, minor: int, micro: int, release: str = \"final\",\n        pre: int = 0, post: int = 0, dev: int = 0\n    ) -> Version:\n        \"\"\"Validate version info.\"\"\"\n\n        # Ensure all parts are positive integers.\n        for value in (major, minor, micro, pre, post):\n            if not (isinstance(value, int) and value >= 0):\n                raise ValueError(\"All version parts except 'release' should be integers.\")\n\n        if release not in REL_MAP:\n            raise ValueError(f\"'{release}' is not a valid release type.\")\n\n        # Ensure valid pre-release (we do not allow implicit pre-releases).\n        if \".dev-candidate\" < release < \"final\":\n            if pre == 0:\n                raise ValueError(\"Implicit pre-releases not allowed.\")\n            elif dev:\n                raise ValueError(\"Version is not a development release.\")\n            elif post:\n                raise ValueError(\"Post-releases are not allowed with pre-releases.\")\n\n        # Ensure valid development or development/pre release\n        elif release < \"alpha\":\n            if release > \".dev\" and pre == 0:\n                raise ValueError(\"Implicit pre-release not allowed.\")\n            elif post:\n                raise ValueError(\"Post-releases are not allowed with pre-releases.\")\n\n        # Ensure a valid normal release\n        else:\n            if pre:\n                raise ValueError(\"Version is not a pre-release.\")\n            elif dev:\n                raise ValueError(\"Version is not a development release.\")\n\n        return super().__new__(cls, major, minor, micro, release, pre, post, dev)\n\n    def _is_pre(self) -> bool:\n        \"\"\"Is prerelease.\"\"\"\n\n        return bool(self.pre > 0)\n\n    def _is_dev(self) -> bool:\n        \"\"\"Is development.\"\"\"\n\n        return bool(self.release < \"alpha\")\n\n    def _is_post(self) -> bool:\n        \"\"\"Is post.\"\"\"\n\n        return bool(self.post > 0)\n\n    def _get_dev_status(self) -> str:  # pragma: no cover\n        \"\"\"Get development status string.\"\"\"\n\n        return DEV_STATUS[self.release]\n\n    def _get_canonical(self) -> str:\n        \"\"\"Get the canonical output string.\"\"\"\n\n        # Assemble major, minor, micro version and append `pre`, `post`, or `dev` if needed..\n        if self.micro == 0:\n            ver = f\"{self.major}.{self.minor}\"\n        else:\n            ver = f\"{self.major}.{self.minor}.{self.micro}\"\n        if self._is_pre():\n            ver += f'{REL_MAP[self.release]}{self.pre}'\n        if self._is_post():\n            ver += f\".post{self.post}\"\n        if self._is_dev():\n            ver += f\".dev{self.dev}\"\n\n        return ver\n\n\ndef parse_version(ver: str) -> Version:\n    \"\"\"Parse version into a comparable Version tuple.\"\"\"\n\n    m = RE_VER.match(ver)\n\n    if m is None:\n        raise ValueError(f\"'{ver}' is not a valid version\")\n\n    # Handle major, minor, micro\n    major = int(m.group('major'))\n    minor = int(m.group('minor')) if m.group('minor') else 0\n    micro = int(m.group('micro')) if m.group('micro') else 0\n\n    # Handle pre releases\n    if m.group('type'):\n        release = PRE_REL_MAP[m.group('type')]\n        pre = int(m.group('pre'))\n    else:\n        release = \"final\"\n        pre = 0\n\n    # Handle development releases\n    dev = m.group('dev') if m.group('dev') else 0\n    if m.group('dev'):\n        dev = int(m.group('dev'))\n        release = '.dev-' + release if pre else '.dev'\n    else:\n        dev = 0\n\n    # Handle post\n    post = int(m.group('post')) if m.group('post') else 0\n\n    return Version(major, minor, micro, release, pre, post, dev)\n\n\n__version_info__ = Version(2, 5, 0, \"final\")\n__version__ = __version_info__._get_canonical()\n"},"hash":"If0aISH0nk"}