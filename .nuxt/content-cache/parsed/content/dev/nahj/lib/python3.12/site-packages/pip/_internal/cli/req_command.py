{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:cli:req_command.py","body":"\"\"\"Contains the Command base classes that depend on PipSession.\n\nThe classes in this module are in a separate module so the commands not\nneeding download / PackageFinder capability don't unnecessarily import the\nPackageFinder machinery and all its vendored dependencies, etc.\n\"\"\"\n\nimport logging\nimport os\nimport sys\nfrom functools import partial\nfrom optparse import Values\nfrom typing import TYPE_CHECKING, Any, List, Optional, Tuple\n\nfrom pip._internal.cache import WheelCache\nfrom pip._internal.cli import cmdoptions\nfrom pip._internal.cli.base_command import Command\nfrom pip._internal.cli.command_context import CommandContextMixIn\nfrom pip._internal.exceptions import CommandError, PreviousBuildDirError\nfrom pip._internal.index.collector import LinkCollector\nfrom pip._internal.index.package_finder import PackageFinder\nfrom pip._internal.models.selection_prefs import SelectionPreferences\nfrom pip._internal.models.target_python import TargetPython\nfrom pip._internal.network.session import PipSession\nfrom pip._internal.operations.build.build_tracker import BuildTracker\nfrom pip._internal.operations.prepare import RequirementPreparer\nfrom pip._internal.req.constructors import (\n    install_req_from_editable,\n    install_req_from_line,\n    install_req_from_parsed_requirement,\n    install_req_from_req_string,\n)\nfrom pip._internal.req.req_file import parse_requirements\nfrom pip._internal.req.req_install import InstallRequirement\nfrom pip._internal.resolution.base import BaseResolver\nfrom pip._internal.self_outdated_check import pip_self_version_check\nfrom pip._internal.utils.temp_dir import (\n    TempDirectory,\n    TempDirectoryTypeRegistry,\n    tempdir_kinds,\n)\nfrom pip._internal.utils.virtualenv import running_under_virtualenv\n\nif TYPE_CHECKING:\n    from ssl import SSLContext\n\nlogger = logging.getLogger(__name__)\n\n\ndef _create_truststore_ssl_context() -> Optional[\"SSLContext\"]:\n    if sys.version_info < (3, 10):\n        raise CommandError(\"The truststore feature is only available for Python 3.10+\")\n\n    try:\n        import ssl\n    except ImportError:\n        logger.warning(\"Disabling truststore since ssl support is missing\")\n        return None\n\n    try:\n        from pip._vendor import truststore\n    except ImportError as e:\n        raise CommandError(f\"The truststore feature is unavailable: {e}\")\n\n    return truststore.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n\n\nclass SessionCommandMixin(CommandContextMixIn):\n\n    \"\"\"\n    A class mixin for command classes needing _build_session().\n    \"\"\"\n\n    def __init__(self) -> None:\n        super().__init__()\n        self._session: Optional[PipSession] = None\n\n    @classmethod\n    def _get_index_urls(cls, options: Values) -> Optional[List[str]]:\n        \"\"\"Return a list of index urls from user-provided options.\"\"\"\n        index_urls = []\n        if not getattr(options, \"no_index\", False):\n            url = getattr(options, \"index_url\", None)\n            if url:\n                index_urls.append(url)\n        urls = getattr(options, \"extra_index_urls\", None)\n        if urls:\n            index_urls.extend(urls)\n        # Return None rather than an empty list\n        return index_urls or None\n\n    def get_default_session(self, options: Values) -> PipSession:\n        \"\"\"Get a default-managed session.\"\"\"\n        if self._session is None:\n            self._session = self.enter_context(self._build_session(options))\n            # there's no type annotation on requests.Session, so it's\n            # automatically ContextManager[Any] and self._session becomes Any,\n            # then https://github.com/python/mypy/issues/7696 kicks in\n            assert self._session is not None\n        return self._session\n\n    def _build_session(\n        self,\n        options: Values,\n        retries: Optional[int] = None,\n        timeout: Optional[int] = None,\n        fallback_to_certifi: bool = False,\n    ) -> PipSession:\n        cache_dir = options.cache_dir\n        assert not cache_dir or os.path.isabs(cache_dir)\n\n        if \"truststore\" in options.features_enabled:\n            try:\n                ssl_context = _create_truststore_ssl_context()\n            except Exception:\n                if not fallback_to_certifi:\n                    raise\n                ssl_context = None\n        else:\n            ssl_context = None\n\n        session = PipSession(\n            cache=os.path.join(cache_dir, \"http-v2\") if cache_dir else None,\n            retries=retries if retries is not None else options.retries,\n            trusted_hosts=options.trusted_hosts,\n            index_urls=self._get_index_urls(options),\n            ssl_context=ssl_context,\n        )\n\n        # Handle custom ca-bundles from the user\n        if options.cert:\n            session.verify = options.cert\n\n        # Handle SSL client certificate\n        if options.client_cert:\n            session.cert = options.client_cert\n\n        # Handle timeouts\n        if options.timeout or timeout:\n            session.timeout = timeout if timeout is not None else options.timeout\n\n        # Handle configured proxies\n        if options.proxy:\n            session.proxies = {\n                \"http\": options.proxy,\n                \"https\": options.proxy,\n            }\n\n        # Determine if we can prompt the user for authentication or not\n        session.auth.prompting = not options.no_input\n        session.auth.keyring_provider = options.keyring_provider\n\n        return session\n\n\nclass IndexGroupCommand(Command, SessionCommandMixin):\n\n    \"\"\"\n    Abstract base class for commands with the index_group options.\n\n    This also corresponds to the commands that permit the pip version check.\n    \"\"\"\n\n    def handle_pip_version_check(self, options: Values) -> None:\n        \"\"\"\n        Do the pip version check if not disabled.\n\n        This overrides the default behavior of not doing the check.\n        \"\"\"\n        # Make sure the index_group options are present.\n        assert hasattr(options, \"no_index\")\n\n        if options.disable_pip_version_check or options.no_index:\n            return\n\n        # Otherwise, check if we're using the latest version of pip available.\n        session = self._build_session(\n            options,\n            retries=0,\n            timeout=min(5, options.timeout),\n            # This is set to ensure the function does not fail when truststore is\n            # specified in use-feature but cannot be loaded. This usually raises a\n            # CommandError and shows a nice user-facing error, but this function is not\n            # called in that try-except block.\n            fallback_to_certifi=True,\n        )\n        with session:\n            pip_self_version_check(session, options)\n\n\nKEEPABLE_TEMPDIR_TYPES = [\n    tempdir_kinds.BUILD_ENV,\n    tempdir_kinds.EPHEM_WHEEL_CACHE,\n    tempdir_kinds.REQ_BUILD,\n]\n\n\ndef warn_if_run_as_root() -> None:\n    \"\"\"Output a warning for sudo users on Unix.\n\n    In a virtual environment, sudo pip still writes to virtualenv.\n    On Windows, users may run pip as Administrator without issues.\n    This warning only applies to Unix root users outside of virtualenv.\n    \"\"\"\n    if running_under_virtualenv():\n        return\n    if not hasattr(os, \"getuid\"):\n        return\n    # On Windows, there are no \"system managed\" Python packages. Installing as\n    # Administrator via pip is the correct way of updating system environments.\n    #\n    # We choose sys.platform over utils.compat.WINDOWS here to enable Mypy platform\n    # checks: https://mypy.readthedocs.io/en/stable/common_issues.html\n    if sys.platform == \"win32\" or sys.platform == \"cygwin\":\n        return\n\n    if os.getuid() != 0:\n        return\n\n    logger.warning(\n        \"Running pip as the 'root' user can result in broken permissions and \"\n        \"conflicting behaviour with the system package manager. \"\n        \"It is recommended to use a virtual environment instead: \"\n        \"https://pip.pypa.io/warnings/venv\"\n    )\n\n\ndef with_cleanup(func: Any) -> Any:\n    \"\"\"Decorator for common logic related to managing temporary\n    directories.\n    \"\"\"\n\n    def configure_tempdir_registry(registry: TempDirectoryTypeRegistry) -> None:\n        for t in KEEPABLE_TEMPDIR_TYPES:\n            registry.set_delete(t, False)\n\n    def wrapper(\n        self: RequirementCommand, options: Values, args: List[Any]\n    ) -> Optional[int]:\n        assert self.tempdir_registry is not None\n        if options.no_clean:\n            configure_tempdir_registry(self.tempdir_registry)\n\n        try:\n            return func(self, options, args)\n        except PreviousBuildDirError:\n            # This kind of conflict can occur when the user passes an explicit\n            # build directory with a pre-existing folder. In that case we do\n            # not want to accidentally remove it.\n            configure_tempdir_registry(self.tempdir_registry)\n            raise\n\n    return wrapper\n\n\nclass RequirementCommand(IndexGroupCommand):\n    def __init__(self, *args: Any, **kw: Any) -> None:\n        super().__init__(*args, **kw)\n\n        self.cmd_opts.add_option(cmdoptions.no_clean())\n\n    @staticmethod\n    def determine_resolver_variant(options: Values) -> str:\n        \"\"\"Determines which resolver should be used, based on the given options.\"\"\"\n        if \"legacy-resolver\" in options.deprecated_features_enabled:\n            return \"legacy\"\n\n        return \"resolvelib\"\n\n    @classmethod\n    def make_requirement_preparer(\n        cls,\n        temp_build_dir: TempDirectory,\n        options: Values,\n        build_tracker: BuildTracker,\n        session: PipSession,\n        finder: PackageFinder,\n        use_user_site: bool,\n        download_dir: Optional[str] = None,\n        verbosity: int = 0,\n    ) -> RequirementPreparer:\n        \"\"\"\n        Create a RequirementPreparer instance for the given parameters.\n        \"\"\"\n        temp_build_dir_path = temp_build_dir.path\n        assert temp_build_dir_path is not None\n        legacy_resolver = False\n\n        resolver_variant = cls.determine_resolver_variant(options)\n        if resolver_variant == \"resolvelib\":\n            lazy_wheel = \"fast-deps\" in options.features_enabled\n            if lazy_wheel:\n                logger.warning(\n                    \"pip is using lazily downloaded wheels using HTTP \"\n                    \"range requests to obtain dependency information. \"\n                    \"This experimental feature is enabled through \"\n                    \"--use-feature=fast-deps and it is not ready for \"\n                    \"production.\"\n                )\n        else:\n            legacy_resolver = True\n            lazy_wheel = False\n            if \"fast-deps\" in options.features_enabled:\n                logger.warning(\n                    \"fast-deps has no effect when used with the legacy resolver.\"\n                )\n\n        return RequirementPreparer(\n            build_dir=temp_build_dir_path,\n            src_dir=options.src_dir,\n            download_dir=download_dir,\n            build_isolation=options.build_isolation,\n            check_build_deps=options.check_build_deps,\n            build_tracker=build_tracker,\n            session=session,\n            progress_bar=options.progress_bar,\n            finder=finder,\n            require_hashes=options.require_hashes,\n            use_user_site=use_user_site,\n            lazy_wheel=lazy_wheel,\n            verbosity=verbosity,\n            legacy_resolver=legacy_resolver,\n        )\n\n    @classmethod\n    def make_resolver(\n        cls,\n        preparer: RequirementPreparer,\n        finder: PackageFinder,\n        options: Values,\n        wheel_cache: Optional[WheelCache] = None,\n        use_user_site: bool = False,\n        ignore_installed: bool = True,\n        ignore_requires_python: bool = False,\n        force_reinstall: bool = False,\n        upgrade_strategy: str = \"to-satisfy-only\",\n        use_pep517: Optional[bool] = None,\n        py_version_info: Optional[Tuple[int, ...]] = None,\n    ) -> BaseResolver:\n        \"\"\"\n        Create a Resolver instance for the given parameters.\n        \"\"\"\n        make_install_req = partial(\n            install_req_from_req_string,\n            isolated=options.isolated_mode,\n            use_pep517=use_pep517,\n        )\n        resolver_variant = cls.determine_resolver_variant(options)\n        # The long import name and duplicated invocation is needed to convince\n        # Mypy into correctly typechecking. Otherwise it would complain the\n        # \"Resolver\" class being redefined.\n        if resolver_variant == \"resolvelib\":\n            import pip._internal.resolution.resolvelib.resolver\n\n            return pip._internal.resolution.resolvelib.resolver.Resolver(\n                preparer=preparer,\n                finder=finder,\n                wheel_cache=wheel_cache,\n                make_install_req=make_install_req,\n                use_user_site=use_user_site,\n                ignore_dependencies=options.ignore_dependencies,\n                ignore_installed=ignore_installed,\n                ignore_requires_python=ignore_requires_python,\n                force_reinstall=force_reinstall,\n                upgrade_strategy=upgrade_strategy,\n                py_version_info=py_version_info,\n            )\n        import pip._internal.resolution.legacy.resolver\n\n        return pip._internal.resolution.legacy.resolver.Resolver(\n            preparer=preparer,\n            finder=finder,\n            wheel_cache=wheel_cache,\n            make_install_req=make_install_req,\n            use_user_site=use_user_site,\n            ignore_dependencies=options.ignore_dependencies,\n            ignore_installed=ignore_installed,\n            ignore_requires_python=ignore_requires_python,\n            force_reinstall=force_reinstall,\n            upgrade_strategy=upgrade_strategy,\n            py_version_info=py_version_info,\n        )\n\n    def get_requirements(\n        self,\n        args: List[str],\n        options: Values,\n        finder: PackageFinder,\n        session: PipSession,\n    ) -> List[InstallRequirement]:\n        \"\"\"\n        Parse command-line arguments into the corresponding requirements.\n        \"\"\"\n        requirements: List[InstallRequirement] = []\n        for filename in options.constraints:\n            for parsed_req in parse_requirements(\n                filename,\n                constraint=True,\n                finder=finder,\n                options=options,\n                session=session,\n            ):\n                req_to_add = install_req_from_parsed_requirement(\n                    parsed_req,\n                    isolated=options.isolated_mode,\n                    user_supplied=False,\n                )\n                requirements.append(req_to_add)\n\n        for req in args:\n            req_to_add = install_req_from_line(\n                req,\n                comes_from=None,\n                isolated=options.isolated_mode,\n                use_pep517=options.use_pep517,\n                user_supplied=True,\n                config_settings=getattr(options, \"config_settings\", None),\n            )\n            requirements.append(req_to_add)\n\n        for req in options.editables:\n            req_to_add = install_req_from_editable(\n                req,\n                user_supplied=True,\n                isolated=options.isolated_mode,\n                use_pep517=options.use_pep517,\n                config_settings=getattr(options, \"config_settings\", None),\n            )\n            requirements.append(req_to_add)\n\n        # NOTE: options.require_hashes may be set if --require-hashes is True\n        for filename in options.requirements:\n            for parsed_req in parse_requirements(\n                filename, finder=finder, options=options, session=session\n            ):\n                req_to_add = install_req_from_parsed_requirement(\n                    parsed_req,\n                    isolated=options.isolated_mode,\n                    use_pep517=options.use_pep517,\n                    user_supplied=True,\n                    config_settings=parsed_req.options.get(\"config_settings\")\n                    if parsed_req.options\n                    else None,\n                )\n                requirements.append(req_to_add)\n\n        # If any requirement has hash options, enable hash checking.\n        if any(req.has_hash_options for req in requirements):\n            options.require_hashes = True\n\n        if not (args or options.editables or options.requirements):\n            opts = {\"name\": self.name}\n            if options.find_links:\n                raise CommandError(\n                    \"You must give at least one requirement to {name} \"\n                    '(maybe you meant \"pip {name} {links}\"?)'.format(\n                        **dict(opts, links=\" \".join(options.find_links))\n                    )\n                )\n            else:\n                raise CommandError(\n                    \"You must give at least one requirement to {name} \"\n                    '(see \"pip help {name}\")'.format(**opts)\n                )\n\n        return requirements\n\n    @staticmethod\n    def trace_basic_info(finder: PackageFinder) -> None:\n        \"\"\"\n        Trace basic information about the provided objects.\n        \"\"\"\n        # Display where finder is looking for packages\n        search_scope = finder.search_scope\n        locations = search_scope.get_formatted_locations()\n        if locations:\n            logger.info(locations)\n\n    def _build_package_finder(\n        self,\n        options: Values,\n        session: PipSession,\n        target_python: Optional[TargetPython] = None,\n        ignore_requires_python: Optional[bool] = None,\n    ) -> PackageFinder:\n        \"\"\"\n        Create a package finder appropriate to this requirement command.\n\n        :param ignore_requires_python: Whether to ignore incompatible\n            \"Requires-Python\" values in links. Defaults to False.\n        \"\"\"\n        link_collector = LinkCollector.create(session, options=options)\n        selection_prefs = SelectionPreferences(\n            allow_yanked=True,\n            format_control=options.format_control,\n            allow_all_prereleases=options.pre,\n            prefer_binary=options.prefer_binary,\n            ignore_requires_python=ignore_requires_python,\n        )\n\n        return PackageFinder.create(\n            link_collector=link_collector,\n            selection_prefs=selection_prefs,\n            target_python=target_python,\n        )\n"},"hash":"MFZrJgn4pn"}