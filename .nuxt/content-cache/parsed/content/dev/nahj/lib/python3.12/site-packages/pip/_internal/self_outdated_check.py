{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:self_outdated_check.py","body":"import datetime\nimport functools\nimport hashlib\nimport json\nimport logging\nimport optparse\nimport os.path\nimport sys\nfrom dataclasses import dataclass\nfrom typing import Any, Callable, Dict, Optional\n\nfrom pip._vendor.packaging.version import parse as parse_version\nfrom pip._vendor.rich.console import Group\nfrom pip._vendor.rich.markup import escape\nfrom pip._vendor.rich.text import Text\n\nfrom pip._internal.index.collector import LinkCollector\nfrom pip._internal.index.package_finder import PackageFinder\nfrom pip._internal.metadata import get_default_environment\nfrom pip._internal.metadata.base import DistributionVersion\nfrom pip._internal.models.selection_prefs import SelectionPreferences\nfrom pip._internal.network.session import PipSession\nfrom pip._internal.utils.compat import WINDOWS\nfrom pip._internal.utils.entrypoints import (\n    get_best_invocation_for_this_pip,\n    get_best_invocation_for_this_python,\n)\nfrom pip._internal.utils.filesystem import adjacent_tmp_file, check_path_owner, replace\nfrom pip._internal.utils.misc import ensure_dir\n\n_WEEK = datetime.timedelta(days=7)\n\nlogger = logging.getLogger(__name__)\n\n\ndef _get_statefile_name(key: str) -> str:\n    key_bytes = key.encode()\n    name = hashlib.sha224(key_bytes).hexdigest()\n    return name\n\n\ndef _convert_date(isodate: str) -> datetime.datetime:\n    \"\"\"Convert an ISO format string to a date.\n\n    Handles the format 2020-01-22T14:24:01Z (trailing Z)\n    which is not supported by older versions of fromisoformat.\n    \"\"\"\n    return datetime.datetime.fromisoformat(isodate.replace(\"Z\", \"+00:00\"))\n\n\nclass SelfCheckState:\n    def __init__(self, cache_dir: str) -> None:\n        self._state: Dict[str, Any] = {}\n        self._statefile_path = None\n\n        # Try to load the existing state\n        if cache_dir:\n            self._statefile_path = os.path.join(\n                cache_dir, \"selfcheck\", _get_statefile_name(self.key)\n            )\n            try:\n                with open(self._statefile_path, encoding=\"utf-8\") as statefile:\n                    self._state = json.load(statefile)\n            except (OSError, ValueError, KeyError):\n                # Explicitly suppressing exceptions, since we don't want to\n                # error out if the cache file is invalid.\n                pass\n\n    @property\n    def key(self) -> str:\n        return sys.prefix\n\n    def get(self, current_time: datetime.datetime) -> Optional[str]:\n        \"\"\"Check if we have a not-outdated version loaded already.\"\"\"\n        if not self._state:\n            return None\n\n        if \"last_check\" not in self._state:\n            return None\n\n        if \"pypi_version\" not in self._state:\n            return None\n\n        # Determine if we need to refresh the state\n        last_check = _convert_date(self._state[\"last_check\"])\n        time_since_last_check = current_time - last_check\n        if time_since_last_check > _WEEK:\n            return None\n\n        return self._state[\"pypi_version\"]\n\n    def set(self, pypi_version: str, current_time: datetime.datetime) -> None:\n        # If we do not have a path to cache in, don't bother saving.\n        if not self._statefile_path:\n            return\n\n        # Check to make sure that we own the directory\n        if not check_path_owner(os.path.dirname(self._statefile_path)):\n            return\n\n        # Now that we've ensured the directory is owned by this user, we'll go\n        # ahead and make sure that all our directories are created.\n        ensure_dir(os.path.dirname(self._statefile_path))\n\n        state = {\n            # Include the key so it's easy to tell which pip wrote the\n            # file.\n            \"key\": self.key,\n            \"last_check\": current_time.isoformat(),\n            \"pypi_version\": pypi_version,\n        }\n\n        text = json.dumps(state, sort_keys=True, separators=(\",\", \":\"))\n\n        with adjacent_tmp_file(self._statefile_path) as f:\n            f.write(text.encode())\n\n        try:\n            # Since we have a prefix-specific state file, we can just\n            # overwrite whatever is there, no need to check.\n            replace(f.name, self._statefile_path)\n        except OSError:\n            # Best effort.\n            pass\n\n\n@dataclass\nclass UpgradePrompt:\n    old: str\n    new: str\n\n    def __rich__(self) -> Group:\n        if WINDOWS:\n            pip_cmd = f\"{get_best_invocation_for_this_python()} -m pip\"\n        else:\n            pip_cmd = get_best_invocation_for_this_pip()\n\n        notice = \"[bold][[reset][blue]notice[reset][bold]][reset]\"\n        return Group(\n            Text(),\n            Text.from_markup(\n                f\"{notice} A new release of pip is available: \"\n                f\"[red]{self.old}[reset] -> [green]{self.new}[reset]\"\n            ),\n            Text.from_markup(\n                f\"{notice} To update, run: \"\n                f\"[green]{escape(pip_cmd)} install --upgrade pip\"\n            ),\n        )\n\n\ndef was_installed_by_pip(pkg: str) -> bool:\n    \"\"\"Checks whether pkg was installed by pip\n\n    This is used not to display the upgrade message when pip is in fact\n    installed by system package manager, such as dnf on Fedora.\n    \"\"\"\n    dist = get_default_environment().get_distribution(pkg)\n    return dist is not None and \"pip\" == dist.installer\n\n\ndef _get_current_remote_pip_version(\n    session: PipSession, options: optparse.Values\n) -> Optional[str]:\n    # Lets use PackageFinder to see what the latest pip version is\n    link_collector = LinkCollector.create(\n        session,\n        options=options,\n        suppress_no_index=True,\n    )\n\n    # Pass allow_yanked=False so we don't suggest upgrading to a\n    # yanked version.\n    selection_prefs = SelectionPreferences(\n        allow_yanked=False,\n        allow_all_prereleases=False,  # Explicitly set to False\n    )\n\n    finder = PackageFinder.create(\n        link_collector=link_collector,\n        selection_prefs=selection_prefs,\n    )\n    best_candidate = finder.find_best_candidate(\"pip\").best_candidate\n    if best_candidate is None:\n        return None\n\n    return str(best_candidate.version)\n\n\ndef _self_version_check_logic(\n    *,\n    state: SelfCheckState,\n    current_time: datetime.datetime,\n    local_version: DistributionVersion,\n    get_remote_version: Callable[[], Optional[str]],\n) -> Optional[UpgradePrompt]:\n    remote_version_str = state.get(current_time)\n    if remote_version_str is None:\n        remote_version_str = get_remote_version()\n        if remote_version_str is None:\n            logger.debug(\"No remote pip version found\")\n            return None\n        state.set(remote_version_str, current_time)\n\n    remote_version = parse_version(remote_version_str)\n    logger.debug(\"Remote version of pip: %s\", remote_version)\n    logger.debug(\"Local version of pip:  %s\", local_version)\n\n    pip_installed_by_pip = was_installed_by_pip(\"pip\")\n    logger.debug(\"Was pip installed by pip? %s\", pip_installed_by_pip)\n    if not pip_installed_by_pip:\n        return None  # Only suggest upgrade if pip is installed by pip.\n\n    local_version_is_older = (\n        local_version < remote_version\n        and local_version.base_version != remote_version.base_version\n    )\n    if local_version_is_older:\n        return UpgradePrompt(old=str(local_version), new=remote_version_str)\n\n    return None\n\n\ndef pip_self_version_check(session: PipSession, options: optparse.Values) -> None:\n    \"\"\"Check for an update for pip.\n\n    Limit the frequency of checks to once per week. State is stored either in\n    the active virtualenv or in the user's USER_CACHE_DIR keyed off the prefix\n    of the pip script path.\n    \"\"\"\n    installed_dist = get_default_environment().get_distribution(\"pip\")\n    if not installed_dist:\n        return\n\n    try:\n        upgrade_prompt = _self_version_check_logic(\n            state=SelfCheckState(cache_dir=options.cache_dir),\n            current_time=datetime.datetime.now(datetime.timezone.utc),\n            local_version=installed_dist.version,\n            get_remote_version=functools.partial(\n                _get_current_remote_pip_version, session, options\n            ),\n        )\n        if upgrade_prompt is not None:\n            logger.warning(\"%s\", upgrade_prompt, extra={\"rich\": True})\n    except Exception:\n        logger.warning(\"There was an error checking the latest version of pip.\")\n        logger.debug(\"See below for error\", exc_info=True)\n"},"hash":"tVD8jPMrY6"}