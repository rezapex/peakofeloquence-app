{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:metadata:base.py","body":"import csv\nimport email.message\nimport functools\nimport json\nimport logging\nimport pathlib\nimport re\nimport zipfile\nfrom typing import (\n    IO,\n    TYPE_CHECKING,\n    Any,\n    Collection,\n    Container,\n    Dict,\n    Iterable,\n    Iterator,\n    List,\n    NamedTuple,\n    Optional,\n    Tuple,\n    Union,\n)\n\nfrom pip._vendor.packaging.requirements import Requirement\nfrom pip._vendor.packaging.specifiers import InvalidSpecifier, SpecifierSet\nfrom pip._vendor.packaging.utils import NormalizedName, canonicalize_name\nfrom pip._vendor.packaging.version import LegacyVersion, Version\n\nfrom pip._internal.exceptions import NoneMetadataError\nfrom pip._internal.locations import site_packages, user_site\nfrom pip._internal.models.direct_url import (\n    DIRECT_URL_METADATA_NAME,\n    DirectUrl,\n    DirectUrlValidationError,\n)\nfrom pip._internal.utils.compat import stdlib_pkgs  # TODO: Move definition here.\nfrom pip._internal.utils.egg_link import egg_link_path_from_sys_path\nfrom pip._internal.utils.misc import is_local, normalize_path\nfrom pip._internal.utils.urls import url_to_path\n\nfrom ._json import msg_to_json\n\nif TYPE_CHECKING:\n    from typing import Protocol\nelse:\n    Protocol = object\n\nDistributionVersion = Union[LegacyVersion, Version]\n\nInfoPath = Union[str, pathlib.PurePath]\n\nlogger = logging.getLogger(__name__)\n\n\nclass BaseEntryPoint(Protocol):\n    @property\n    def name(self) -> str:\n        raise NotImplementedError()\n\n    @property\n    def value(self) -> str:\n        raise NotImplementedError()\n\n    @property\n    def group(self) -> str:\n        raise NotImplementedError()\n\n\ndef _convert_installed_files_path(\n    entry: Tuple[str, ...],\n    info: Tuple[str, ...],\n) -> str:\n    \"\"\"Convert a legacy installed-files.txt path into modern RECORD path.\n\n    The legacy format stores paths relative to the info directory, while the\n    modern format stores paths relative to the package root, e.g. the\n    site-packages directory.\n\n    :param entry: Path parts of the installed-files.txt entry.\n    :param info: Path parts of the egg-info directory relative to package root.\n    :returns: The converted entry.\n\n    For best compatibility with symlinks, this does not use ``abspath()`` or\n    ``Path.resolve()``, but tries to work with path parts:\n\n    1. While ``entry`` starts with ``..``, remove the equal amounts of parts\n       from ``info``; if ``info`` is empty, start appending ``..`` instead.\n    2. Join the two directly.\n    \"\"\"\n    while entry and entry[0] == \"..\":\n        if not info or info[-1] == \"..\":\n            info += (\"..\",)\n        else:\n            info = info[:-1]\n        entry = entry[1:]\n    return str(pathlib.Path(*info, *entry))\n\n\nclass RequiresEntry(NamedTuple):\n    requirement: str\n    extra: str\n    marker: str\n\n\nclass BaseDistribution(Protocol):\n    @classmethod\n    def from_directory(cls, directory: str) -> \"BaseDistribution\":\n        \"\"\"Load the distribution from a metadata directory.\n\n        :param directory: Path to a metadata directory, e.g. ``.dist-info``.\n        \"\"\"\n        raise NotImplementedError()\n\n    @classmethod\n    def from_metadata_file_contents(\n        cls,\n        metadata_contents: bytes,\n        filename: str,\n        project_name: str,\n    ) -> \"BaseDistribution\":\n        \"\"\"Load the distribution from the contents of a METADATA file.\n\n        This is used to implement PEP 658 by generating a \"shallow\" dist object that can\n        be used for resolution without downloading or building the actual dist yet.\n\n        :param metadata_contents: The contents of a METADATA file.\n        :param filename: File name for the dist with this metadata.\n        :param project_name: Name of the project this dist represents.\n        \"\"\"\n        raise NotImplementedError()\n\n    @classmethod\n    def from_wheel(cls, wheel: \"Wheel\", name: str) -> \"BaseDistribution\":\n        \"\"\"Load the distribution from a given wheel.\n\n        :param wheel: A concrete wheel definition.\n        :param name: File name of the wheel.\n\n        :raises InvalidWheel: Whenever loading of the wheel causes a\n            :py:exc:`zipfile.BadZipFile` exception to be thrown.\n        :raises UnsupportedWheel: If the wheel is a valid zip, but malformed\n            internally.\n        \"\"\"\n        raise NotImplementedError()\n\n    def __repr__(self) -> str:\n        return f\"{self.raw_name} {self.version} ({self.location})\"\n\n    def __str__(self) -> str:\n        return f\"{self.raw_name} {self.version}\"\n\n    @property\n    def location(self) -> Optional[str]:\n        \"\"\"Where the distribution is loaded from.\n\n        A string value is not necessarily a filesystem path, since distributions\n        can be loaded from other sources, e.g. arbitrary zip archives. ``None``\n        means the distribution is created in-memory.\n\n        Do not canonicalize this value with e.g. ``pathlib.Path.resolve()``. If\n        this is a symbolic link, we want to preserve the relative path between\n        it and files in the distribution.\n        \"\"\"\n        raise NotImplementedError()\n\n    @property\n    def editable_project_location(self) -> Optional[str]:\n        \"\"\"The project location for editable distributions.\n\n        This is the directory where pyproject.toml or setup.py is located.\n        None if the distribution is not installed in editable mode.\n        \"\"\"\n        # TODO: this property is relatively costly to compute, memoize it ?\n        direct_url = self.direct_url\n        if direct_url:\n            if direct_url.is_local_editable():\n                return url_to_path(direct_url.url)\n        else:\n            # Search for an .egg-link file by walking sys.path, as it was\n            # done before by dist_is_editable().\n            egg_link_path = egg_link_path_from_sys_path(self.raw_name)\n            if egg_link_path:\n                # TODO: get project location from second line of egg_link file\n                #       (https://github.com/pypa/pip/issues/10243)\n                return self.location\n        return None\n\n    @property\n    def installed_location(self) -> Optional[str]:\n        \"\"\"The distribution's \"installed\" location.\n\n        This should generally be a ``site-packages`` directory. This is\n        usually ``dist.location``, except for legacy develop-installed packages,\n        where ``dist.location`` is the source code location, and this is where\n        the ``.egg-link`` file is.\n\n        The returned location is normalized (in particular, with symlinks removed).\n        \"\"\"\n        raise NotImplementedError()\n\n    @property\n    def info_location(self) -> Optional[str]:\n        \"\"\"Location of the .[egg|dist]-info directory or file.\n\n        Similarly to ``location``, a string value is not necessarily a\n        filesystem path. ``None`` means the distribution is created in-memory.\n\n        For a modern .dist-info installation on disk, this should be something\n        like ``{location}/{raw_name}-{version}.dist-info``.\n\n        Do not canonicalize this value with e.g. ``pathlib.Path.resolve()``. If\n        this is a symbolic link, we want to preserve the relative path between\n        it and other files in the distribution.\n        \"\"\"\n        raise NotImplementedError()\n\n    @property\n    def installed_by_distutils(self) -> bool:\n        \"\"\"Whether this distribution is installed with legacy distutils format.\n\n        A distribution installed with \"raw\" distutils not patched by setuptools\n        uses one single file at ``info_location`` to store metadata. We need to\n        treat this specially on uninstallation.\n        \"\"\"\n        info_location = self.info_location\n        if not info_location:\n            return False\n        return pathlib.Path(info_location).is_file()\n\n    @property\n    def installed_as_egg(self) -> bool:\n        \"\"\"Whether this distribution is installed as an egg.\n\n        This usually indicates the distribution was installed by (older versions\n        of) easy_install.\n        \"\"\"\n        location = self.location\n        if not location:\n            return False\n        return location.endswith(\".egg\")\n\n    @property\n    def installed_with_setuptools_egg_info(self) -> bool:\n        \"\"\"Whether this distribution is installed with the ``.egg-info`` format.\n\n        This usually indicates the distribution was installed with setuptools\n        with an old pip version or with ``single-version-externally-managed``.\n\n        Note that this ensure the metadata store is a directory. distutils can\n        also installs an ``.egg-info``, but as a file, not a directory. This\n        property is *False* for that case. Also see ``installed_by_distutils``.\n        \"\"\"\n        info_location = self.info_location\n        if not info_location:\n            return False\n        if not info_location.endswith(\".egg-info\"):\n            return False\n        return pathlib.Path(info_location).is_dir()\n\n    @property\n    def installed_with_dist_info(self) -> bool:\n        \"\"\"Whether this distribution is installed with the \"modern format\".\n\n        This indicates a \"modern\" installation, e.g. storing metadata in the\n        ``.dist-info`` directory. This applies to installations made by\n        setuptools (but through pip, not directly), or anything using the\n        standardized build backend interface (PEP 517).\n        \"\"\"\n        info_location = self.info_location\n        if not info_location:\n            return False\n        if not info_location.endswith(\".dist-info\"):\n            return False\n        return pathlib.Path(info_location).is_dir()\n\n    @property\n    def canonical_name(self) -> NormalizedName:\n        raise NotImplementedError()\n\n    @property\n    def version(self) -> DistributionVersion:\n        raise NotImplementedError()\n\n    @property\n    def setuptools_filename(self) -> str:\n        \"\"\"Convert a project name to its setuptools-compatible filename.\n\n        This is a copy of ``pkg_resources.to_filename()`` for compatibility.\n        \"\"\"\n        return self.raw_name.replace(\"-\", \"_\")\n\n    @property\n    def direct_url(self) -> Optional[DirectUrl]:\n        \"\"\"Obtain a DirectUrl from this distribution.\n\n        Returns None if the distribution has no `direct_url.json` metadata,\n        or if `direct_url.json` is invalid.\n        \"\"\"\n        try:\n            content = self.read_text(DIRECT_URL_METADATA_NAME)\n        except FileNotFoundError:\n            return None\n        try:\n            return DirectUrl.from_json(content)\n        except (\n            UnicodeDecodeError,\n            json.JSONDecodeError,\n            DirectUrlValidationError,\n        ) as e:\n            logger.warning(\n                \"Error parsing %s for %s: %s\",\n                DIRECT_URL_METADATA_NAME,\n                self.canonical_name,\n                e,\n            )\n            return None\n\n    @property\n    def installer(self) -> str:\n        try:\n            installer_text = self.read_text(\"INSTALLER\")\n        except (OSError, ValueError, NoneMetadataError):\n            return \"\"  # Fail silently if the installer file cannot be read.\n        for line in installer_text.splitlines():\n            cleaned_line = line.strip()\n            if cleaned_line:\n                return cleaned_line\n        return \"\"\n\n    @property\n    def requested(self) -> bool:\n        return self.is_file(\"REQUESTED\")\n\n    @property\n    def editable(self) -> bool:\n        return bool(self.editable_project_location)\n\n    @property\n    def local(self) -> bool:\n        \"\"\"If distribution is installed in the current virtual environment.\n\n        Always True if we're not in a virtualenv.\n        \"\"\"\n        if self.installed_location is None:\n            return False\n        return is_local(self.installed_location)\n\n    @property\n    def in_usersite(self) -> bool:\n        if self.installed_location is None or user_site is None:\n            return False\n        return self.installed_location.startswith(normalize_path(user_site))\n\n    @property\n    def in_site_packages(self) -> bool:\n        if self.installed_location is None or site_packages is None:\n            return False\n        return self.installed_location.startswith(normalize_path(site_packages))\n\n    def is_file(self, path: InfoPath) -> bool:\n        \"\"\"Check whether an entry in the info directory is a file.\"\"\"\n        raise NotImplementedError()\n\n    def iter_distutils_script_names(self) -> Iterator[str]:\n        \"\"\"Find distutils 'scripts' entries metadata.\n\n        If 'scripts' is supplied in ``setup.py``, distutils records those in the\n        installed distribution's ``scripts`` directory, a file for each script.\n        \"\"\"\n        raise NotImplementedError()\n\n    def read_text(self, path: InfoPath) -> str:\n        \"\"\"Read a file in the info directory.\n\n        :raise FileNotFoundError: If ``path`` does not exist in the directory.\n        :raise NoneMetadataError: If ``path`` exists in the info directory, but\n            cannot be read.\n        \"\"\"\n        raise NotImplementedError()\n\n    def iter_entry_points(self) -> Iterable[BaseEntryPoint]:\n        raise NotImplementedError()\n\n    def _metadata_impl(self) -> email.message.Message:\n        raise NotImplementedError()\n\n    @functools.lru_cache(maxsize=1)\n    def _metadata_cached(self) -> email.message.Message:\n        # When we drop python 3.7 support, move this to the metadata property and use\n        # functools.cached_property instead of lru_cache.\n        metadata = self._metadata_impl()\n        self._add_egg_info_requires(metadata)\n        return metadata\n\n    @property\n    def metadata(self) -> email.message.Message:\n        \"\"\"Metadata of distribution parsed from e.g. METADATA or PKG-INFO.\n\n        This should return an empty message if the metadata file is unavailable.\n\n        :raises NoneMetadataError: If the metadata file is available, but does\n            not contain valid metadata.\n        \"\"\"\n        return self._metadata_cached()\n\n    @property\n    def metadata_dict(self) -> Dict[str, Any]:\n        \"\"\"PEP 566 compliant JSON-serializable representation of METADATA or PKG-INFO.\n\n        This should return an empty dict if the metadata file is unavailable.\n\n        :raises NoneMetadataError: If the metadata file is available, but does\n            not contain valid metadata.\n        \"\"\"\n        return msg_to_json(self.metadata)\n\n    @property\n    def metadata_version(self) -> Optional[str]:\n        \"\"\"Value of \"Metadata-Version:\" in distribution metadata, if available.\"\"\"\n        return self.metadata.get(\"Metadata-Version\")\n\n    @property\n    def raw_name(self) -> str:\n        \"\"\"Value of \"Name:\" in distribution metadata.\"\"\"\n        # The metadata should NEVER be missing the Name: key, but if it somehow\n        # does, fall back to the known canonical name.\n        return self.metadata.get(\"Name\", self.canonical_name)\n\n    @property\n    def requires_python(self) -> SpecifierSet:\n        \"\"\"Value of \"Requires-Python:\" in distribution metadata.\n\n        If the key does not exist or contains an invalid value, an empty\n        SpecifierSet should be returned.\n        \"\"\"\n        value = self.metadata.get(\"Requires-Python\")\n        if value is None:\n            return SpecifierSet()\n        try:\n            # Convert to str to satisfy the type checker; this can be a Header object.\n            spec = SpecifierSet(str(value))\n        except InvalidSpecifier as e:\n            message = \"Package %r has an invalid Requires-Python: %s\"\n            logger.warning(message, self.raw_name, e)\n            return SpecifierSet()\n        return spec\n\n    def iter_dependencies(self, extras: Collection[str] = ()) -> Iterable[Requirement]:\n        \"\"\"Dependencies of this distribution.\n\n        For modern .dist-info distributions, this is the collection of\n        \"Requires-Dist:\" entries in distribution metadata.\n        \"\"\"\n        raise NotImplementedError()\n\n    def iter_provided_extras(self) -> Iterable[str]:\n        \"\"\"Extras provided by this distribution.\n\n        For modern .dist-info distributions, this is the collection of\n        \"Provides-Extra:\" entries in distribution metadata.\n\n        The return value of this function is not particularly useful other than\n        display purposes due to backward compatibility issues and the extra\n        names being poorly normalized prior to PEP 685. If you want to perform\n        logic operations on extras, use :func:`is_extra_provided` instead.\n        \"\"\"\n        raise NotImplementedError()\n\n    def is_extra_provided(self, extra: str) -> bool:\n        \"\"\"Check whether an extra is provided by this distribution.\n\n        This is needed mostly for compatibility issues with pkg_resources not\n        following the extra normalization rules defined in PEP 685.\n        \"\"\"\n        raise NotImplementedError()\n\n    def _iter_declared_entries_from_record(self) -> Optional[Iterator[str]]:\n        try:\n            text = self.read_text(\"RECORD\")\n        except FileNotFoundError:\n            return None\n        # This extra Path-str cast normalizes entries.\n        return (str(pathlib.Path(row[0])) for row in csv.reader(text.splitlines()))\n\n    def _iter_declared_entries_from_legacy(self) -> Optional[Iterator[str]]:\n        try:\n            text = self.read_text(\"installed-files.txt\")\n        except FileNotFoundError:\n            return None\n        paths = (p for p in text.splitlines(keepends=False) if p)\n        root = self.location\n        info = self.info_location\n        if root is None or info is None:\n            return paths\n        try:\n            info_rel = pathlib.Path(info).relative_to(root)\n        except ValueError:  # info is not relative to root.\n            return paths\n        if not info_rel.parts:  # info *is* root.\n            return paths\n        return (\n            _convert_installed_files_path(pathlib.Path(p).parts, info_rel.parts)\n            for p in paths\n        )\n\n    def iter_declared_entries(self) -> Optional[Iterator[str]]:\n        \"\"\"Iterate through file entries declared in this distribution.\n\n        For modern .dist-info distributions, this is the files listed in the\n        ``RECORD`` metadata file. For legacy setuptools distributions, this\n        comes from ``installed-files.txt``, with entries normalized to be\n        compatible with the format used by ``RECORD``.\n\n        :return: An iterator for listed entries, or None if the distribution\n            contains neither ``RECORD`` nor ``installed-files.txt``.\n        \"\"\"\n        return (\n            self._iter_declared_entries_from_record()\n            or self._iter_declared_entries_from_legacy()\n        )\n\n    def _iter_requires_txt_entries(self) -> Iterator[RequiresEntry]:\n        \"\"\"Parse a ``requires.txt`` in an egg-info directory.\n\n        This is an INI-ish format where an egg-info stores dependencies. A\n        section name describes extra other environment markers, while each entry\n        is an arbitrary string (not a key-value pair) representing a dependency\n        as a requirement string (no markers).\n\n        There is a construct in ``importlib.metadata`` called ``Sectioned`` that\n        does mostly the same, but the format is currently considered private.\n        \"\"\"\n        try:\n            content = self.read_text(\"requires.txt\")\n        except FileNotFoundError:\n            return\n        extra = marker = \"\"  # Section-less entries don't have markers.\n        for line in content.splitlines():\n            line = line.strip()\n            if not line or line.startswith(\"#\"):  # Comment; ignored.\n                continue\n            if line.startswith(\"[\") and line.endswith(\"]\"):  # A section header.\n                extra, _, marker = line.strip(\"[]\").partition(\":\")\n                continue\n            yield RequiresEntry(requirement=line, extra=extra, marker=marker)\n\n    def _iter_egg_info_extras(self) -> Iterable[str]:\n        \"\"\"Get extras from the egg-info directory.\"\"\"\n        known_extras = {\"\"}\n        for entry in self._iter_requires_txt_entries():\n            extra = canonicalize_name(entry.extra)\n            if extra in known_extras:\n                continue\n            known_extras.add(extra)\n            yield extra\n\n    def _iter_egg_info_dependencies(self) -> Iterable[str]:\n        \"\"\"Get distribution dependencies from the egg-info directory.\n\n        To ease parsing, this converts a legacy dependency entry into a PEP 508\n        requirement string. Like ``_iter_requires_txt_entries()``, there is code\n        in ``importlib.metadata`` that does mostly the same, but not do exactly\n        what we need.\n\n        Namely, ``importlib.metadata`` does not normalize the extra name before\n        putting it into the requirement string, which causes marker comparison\n        to fail because the dist-info format do normalize. This is consistent in\n        all currently available PEP 517 backends, although not standardized.\n        \"\"\"\n        for entry in self._iter_requires_txt_entries():\n            extra = canonicalize_name(entry.extra)\n            if extra and entry.marker:\n                marker = f'({entry.marker}) and extra == \"{extra}\"'\n            elif extra:\n                marker = f'extra == \"{extra}\"'\n            elif entry.marker:\n                marker = entry.marker\n            else:\n                marker = \"\"\n            if marker:\n                yield f\"{entry.requirement} ; {marker}\"\n            else:\n                yield entry.requirement\n\n    def _add_egg_info_requires(self, metadata: email.message.Message) -> None:\n        \"\"\"Add egg-info requires.txt information to the metadata.\"\"\"\n        if not metadata.get_all(\"Requires-Dist\"):\n            for dep in self._iter_egg_info_dependencies():\n                metadata[\"Requires-Dist\"] = dep\n        if not metadata.get_all(\"Provides-Extra\"):\n            for extra in self._iter_egg_info_extras():\n                metadata[\"Provides-Extra\"] = extra\n\n\nclass BaseEnvironment:\n    \"\"\"An environment containing distributions to introspect.\"\"\"\n\n    @classmethod\n    def default(cls) -> \"BaseEnvironment\":\n        raise NotImplementedError()\n\n    @classmethod\n    def from_paths(cls, paths: Optional[List[str]]) -> \"BaseEnvironment\":\n        raise NotImplementedError()\n\n    def get_distribution(self, name: str) -> Optional[\"BaseDistribution\"]:\n        \"\"\"Given a requirement name, return the installed distributions.\n\n        The name may not be normalized. The implementation must canonicalize\n        it for lookup.\n        \"\"\"\n        raise NotImplementedError()\n\n    def _iter_distributions(self) -> Iterator[\"BaseDistribution\"]:\n        \"\"\"Iterate through installed distributions.\n\n        This function should be implemented by subclass, but never called\n        directly. Use the public ``iter_distribution()`` instead, which\n        implements additional logic to make sure the distributions are valid.\n        \"\"\"\n        raise NotImplementedError()\n\n    def iter_all_distributions(self) -> Iterator[BaseDistribution]:\n        \"\"\"Iterate through all installed distributions without any filtering.\"\"\"\n        for dist in self._iter_distributions():\n            # Make sure the distribution actually comes from a valid Python\n            # packaging distribution. Pip's AdjacentTempDirectory leaves folders\n            # e.g. ``~atplotlib.dist-info`` if cleanup was interrupted. The\n            # valid project name pattern is taken from PEP 508.\n            project_name_valid = re.match(\n                r\"^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$\",\n                dist.canonical_name,\n                flags=re.IGNORECASE,\n            )\n            if not project_name_valid:\n                logger.warning(\n                    \"Ignoring invalid distribution %s (%s)\",\n                    dist.canonical_name,\n                    dist.location,\n                )\n                continue\n            yield dist\n\n    def iter_installed_distributions(\n        self,\n        local_only: bool = True,\n        skip: Container[str] = stdlib_pkgs,\n        include_editables: bool = True,\n        editables_only: bool = False,\n        user_only: bool = False,\n    ) -> Iterator[BaseDistribution]:\n        \"\"\"Return a list of installed distributions.\n\n        This is based on ``iter_all_distributions()`` with additional filtering\n        options. Note that ``iter_installed_distributions()`` without arguments\n        is *not* equal to ``iter_all_distributions()``, since some of the\n        configurations exclude packages by default.\n\n        :param local_only: If True (default), only return installations\n        local to the current virtualenv, if in a virtualenv.\n        :param skip: An iterable of canonicalized project names to ignore;\n            defaults to ``stdlib_pkgs``.\n        :param include_editables: If False, don't report editables.\n        :param editables_only: If True, only report editables.\n        :param user_only: If True, only report installations in the user\n        site directory.\n        \"\"\"\n        it = self.iter_all_distributions()\n        if local_only:\n            it = (d for d in it if d.local)\n        if not include_editables:\n            it = (d for d in it if not d.editable)\n        if editables_only:\n            it = (d for d in it if d.editable)\n        if user_only:\n            it = (d for d in it if d.in_usersite)\n        return (d for d in it if d.canonical_name not in skip)\n\n\nclass Wheel(Protocol):\n    location: str\n\n    def as_zipfile(self) -> zipfile.ZipFile:\n        raise NotImplementedError()\n\n\nclass FilesystemWheel(Wheel):\n    def __init__(self, location: str) -> None:\n        self.location = location\n\n    def as_zipfile(self) -> zipfile.ZipFile:\n        return zipfile.ZipFile(self.location, allowZip64=True)\n\n\nclass MemoryWheel(Wheel):\n    def __init__(self, location: str, stream: IO[bytes]) -> None:\n        self.location = location\n        self.stream = stream\n\n    def as_zipfile(self) -> zipfile.ZipFile:\n        return zipfile.ZipFile(self.stream, allowZip64=True)\n"},"hash":"ZtDQRwi50W"}