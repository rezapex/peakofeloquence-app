{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:rich:cells.py","body":"import re\nfrom functools import lru_cache\nfrom typing import Callable, List\n\nfrom ._cell_widths import CELL_WIDTHS\n\n# Regex to match sequence of the most common character ranges\n_is_single_cell_widths = re.compile(\"^[\\u0020-\\u006f\\u00a0\\u02ff\\u0370-\\u0482]*$\").match\n\n\n@lru_cache(4096)\ndef cached_cell_len(text: str) -> int:\n    \"\"\"Get the number of cells required to display text.\n\n    This method always caches, which may use up a lot of memory. It is recommended to use\n    `cell_len` over this method.\n\n    Args:\n        text (str): Text to display.\n\n    Returns:\n        int: Get the number of cells required to display text.\n    \"\"\"\n    _get_size = get_character_cell_size\n    total_size = sum(_get_size(character) for character in text)\n    return total_size\n\n\ndef cell_len(text: str, _cell_len: Callable[[str], int] = cached_cell_len) -> int:\n    \"\"\"Get the number of cells required to display text.\n\n    Args:\n        text (str): Text to display.\n\n    Returns:\n        int: Get the number of cells required to display text.\n    \"\"\"\n    if len(text) < 512:\n        return _cell_len(text)\n    _get_size = get_character_cell_size\n    total_size = sum(_get_size(character) for character in text)\n    return total_size\n\n\n@lru_cache(maxsize=4096)\ndef get_character_cell_size(character: str) -> int:\n    \"\"\"Get the cell size of a character.\n\n    Args:\n        character (str): A single character.\n\n    Returns:\n        int: Number of cells (0, 1 or 2) occupied by that character.\n    \"\"\"\n    return _get_codepoint_cell_size(ord(character))\n\n\n@lru_cache(maxsize=4096)\ndef _get_codepoint_cell_size(codepoint: int) -> int:\n    \"\"\"Get the cell size of a character.\n\n    Args:\n        codepoint (int): Codepoint of a character.\n\n    Returns:\n        int: Number of cells (0, 1 or 2) occupied by that character.\n    \"\"\"\n\n    _table = CELL_WIDTHS\n    lower_bound = 0\n    upper_bound = len(_table) - 1\n    index = (lower_bound + upper_bound) // 2\n    while True:\n        start, end, width = _table[index]\n        if codepoint < start:\n            upper_bound = index - 1\n        elif codepoint > end:\n            lower_bound = index + 1\n        else:\n            return 0 if width == -1 else width\n        if upper_bound < lower_bound:\n            break\n        index = (lower_bound + upper_bound) // 2\n    return 1\n\n\ndef set_cell_size(text: str, total: int) -> str:\n    \"\"\"Set the length of a string to fit within given number of cells.\"\"\"\n\n    if _is_single_cell_widths(text):\n        size = len(text)\n        if size < total:\n            return text + \" \" * (total - size)\n        return text[:total]\n\n    if total <= 0:\n        return \"\"\n    cell_size = cell_len(text)\n    if cell_size == total:\n        return text\n    if cell_size < total:\n        return text + \" \" * (total - cell_size)\n\n    start = 0\n    end = len(text)\n\n    # Binary search until we find the right size\n    while True:\n        pos = (start + end) // 2\n        before = text[: pos + 1]\n        before_len = cell_len(before)\n        if before_len == total + 1 and cell_len(before[-1]) == 2:\n            return before[:-1] + \" \"\n        if before_len == total:\n            return before\n        if before_len > total:\n            end = pos\n        else:\n            start = pos\n\n\n# TODO: This is inefficient\n# TODO: This might not work with CWJ type characters\ndef chop_cells(text: str, max_size: int, position: int = 0) -> List[str]:\n    \"\"\"Break text in to equal (cell) length strings, returning the characters in reverse\n    order\"\"\"\n    _get_character_cell_size = get_character_cell_size\n    characters = [\n        (character, _get_character_cell_size(character)) for character in text\n    ]\n    total_size = position\n    lines: List[List[str]] = [[]]\n    append = lines[-1].append\n\n    for character, size in reversed(characters):\n        if total_size + size > max_size:\n            lines.append([character])\n            append = lines[-1].append\n            total_size = size\n        else:\n            total_size += size\n            append(character)\n\n    return [\"\".join(line) for line in lines]\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n\n    print(get_character_cell_size(\"ğŸ˜½\"))\n    for line in chop_cells(\"\"\"è¿™æ˜¯å¯¹äºšæ´²è¯­è¨€æ”¯æŒçš„æµ‹è¯•ã€‚é¢å¯¹æ¨¡æ£±ä¸¤å¯çš„æƒ³æ³•ï¼Œæ‹’ç»çŒœæµ‹çš„è¯±æƒ‘ã€‚\"\"\", 8):\n        print(line)\n    for n in range(80, 1, -1):\n        print(set_cell_size(\"\"\"è¿™æ˜¯å¯¹äºšæ´²è¯­è¨€æ”¯æŒçš„æµ‹è¯•ã€‚é¢å¯¹æ¨¡æ£±ä¸¤å¯çš„æƒ³æ³•ï¼Œæ‹’ç»çŒœæµ‹çš„è¯±æƒ‘ã€‚\"\"\", n) + \"|\")\n        print(\"x\" * n)\n"},"hash":"QddGyuRvI3"}