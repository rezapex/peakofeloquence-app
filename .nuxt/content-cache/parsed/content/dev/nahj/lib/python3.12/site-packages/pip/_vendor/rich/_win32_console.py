{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:rich:_win32_console.py","body":"\"\"\"Light wrapper around the Win32 Console API - this module should only be imported on Windows\n\nThe API that this module wraps is documented at https://docs.microsoft.com/en-us/windows/console/console-functions\n\"\"\"\nimport ctypes\nimport sys\nfrom typing import Any\n\nwindll: Any = None\nif sys.platform == \"win32\":\n    windll = ctypes.LibraryLoader(ctypes.WinDLL)\nelse:\n    raise ImportError(f\"{__name__} can only be imported on Windows\")\n\nimport time\nfrom ctypes import Structure, byref, wintypes\nfrom typing import IO, NamedTuple, Type, cast\n\nfrom pip._vendor.rich.color import ColorSystem\nfrom pip._vendor.rich.style import Style\n\nSTDOUT = -11\nENABLE_VIRTUAL_TERMINAL_PROCESSING = 4\n\nCOORD = wintypes._COORD\n\n\nclass LegacyWindowsError(Exception):\n    pass\n\n\nclass WindowsCoordinates(NamedTuple):\n    \"\"\"Coordinates in the Windows Console API are (y, x), not (x, y).\n    This class is intended to prevent that confusion.\n    Rows and columns are indexed from 0.\n    This class can be used in place of wintypes._COORD in arguments and argtypes.\n    \"\"\"\n\n    row: int\n    col: int\n\n    @classmethod\n    def from_param(cls, value: \"WindowsCoordinates\") -> COORD:\n        \"\"\"Converts a WindowsCoordinates into a wintypes _COORD structure.\n        This classmethod is internally called by ctypes to perform the conversion.\n\n        Args:\n            value (WindowsCoordinates): The input coordinates to convert.\n\n        Returns:\n            wintypes._COORD: The converted coordinates struct.\n        \"\"\"\n        return COORD(value.col, value.row)\n\n\nclass CONSOLE_SCREEN_BUFFER_INFO(Structure):\n    _fields_ = [\n        (\"dwSize\", COORD),\n        (\"dwCursorPosition\", COORD),\n        (\"wAttributes\", wintypes.WORD),\n        (\"srWindow\", wintypes.SMALL_RECT),\n        (\"dwMaximumWindowSize\", COORD),\n    ]\n\n\nclass CONSOLE_CURSOR_INFO(ctypes.Structure):\n    _fields_ = [(\"dwSize\", wintypes.DWORD), (\"bVisible\", wintypes.BOOL)]\n\n\n_GetStdHandle = windll.kernel32.GetStdHandle\n_GetStdHandle.argtypes = [\n    wintypes.DWORD,\n]\n_GetStdHandle.restype = wintypes.HANDLE\n\n\ndef GetStdHandle(handle: int = STDOUT) -> wintypes.HANDLE:\n    \"\"\"Retrieves a handle to the specified standard device (standard input, standard output, or standard error).\n\n    Args:\n        handle (int): Integer identifier for the handle. Defaults to -11 (stdout).\n\n    Returns:\n        wintypes.HANDLE: The handle\n    \"\"\"\n    return cast(wintypes.HANDLE, _GetStdHandle(handle))\n\n\n_GetConsoleMode = windll.kernel32.GetConsoleMode\n_GetConsoleMode.argtypes = [wintypes.HANDLE, wintypes.LPDWORD]\n_GetConsoleMode.restype = wintypes.BOOL\n\n\ndef GetConsoleMode(std_handle: wintypes.HANDLE) -> int:\n    \"\"\"Retrieves the current input mode of a console's input buffer\n    or the current output mode of a console screen buffer.\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n\n    Raises:\n        LegacyWindowsError: If any error occurs while calling the Windows console API.\n\n    Returns:\n        int: Value representing the current console mode as documented at\n            https://docs.microsoft.com/en-us/windows/console/getconsolemode#parameters\n    \"\"\"\n\n    console_mode = wintypes.DWORD()\n    success = bool(_GetConsoleMode(std_handle, console_mode))\n    if not success:\n        raise LegacyWindowsError(\"Unable to get legacy Windows Console Mode\")\n    return console_mode.value\n\n\n_FillConsoleOutputCharacterW = windll.kernel32.FillConsoleOutputCharacterW\n_FillConsoleOutputCharacterW.argtypes = [\n    wintypes.HANDLE,\n    ctypes.c_char,\n    wintypes.DWORD,\n    cast(Type[COORD], WindowsCoordinates),\n    ctypes.POINTER(wintypes.DWORD),\n]\n_FillConsoleOutputCharacterW.restype = wintypes.BOOL\n\n\ndef FillConsoleOutputCharacter(\n    std_handle: wintypes.HANDLE,\n    char: str,\n    length: int,\n    start: WindowsCoordinates,\n) -> int:\n    \"\"\"Writes a character to the console screen buffer a specified number of times, beginning at the specified coordinates.\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n        char (str): The character to write. Must be a string of length 1.\n        length (int): The number of times to write the character.\n        start (WindowsCoordinates): The coordinates to start writing at.\n\n    Returns:\n        int: The number of characters written.\n    \"\"\"\n    character = ctypes.c_char(char.encode())\n    num_characters = wintypes.DWORD(length)\n    num_written = wintypes.DWORD(0)\n    _FillConsoleOutputCharacterW(\n        std_handle,\n        character,\n        num_characters,\n        start,\n        byref(num_written),\n    )\n    return num_written.value\n\n\n_FillConsoleOutputAttribute = windll.kernel32.FillConsoleOutputAttribute\n_FillConsoleOutputAttribute.argtypes = [\n    wintypes.HANDLE,\n    wintypes.WORD,\n    wintypes.DWORD,\n    cast(Type[COORD], WindowsCoordinates),\n    ctypes.POINTER(wintypes.DWORD),\n]\n_FillConsoleOutputAttribute.restype = wintypes.BOOL\n\n\ndef FillConsoleOutputAttribute(\n    std_handle: wintypes.HANDLE,\n    attributes: int,\n    length: int,\n    start: WindowsCoordinates,\n) -> int:\n    \"\"\"Sets the character attributes for a specified number of character cells,\n    beginning at the specified coordinates in a screen buffer.\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n        attributes (int): Integer value representing the foreground and background colours of the cells.\n        length (int): The number of cells to set the output attribute of.\n        start (WindowsCoordinates): The coordinates of the first cell whose attributes are to be set.\n\n    Returns:\n        int: The number of cells whose attributes were actually set.\n    \"\"\"\n    num_cells = wintypes.DWORD(length)\n    style_attrs = wintypes.WORD(attributes)\n    num_written = wintypes.DWORD(0)\n    _FillConsoleOutputAttribute(\n        std_handle, style_attrs, num_cells, start, byref(num_written)\n    )\n    return num_written.value\n\n\n_SetConsoleTextAttribute = windll.kernel32.SetConsoleTextAttribute\n_SetConsoleTextAttribute.argtypes = [\n    wintypes.HANDLE,\n    wintypes.WORD,\n]\n_SetConsoleTextAttribute.restype = wintypes.BOOL\n\n\ndef SetConsoleTextAttribute(\n    std_handle: wintypes.HANDLE, attributes: wintypes.WORD\n) -> bool:\n    \"\"\"Set the colour attributes for all text written after this function is called.\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n        attributes (int): Integer value representing the foreground and background colours.\n\n\n    Returns:\n        bool: True if the attribute was set successfully, otherwise False.\n    \"\"\"\n    return bool(_SetConsoleTextAttribute(std_handle, attributes))\n\n\n_GetConsoleScreenBufferInfo = windll.kernel32.GetConsoleScreenBufferInfo\n_GetConsoleScreenBufferInfo.argtypes = [\n    wintypes.HANDLE,\n    ctypes.POINTER(CONSOLE_SCREEN_BUFFER_INFO),\n]\n_GetConsoleScreenBufferInfo.restype = wintypes.BOOL\n\n\ndef GetConsoleScreenBufferInfo(\n    std_handle: wintypes.HANDLE,\n) -> CONSOLE_SCREEN_BUFFER_INFO:\n    \"\"\"Retrieves information about the specified console screen buffer.\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n\n    Returns:\n        CONSOLE_SCREEN_BUFFER_INFO: A CONSOLE_SCREEN_BUFFER_INFO ctype struct contain information about\n            screen size, cursor position, colour attributes, and more.\"\"\"\n    console_screen_buffer_info = CONSOLE_SCREEN_BUFFER_INFO()\n    _GetConsoleScreenBufferInfo(std_handle, byref(console_screen_buffer_info))\n    return console_screen_buffer_info\n\n\n_SetConsoleCursorPosition = windll.kernel32.SetConsoleCursorPosition\n_SetConsoleCursorPosition.argtypes = [\n    wintypes.HANDLE,\n    cast(Type[COORD], WindowsCoordinates),\n]\n_SetConsoleCursorPosition.restype = wintypes.BOOL\n\n\ndef SetConsoleCursorPosition(\n    std_handle: wintypes.HANDLE, coords: WindowsCoordinates\n) -> bool:\n    \"\"\"Set the position of the cursor in the console screen\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n        coords (WindowsCoordinates): The coordinates to move the cursor to.\n\n    Returns:\n        bool: True if the function succeeds, otherwise False.\n    \"\"\"\n    return bool(_SetConsoleCursorPosition(std_handle, coords))\n\n\n_GetConsoleCursorInfo = windll.kernel32.GetConsoleCursorInfo\n_GetConsoleCursorInfo.argtypes = [\n    wintypes.HANDLE,\n    ctypes.POINTER(CONSOLE_CURSOR_INFO),\n]\n_GetConsoleCursorInfo.restype = wintypes.BOOL\n\n\ndef GetConsoleCursorInfo(\n    std_handle: wintypes.HANDLE, cursor_info: CONSOLE_CURSOR_INFO\n) -> bool:\n    \"\"\"Get the cursor info - used to get cursor visibility and width\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n        cursor_info (CONSOLE_CURSOR_INFO): CONSOLE_CURSOR_INFO ctype struct that receives information\n            about the console's cursor.\n\n    Returns:\n          bool: True if the function succeeds, otherwise False.\n    \"\"\"\n    return bool(_GetConsoleCursorInfo(std_handle, byref(cursor_info)))\n\n\n_SetConsoleCursorInfo = windll.kernel32.SetConsoleCursorInfo\n_SetConsoleCursorInfo.argtypes = [\n    wintypes.HANDLE,\n    ctypes.POINTER(CONSOLE_CURSOR_INFO),\n]\n_SetConsoleCursorInfo.restype = wintypes.BOOL\n\n\ndef SetConsoleCursorInfo(\n    std_handle: wintypes.HANDLE, cursor_info: CONSOLE_CURSOR_INFO\n) -> bool:\n    \"\"\"Set the cursor info - used for adjusting cursor visibility and width\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n        cursor_info (CONSOLE_CURSOR_INFO): CONSOLE_CURSOR_INFO ctype struct containing the new cursor info.\n\n    Returns:\n          bool: True if the function succeeds, otherwise False.\n    \"\"\"\n    return bool(_SetConsoleCursorInfo(std_handle, byref(cursor_info)))\n\n\n_SetConsoleTitle = windll.kernel32.SetConsoleTitleW\n_SetConsoleTitle.argtypes = [wintypes.LPCWSTR]\n_SetConsoleTitle.restype = wintypes.BOOL\n\n\ndef SetConsoleTitle(title: str) -> bool:\n    \"\"\"Sets the title of the current console window\n\n    Args:\n        title (str): The new title of the console window.\n\n    Returns:\n        bool: True if the function succeeds, otherwise False.\n    \"\"\"\n    return bool(_SetConsoleTitle(title))\n\n\nclass LegacyWindowsTerm:\n    \"\"\"This class allows interaction with the legacy Windows Console API. It should only be used in the context\n    of environments where virtual terminal processing is not available. However, if it is used in a Windows environment,\n    the entire API should work.\n\n    Args:\n        file (IO[str]): The file which the Windows Console API HANDLE is retrieved from, defaults to sys.stdout.\n    \"\"\"\n\n    BRIGHT_BIT = 8\n\n    # Indices are ANSI color numbers, values are the corresponding Windows Console API color numbers\n    ANSI_TO_WINDOWS = [\n        0,  # black                      The Windows colours are defined in wincon.h as follows:\n        4,  # red                         define FOREGROUND_BLUE            0x0001 -- 0000 0001\n        2,  # green                       define FOREGROUND_GREEN           0x0002 -- 0000 0010\n        6,  # yellow                      define FOREGROUND_RED             0x0004 -- 0000 0100\n        1,  # blue                        define FOREGROUND_INTENSITY       0x0008 -- 0000 1000\n        5,  # magenta                     define BACKGROUND_BLUE            0x0010 -- 0001 0000\n        3,  # cyan                        define BACKGROUND_GREEN           0x0020 -- 0010 0000\n        7,  # white                       define BACKGROUND_RED             0x0040 -- 0100 0000\n        8,  # bright black (grey)         define BACKGROUND_INTENSITY       0x0080 -- 1000 0000\n        12,  # bright red\n        10,  # bright green\n        14,  # bright yellow\n        9,  # bright blue\n        13,  # bright magenta\n        11,  # bright cyan\n        15,  # bright white\n    ]\n\n    def __init__(self, file: \"IO[str]\") -> None:\n        handle = GetStdHandle(STDOUT)\n        self._handle = handle\n        default_text = GetConsoleScreenBufferInfo(handle).wAttributes\n        self._default_text = default_text\n\n        self._default_fore = default_text & 7\n        self._default_back = (default_text >> 4) & 7\n        self._default_attrs = self._default_fore | (self._default_back << 4)\n\n        self._file = file\n        self.write = file.write\n        self.flush = file.flush\n\n    @property\n    def cursor_position(self) -> WindowsCoordinates:\n        \"\"\"Returns the current position of the cursor (0-based)\n\n        Returns:\n            WindowsCoordinates: The current cursor position.\n        \"\"\"\n        coord: COORD = GetConsoleScreenBufferInfo(self._handle).dwCursorPosition\n        return WindowsCoordinates(row=cast(int, coord.Y), col=cast(int, coord.X))\n\n    @property\n    def screen_size(self) -> WindowsCoordinates:\n        \"\"\"Returns the current size of the console screen buffer, in character columns and rows\n\n        Returns:\n            WindowsCoordinates: The width and height of the screen as WindowsCoordinates.\n        \"\"\"\n        screen_size: COORD = GetConsoleScreenBufferInfo(self._handle).dwSize\n        return WindowsCoordinates(\n            row=cast(int, screen_size.Y), col=cast(int, screen_size.X)\n        )\n\n    def write_text(self, text: str) -> None:\n        \"\"\"Write text directly to the terminal without any modification of styles\n\n        Args:\n            text (str): The text to write to the console\n        \"\"\"\n        self.write(text)\n        self.flush()\n\n    def write_styled(self, text: str, style: Style) -> None:\n        \"\"\"Write styled text to the terminal.\n\n        Args:\n            text (str): The text to write\n            style (Style): The style of the text\n        \"\"\"\n        color = style.color\n        bgcolor = style.bgcolor\n        if style.reverse:\n            color, bgcolor = bgcolor, color\n\n        if color:\n            fore = color.downgrade(ColorSystem.WINDOWS).number\n            fore = fore if fore is not None else 7  # Default to ANSI 7: White\n            if style.bold:\n                fore = fore | self.BRIGHT_BIT\n            if style.dim:\n                fore = fore & ~self.BRIGHT_BIT\n            fore = self.ANSI_TO_WINDOWS[fore]\n        else:\n            fore = self._default_fore\n\n        if bgcolor:\n            back = bgcolor.downgrade(ColorSystem.WINDOWS).number\n            back = back if back is not None else 0  # Default to ANSI 0: Black\n            back = self.ANSI_TO_WINDOWS[back]\n        else:\n            back = self._default_back\n\n        assert fore is not None\n        assert back is not None\n\n        SetConsoleTextAttribute(\n            self._handle, attributes=ctypes.c_ushort(fore | (back << 4))\n        )\n        self.write_text(text)\n        SetConsoleTextAttribute(self._handle, attributes=self._default_text)\n\n    def move_cursor_to(self, new_position: WindowsCoordinates) -> None:\n        \"\"\"Set the position of the cursor\n\n        Args:\n            new_position (WindowsCoordinates): The WindowsCoordinates representing the new position of the cursor.\n        \"\"\"\n        if new_position.col < 0 or new_position.row < 0:\n            return\n        SetConsoleCursorPosition(self._handle, coords=new_position)\n\n    def erase_line(self) -> None:\n        \"\"\"Erase all content on the line the cursor is currently located at\"\"\"\n        screen_size = self.screen_size\n        cursor_position = self.cursor_position\n        cells_to_erase = screen_size.col\n        start_coordinates = WindowsCoordinates(row=cursor_position.row, col=0)\n        FillConsoleOutputCharacter(\n            self._handle, \" \", length=cells_to_erase, start=start_coordinates\n        )\n        FillConsoleOutputAttribute(\n            self._handle,\n            self._default_attrs,\n            length=cells_to_erase,\n            start=start_coordinates,\n        )\n\n    def erase_end_of_line(self) -> None:\n        \"\"\"Erase all content from the cursor position to the end of that line\"\"\"\n        cursor_position = self.cursor_position\n        cells_to_erase = self.screen_size.col - cursor_position.col\n        FillConsoleOutputCharacter(\n            self._handle, \" \", length=cells_to_erase, start=cursor_position\n        )\n        FillConsoleOutputAttribute(\n            self._handle,\n            self._default_attrs,\n            length=cells_to_erase,\n            start=cursor_position,\n        )\n\n    def erase_start_of_line(self) -> None:\n        \"\"\"Erase all content from the cursor position to the start of that line\"\"\"\n        row, col = self.cursor_position\n        start = WindowsCoordinates(row, 0)\n        FillConsoleOutputCharacter(self._handle, \" \", length=col, start=start)\n        FillConsoleOutputAttribute(\n            self._handle, self._default_attrs, length=col, start=start\n        )\n\n    def move_cursor_up(self) -> None:\n        \"\"\"Move the cursor up a single cell\"\"\"\n        cursor_position = self.cursor_position\n        SetConsoleCursorPosition(\n            self._handle,\n            coords=WindowsCoordinates(\n                row=cursor_position.row - 1, col=cursor_position.col\n            ),\n        )\n\n    def move_cursor_down(self) -> None:\n        \"\"\"Move the cursor down a single cell\"\"\"\n        cursor_position = self.cursor_position\n        SetConsoleCursorPosition(\n            self._handle,\n            coords=WindowsCoordinates(\n                row=cursor_position.row + 1,\n                col=cursor_position.col,\n            ),\n        )\n\n    def move_cursor_forward(self) -> None:\n        \"\"\"Move the cursor forward a single cell. Wrap to the next line if required.\"\"\"\n        row, col = self.cursor_position\n        if col == self.screen_size.col - 1:\n            row += 1\n            col = 0\n        else:\n            col += 1\n        SetConsoleCursorPosition(\n            self._handle, coords=WindowsCoordinates(row=row, col=col)\n        )\n\n    def move_cursor_to_column(self, column: int) -> None:\n        \"\"\"Move cursor to the column specified by the zero-based column index, staying on the same row\n\n        Args:\n            column (int): The zero-based column index to move the cursor to.\n        \"\"\"\n        row, _ = self.cursor_position\n        SetConsoleCursorPosition(self._handle, coords=WindowsCoordinates(row, column))\n\n    def move_cursor_backward(self) -> None:\n        \"\"\"Move the cursor backward a single cell. Wrap to the previous line if required.\"\"\"\n        row, col = self.cursor_position\n        if col == 0:\n            row -= 1\n            col = self.screen_size.col - 1\n        else:\n            col -= 1\n        SetConsoleCursorPosition(\n            self._handle, coords=WindowsCoordinates(row=row, col=col)\n        )\n\n    def hide_cursor(self) -> None:\n        \"\"\"Hide the cursor\"\"\"\n        current_cursor_size = self._get_cursor_size()\n        invisible_cursor = CONSOLE_CURSOR_INFO(dwSize=current_cursor_size, bVisible=0)\n        SetConsoleCursorInfo(self._handle, cursor_info=invisible_cursor)\n\n    def show_cursor(self) -> None:\n        \"\"\"Show the cursor\"\"\"\n        current_cursor_size = self._get_cursor_size()\n        visible_cursor = CONSOLE_CURSOR_INFO(dwSize=current_cursor_size, bVisible=1)\n        SetConsoleCursorInfo(self._handle, cursor_info=visible_cursor)\n\n    def set_title(self, title: str) -> None:\n        \"\"\"Set the title of the terminal window\n\n        Args:\n            title (str): The new title of the console window\n        \"\"\"\n        assert len(title) < 255, \"Console title must be less than 255 characters\"\n        SetConsoleTitle(title)\n\n    def _get_cursor_size(self) -> int:\n        \"\"\"Get the percentage of the character cell that is filled by the cursor\"\"\"\n        cursor_info = CONSOLE_CURSOR_INFO()\n        GetConsoleCursorInfo(self._handle, cursor_info=cursor_info)\n        return int(cursor_info.dwSize)\n\n\nif __name__ == \"__main__\":\n    handle = GetStdHandle()\n\n    from pip._vendor.rich.console import Console\n\n    console = Console()\n\n    term = LegacyWindowsTerm(sys.stdout)\n    term.set_title(\"Win32 Console Examples\")\n\n    style = Style(color=\"black\", bgcolor=\"red\")\n\n    heading = Style.parse(\"black on green\")\n\n    # Check colour output\n    console.rule(\"Checking colour output\")\n    console.print(\"[on red]on red!\")\n    console.print(\"[blue]blue!\")\n    console.print(\"[yellow]yellow!\")\n    console.print(\"[bold yellow]bold yellow!\")\n    console.print(\"[bright_yellow]bright_yellow!\")\n    console.print(\"[dim bright_yellow]dim bright_yellow!\")\n    console.print(\"[italic cyan]italic cyan!\")\n    console.print(\"[bold white on blue]bold white on blue!\")\n    console.print(\"[reverse bold white on blue]reverse bold white on blue!\")\n    console.print(\"[bold black on cyan]bold black on cyan!\")\n    console.print(\"[black on green]black on green!\")\n    console.print(\"[blue on green]blue on green!\")\n    console.print(\"[white on black]white on black!\")\n    console.print(\"[black on white]black on white!\")\n    console.print(\"[#1BB152 on #DA812D]#1BB152 on #DA812D!\")\n\n    # Check cursor movement\n    console.rule(\"Checking cursor movement\")\n    console.print()\n    term.move_cursor_backward()\n    term.move_cursor_backward()\n    term.write_text(\"went back and wrapped to prev line\")\n    time.sleep(1)\n    term.move_cursor_up()\n    term.write_text(\"we go up\")\n    time.sleep(1)\n    term.move_cursor_down()\n    term.write_text(\"and down\")\n    time.sleep(1)\n    term.move_cursor_up()\n    term.move_cursor_backward()\n    term.move_cursor_backward()\n    term.write_text(\"we went up and back 2\")\n    time.sleep(1)\n    term.move_cursor_down()\n    term.move_cursor_backward()\n    term.move_cursor_backward()\n    term.write_text(\"we went down and back 2\")\n    time.sleep(1)\n\n    # Check erasing of lines\n    term.hide_cursor()\n    console.print()\n    console.rule(\"Checking line erasing\")\n    console.print(\"\\n...Deleting to the start of the line...\")\n    term.write_text(\"The red arrow shows the cursor location, and direction of erase\")\n    time.sleep(1)\n    term.move_cursor_to_column(16)\n    term.write_styled(\"<\", Style.parse(\"black on red\"))\n    term.move_cursor_backward()\n    time.sleep(1)\n    term.erase_start_of_line()\n    time.sleep(1)\n\n    console.print(\"\\n\\n...And to the end of the line...\")\n    term.write_text(\"The red arrow shows the cursor location, and direction of erase\")\n    time.sleep(1)\n\n    term.move_cursor_to_column(16)\n    term.write_styled(\">\", Style.parse(\"black on red\"))\n    time.sleep(1)\n    term.erase_end_of_line()\n    time.sleep(1)\n\n    console.print(\"\\n\\n...Now the whole line will be erased...\")\n    term.write_styled(\"I'm going to disappear!\", style=Style.parse(\"black on cyan\"))\n    time.sleep(1)\n    term.erase_line()\n\n    term.show_cursor()\n    print(\"\\n\")\n"},"hash":"Irm9ywkV9q"}