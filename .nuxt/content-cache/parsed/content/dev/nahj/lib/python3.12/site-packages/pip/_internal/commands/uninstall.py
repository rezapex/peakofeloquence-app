{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:commands:uninstall.py","body":"import logging\nfrom optparse import Values\nfrom typing import List\n\nfrom pip._vendor.packaging.utils import canonicalize_name\n\nfrom pip._internal.cli import cmdoptions\nfrom pip._internal.cli.base_command import Command\nfrom pip._internal.cli.req_command import SessionCommandMixin, warn_if_run_as_root\nfrom pip._internal.cli.status_codes import SUCCESS\nfrom pip._internal.exceptions import InstallationError\nfrom pip._internal.req import parse_requirements\nfrom pip._internal.req.constructors import (\n    install_req_from_line,\n    install_req_from_parsed_requirement,\n)\nfrom pip._internal.utils.misc import (\n    check_externally_managed,\n    protect_pip_from_modification_on_windows,\n)\n\nlogger = logging.getLogger(__name__)\n\n\nclass UninstallCommand(Command, SessionCommandMixin):\n    \"\"\"\n    Uninstall packages.\n\n    pip is able to uninstall most installed packages. Known exceptions are:\n\n    - Pure distutils packages installed with ``python setup.py install``, which\n      leave behind no metadata to determine what files were installed.\n    - Script wrappers installed by ``python setup.py develop``.\n    \"\"\"\n\n    usage = \"\"\"\n      %prog [options] <package> ...\n      %prog [options] -r <requirements file> ...\"\"\"\n\n    def add_options(self) -> None:\n        self.cmd_opts.add_option(\n            \"-r\",\n            \"--requirement\",\n            dest=\"requirements\",\n            action=\"append\",\n            default=[],\n            metavar=\"file\",\n            help=(\n                \"Uninstall all the packages listed in the given requirements \"\n                \"file.  This option can be used multiple times.\"\n            ),\n        )\n        self.cmd_opts.add_option(\n            \"-y\",\n            \"--yes\",\n            dest=\"yes\",\n            action=\"store_true\",\n            help=\"Don't ask for confirmation of uninstall deletions.\",\n        )\n        self.cmd_opts.add_option(cmdoptions.root_user_action())\n        self.cmd_opts.add_option(cmdoptions.override_externally_managed())\n        self.parser.insert_option_group(0, self.cmd_opts)\n\n    def run(self, options: Values, args: List[str]) -> int:\n        session = self.get_default_session(options)\n\n        reqs_to_uninstall = {}\n        for name in args:\n            req = install_req_from_line(\n                name,\n                isolated=options.isolated_mode,\n            )\n            if req.name:\n                reqs_to_uninstall[canonicalize_name(req.name)] = req\n            else:\n                logger.warning(\n                    \"Invalid requirement: %r ignored -\"\n                    \" the uninstall command expects named\"\n                    \" requirements.\",\n                    name,\n                )\n        for filename in options.requirements:\n            for parsed_req in parse_requirements(\n                filename, options=options, session=session\n            ):\n                req = install_req_from_parsed_requirement(\n                    parsed_req, isolated=options.isolated_mode\n                )\n                if req.name:\n                    reqs_to_uninstall[canonicalize_name(req.name)] = req\n        if not reqs_to_uninstall:\n            raise InstallationError(\n                f\"You must give at least one requirement to {self.name} (see \"\n                f'\"pip help {self.name}\")'\n            )\n\n        if not options.override_externally_managed:\n            check_externally_managed()\n\n        protect_pip_from_modification_on_windows(\n            modifying_pip=\"pip\" in reqs_to_uninstall\n        )\n\n        for req in reqs_to_uninstall.values():\n            uninstall_pathset = req.uninstall(\n                auto_confirm=options.yes,\n                verbose=self.verbosity > 0,\n            )\n            if uninstall_pathset:\n                uninstall_pathset.commit()\n        if options.root_user_action == \"warn\":\n            warn_if_run_as_root()\n        return SUCCESS\n"},"hash":"27C9cTcQpJ"}