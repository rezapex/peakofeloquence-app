{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:network:utils.py","body":"from typing import Dict, Generator\n\nfrom pip._vendor.requests.models import CONTENT_CHUNK_SIZE, Response\n\nfrom pip._internal.exceptions import NetworkConnectionError\n\n# The following comments and HTTP headers were originally added by\n# Donald Stufft in git commit 22c562429a61bb77172039e480873fb239dd8c03.\n#\n# We use Accept-Encoding: identity here because requests defaults to\n# accepting compressed responses. This breaks in a variety of ways\n# depending on how the server is configured.\n# - Some servers will notice that the file isn't a compressible file\n#   and will leave the file alone and with an empty Content-Encoding\n# - Some servers will notice that the file is already compressed and\n#   will leave the file alone, adding a Content-Encoding: gzip header\n# - Some servers won't notice anything at all and will take a file\n#   that's already been compressed and compress it again, and set\n#   the Content-Encoding: gzip header\n# By setting this to request only the identity encoding we're hoping\n# to eliminate the third case.  Hopefully there does not exist a server\n# which when given a file will notice it is already compressed and that\n# you're not asking for a compressed file and will then decompress it\n# before sending because if that's the case I don't think it'll ever be\n# possible to make this work.\nHEADERS: Dict[str, str] = {\"Accept-Encoding\": \"identity\"}\n\n\ndef raise_for_status(resp: Response) -> None:\n    http_error_msg = \"\"\n    if isinstance(resp.reason, bytes):\n        # We attempt to decode utf-8 first because some servers\n        # choose to localize their reason strings. If the string\n        # isn't utf-8, we fall back to iso-8859-1 for all other\n        # encodings.\n        try:\n            reason = resp.reason.decode(\"utf-8\")\n        except UnicodeDecodeError:\n            reason = resp.reason.decode(\"iso-8859-1\")\n    else:\n        reason = resp.reason\n\n    if 400 <= resp.status_code < 500:\n        http_error_msg = (\n            f\"{resp.status_code} Client Error: {reason} for url: {resp.url}\"\n        )\n\n    elif 500 <= resp.status_code < 600:\n        http_error_msg = (\n            f\"{resp.status_code} Server Error: {reason} for url: {resp.url}\"\n        )\n\n    if http_error_msg:\n        raise NetworkConnectionError(http_error_msg, response=resp)\n\n\ndef response_chunks(\n    response: Response, chunk_size: int = CONTENT_CHUNK_SIZE\n) -> Generator[bytes, None, None]:\n    \"\"\"Given a requests Response, provide the data chunks.\"\"\"\n    try:\n        # Special case for urllib3.\n        for chunk in response.raw.stream(\n            chunk_size,\n            # We use decode_content=False here because we don't\n            # want urllib3 to mess with the raw bytes we get\n            # from the server. If we decompress inside of\n            # urllib3 then we cannot verify the checksum\n            # because the checksum will be of the compressed\n            # file. This breakage will only occur if the\n            # server adds a Content-Encoding header, which\n            # depends on how the server was configured:\n            # - Some servers will notice that the file isn't a\n            #   compressible file and will leave the file alone\n            #   and with an empty Content-Encoding\n            # - Some servers will notice that the file is\n            #   already compressed and will leave the file\n            #   alone and will add a Content-Encoding: gzip\n            #   header\n            # - Some servers won't notice anything at all and\n            #   will take a file that's already been compressed\n            #   and compress it again and set the\n            #   Content-Encoding: gzip header\n            #\n            # By setting this not to decode automatically we\n            # hope to eliminate problems with the second case.\n            decode_content=False,\n        ):\n            yield chunk\n    except AttributeError:\n        # Standard file-like object.\n        while True:\n            chunk = response.raw.read(chunk_size)\n            if not chunk:\n                break\n            yield chunk\n"},"hash":"yra258p2b6"}