{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:truststore:_openssl.py","body":"import contextlib\nimport os\nimport re\nimport ssl\nimport typing\n\n# candidates based on https://github.com/tiran/certifi-system-store by Christian Heimes\n_CA_FILE_CANDIDATES = [\n    # Alpine, Arch, Fedora 34+, OpenWRT, RHEL 9+, BSD\n    \"/etc/ssl/cert.pem\",\n    # Fedora <= 34, RHEL <= 9, CentOS <= 9\n    \"/etc/pki/tls/cert.pem\",\n    # Debian, Ubuntu (requires ca-certificates)\n    \"/etc/ssl/certs/ca-certificates.crt\",\n    # SUSE\n    \"/etc/ssl/ca-bundle.pem\",\n]\n\n_HASHED_CERT_FILENAME_RE = re.compile(r\"^[0-9a-fA-F]{8}\\.[0-9]$\")\n\n\n@contextlib.contextmanager\ndef _configure_context(ctx: ssl.SSLContext) -> typing.Iterator[None]:\n    # First, check whether the default locations from OpenSSL\n    # seem like they will give us a usable set of CA certs.\n    # ssl.get_default_verify_paths already takes care of:\n    # - getting cafile from either the SSL_CERT_FILE env var\n    #   or the path configured when OpenSSL was compiled,\n    #   and verifying that that path exists\n    # - getting capath from either the SSL_CERT_DIR env var\n    #   or the path configured when OpenSSL was compiled,\n    #   and verifying that that path exists\n    # In addition we'll check whether capath appears to contain certs.\n    defaults = ssl.get_default_verify_paths()\n    if defaults.cafile or (defaults.capath and _capath_contains_certs(defaults.capath)):\n        ctx.set_default_verify_paths()\n    else:\n        # cafile from OpenSSL doesn't exist\n        # and capath from OpenSSL doesn't contain certs.\n        # Let's search other common locations instead.\n        for cafile in _CA_FILE_CANDIDATES:\n            if os.path.isfile(cafile):\n                ctx.load_verify_locations(cafile=cafile)\n                break\n\n    yield\n\n\ndef _capath_contains_certs(capath: str) -> bool:\n    \"\"\"Check whether capath exists and contains certs in the expected format.\"\"\"\n    if not os.path.isdir(capath):\n        return False\n    for name in os.listdir(capath):\n        if _HASHED_CERT_FILENAME_RE.match(name):\n            return True\n    return False\n\n\ndef _verify_peercerts_impl(\n    ssl_context: ssl.SSLContext,\n    cert_chain: list[bytes],\n    server_hostname: str | None = None,\n) -> None:\n    # This is a no-op because we've enabled SSLContext's built-in\n    # verification via verify_mode=CERT_REQUIRED, and don't need to repeat it.\n    pass\n"},"hash":"pkw4wKDMLd"}