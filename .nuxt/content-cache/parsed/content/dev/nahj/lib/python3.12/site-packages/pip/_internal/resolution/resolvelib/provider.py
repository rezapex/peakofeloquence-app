{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:resolution:resolvelib:provider.py","body":"import collections\nimport math\nfrom typing import (\n    TYPE_CHECKING,\n    Dict,\n    Iterable,\n    Iterator,\n    Mapping,\n    Sequence,\n    TypeVar,\n    Union,\n)\n\nfrom pip._vendor.resolvelib.providers import AbstractProvider\n\nfrom .base import Candidate, Constraint, Requirement\nfrom .candidates import REQUIRES_PYTHON_IDENTIFIER\nfrom .factory import Factory\n\nif TYPE_CHECKING:\n    from pip._vendor.resolvelib.providers import Preference\n    from pip._vendor.resolvelib.resolvers import RequirementInformation\n\n    PreferenceInformation = RequirementInformation[Requirement, Candidate]\n\n    _ProviderBase = AbstractProvider[Requirement, Candidate, str]\nelse:\n    _ProviderBase = AbstractProvider\n\n# Notes on the relationship between the provider, the factory, and the\n# candidate and requirement classes.\n#\n# The provider is a direct implementation of the resolvelib class. Its role\n# is to deliver the API that resolvelib expects.\n#\n# Rather than work with completely abstract \"requirement\" and \"candidate\"\n# concepts as resolvelib does, pip has concrete classes implementing these two\n# ideas. The API of Requirement and Candidate objects are defined in the base\n# classes, but essentially map fairly directly to the equivalent provider\n# methods. In particular, `find_matches` and `is_satisfied_by` are\n# requirement methods, and `get_dependencies` is a candidate method.\n#\n# The factory is the interface to pip's internal mechanisms. It is stateless,\n# and is created by the resolver and held as a property of the provider. It is\n# responsible for creating Requirement and Candidate objects, and provides\n# services to those objects (access to pip's finder and preparer).\n\n\nD = TypeVar(\"D\")\nV = TypeVar(\"V\")\n\n\ndef _get_with_identifier(\n    mapping: Mapping[str, V],\n    identifier: str,\n    default: D,\n) -> Union[D, V]:\n    \"\"\"Get item from a package name lookup mapping with a resolver identifier.\n\n    This extra logic is needed when the target mapping is keyed by package\n    name, which cannot be directly looked up with an identifier (which may\n    contain requested extras). Additional logic is added to also look up a value\n    by \"cleaning up\" the extras from the identifier.\n    \"\"\"\n    if identifier in mapping:\n        return mapping[identifier]\n    # HACK: Theoretically we should check whether this identifier is a valid\n    # \"NAME[EXTRAS]\" format, and parse out the name part with packaging or\n    # some regular expression. But since pip's resolver only spits out three\n    # kinds of identifiers: normalized PEP 503 names, normalized names plus\n    # extras, and Requires-Python, we can cheat a bit here.\n    name, open_bracket, _ = identifier.partition(\"[\")\n    if open_bracket and name in mapping:\n        return mapping[name]\n    return default\n\n\nclass PipProvider(_ProviderBase):\n    \"\"\"Pip's provider implementation for resolvelib.\n\n    :params constraints: A mapping of constraints specified by the user. Keys\n        are canonicalized project names.\n    :params ignore_dependencies: Whether the user specified ``--no-deps``.\n    :params upgrade_strategy: The user-specified upgrade strategy.\n    :params user_requested: A set of canonicalized package names that the user\n        supplied for pip to install/upgrade.\n    \"\"\"\n\n    def __init__(\n        self,\n        factory: Factory,\n        constraints: Dict[str, Constraint],\n        ignore_dependencies: bool,\n        upgrade_strategy: str,\n        user_requested: Dict[str, int],\n    ) -> None:\n        self._factory = factory\n        self._constraints = constraints\n        self._ignore_dependencies = ignore_dependencies\n        self._upgrade_strategy = upgrade_strategy\n        self._user_requested = user_requested\n        self._known_depths: Dict[str, float] = collections.defaultdict(lambda: math.inf)\n\n    def identify(self, requirement_or_candidate: Union[Requirement, Candidate]) -> str:\n        return requirement_or_candidate.name\n\n    def get_preference(\n        self,\n        identifier: str,\n        resolutions: Mapping[str, Candidate],\n        candidates: Mapping[str, Iterator[Candidate]],\n        information: Mapping[str, Iterable[\"PreferenceInformation\"]],\n        backtrack_causes: Sequence[\"PreferenceInformation\"],\n    ) -> \"Preference\":\n        \"\"\"Produce a sort key for given requirement based on preference.\n\n        The lower the return value is, the more preferred this group of\n        arguments is.\n\n        Currently pip considers the following in order:\n\n        * Prefer if any of the known requirements is \"direct\", e.g. points to an\n          explicit URL.\n        * If equal, prefer if any requirement is \"pinned\", i.e. contains\n          operator ``===`` or ``==``.\n        * If equal, calculate an approximate \"depth\" and resolve requirements\n          closer to the user-specified requirements first. If the depth cannot\n          by determined (eg: due to no matching parents), it is considered\n          infinite.\n        * Order user-specified requirements by the order they are specified.\n        * If equal, prefers \"non-free\" requirements, i.e. contains at least one\n          operator, such as ``>=`` or ``<``.\n        * If equal, order alphabetically for consistency (helps debuggability).\n        \"\"\"\n        try:\n            next(iter(information[identifier]))\n        except StopIteration:\n            # There is no information for this identifier, so there's no known\n            # candidates.\n            has_information = False\n        else:\n            has_information = True\n\n        if has_information:\n            lookups = (r.get_candidate_lookup() for r, _ in information[identifier])\n            candidate, ireqs = zip(*lookups)\n        else:\n            candidate, ireqs = None, ()\n\n        operators = [\n            specifier.operator\n            for specifier_set in (ireq.specifier for ireq in ireqs if ireq)\n            for specifier in specifier_set\n        ]\n\n        direct = candidate is not None\n        pinned = any(op[:2] == \"==\" for op in operators)\n        unfree = bool(operators)\n\n        try:\n            requested_order: Union[int, float] = self._user_requested[identifier]\n        except KeyError:\n            requested_order = math.inf\n            if has_information:\n                parent_depths = (\n                    self._known_depths[parent.name] if parent is not None else 0.0\n                    for _, parent in information[identifier]\n                )\n                inferred_depth = min(d for d in parent_depths) + 1.0\n            else:\n                inferred_depth = math.inf\n        else:\n            inferred_depth = 1.0\n        self._known_depths[identifier] = inferred_depth\n\n        requested_order = self._user_requested.get(identifier, math.inf)\n\n        # Requires-Python has only one candidate and the check is basically\n        # free, so we always do it first to avoid needless work if it fails.\n        requires_python = identifier == REQUIRES_PYTHON_IDENTIFIER\n\n        # Prefer the causes of backtracking on the assumption that the problem\n        # resolving the dependency tree is related to the failures that caused\n        # the backtracking\n        backtrack_cause = self.is_backtrack_cause(identifier, backtrack_causes)\n\n        return (\n            not requires_python,\n            not direct,\n            not pinned,\n            not backtrack_cause,\n            inferred_depth,\n            requested_order,\n            not unfree,\n            identifier,\n        )\n\n    def find_matches(\n        self,\n        identifier: str,\n        requirements: Mapping[str, Iterator[Requirement]],\n        incompatibilities: Mapping[str, Iterator[Candidate]],\n    ) -> Iterable[Candidate]:\n        def _eligible_for_upgrade(identifier: str) -> bool:\n            \"\"\"Are upgrades allowed for this project?\n\n            This checks the upgrade strategy, and whether the project was one\n            that the user specified in the command line, in order to decide\n            whether we should upgrade if there's a newer version available.\n\n            (Note that we don't need access to the `--upgrade` flag, because\n            an upgrade strategy of \"to-satisfy-only\" means that `--upgrade`\n            was not specified).\n            \"\"\"\n            if self._upgrade_strategy == \"eager\":\n                return True\n            elif self._upgrade_strategy == \"only-if-needed\":\n                user_order = _get_with_identifier(\n                    self._user_requested,\n                    identifier,\n                    default=None,\n                )\n                return user_order is not None\n            return False\n\n        constraint = _get_with_identifier(\n            self._constraints,\n            identifier,\n            default=Constraint.empty(),\n        )\n        return self._factory.find_candidates(\n            identifier=identifier,\n            requirements=requirements,\n            constraint=constraint,\n            prefers_installed=(not _eligible_for_upgrade(identifier)),\n            incompatibilities=incompatibilities,\n        )\n\n    def is_satisfied_by(self, requirement: Requirement, candidate: Candidate) -> bool:\n        return requirement.is_satisfied_by(candidate)\n\n    def get_dependencies(self, candidate: Candidate) -> Sequence[Requirement]:\n        with_requires = not self._ignore_dependencies\n        return [r for r in candidate.iter_dependencies(with_requires) if r is not None]\n\n    @staticmethod\n    def is_backtrack_cause(\n        identifier: str, backtrack_causes: Sequence[\"PreferenceInformation\"]\n    ) -> bool:\n        for backtrack_cause in backtrack_causes:\n            if identifier == backtrack_cause.requirement.name:\n                return True\n            if backtrack_cause.parent and identifier == backtrack_cause.parent.name:\n                return True\n        return False\n"},"hash":"6noGKgM95T"}