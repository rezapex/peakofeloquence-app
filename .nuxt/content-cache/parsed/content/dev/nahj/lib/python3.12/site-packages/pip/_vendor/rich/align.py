{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:rich:align.py","body":"import sys\nfrom itertools import chain\nfrom typing import TYPE_CHECKING, Iterable, Optional\n\nif sys.version_info >= (3, 8):\n    from typing import Literal\nelse:\n    from pip._vendor.typing_extensions import Literal  # pragma: no cover\n\nfrom .constrain import Constrain\nfrom .jupyter import JupyterMixin\nfrom .measure import Measurement\nfrom .segment import Segment\nfrom .style import StyleType\n\nif TYPE_CHECKING:\n    from .console import Console, ConsoleOptions, RenderableType, RenderResult\n\nAlignMethod = Literal[\"left\", \"center\", \"right\"]\nVerticalAlignMethod = Literal[\"top\", \"middle\", \"bottom\"]\n\n\nclass Align(JupyterMixin):\n    \"\"\"Align a renderable by adding spaces if necessary.\n\n    Args:\n        renderable (RenderableType): A console renderable.\n        align (AlignMethod): One of \"left\", \"center\", or \"right\"\"\n        style (StyleType, optional): An optional style to apply to the background.\n        vertical (Optional[VerticalAlginMethod], optional): Optional vertical align, one of \"top\", \"middle\", or \"bottom\". Defaults to None.\n        pad (bool, optional): Pad the right with spaces. Defaults to True.\n        width (int, optional): Restrict contents to given width, or None to use default width. Defaults to None.\n        height (int, optional): Set height of align renderable, or None to fit to contents. Defaults to None.\n\n    Raises:\n        ValueError: if ``align`` is not one of the expected values.\n    \"\"\"\n\n    def __init__(\n        self,\n        renderable: \"RenderableType\",\n        align: AlignMethod = \"left\",\n        style: Optional[StyleType] = None,\n        *,\n        vertical: Optional[VerticalAlignMethod] = None,\n        pad: bool = True,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n    ) -> None:\n        if align not in (\"left\", \"center\", \"right\"):\n            raise ValueError(\n                f'invalid value for align, expected \"left\", \"center\", or \"right\" (not {align!r})'\n            )\n        if vertical is not None and vertical not in (\"top\", \"middle\", \"bottom\"):\n            raise ValueError(\n                f'invalid value for vertical, expected \"top\", \"middle\", or \"bottom\" (not {vertical!r})'\n            )\n        self.renderable = renderable\n        self.align = align\n        self.style = style\n        self.vertical = vertical\n        self.pad = pad\n        self.width = width\n        self.height = height\n\n    def __repr__(self) -> str:\n        return f\"Align({self.renderable!r}, {self.align!r})\"\n\n    @classmethod\n    def left(\n        cls,\n        renderable: \"RenderableType\",\n        style: Optional[StyleType] = None,\n        *,\n        vertical: Optional[VerticalAlignMethod] = None,\n        pad: bool = True,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n    ) -> \"Align\":\n        \"\"\"Align a renderable to the left.\"\"\"\n        return cls(\n            renderable,\n            \"left\",\n            style=style,\n            vertical=vertical,\n            pad=pad,\n            width=width,\n            height=height,\n        )\n\n    @classmethod\n    def center(\n        cls,\n        renderable: \"RenderableType\",\n        style: Optional[StyleType] = None,\n        *,\n        vertical: Optional[VerticalAlignMethod] = None,\n        pad: bool = True,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n    ) -> \"Align\":\n        \"\"\"Align a renderable to the center.\"\"\"\n        return cls(\n            renderable,\n            \"center\",\n            style=style,\n            vertical=vertical,\n            pad=pad,\n            width=width,\n            height=height,\n        )\n\n    @classmethod\n    def right(\n        cls,\n        renderable: \"RenderableType\",\n        style: Optional[StyleType] = None,\n        *,\n        vertical: Optional[VerticalAlignMethod] = None,\n        pad: bool = True,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n    ) -> \"Align\":\n        \"\"\"Align a renderable to the right.\"\"\"\n        return cls(\n            renderable,\n            \"right\",\n            style=style,\n            vertical=vertical,\n            pad=pad,\n            width=width,\n            height=height,\n        )\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        align = self.align\n        width = console.measure(self.renderable, options=options).maximum\n        rendered = console.render(\n            Constrain(\n                self.renderable, width if self.width is None else min(width, self.width)\n            ),\n            options.update(height=None),\n        )\n        lines = list(Segment.split_lines(rendered))\n        width, height = Segment.get_shape(lines)\n        lines = Segment.set_shape(lines, width, height)\n        new_line = Segment.line()\n        excess_space = options.max_width - width\n        style = console.get_style(self.style) if self.style is not None else None\n\n        def generate_segments() -> Iterable[Segment]:\n            if excess_space <= 0:\n                # Exact fit\n                for line in lines:\n                    yield from line\n                    yield new_line\n\n            elif align == \"left\":\n                # Pad on the right\n                pad = Segment(\" \" * excess_space, style) if self.pad else None\n                for line in lines:\n                    yield from line\n                    if pad:\n                        yield pad\n                    yield new_line\n\n            elif align == \"center\":\n                # Pad left and right\n                left = excess_space // 2\n                pad = Segment(\" \" * left, style)\n                pad_right = (\n                    Segment(\" \" * (excess_space - left), style) if self.pad else None\n                )\n                for line in lines:\n                    if left:\n                        yield pad\n                    yield from line\n                    if pad_right:\n                        yield pad_right\n                    yield new_line\n\n            elif align == \"right\":\n                # Padding on left\n                pad = Segment(\" \" * excess_space, style)\n                for line in lines:\n                    yield pad\n                    yield from line\n                    yield new_line\n\n        blank_line = (\n            Segment(f\"{' ' * (self.width or options.max_width)}\\n\", style)\n            if self.pad\n            else Segment(\"\\n\")\n        )\n\n        def blank_lines(count: int) -> Iterable[Segment]:\n            if count > 0:\n                for _ in range(count):\n                    yield blank_line\n\n        vertical_height = self.height or options.height\n        iter_segments: Iterable[Segment]\n        if self.vertical and vertical_height is not None:\n            if self.vertical == \"top\":\n                bottom_space = vertical_height - height\n                iter_segments = chain(generate_segments(), blank_lines(bottom_space))\n            elif self.vertical == \"middle\":\n                top_space = (vertical_height - height) // 2\n                bottom_space = vertical_height - top_space - height\n                iter_segments = chain(\n                    blank_lines(top_space),\n                    generate_segments(),\n                    blank_lines(bottom_space),\n                )\n            else:  #  self.vertical == \"bottom\":\n                top_space = vertical_height - height\n                iter_segments = chain(blank_lines(top_space), generate_segments())\n        else:\n            iter_segments = generate_segments()\n        if self.style:\n            style = console.get_style(self.style)\n            iter_segments = Segment.apply_style(iter_segments, style)\n        yield from iter_segments\n\n    def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> Measurement:\n        measurement = Measurement.get(console, options, self.renderable)\n        return measurement\n\n\nclass VerticalCenter(JupyterMixin):\n    \"\"\"Vertically aligns a renderable.\n\n    Warn:\n        This class is deprecated and may be removed in a future version. Use Align class with\n        `vertical=\"middle\"`.\n\n    Args:\n        renderable (RenderableType): A renderable object.\n    \"\"\"\n\n    def __init__(\n        self,\n        renderable: \"RenderableType\",\n        style: Optional[StyleType] = None,\n    ) -> None:\n        self.renderable = renderable\n        self.style = style\n\n    def __repr__(self) -> str:\n        return f\"VerticalCenter({self.renderable!r})\"\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        style = console.get_style(self.style) if self.style is not None else None\n        lines = console.render_lines(\n            self.renderable, options.update(height=None), pad=False\n        )\n        width, _height = Segment.get_shape(lines)\n        new_line = Segment.line()\n        height = options.height or options.size.height\n        top_space = (height - len(lines)) // 2\n        bottom_space = height - top_space - len(lines)\n        blank_line = Segment(f\"{' ' * width}\", style)\n\n        def blank_lines(count: int) -> Iterable[Segment]:\n            for _ in range(count):\n                yield blank_line\n                yield new_line\n\n        if top_space > 0:\n            yield from blank_lines(top_space)\n        for line in lines:\n            yield from line\n            yield new_line\n        if bottom_space > 0:\n            yield from blank_lines(bottom_space)\n\n    def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> Measurement:\n        measurement = Measurement.get(console, options, self.renderable)\n        return measurement\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    from pip._vendor.rich.console import Console, Group\n    from pip._vendor.rich.highlighter import ReprHighlighter\n    from pip._vendor.rich.panel import Panel\n\n    highlighter = ReprHighlighter()\n    console = Console()\n\n    panel = Panel(\n        Group(\n            Align.left(highlighter(\"align='left'\")),\n            Align.center(highlighter(\"align='center'\")),\n            Align.right(highlighter(\"align='right'\")),\n        ),\n        width=60,\n        style=\"on dark_blue\",\n        title=\"Align\",\n    )\n\n    console.print(\n        Align.center(panel, vertical=\"middle\", style=\"on red\", height=console.height)\n    )\n"},"hash":"bDHLgFviJz"}