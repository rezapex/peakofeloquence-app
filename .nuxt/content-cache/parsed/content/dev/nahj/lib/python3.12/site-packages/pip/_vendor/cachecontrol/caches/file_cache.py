{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:cachecontrol:caches:file_cache.py","body":"# SPDX-FileCopyrightText: 2015 Eric Larson\n#\n# SPDX-License-Identifier: Apache-2.0\nfrom __future__ import annotations\n\nimport hashlib\nimport os\nfrom textwrap import dedent\nfrom typing import IO, TYPE_CHECKING\n\nfrom pip._vendor.cachecontrol.cache import BaseCache, SeparateBodyBaseCache\nfrom pip._vendor.cachecontrol.controller import CacheController\n\nif TYPE_CHECKING:\n    from datetime import datetime\n\n    from filelock import BaseFileLock\n\n\ndef _secure_open_write(filename: str, fmode: int) -> IO[bytes]:\n    # We only want to write to this file, so open it in write only mode\n    flags = os.O_WRONLY\n\n    # os.O_CREAT | os.O_EXCL will fail if the file already exists, so we only\n    #  will open *new* files.\n    # We specify this because we want to ensure that the mode we pass is the\n    # mode of the file.\n    flags |= os.O_CREAT | os.O_EXCL\n\n    # Do not follow symlinks to prevent someone from making a symlink that\n    # we follow and insecurely open a cache file.\n    if hasattr(os, \"O_NOFOLLOW\"):\n        flags |= os.O_NOFOLLOW\n\n    # On Windows we'll mark this file as binary\n    if hasattr(os, \"O_BINARY\"):\n        flags |= os.O_BINARY\n\n    # Before we open our file, we want to delete any existing file that is\n    # there\n    try:\n        os.remove(filename)\n    except OSError:\n        # The file must not exist already, so we can just skip ahead to opening\n        pass\n\n    # Open our file, the use of os.O_CREAT | os.O_EXCL will ensure that if a\n    # race condition happens between the os.remove and this line, that an\n    # error will be raised. Because we utilize a lockfile this should only\n    # happen if someone is attempting to attack us.\n    fd = os.open(filename, flags, fmode)\n    try:\n        return os.fdopen(fd, \"wb\")\n\n    except:\n        # An error occurred wrapping our FD in a file object\n        os.close(fd)\n        raise\n\n\nclass _FileCacheMixin:\n    \"\"\"Shared implementation for both FileCache variants.\"\"\"\n\n    def __init__(\n        self,\n        directory: str,\n        forever: bool = False,\n        filemode: int = 0o0600,\n        dirmode: int = 0o0700,\n        lock_class: type[BaseFileLock] | None = None,\n    ) -> None:\n        try:\n            if lock_class is None:\n                from filelock import FileLock\n\n                lock_class = FileLock\n        except ImportError:\n            notice = dedent(\n                \"\"\"\n            NOTE: In order to use the FileCache you must have\n            filelock installed. You can install it via pip:\n              pip install filelock\n            \"\"\"\n            )\n            raise ImportError(notice)\n\n        self.directory = directory\n        self.forever = forever\n        self.filemode = filemode\n        self.dirmode = dirmode\n        self.lock_class = lock_class\n\n    @staticmethod\n    def encode(x: str) -> str:\n        return hashlib.sha224(x.encode()).hexdigest()\n\n    def _fn(self, name: str) -> str:\n        # NOTE: This method should not change as some may depend on it.\n        #       See: https://github.com/ionrock/cachecontrol/issues/63\n        hashed = self.encode(name)\n        parts = list(hashed[:5]) + [hashed]\n        return os.path.join(self.directory, *parts)\n\n    def get(self, key: str) -> bytes | None:\n        name = self._fn(key)\n        try:\n            with open(name, \"rb\") as fh:\n                return fh.read()\n\n        except FileNotFoundError:\n            return None\n\n    def set(\n        self, key: str, value: bytes, expires: int | datetime | None = None\n    ) -> None:\n        name = self._fn(key)\n        self._write(name, value)\n\n    def _write(self, path: str, data: bytes) -> None:\n        \"\"\"\n        Safely write the data to the given path.\n        \"\"\"\n        # Make sure the directory exists\n        try:\n            os.makedirs(os.path.dirname(path), self.dirmode)\n        except OSError:\n            pass\n\n        with self.lock_class(path + \".lock\"):\n            # Write our actual file\n            with _secure_open_write(path, self.filemode) as fh:\n                fh.write(data)\n\n    def _delete(self, key: str, suffix: str) -> None:\n        name = self._fn(key) + suffix\n        if not self.forever:\n            try:\n                os.remove(name)\n            except FileNotFoundError:\n                pass\n\n\nclass FileCache(_FileCacheMixin, BaseCache):\n    \"\"\"\n    Traditional FileCache: body is stored in memory, so not suitable for large\n    downloads.\n    \"\"\"\n\n    def delete(self, key: str) -> None:\n        self._delete(key, \"\")\n\n\nclass SeparateBodyFileCache(_FileCacheMixin, SeparateBodyBaseCache):\n    \"\"\"\n    Memory-efficient FileCache: body is stored in a separate file, reducing\n    peak memory usage.\n    \"\"\"\n\n    def get_body(self, key: str) -> IO[bytes] | None:\n        name = self._fn(key) + \".body\"\n        try:\n            return open(name, \"rb\")\n        except FileNotFoundError:\n            return None\n\n    def set_body(self, key: str, body: bytes) -> None:\n        name = self._fn(key) + \".body\"\n        self._write(name, body)\n\n    def delete(self, key: str) -> None:\n        self._delete(key, \"\")\n        self._delete(key, \".body\")\n\n\ndef url_to_file_path(url: str, filecache: FileCache) -> str:\n    \"\"\"Return the file cache path based on the URL.\n\n    This does not ensure the file exists!\n    \"\"\"\n    key = CacheController.cache_url(url)\n    return filecache._fn(key)\n"},"hash":"rMq4XBDbTA"}