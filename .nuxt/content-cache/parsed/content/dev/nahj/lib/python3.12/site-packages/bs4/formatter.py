{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:bs4:formatter.py","body":"from bs4.dammit import EntitySubstitution\n\nclass Formatter(EntitySubstitution):\n    \"\"\"Describes a strategy to use when outputting a parse tree to a string.\n\n    Some parts of this strategy come from the distinction between\n    HTML4, HTML5, and XML. Others are configurable by the user.\n\n    Formatters are passed in as the `formatter` argument to methods\n    like `PageElement.encode`. Most people won't need to think about\n    formatters, and most people who need to think about them can pass\n    in one of these predefined strings as `formatter` rather than\n    making a new Formatter object:\n\n    For HTML documents:\n     * 'html' - HTML entity substitution for generic HTML documents. (default)\n     * 'html5' - HTML entity substitution for HTML5 documents, as\n                 well as some optimizations in the way tags are rendered.\n     * 'minimal' - Only make the substitutions necessary to guarantee\n                   valid HTML.\n     * None - Do not perform any substitution. This will be faster\n              but may result in invalid markup.\n\n    For XML documents:\n     * 'html' - Entity substitution for XHTML documents.\n     * 'minimal' - Only make the substitutions necessary to guarantee\n                   valid XML. (default)\n     * None - Do not perform any substitution. This will be faster\n              but may result in invalid markup.\n    \"\"\"\n    # Registries of XML and HTML formatters.\n    XML_FORMATTERS = {}\n    HTML_FORMATTERS = {}\n\n    HTML = 'html'\n    XML = 'xml'\n\n    HTML_DEFAULTS = dict(\n        cdata_containing_tags=set([\"script\", \"style\"]),\n    )\n\n    def _default(self, language, value, kwarg):\n        if value is not None:\n            return value\n        if language == self.XML:\n            return set()\n        return self.HTML_DEFAULTS[kwarg]\n\n    def __init__(\n            self, language=None, entity_substitution=None,\n            void_element_close_prefix='/', cdata_containing_tags=None,\n            empty_attributes_are_booleans=False, indent=1,\n    ):\n        r\"\"\"Constructor.\n\n        :param language: This should be Formatter.XML if you are formatting\n           XML markup and Formatter.HTML if you are formatting HTML markup.\n\n        :param entity_substitution: A function to call to replace special\n           characters with XML/HTML entities. For examples, see \n           bs4.dammit.EntitySubstitution.substitute_html and substitute_xml.\n        :param void_element_close_prefix: By default, void elements\n           are represented as <tag/> (XML rules) rather than <tag>\n           (HTML rules). To get <tag>, pass in the empty string.\n        :param cdata_containing_tags: The list of tags that are defined\n           as containing CDATA in this dialect. For example, in HTML,\n           <script> and <style> tags are defined as containing CDATA,\n           and their contents should not be formatted.\n        :param blank_attributes_are_booleans: Render attributes whose value\n            is the empty string as HTML-style boolean attributes.\n            (Attributes whose value is None are always rendered this way.)\n\n        :param indent: If indent is a non-negative integer or string,\n            then the contents of elements will be indented\n            appropriately when pretty-printing. An indent level of 0,\n            negative, or \"\" will only insert newlines. Using a\n            positive integer indent indents that many spaces per\n            level. If indent is a string (such as \"\\t\"), that string\n            is used to indent each level. The default behavior is to\n            indent one space per level.\n        \"\"\"\n        self.language = language\n        self.entity_substitution = entity_substitution\n        self.void_element_close_prefix = void_element_close_prefix\n        self.cdata_containing_tags = self._default(\n            language, cdata_containing_tags, 'cdata_containing_tags'\n        )\n        self.empty_attributes_are_booleans=empty_attributes_are_booleans\n        if indent is None:\n            indent = 0\n        if isinstance(indent, int):\n            if indent < 0:\n                indent = 0\n            indent = ' ' * indent\n        elif isinstance(indent, str):\n            indent = indent\n        else:\n            indent = ' '\n        self.indent = indent\n\n    def substitute(self, ns):\n        \"\"\"Process a string that needs to undergo entity substitution.\n        This may be a string encountered in an attribute value or as\n        text.\n\n        :param ns: A string.\n        :return: A string with certain characters replaced by named\n           or numeric entities.\n        \"\"\"\n        if not self.entity_substitution:\n            return ns\n        from .element import NavigableString\n        if (isinstance(ns, NavigableString)\n            and ns.parent is not None\n            and ns.parent.name in self.cdata_containing_tags):\n            # Do nothing.\n            return ns\n        # Substitute.\n        return self.entity_substitution(ns)\n\n    def attribute_value(self, value):\n        \"\"\"Process the value of an attribute.\n\n        :param ns: A string.\n        :return: A string with certain characters replaced by named\n           or numeric entities.\n        \"\"\"\n        return self.substitute(value)\n    \n    def attributes(self, tag):\n        \"\"\"Reorder a tag's attributes however you want.\n        \n        By default, attributes are sorted alphabetically. This makes\n        behavior consistent between Python 2 and Python 3, and preserves\n        backwards compatibility with older versions of Beautiful Soup.\n\n        If `empty_boolean_attributes` is True, then attributes whose\n        values are set to the empty string will be treated as boolean\n        attributes.\n        \"\"\"\n        if tag.attrs is None:\n            return []\n        return sorted(\n            (k, (None if self.empty_attributes_are_booleans and v == '' else v))\n            for k, v in list(tag.attrs.items())\n        )\n   \nclass HTMLFormatter(Formatter):\n    \"\"\"A generic Formatter for HTML.\"\"\"\n    REGISTRY = {}\n    def __init__(self, *args, **kwargs):\n        super(HTMLFormatter, self).__init__(self.HTML, *args, **kwargs)\n\n    \nclass XMLFormatter(Formatter):\n    \"\"\"A generic Formatter for XML.\"\"\"\n    REGISTRY = {}\n    def __init__(self, *args, **kwargs):\n        super(XMLFormatter, self).__init__(self.XML, *args, **kwargs)\n\n\n# Set up aliases for the default formatters.\nHTMLFormatter.REGISTRY['html'] = HTMLFormatter(\n    entity_substitution=EntitySubstitution.substitute_html\n)\nHTMLFormatter.REGISTRY[\"html5\"] = HTMLFormatter(\n    entity_substitution=EntitySubstitution.substitute_html,\n    void_element_close_prefix=None,\n    empty_attributes_are_booleans=True,\n)\nHTMLFormatter.REGISTRY[\"minimal\"] = HTMLFormatter(\n    entity_substitution=EntitySubstitution.substitute_xml\n)\nHTMLFormatter.REGISTRY[None] = HTMLFormatter(\n    entity_substitution=None\n)\nXMLFormatter.REGISTRY[\"html\"] =  XMLFormatter(\n    entity_substitution=EntitySubstitution.substitute_html\n)\nXMLFormatter.REGISTRY[\"minimal\"] = XMLFormatter(\n    entity_substitution=EntitySubstitution.substitute_xml\n)\nXMLFormatter.REGISTRY[None] = Formatter(\n    Formatter(Formatter.XML, entity_substitution=None)\n)\n"},"hash":"d3flk0KqC7"}