{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:colorama:tests:ansitowin32_test.py","body":"# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.\nfrom io import StringIO, TextIOWrapper\nfrom unittest import TestCase, main\ntry:\n    from contextlib import ExitStack\nexcept ImportError:\n    # python 2\n    from contextlib2 import ExitStack\n\ntry:\n    from unittest.mock import MagicMock, Mock, patch\nexcept ImportError:\n    from mock import MagicMock, Mock, patch\n\nfrom ..ansitowin32 import AnsiToWin32, StreamWrapper\nfrom ..win32 import ENABLE_VIRTUAL_TERMINAL_PROCESSING\nfrom .utils import osname\n\n\nclass StreamWrapperTest(TestCase):\n\n    def testIsAProxy(self):\n        mockStream = Mock()\n        wrapper = StreamWrapper(mockStream, None)\n        self.assertTrue( wrapper.random_attr is mockStream.random_attr )\n\n    def testDelegatesWrite(self):\n        mockStream = Mock()\n        mockConverter = Mock()\n        wrapper = StreamWrapper(mockStream, mockConverter)\n        wrapper.write('hello')\n        self.assertTrue(mockConverter.write.call_args, (('hello',), {}))\n\n    def testDelegatesContext(self):\n        mockConverter = Mock()\n        s = StringIO()\n        with StreamWrapper(s, mockConverter) as fp:\n            fp.write(u'hello')\n        self.assertTrue(s.closed)\n\n    def testProxyNoContextManager(self):\n        mockStream = MagicMock()\n        mockStream.__enter__.side_effect = AttributeError()\n        mockConverter = Mock()\n        with self.assertRaises(AttributeError) as excinfo:\n            with StreamWrapper(mockStream, mockConverter) as wrapper:\n                wrapper.write('hello')\n\n    def test_closed_shouldnt_raise_on_closed_stream(self):\n        stream = StringIO()\n        stream.close()\n        wrapper = StreamWrapper(stream, None)\n        self.assertEqual(wrapper.closed, True)\n\n    def test_closed_shouldnt_raise_on_detached_stream(self):\n        stream = TextIOWrapper(StringIO())\n        stream.detach()\n        wrapper = StreamWrapper(stream, None)\n        self.assertEqual(wrapper.closed, True)\n\nclass AnsiToWin32Test(TestCase):\n\n    def testInit(self):\n        mockStdout = Mock()\n        auto = Mock()\n        stream = AnsiToWin32(mockStdout, autoreset=auto)\n        self.assertEqual(stream.wrapped, mockStdout)\n        self.assertEqual(stream.autoreset, auto)\n\n    @patch('colorama.ansitowin32.winterm', None)\n    @patch('colorama.ansitowin32.winapi_test', lambda *_: True)\n    def testStripIsTrueOnWindows(self):\n        with osname('nt'):\n            mockStdout = Mock()\n            stream = AnsiToWin32(mockStdout)\n            self.assertTrue(stream.strip)\n\n    def testStripIsFalseOffWindows(self):\n        with osname('posix'):\n            mockStdout = Mock(closed=False)\n            stream = AnsiToWin32(mockStdout)\n            self.assertFalse(stream.strip)\n\n    def testWriteStripsAnsi(self):\n        mockStdout = Mock()\n        stream = AnsiToWin32(mockStdout)\n        stream.wrapped = Mock()\n        stream.write_and_convert = Mock()\n        stream.strip = True\n\n        stream.write('abc')\n\n        self.assertFalse(stream.wrapped.write.called)\n        self.assertEqual(stream.write_and_convert.call_args, (('abc',), {}))\n\n    def testWriteDoesNotStripAnsi(self):\n        mockStdout = Mock()\n        stream = AnsiToWin32(mockStdout)\n        stream.wrapped = Mock()\n        stream.write_and_convert = Mock()\n        stream.strip = False\n        stream.convert = False\n\n        stream.write('abc')\n\n        self.assertFalse(stream.write_and_convert.called)\n        self.assertEqual(stream.wrapped.write.call_args, (('abc',), {}))\n\n    def assert_autoresets(self, convert, autoreset=True):\n        stream = AnsiToWin32(Mock())\n        stream.convert = convert\n        stream.reset_all = Mock()\n        stream.autoreset = autoreset\n        stream.winterm = Mock()\n\n        stream.write('abc')\n\n        self.assertEqual(stream.reset_all.called, autoreset)\n\n    def testWriteAutoresets(self):\n        self.assert_autoresets(convert=True)\n        self.assert_autoresets(convert=False)\n        self.assert_autoresets(convert=True, autoreset=False)\n        self.assert_autoresets(convert=False, autoreset=False)\n\n    def testWriteAndConvertWritesPlainText(self):\n        stream = AnsiToWin32(Mock())\n        stream.write_and_convert( 'abc' )\n        self.assertEqual( stream.wrapped.write.call_args, (('abc',), {}) )\n\n    def testWriteAndConvertStripsAllValidAnsi(self):\n        stream = AnsiToWin32(Mock())\n        stream.call_win32 = Mock()\n        data = [\n            'abc\\033[mdef',\n            'abc\\033[0mdef',\n            'abc\\033[2mdef',\n            'abc\\033[02mdef',\n            'abc\\033[002mdef',\n            'abc\\033[40mdef',\n            'abc\\033[040mdef',\n            'abc\\033[0;1mdef',\n            'abc\\033[40;50mdef',\n            'abc\\033[50;30;40mdef',\n            'abc\\033[Adef',\n            'abc\\033[0Gdef',\n            'abc\\033[1;20;128Hdef',\n        ]\n        for datum in data:\n            stream.wrapped.write.reset_mock()\n            stream.write_and_convert( datum )\n            self.assertEqual(\n               [args[0] for args in stream.wrapped.write.call_args_list],\n               [ ('abc',), ('def',) ]\n            )\n\n    def testWriteAndConvertSkipsEmptySnippets(self):\n        stream = AnsiToWin32(Mock())\n        stream.call_win32 = Mock()\n        stream.write_and_convert( '\\033[40m\\033[41m' )\n        self.assertFalse( stream.wrapped.write.called )\n\n    def testWriteAndConvertCallsWin32WithParamsAndCommand(self):\n        stream = AnsiToWin32(Mock())\n        stream.convert = True\n        stream.call_win32 = Mock()\n        stream.extract_params = Mock(return_value='params')\n        data = {\n            'abc\\033[adef':         ('a', 'params'),\n            'abc\\033[;;bdef':       ('b', 'params'),\n            'abc\\033[0cdef':        ('c', 'params'),\n            'abc\\033[;;0;;Gdef':    ('G', 'params'),\n            'abc\\033[1;20;128Hdef': ('H', 'params'),\n        }\n        for datum, expected in data.items():\n            stream.call_win32.reset_mock()\n            stream.write_and_convert( datum )\n            self.assertEqual( stream.call_win32.call_args[0], expected )\n\n    def test_reset_all_shouldnt_raise_on_closed_orig_stdout(self):\n        stream = StringIO()\n        converter = AnsiToWin32(stream)\n        stream.close()\n\n        converter.reset_all()\n\n    def test_wrap_shouldnt_raise_on_closed_orig_stdout(self):\n        stream = StringIO()\n        stream.close()\n        with \\\n            patch(\"colorama.ansitowin32.os.name\", \"nt\"), \\\n            patch(\"colorama.ansitowin32.winapi_test\", lambda: True):\n                converter = AnsiToWin32(stream)\n        self.assertTrue(converter.strip)\n        self.assertFalse(converter.convert)\n\n    def test_wrap_shouldnt_raise_on_missing_closed_attr(self):\n        with \\\n            patch(\"colorama.ansitowin32.os.name\", \"nt\"), \\\n            patch(\"colorama.ansitowin32.winapi_test\", lambda: True):\n                converter = AnsiToWin32(object())\n        self.assertTrue(converter.strip)\n        self.assertFalse(converter.convert)\n\n    def testExtractParams(self):\n        stream = AnsiToWin32(Mock())\n        data = {\n            '':               (0,),\n            ';;':             (0,),\n            '2':              (2,),\n            ';;002;;':        (2,),\n            '0;1':            (0, 1),\n            ';;003;;456;;':   (3, 456),\n            '11;22;33;44;55': (11, 22, 33, 44, 55),\n        }\n        for datum, expected in data.items():\n            self.assertEqual(stream.extract_params('m', datum), expected)\n\n    def testCallWin32UsesLookup(self):\n        listener = Mock()\n        stream = AnsiToWin32(listener)\n        stream.win32_calls = {\n            1: (lambda *_, **__: listener(11),),\n            2: (lambda *_, **__: listener(22),),\n            3: (lambda *_, **__: listener(33),),\n        }\n        stream.call_win32('m', (3, 1, 99, 2))\n        self.assertEqual(\n            [a[0][0] for a in listener.call_args_list],\n            [33, 11, 22] )\n\n    def test_osc_codes(self):\n        mockStdout = Mock()\n        stream = AnsiToWin32(mockStdout, convert=True)\n        with patch('colorama.ansitowin32.winterm') as winterm:\n            data = [\n                '\\033]0\\x07',                      # missing arguments\n                '\\033]0;foo\\x08',                  # wrong OSC command\n                '\\033]0;colorama_test_title\\x07',  # should work\n                '\\033]1;colorama_test_title\\x07',  # wrong set command\n                '\\033]2;colorama_test_title\\x07',  # should work\n                '\\033]' + ';' * 64 + '\\x08',       # see issue #247\n            ]\n            for code in data:\n                stream.write(code)\n            self.assertEqual(winterm.set_title.call_count, 2)\n\n    def test_native_windows_ansi(self):\n        with ExitStack() as stack:\n            def p(a, b):\n                stack.enter_context(patch(a, b, create=True))\n            # Pretend to be on Windows\n            p(\"colorama.ansitowin32.os.name\", \"nt\")\n            p(\"colorama.ansitowin32.winapi_test\", lambda: True)\n            p(\"colorama.win32.winapi_test\", lambda: True)\n            p(\"colorama.winterm.win32.windll\", \"non-None\")\n            p(\"colorama.winterm.get_osfhandle\", lambda _: 1234)\n\n            # Pretend that our mock stream has native ANSI support\n            p(\n                \"colorama.winterm.win32.GetConsoleMode\",\n                lambda _: ENABLE_VIRTUAL_TERMINAL_PROCESSING,\n            )\n            SetConsoleMode = Mock()\n            p(\"colorama.winterm.win32.SetConsoleMode\", SetConsoleMode)\n\n            stdout = Mock()\n            stdout.closed = False\n            stdout.isatty.return_value = True\n            stdout.fileno.return_value = 1\n\n            # Our fake console says it has native vt support, so AnsiToWin32 should\n            # enable that support and do nothing else.\n            stream = AnsiToWin32(stdout)\n            SetConsoleMode.assert_called_with(1234, ENABLE_VIRTUAL_TERMINAL_PROCESSING)\n            self.assertFalse(stream.strip)\n            self.assertFalse(stream.convert)\n            self.assertFalse(stream.should_wrap())\n\n            # Now let's pretend we're on an old Windows console, that doesn't have\n            # native ANSI support.\n            p(\"colorama.winterm.win32.GetConsoleMode\", lambda _: 0)\n            SetConsoleMode = Mock()\n            p(\"colorama.winterm.win32.SetConsoleMode\", SetConsoleMode)\n\n            stream = AnsiToWin32(stdout)\n            SetConsoleMode.assert_called_with(1234, ENABLE_VIRTUAL_TERMINAL_PROCESSING)\n            self.assertTrue(stream.strip)\n            self.assertTrue(stream.convert)\n            self.assertTrue(stream.should_wrap())\n\n\nif __name__ == '__main__':\n    main()\n"},"hash":"BC76ci8S4C"}