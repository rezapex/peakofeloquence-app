{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:resolvelib:structs.py","body":"import itertools\n\nfrom .compat import collections_abc\n\n\nclass DirectedGraph(object):\n    \"\"\"A graph structure with directed edges.\"\"\"\n\n    def __init__(self):\n        self._vertices = set()\n        self._forwards = {}  # <key> -> Set[<key>]\n        self._backwards = {}  # <key> -> Set[<key>]\n\n    def __iter__(self):\n        return iter(self._vertices)\n\n    def __len__(self):\n        return len(self._vertices)\n\n    def __contains__(self, key):\n        return key in self._vertices\n\n    def copy(self):\n        \"\"\"Return a shallow copy of this graph.\"\"\"\n        other = DirectedGraph()\n        other._vertices = set(self._vertices)\n        other._forwards = {k: set(v) for k, v in self._forwards.items()}\n        other._backwards = {k: set(v) for k, v in self._backwards.items()}\n        return other\n\n    def add(self, key):\n        \"\"\"Add a new vertex to the graph.\"\"\"\n        if key in self._vertices:\n            raise ValueError(\"vertex exists\")\n        self._vertices.add(key)\n        self._forwards[key] = set()\n        self._backwards[key] = set()\n\n    def remove(self, key):\n        \"\"\"Remove a vertex from the graph, disconnecting all edges from/to it.\"\"\"\n        self._vertices.remove(key)\n        for f in self._forwards.pop(key):\n            self._backwards[f].remove(key)\n        for t in self._backwards.pop(key):\n            self._forwards[t].remove(key)\n\n    def connected(self, f, t):\n        return f in self._backwards[t] and t in self._forwards[f]\n\n    def connect(self, f, t):\n        \"\"\"Connect two existing vertices.\n\n        Nothing happens if the vertices are already connected.\n        \"\"\"\n        if t not in self._vertices:\n            raise KeyError(t)\n        self._forwards[f].add(t)\n        self._backwards[t].add(f)\n\n    def iter_edges(self):\n        for f, children in self._forwards.items():\n            for t in children:\n                yield f, t\n\n    def iter_children(self, key):\n        return iter(self._forwards[key])\n\n    def iter_parents(self, key):\n        return iter(self._backwards[key])\n\n\nclass IteratorMapping(collections_abc.Mapping):\n    def __init__(self, mapping, accessor, appends=None):\n        self._mapping = mapping\n        self._accessor = accessor\n        self._appends = appends or {}\n\n    def __repr__(self):\n        return \"IteratorMapping({!r}, {!r}, {!r})\".format(\n            self._mapping,\n            self._accessor,\n            self._appends,\n        )\n\n    def __bool__(self):\n        return bool(self._mapping or self._appends)\n\n    __nonzero__ = __bool__  # XXX: Python 2.\n\n    def __contains__(self, key):\n        return key in self._mapping or key in self._appends\n\n    def __getitem__(self, k):\n        try:\n            v = self._mapping[k]\n        except KeyError:\n            return iter(self._appends[k])\n        return itertools.chain(self._accessor(v), self._appends.get(k, ()))\n\n    def __iter__(self):\n        more = (k for k in self._appends if k not in self._mapping)\n        return itertools.chain(self._mapping, more)\n\n    def __len__(self):\n        more = sum(1 for k in self._appends if k not in self._mapping)\n        return len(self._mapping) + more\n\n\nclass _FactoryIterableView(object):\n    \"\"\"Wrap an iterator factory returned by `find_matches()`.\n\n    Calling `iter()` on this class would invoke the underlying iterator\n    factory, making it a \"collection with ordering\" that can be iterated\n    through multiple times, but lacks random access methods presented in\n    built-in Python sequence types.\n    \"\"\"\n\n    def __init__(self, factory):\n        self._factory = factory\n        self._iterable = None\n\n    def __repr__(self):\n        return \"{}({})\".format(type(self).__name__, list(self))\n\n    def __bool__(self):\n        try:\n            next(iter(self))\n        except StopIteration:\n            return False\n        return True\n\n    __nonzero__ = __bool__  # XXX: Python 2.\n\n    def __iter__(self):\n        iterable = (\n            self._factory() if self._iterable is None else self._iterable\n        )\n        self._iterable, current = itertools.tee(iterable)\n        return current\n\n\nclass _SequenceIterableView(object):\n    \"\"\"Wrap an iterable returned by find_matches().\n\n    This is essentially just a proxy to the underlying sequence that provides\n    the same interface as `_FactoryIterableView`.\n    \"\"\"\n\n    def __init__(self, sequence):\n        self._sequence = sequence\n\n    def __repr__(self):\n        return \"{}({})\".format(type(self).__name__, self._sequence)\n\n    def __bool__(self):\n        return bool(self._sequence)\n\n    __nonzero__ = __bool__  # XXX: Python 2.\n\n    def __iter__(self):\n        return iter(self._sequence)\n\n\ndef build_iter_view(matches):\n    \"\"\"Build an iterable view from the value returned by `find_matches()`.\"\"\"\n    if callable(matches):\n        return _FactoryIterableView(matches)\n    if not isinstance(matches, collections_abc.Sequence):\n        matches = list(matches)\n    return _SequenceIterableView(matches)\n"},"hash":"2wWATgBXOw"}