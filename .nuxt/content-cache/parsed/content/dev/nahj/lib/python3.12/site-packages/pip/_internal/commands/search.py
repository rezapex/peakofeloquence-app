{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:commands:search.py","body":"import logging\nimport shutil\nimport sys\nimport textwrap\nimport xmlrpc.client\nfrom collections import OrderedDict\nfrom optparse import Values\nfrom typing import TYPE_CHECKING, Dict, List, Optional\n\nfrom pip._vendor.packaging.version import parse as parse_version\n\nfrom pip._internal.cli.base_command import Command\nfrom pip._internal.cli.req_command import SessionCommandMixin\nfrom pip._internal.cli.status_codes import NO_MATCHES_FOUND, SUCCESS\nfrom pip._internal.exceptions import CommandError\nfrom pip._internal.metadata import get_default_environment\nfrom pip._internal.models.index import PyPI\nfrom pip._internal.network.xmlrpc import PipXmlrpcTransport\nfrom pip._internal.utils.logging import indent_log\nfrom pip._internal.utils.misc import write_output\n\nif TYPE_CHECKING:\n    from typing import TypedDict\n\n    class TransformedHit(TypedDict):\n        name: str\n        summary: str\n        versions: List[str]\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass SearchCommand(Command, SessionCommandMixin):\n    \"\"\"Search for PyPI packages whose name or summary contains <query>.\"\"\"\n\n    usage = \"\"\"\n      %prog [options] <query>\"\"\"\n    ignore_require_venv = True\n\n    def add_options(self) -> None:\n        self.cmd_opts.add_option(\n            \"-i\",\n            \"--index\",\n            dest=\"index\",\n            metavar=\"URL\",\n            default=PyPI.pypi_url,\n            help=\"Base URL of Python Package Index (default %default)\",\n        )\n\n        self.parser.insert_option_group(0, self.cmd_opts)\n\n    def run(self, options: Values, args: List[str]) -> int:\n        if not args:\n            raise CommandError(\"Missing required argument (search query).\")\n        query = args\n        pypi_hits = self.search(query, options)\n        hits = transform_hits(pypi_hits)\n\n        terminal_width = None\n        if sys.stdout.isatty():\n            terminal_width = shutil.get_terminal_size()[0]\n\n        print_results(hits, terminal_width=terminal_width)\n        if pypi_hits:\n            return SUCCESS\n        return NO_MATCHES_FOUND\n\n    def search(self, query: List[str], options: Values) -> List[Dict[str, str]]:\n        index_url = options.index\n\n        session = self.get_default_session(options)\n\n        transport = PipXmlrpcTransport(index_url, session)\n        pypi = xmlrpc.client.ServerProxy(index_url, transport)\n        try:\n            hits = pypi.search({\"name\": query, \"summary\": query}, \"or\")\n        except xmlrpc.client.Fault as fault:\n            message = \"XMLRPC request failed [code: {code}]\\n{string}\".format(\n                code=fault.faultCode,\n                string=fault.faultString,\n            )\n            raise CommandError(message)\n        assert isinstance(hits, list)\n        return hits\n\n\ndef transform_hits(hits: List[Dict[str, str]]) -> List[\"TransformedHit\"]:\n    \"\"\"\n    The list from pypi is really a list of versions. We want a list of\n    packages with the list of versions stored inline. This converts the\n    list from pypi into one we can use.\n    \"\"\"\n    packages: Dict[str, \"TransformedHit\"] = OrderedDict()\n    for hit in hits:\n        name = hit[\"name\"]\n        summary = hit[\"summary\"]\n        version = hit[\"version\"]\n\n        if name not in packages.keys():\n            packages[name] = {\n                \"name\": name,\n                \"summary\": summary,\n                \"versions\": [version],\n            }\n        else:\n            packages[name][\"versions\"].append(version)\n\n            # if this is the highest version, replace summary and score\n            if version == highest_version(packages[name][\"versions\"]):\n                packages[name][\"summary\"] = summary\n\n    return list(packages.values())\n\n\ndef print_dist_installation_info(name: str, latest: str) -> None:\n    env = get_default_environment()\n    dist = env.get_distribution(name)\n    if dist is not None:\n        with indent_log():\n            if dist.version == latest:\n                write_output(\"INSTALLED: %s (latest)\", dist.version)\n            else:\n                write_output(\"INSTALLED: %s\", dist.version)\n                if parse_version(latest).pre:\n                    write_output(\n                        \"LATEST:    %s (pre-release; install\"\n                        \" with `pip install --pre`)\",\n                        latest,\n                    )\n                else:\n                    write_output(\"LATEST:    %s\", latest)\n\n\ndef print_results(\n    hits: List[\"TransformedHit\"],\n    name_column_width: Optional[int] = None,\n    terminal_width: Optional[int] = None,\n) -> None:\n    if not hits:\n        return\n    if name_column_width is None:\n        name_column_width = (\n            max(\n                [\n                    len(hit[\"name\"]) + len(highest_version(hit.get(\"versions\", [\"-\"])))\n                    for hit in hits\n                ]\n            )\n            + 4\n        )\n\n    for hit in hits:\n        name = hit[\"name\"]\n        summary = hit[\"summary\"] or \"\"\n        latest = highest_version(hit.get(\"versions\", [\"-\"]))\n        if terminal_width is not None:\n            target_width = terminal_width - name_column_width - 5\n            if target_width > 10:\n                # wrap and indent summary to fit terminal\n                summary_lines = textwrap.wrap(summary, target_width)\n                summary = (\"\\n\" + \" \" * (name_column_width + 3)).join(summary_lines)\n\n        name_latest = f\"{name} ({latest})\"\n        line = f\"{name_latest:{name_column_width}} - {summary}\"\n        try:\n            write_output(line)\n            print_dist_installation_info(name, latest)\n        except UnicodeEncodeError:\n            pass\n\n\ndef highest_version(versions: List[str]) -> str:\n    return max(versions, key=parse_version)\n"},"hash":"hu2p4w5bSx"}