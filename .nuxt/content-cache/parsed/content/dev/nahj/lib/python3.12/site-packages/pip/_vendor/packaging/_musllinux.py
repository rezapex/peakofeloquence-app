{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:packaging:_musllinux.py","body":"\"\"\"PEP 656 support.\n\nThis module implements logic to detect if the currently running Python is\nlinked against musl, and what musl version is used.\n\"\"\"\n\nimport contextlib\nimport functools\nimport operator\nimport os\nimport re\nimport struct\nimport subprocess\nimport sys\nfrom typing import IO, Iterator, NamedTuple, Optional, Tuple\n\n\ndef _read_unpacked(f: IO[bytes], fmt: str) -> Tuple[int, ...]:\n    return struct.unpack(fmt, f.read(struct.calcsize(fmt)))\n\n\ndef _parse_ld_musl_from_elf(f: IO[bytes]) -> Optional[str]:\n    \"\"\"Detect musl libc location by parsing the Python executable.\n\n    Based on: https://gist.github.com/lyssdod/f51579ae8d93c8657a5564aefc2ffbca\n    ELF header: https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html\n    \"\"\"\n    f.seek(0)\n    try:\n        ident = _read_unpacked(f, \"16B\")\n    except struct.error:\n        return None\n    if ident[:4] != tuple(b\"\\x7fELF\"):  # Invalid magic, not ELF.\n        return None\n    f.seek(struct.calcsize(\"HHI\"), 1)  # Skip file type, machine, and version.\n\n    try:\n        # e_fmt: Format for program header.\n        # p_fmt: Format for section header.\n        # p_idx: Indexes to find p_type, p_offset, and p_filesz.\n        e_fmt, p_fmt, p_idx = {\n            1: (\"IIIIHHH\", \"IIIIIIII\", (0, 1, 4)),  # 32-bit.\n            2: (\"QQQIHHH\", \"IIQQQQQQ\", (0, 2, 5)),  # 64-bit.\n        }[ident[4]]\n    except KeyError:\n        return None\n    else:\n        p_get = operator.itemgetter(*p_idx)\n\n    # Find the interpreter section and return its content.\n    try:\n        _, e_phoff, _, _, _, e_phentsize, e_phnum = _read_unpacked(f, e_fmt)\n    except struct.error:\n        return None\n    for i in range(e_phnum + 1):\n        f.seek(e_phoff + e_phentsize * i)\n        try:\n            p_type, p_offset, p_filesz = p_get(_read_unpacked(f, p_fmt))\n        except struct.error:\n            return None\n        if p_type != 3:  # Not PT_INTERP.\n            continue\n        f.seek(p_offset)\n        interpreter = os.fsdecode(f.read(p_filesz)).strip(\"\\0\")\n        if \"musl\" not in interpreter:\n            return None\n        return interpreter\n    return None\n\n\nclass _MuslVersion(NamedTuple):\n    major: int\n    minor: int\n\n\ndef _parse_musl_version(output: str) -> Optional[_MuslVersion]:\n    lines = [n for n in (n.strip() for n in output.splitlines()) if n]\n    if len(lines) < 2 or lines[0][:4] != \"musl\":\n        return None\n    m = re.match(r\"Version (\\d+)\\.(\\d+)\", lines[1])\n    if not m:\n        return None\n    return _MuslVersion(major=int(m.group(1)), minor=int(m.group(2)))\n\n\n@functools.lru_cache()\ndef _get_musl_version(executable: str) -> Optional[_MuslVersion]:\n    \"\"\"Detect currently-running musl runtime version.\n\n    This is done by checking the specified executable's dynamic linking\n    information, and invoking the loader to parse its output for a version\n    string. If the loader is musl, the output would be something like::\n\n        musl libc (x86_64)\n        Version 1.2.2\n        Dynamic Program Loader\n    \"\"\"\n    with contextlib.ExitStack() as stack:\n        try:\n            f = stack.enter_context(open(executable, \"rb\"))\n        except OSError:\n            return None\n        ld = _parse_ld_musl_from_elf(f)\n    if not ld:\n        return None\n    proc = subprocess.run([ld], stderr=subprocess.PIPE, universal_newlines=True)\n    return _parse_musl_version(proc.stderr)\n\n\ndef platform_tags(arch: str) -> Iterator[str]:\n    \"\"\"Generate musllinux tags compatible to the current platform.\n\n    :param arch: Should be the part of platform tag after the ``linux_``\n        prefix, e.g. ``x86_64``. The ``linux_`` prefix is assumed as a\n        prerequisite for the current platform to be musllinux-compatible.\n\n    :returns: An iterator of compatible musllinux tags.\n    \"\"\"\n    sys_musl = _get_musl_version(sys.executable)\n    if sys_musl is None:  # Python not dynamically linked against musl.\n        return\n    for minor in range(sys_musl.minor, -1, -1):\n        yield f\"musllinux_{sys_musl.major}_{minor}_{arch}\"\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    import sysconfig\n\n    plat = sysconfig.get_platform()\n    assert plat.startswith(\"linux-\"), \"not linux\"\n\n    print(\"plat:\", plat)\n    print(\"musl:\", _get_musl_version(sys.executable))\n    print(\"tags:\", end=\" \")\n    for t in platform_tags(re.sub(r\"[.-]\", \"_\", plat.split(\"-\", 1)[-1])):\n        print(t, end=\"\\n      \")\n"},"hash":"1HRg4me9Gk"}