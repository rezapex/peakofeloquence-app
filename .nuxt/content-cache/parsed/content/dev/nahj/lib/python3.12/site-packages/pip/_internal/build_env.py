{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:build_env.py","body":"\"\"\"Build Environment used for isolation during sdist building\n\"\"\"\n\nimport logging\nimport os\nimport pathlib\nimport site\nimport sys\nimport textwrap\nfrom collections import OrderedDict\nfrom types import TracebackType\nfrom typing import TYPE_CHECKING, Iterable, List, Optional, Set, Tuple, Type, Union\n\nfrom pip._vendor.certifi import where\nfrom pip._vendor.packaging.requirements import Requirement\nfrom pip._vendor.packaging.version import Version\n\nfrom pip import __file__ as pip_location\nfrom pip._internal.cli.spinners import open_spinner\nfrom pip._internal.locations import get_platlib, get_purelib, get_scheme\nfrom pip._internal.metadata import get_default_environment, get_environment\nfrom pip._internal.utils.subprocess import call_subprocess\nfrom pip._internal.utils.temp_dir import TempDirectory, tempdir_kinds\n\nif TYPE_CHECKING:\n    from pip._internal.index.package_finder import PackageFinder\n\nlogger = logging.getLogger(__name__)\n\n\ndef _dedup(a: str, b: str) -> Union[Tuple[str], Tuple[str, str]]:\n    return (a, b) if a != b else (a,)\n\n\nclass _Prefix:\n    def __init__(self, path: str) -> None:\n        self.path = path\n        self.setup = False\n        scheme = get_scheme(\"\", prefix=path)\n        self.bin_dir = scheme.scripts\n        self.lib_dirs = _dedup(scheme.purelib, scheme.platlib)\n\n\ndef get_runnable_pip() -> str:\n    \"\"\"Get a file to pass to a Python executable, to run the currently-running pip.\n\n    This is used to run a pip subprocess, for installing requirements into the build\n    environment.\n    \"\"\"\n    source = pathlib.Path(pip_location).resolve().parent\n\n    if not source.is_dir():\n        # This would happen if someone is using pip from inside a zip file. In that\n        # case, we can use that directly.\n        return str(source)\n\n    return os.fsdecode(source / \"__pip-runner__.py\")\n\n\ndef _get_system_sitepackages() -> Set[str]:\n    \"\"\"Get system site packages\n\n    Usually from site.getsitepackages,\n    but fallback on `get_purelib()/get_platlib()` if unavailable\n    (e.g. in a virtualenv created by virtualenv<20)\n\n    Returns normalized set of strings.\n    \"\"\"\n    if hasattr(site, \"getsitepackages\"):\n        system_sites = site.getsitepackages()\n    else:\n        # virtualenv < 20 overwrites site.py without getsitepackages\n        # fallback on get_purelib/get_platlib.\n        # this is known to miss things, but shouldn't in the cases\n        # where getsitepackages() has been removed (inside a virtualenv)\n        system_sites = [get_purelib(), get_platlib()]\n    return {os.path.normcase(path) for path in system_sites}\n\n\nclass BuildEnvironment:\n    \"\"\"Creates and manages an isolated environment to install build deps\"\"\"\n\n    def __init__(self) -> None:\n        temp_dir = TempDirectory(kind=tempdir_kinds.BUILD_ENV, globally_managed=True)\n\n        self._prefixes = OrderedDict(\n            (name, _Prefix(os.path.join(temp_dir.path, name)))\n            for name in (\"normal\", \"overlay\")\n        )\n\n        self._bin_dirs: List[str] = []\n        self._lib_dirs: List[str] = []\n        for prefix in reversed(list(self._prefixes.values())):\n            self._bin_dirs.append(prefix.bin_dir)\n            self._lib_dirs.extend(prefix.lib_dirs)\n\n        # Customize site to:\n        # - ensure .pth files are honored\n        # - prevent access to system site packages\n        system_sites = _get_system_sitepackages()\n\n        self._site_dir = os.path.join(temp_dir.path, \"site\")\n        if not os.path.exists(self._site_dir):\n            os.mkdir(self._site_dir)\n        with open(\n            os.path.join(self._site_dir, \"sitecustomize.py\"), \"w\", encoding=\"utf-8\"\n        ) as fp:\n            fp.write(\n                textwrap.dedent(\n                    \"\"\"\n                import os, site, sys\n\n                # First, drop system-sites related paths.\n                original_sys_path = sys.path[:]\n                known_paths = set()\n                for path in {system_sites!r}:\n                    site.addsitedir(path, known_paths=known_paths)\n                system_paths = set(\n                    os.path.normcase(path)\n                    for path in sys.path[len(original_sys_path):]\n                )\n                original_sys_path = [\n                    path for path in original_sys_path\n                    if os.path.normcase(path) not in system_paths\n                ]\n                sys.path = original_sys_path\n\n                # Second, add lib directories.\n                # ensuring .pth file are processed.\n                for path in {lib_dirs!r}:\n                    assert not path in sys.path\n                    site.addsitedir(path)\n                \"\"\"\n                ).format(system_sites=system_sites, lib_dirs=self._lib_dirs)\n            )\n\n    def __enter__(self) -> None:\n        self._save_env = {\n            name: os.environ.get(name, None)\n            for name in (\"PATH\", \"PYTHONNOUSERSITE\", \"PYTHONPATH\")\n        }\n\n        path = self._bin_dirs[:]\n        old_path = self._save_env[\"PATH\"]\n        if old_path:\n            path.extend(old_path.split(os.pathsep))\n\n        pythonpath = [self._site_dir]\n\n        os.environ.update(\n            {\n                \"PATH\": os.pathsep.join(path),\n                \"PYTHONNOUSERSITE\": \"1\",\n                \"PYTHONPATH\": os.pathsep.join(pythonpath),\n            }\n        )\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        for varname, old_value in self._save_env.items():\n            if old_value is None:\n                os.environ.pop(varname, None)\n            else:\n                os.environ[varname] = old_value\n\n    def check_requirements(\n        self, reqs: Iterable[str]\n    ) -> Tuple[Set[Tuple[str, str]], Set[str]]:\n        \"\"\"Return 2 sets:\n        - conflicting requirements: set of (installed, wanted) reqs tuples\n        - missing requirements: set of reqs\n        \"\"\"\n        missing = set()\n        conflicting = set()\n        if reqs:\n            env = (\n                get_environment(self._lib_dirs)\n                if hasattr(self, \"_lib_dirs\")\n                else get_default_environment()\n            )\n            for req_str in reqs:\n                req = Requirement(req_str)\n                # We're explicitly evaluating with an empty extra value, since build\n                # environments are not provided any mechanism to select specific extras.\n                if req.marker is not None and not req.marker.evaluate({\"extra\": \"\"}):\n                    continue\n                dist = env.get_distribution(req.name)\n                if not dist:\n                    missing.add(req_str)\n                    continue\n                if isinstance(dist.version, Version):\n                    installed_req_str = f\"{req.name}=={dist.version}\"\n                else:\n                    installed_req_str = f\"{req.name}==={dist.version}\"\n                if not req.specifier.contains(dist.version, prereleases=True):\n                    conflicting.add((installed_req_str, req_str))\n                # FIXME: Consider direct URL?\n        return conflicting, missing\n\n    def install_requirements(\n        self,\n        finder: \"PackageFinder\",\n        requirements: Iterable[str],\n        prefix_as_string: str,\n        *,\n        kind: str,\n    ) -> None:\n        prefix = self._prefixes[prefix_as_string]\n        assert not prefix.setup\n        prefix.setup = True\n        if not requirements:\n            return\n        self._install_requirements(\n            get_runnable_pip(),\n            finder,\n            requirements,\n            prefix,\n            kind=kind,\n        )\n\n    @staticmethod\n    def _install_requirements(\n        pip_runnable: str,\n        finder: \"PackageFinder\",\n        requirements: Iterable[str],\n        prefix: _Prefix,\n        *,\n        kind: str,\n    ) -> None:\n        args: List[str] = [\n            sys.executable,\n            pip_runnable,\n            \"install\",\n            \"--ignore-installed\",\n            \"--no-user\",\n            \"--prefix\",\n            prefix.path,\n            \"--no-warn-script-location\",\n        ]\n        if logger.getEffectiveLevel() <= logging.DEBUG:\n            args.append(\"-v\")\n        for format_control in (\"no_binary\", \"only_binary\"):\n            formats = getattr(finder.format_control, format_control)\n            args.extend(\n                (\n                    \"--\" + format_control.replace(\"_\", \"-\"),\n                    \",\".join(sorted(formats or {\":none:\"})),\n                )\n            )\n\n        index_urls = finder.index_urls\n        if index_urls:\n            args.extend([\"-i\", index_urls[0]])\n            for extra_index in index_urls[1:]:\n                args.extend([\"--extra-index-url\", extra_index])\n        else:\n            args.append(\"--no-index\")\n        for link in finder.find_links:\n            args.extend([\"--find-links\", link])\n\n        for host in finder.trusted_hosts:\n            args.extend([\"--trusted-host\", host])\n        if finder.allow_all_prereleases:\n            args.append(\"--pre\")\n        if finder.prefer_binary:\n            args.append(\"--prefer-binary\")\n        args.append(\"--\")\n        args.extend(requirements)\n        extra_environ = {\"_PIP_STANDALONE_CERT\": where()}\n        with open_spinner(f\"Installing {kind}\") as spinner:\n            call_subprocess(\n                args,\n                command_desc=f\"pip subprocess to install {kind}\",\n                spinner=spinner,\n                extra_environ=extra_environ,\n            )\n\n\nclass NoOpBuildEnvironment(BuildEnvironment):\n    \"\"\"A no-op drop-in replacement for BuildEnvironment\"\"\"\n\n    def __init__(self) -> None:\n        pass\n\n    def __enter__(self) -> None:\n        pass\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        pass\n\n    def cleanup(self) -> None:\n        pass\n\n    def install_requirements(\n        self,\n        finder: \"PackageFinder\",\n        requirements: Iterable[str],\n        prefix_as_string: str,\n        *,\n        kind: str,\n    ) -> None:\n        raise NotImplementedError()\n"},"hash":"VDW7LFsYnp"}