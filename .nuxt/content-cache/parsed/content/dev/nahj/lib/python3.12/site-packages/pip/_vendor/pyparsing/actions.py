{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:pyparsing:actions.py","body":"# actions.py\n\nfrom .exceptions import ParseException\nfrom .util import col, replaced_by_pep8\n\n\nclass OnlyOnce:\n    \"\"\"\n    Wrapper for parse actions, to ensure they are only called once.\n    \"\"\"\n\n    def __init__(self, method_call):\n        from .core import _trim_arity\n\n        self.callable = _trim_arity(method_call)\n        self.called = False\n\n    def __call__(self, s, l, t):\n        if not self.called:\n            results = self.callable(s, l, t)\n            self.called = True\n            return results\n        raise ParseException(s, l, \"OnlyOnce obj called multiple times w/out reset\")\n\n    def reset(self):\n        \"\"\"\n        Allow the associated parse action to be called once more.\n        \"\"\"\n\n        self.called = False\n\n\ndef match_only_at_col(n):\n    \"\"\"\n    Helper method for defining parse actions that require matching at\n    a specific column in the input text.\n    \"\"\"\n\n    def verify_col(strg, locn, toks):\n        if col(locn, strg) != n:\n            raise ParseException(strg, locn, f\"matched token not at column {n}\")\n\n    return verify_col\n\n\ndef replace_with(repl_str):\n    \"\"\"\n    Helper method for common parse actions that simply return\n    a literal value.  Especially useful when used with\n    :class:`transform_string<ParserElement.transform_string>` ().\n\n    Example::\n\n        num = Word(nums).set_parse_action(lambda toks: int(toks[0]))\n        na = one_of(\"N/A NA\").set_parse_action(replace_with(math.nan))\n        term = na | num\n\n        term[1, ...].parse_string(\"324 234 N/A 234\") # -> [324, 234, nan, 234]\n    \"\"\"\n    return lambda s, l, t: [repl_str]\n\n\ndef remove_quotes(s, l, t):\n    \"\"\"\n    Helper parse action for removing quotation marks from parsed\n    quoted strings.\n\n    Example::\n\n        # by default, quotation marks are included in parsed results\n        quoted_string.parse_string(\"'Now is the Winter of our Discontent'\") # -> [\"'Now is the Winter of our Discontent'\"]\n\n        # use remove_quotes to strip quotation marks from parsed results\n        quoted_string.set_parse_action(remove_quotes)\n        quoted_string.parse_string(\"'Now is the Winter of our Discontent'\") # -> [\"Now is the Winter of our Discontent\"]\n    \"\"\"\n    return t[0][1:-1]\n\n\ndef with_attribute(*args, **attr_dict):\n    \"\"\"\n    Helper to create a validating parse action to be used with start\n    tags created with :class:`make_xml_tags` or\n    :class:`make_html_tags`. Use ``with_attribute`` to qualify\n    a starting tag with a required attribute value, to avoid false\n    matches on common tags such as ``<TD>`` or ``<DIV>``.\n\n    Call ``with_attribute`` with a series of attribute names and\n    values. Specify the list of filter attributes names and values as:\n\n    - keyword arguments, as in ``(align=\"right\")``, or\n    - as an explicit dict with ``**`` operator, when an attribute\n      name is also a Python reserved word, as in ``**{\"class\":\"Customer\", \"align\":\"right\"}``\n    - a list of name-value tuples, as in ``((\"ns1:class\", \"Customer\"), (\"ns2:align\", \"right\"))``\n\n    For attribute names with a namespace prefix, you must use the second\n    form.  Attribute names are matched insensitive to upper/lower case.\n\n    If just testing for ``class`` (with or without a namespace), use\n    :class:`with_class`.\n\n    To verify that the attribute exists, but without specifying a value,\n    pass ``with_attribute.ANY_VALUE`` as the value.\n\n    Example::\n\n        html = '''\n            <div>\n            Some text\n            <div type=\"grid\">1 4 0 1 0</div>\n            <div type=\"graph\">1,3 2,3 1,1</div>\n            <div>this has no type</div>\n            </div>\n\n        '''\n        div,div_end = make_html_tags(\"div\")\n\n        # only match div tag having a type attribute with value \"grid\"\n        div_grid = div().set_parse_action(with_attribute(type=\"grid\"))\n        grid_expr = div_grid + SkipTo(div | div_end)(\"body\")\n        for grid_header in grid_expr.search_string(html):\n            print(grid_header.body)\n\n        # construct a match with any div tag having a type attribute, regardless of the value\n        div_any_type = div().set_parse_action(with_attribute(type=with_attribute.ANY_VALUE))\n        div_expr = div_any_type + SkipTo(div | div_end)(\"body\")\n        for div_header in div_expr.search_string(html):\n            print(div_header.body)\n\n    prints::\n\n        1 4 0 1 0\n\n        1 4 0 1 0\n        1,3 2,3 1,1\n    \"\"\"\n    if args:\n        attrs = args[:]\n    else:\n        attrs = attr_dict.items()\n    attrs = [(k, v) for k, v in attrs]\n\n    def pa(s, l, tokens):\n        for attrName, attrValue in attrs:\n            if attrName not in tokens:\n                raise ParseException(s, l, \"no matching attribute \" + attrName)\n            if attrValue != with_attribute.ANY_VALUE and tokens[attrName] != attrValue:\n                raise ParseException(\n                    s,\n                    l,\n                    f\"attribute {attrName!r} has value {tokens[attrName]!r}, must be {attrValue!r}\",\n                )\n\n    return pa\n\n\nwith_attribute.ANY_VALUE = object()  # type: ignore [attr-defined]\n\n\ndef with_class(classname, namespace=\"\"):\n    \"\"\"\n    Simplified version of :class:`with_attribute` when\n    matching on a div class - made difficult because ``class`` is\n    a reserved word in Python.\n\n    Example::\n\n        html = '''\n            <div>\n            Some text\n            <div class=\"grid\">1 4 0 1 0</div>\n            <div class=\"graph\">1,3 2,3 1,1</div>\n            <div>this &lt;div&gt; has no class</div>\n            </div>\n\n        '''\n        div,div_end = make_html_tags(\"div\")\n        div_grid = div().set_parse_action(with_class(\"grid\"))\n\n        grid_expr = div_grid + SkipTo(div | div_end)(\"body\")\n        for grid_header in grid_expr.search_string(html):\n            print(grid_header.body)\n\n        div_any_type = div().set_parse_action(with_class(withAttribute.ANY_VALUE))\n        div_expr = div_any_type + SkipTo(div | div_end)(\"body\")\n        for div_header in div_expr.search_string(html):\n            print(div_header.body)\n\n    prints::\n\n        1 4 0 1 0\n\n        1 4 0 1 0\n        1,3 2,3 1,1\n    \"\"\"\n    classattr = f\"{namespace}:class\" if namespace else \"class\"\n    return with_attribute(**{classattr: classname})\n\n\n# pre-PEP8 compatibility symbols\n# fmt: off\n@replaced_by_pep8(replace_with)\ndef replaceWith(): ...\n\n@replaced_by_pep8(remove_quotes)\ndef removeQuotes(): ...\n\n@replaced_by_pep8(with_attribute)\ndef withAttribute(): ...\n\n@replaced_by_pep8(with_class)\ndef withClass(): ...\n\n@replaced_by_pep8(match_only_at_col)\ndef matchOnlyAtCol(): ...\n\n# fmt: on\n"},"hash":"9GibIRTUVh"}