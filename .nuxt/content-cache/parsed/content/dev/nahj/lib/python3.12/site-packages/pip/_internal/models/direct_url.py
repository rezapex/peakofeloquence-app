{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:models:direct_url.py","body":"\"\"\" PEP 610 \"\"\"\nimport json\nimport re\nimport urllib.parse\nfrom typing import Any, Dict, Iterable, Optional, Type, TypeVar, Union\n\n__all__ = [\n    \"DirectUrl\",\n    \"DirectUrlValidationError\",\n    \"DirInfo\",\n    \"ArchiveInfo\",\n    \"VcsInfo\",\n]\n\nT = TypeVar(\"T\")\n\nDIRECT_URL_METADATA_NAME = \"direct_url.json\"\nENV_VAR_RE = re.compile(r\"^\\$\\{[A-Za-z0-9-_]+\\}(:\\$\\{[A-Za-z0-9-_]+\\})?$\")\n\n\nclass DirectUrlValidationError(Exception):\n    pass\n\n\ndef _get(\n    d: Dict[str, Any], expected_type: Type[T], key: str, default: Optional[T] = None\n) -> Optional[T]:\n    \"\"\"Get value from dictionary and verify expected type.\"\"\"\n    if key not in d:\n        return default\n    value = d[key]\n    if not isinstance(value, expected_type):\n        raise DirectUrlValidationError(\n            f\"{value!r} has unexpected type for {key} (expected {expected_type})\"\n        )\n    return value\n\n\ndef _get_required(\n    d: Dict[str, Any], expected_type: Type[T], key: str, default: Optional[T] = None\n) -> T:\n    value = _get(d, expected_type, key, default)\n    if value is None:\n        raise DirectUrlValidationError(f\"{key} must have a value\")\n    return value\n\n\ndef _exactly_one_of(infos: Iterable[Optional[\"InfoType\"]]) -> \"InfoType\":\n    infos = [info for info in infos if info is not None]\n    if not infos:\n        raise DirectUrlValidationError(\n            \"missing one of archive_info, dir_info, vcs_info\"\n        )\n    if len(infos) > 1:\n        raise DirectUrlValidationError(\n            \"more than one of archive_info, dir_info, vcs_info\"\n        )\n    assert infos[0] is not None\n    return infos[0]\n\n\ndef _filter_none(**kwargs: Any) -> Dict[str, Any]:\n    \"\"\"Make dict excluding None values.\"\"\"\n    return {k: v for k, v in kwargs.items() if v is not None}\n\n\nclass VcsInfo:\n    name = \"vcs_info\"\n\n    def __init__(\n        self,\n        vcs: str,\n        commit_id: str,\n        requested_revision: Optional[str] = None,\n    ) -> None:\n        self.vcs = vcs\n        self.requested_revision = requested_revision\n        self.commit_id = commit_id\n\n    @classmethod\n    def _from_dict(cls, d: Optional[Dict[str, Any]]) -> Optional[\"VcsInfo\"]:\n        if d is None:\n            return None\n        return cls(\n            vcs=_get_required(d, str, \"vcs\"),\n            commit_id=_get_required(d, str, \"commit_id\"),\n            requested_revision=_get(d, str, \"requested_revision\"),\n        )\n\n    def _to_dict(self) -> Dict[str, Any]:\n        return _filter_none(\n            vcs=self.vcs,\n            requested_revision=self.requested_revision,\n            commit_id=self.commit_id,\n        )\n\n\nclass ArchiveInfo:\n    name = \"archive_info\"\n\n    def __init__(\n        self,\n        hash: Optional[str] = None,\n        hashes: Optional[Dict[str, str]] = None,\n    ) -> None:\n        # set hashes before hash, since the hash setter will further populate hashes\n        self.hashes = hashes\n        self.hash = hash\n\n    @property\n    def hash(self) -> Optional[str]:\n        return self._hash\n\n    @hash.setter\n    def hash(self, value: Optional[str]) -> None:\n        if value is not None:\n            # Auto-populate the hashes key to upgrade to the new format automatically.\n            # We don't back-populate the legacy hash key from hashes.\n            try:\n                hash_name, hash_value = value.split(\"=\", 1)\n            except ValueError:\n                raise DirectUrlValidationError(\n                    f\"invalid archive_info.hash format: {value!r}\"\n                )\n            if self.hashes is None:\n                self.hashes = {hash_name: hash_value}\n            elif hash_name not in self.hashes:\n                self.hashes = self.hashes.copy()\n                self.hashes[hash_name] = hash_value\n        self._hash = value\n\n    @classmethod\n    def _from_dict(cls, d: Optional[Dict[str, Any]]) -> Optional[\"ArchiveInfo\"]:\n        if d is None:\n            return None\n        return cls(hash=_get(d, str, \"hash\"), hashes=_get(d, dict, \"hashes\"))\n\n    def _to_dict(self) -> Dict[str, Any]:\n        return _filter_none(hash=self.hash, hashes=self.hashes)\n\n\nclass DirInfo:\n    name = \"dir_info\"\n\n    def __init__(\n        self,\n        editable: bool = False,\n    ) -> None:\n        self.editable = editable\n\n    @classmethod\n    def _from_dict(cls, d: Optional[Dict[str, Any]]) -> Optional[\"DirInfo\"]:\n        if d is None:\n            return None\n        return cls(editable=_get_required(d, bool, \"editable\", default=False))\n\n    def _to_dict(self) -> Dict[str, Any]:\n        return _filter_none(editable=self.editable or None)\n\n\nInfoType = Union[ArchiveInfo, DirInfo, VcsInfo]\n\n\nclass DirectUrl:\n    def __init__(\n        self,\n        url: str,\n        info: InfoType,\n        subdirectory: Optional[str] = None,\n    ) -> None:\n        self.url = url\n        self.info = info\n        self.subdirectory = subdirectory\n\n    def _remove_auth_from_netloc(self, netloc: str) -> str:\n        if \"@\" not in netloc:\n            return netloc\n        user_pass, netloc_no_user_pass = netloc.split(\"@\", 1)\n        if (\n            isinstance(self.info, VcsInfo)\n            and self.info.vcs == \"git\"\n            and user_pass == \"git\"\n        ):\n            return netloc\n        if ENV_VAR_RE.match(user_pass):\n            return netloc\n        return netloc_no_user_pass\n\n    @property\n    def redacted_url(self) -> str:\n        \"\"\"url with user:password part removed unless it is formed with\n        environment variables as specified in PEP 610, or it is ``git``\n        in the case of a git URL.\n        \"\"\"\n        purl = urllib.parse.urlsplit(self.url)\n        netloc = self._remove_auth_from_netloc(purl.netloc)\n        surl = urllib.parse.urlunsplit(\n            (purl.scheme, netloc, purl.path, purl.query, purl.fragment)\n        )\n        return surl\n\n    def validate(self) -> None:\n        self.from_dict(self.to_dict())\n\n    @classmethod\n    def from_dict(cls, d: Dict[str, Any]) -> \"DirectUrl\":\n        return DirectUrl(\n            url=_get_required(d, str, \"url\"),\n            subdirectory=_get(d, str, \"subdirectory\"),\n            info=_exactly_one_of(\n                [\n                    ArchiveInfo._from_dict(_get(d, dict, \"archive_info\")),\n                    DirInfo._from_dict(_get(d, dict, \"dir_info\")),\n                    VcsInfo._from_dict(_get(d, dict, \"vcs_info\")),\n                ]\n            ),\n        )\n\n    def to_dict(self) -> Dict[str, Any]:\n        res = _filter_none(\n            url=self.redacted_url,\n            subdirectory=self.subdirectory,\n        )\n        res[self.info.name] = self.info._to_dict()\n        return res\n\n    @classmethod\n    def from_json(cls, s: str) -> \"DirectUrl\":\n        return cls.from_dict(json.loads(s))\n\n    def to_json(self) -> str:\n        return json.dumps(self.to_dict(), sort_keys=True)\n\n    def is_local_editable(self) -> bool:\n        return isinstance(self.info, DirInfo) and self.info.editable\n"},"hash":"SAcdi8XENv"}