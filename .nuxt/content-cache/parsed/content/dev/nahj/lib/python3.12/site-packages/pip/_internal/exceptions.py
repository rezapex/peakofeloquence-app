{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:exceptions.py","body":"\"\"\"Exceptions used throughout package.\n\nThis module MUST NOT try to import from anything within `pip._internal` to\noperate. This is expected to be importable from any/all files within the\nsubpackage and, thus, should not depend on them.\n\"\"\"\n\nimport configparser\nimport contextlib\nimport locale\nimport logging\nimport pathlib\nimport re\nimport sys\nfrom itertools import chain, groupby, repeat\nfrom typing import TYPE_CHECKING, Dict, Iterator, List, Optional, Union\n\nfrom pip._vendor.requests.models import Request, Response\nfrom pip._vendor.rich.console import Console, ConsoleOptions, RenderResult\nfrom pip._vendor.rich.markup import escape\nfrom pip._vendor.rich.text import Text\n\nif TYPE_CHECKING:\n    from hashlib import _Hash\n    from typing import Literal\n\n    from pip._internal.metadata import BaseDistribution\n    from pip._internal.req.req_install import InstallRequirement\n\nlogger = logging.getLogger(__name__)\n\n\n#\n# Scaffolding\n#\ndef _is_kebab_case(s: str) -> bool:\n    return re.match(r\"^[a-z]+(-[a-z]+)*$\", s) is not None\n\n\ndef _prefix_with_indent(\n    s: Union[Text, str],\n    console: Console,\n    *,\n    prefix: str,\n    indent: str,\n) -> Text:\n    if isinstance(s, Text):\n        text = s\n    else:\n        text = console.render_str(s)\n\n    return console.render_str(prefix, overflow=\"ignore\") + console.render_str(\n        f\"\\n{indent}\", overflow=\"ignore\"\n    ).join(text.split(allow_blank=True))\n\n\nclass PipError(Exception):\n    \"\"\"The base pip error.\"\"\"\n\n\nclass DiagnosticPipError(PipError):\n    \"\"\"An error, that presents diagnostic information to the user.\n\n    This contains a bunch of logic, to enable pretty presentation of our error\n    messages. Each error gets a unique reference. Each error can also include\n    additional context, a hint and/or a note -- which are presented with the\n    main error message in a consistent style.\n\n    This is adapted from the error output styling in `sphinx-theme-builder`.\n    \"\"\"\n\n    reference: str\n\n    def __init__(\n        self,\n        *,\n        kind: 'Literal[\"error\", \"warning\"]' = \"error\",\n        reference: Optional[str] = None,\n        message: Union[str, Text],\n        context: Optional[Union[str, Text]],\n        hint_stmt: Optional[Union[str, Text]],\n        note_stmt: Optional[Union[str, Text]] = None,\n        link: Optional[str] = None,\n    ) -> None:\n        # Ensure a proper reference is provided.\n        if reference is None:\n            assert hasattr(self, \"reference\"), \"error reference not provided!\"\n            reference = self.reference\n        assert _is_kebab_case(reference), \"error reference must be kebab-case!\"\n\n        self.kind = kind\n        self.reference = reference\n\n        self.message = message\n        self.context = context\n\n        self.note_stmt = note_stmt\n        self.hint_stmt = hint_stmt\n\n        self.link = link\n\n        super().__init__(f\"<{self.__class__.__name__}: {self.reference}>\")\n\n    def __repr__(self) -> str:\n        return (\n            f\"<{self.__class__.__name__}(\"\n            f\"reference={self.reference!r}, \"\n            f\"message={self.message!r}, \"\n            f\"context={self.context!r}, \"\n            f\"note_stmt={self.note_stmt!r}, \"\n            f\"hint_stmt={self.hint_stmt!r}\"\n            \")>\"\n        )\n\n    def __rich_console__(\n        self,\n        console: Console,\n        options: ConsoleOptions,\n    ) -> RenderResult:\n        colour = \"red\" if self.kind == \"error\" else \"yellow\"\n\n        yield f\"[{colour} bold]{self.kind}[/]: [bold]{self.reference}[/]\"\n        yield \"\"\n\n        if not options.ascii_only:\n            # Present the main message, with relevant context indented.\n            if self.context is not None:\n                yield _prefix_with_indent(\n                    self.message,\n                    console,\n                    prefix=f\"[{colour}]×[/] \",\n                    indent=f\"[{colour}]│[/] \",\n                )\n                yield _prefix_with_indent(\n                    self.context,\n                    console,\n                    prefix=f\"[{colour}]╰─>[/] \",\n                    indent=f\"[{colour}]   [/] \",\n                )\n            else:\n                yield _prefix_with_indent(\n                    self.message,\n                    console,\n                    prefix=\"[red]×[/] \",\n                    indent=\"  \",\n                )\n        else:\n            yield self.message\n            if self.context is not None:\n                yield \"\"\n                yield self.context\n\n        if self.note_stmt is not None or self.hint_stmt is not None:\n            yield \"\"\n\n        if self.note_stmt is not None:\n            yield _prefix_with_indent(\n                self.note_stmt,\n                console,\n                prefix=\"[magenta bold]note[/]: \",\n                indent=\"      \",\n            )\n        if self.hint_stmt is not None:\n            yield _prefix_with_indent(\n                self.hint_stmt,\n                console,\n                prefix=\"[cyan bold]hint[/]: \",\n                indent=\"      \",\n            )\n\n        if self.link is not None:\n            yield \"\"\n            yield f\"Link: {self.link}\"\n\n\n#\n# Actual Errors\n#\nclass ConfigurationError(PipError):\n    \"\"\"General exception in configuration\"\"\"\n\n\nclass InstallationError(PipError):\n    \"\"\"General exception during installation\"\"\"\n\n\nclass UninstallationError(PipError):\n    \"\"\"General exception during uninstallation\"\"\"\n\n\nclass MissingPyProjectBuildRequires(DiagnosticPipError):\n    \"\"\"Raised when pyproject.toml has `build-system`, but no `build-system.requires`.\"\"\"\n\n    reference = \"missing-pyproject-build-system-requires\"\n\n    def __init__(self, *, package: str) -> None:\n        super().__init__(\n            message=f\"Can not process {escape(package)}\",\n            context=Text(\n                \"This package has an invalid pyproject.toml file.\\n\"\n                \"The [build-system] table is missing the mandatory `requires` key.\"\n            ),\n            note_stmt=\"This is an issue with the package mentioned above, not pip.\",\n            hint_stmt=Text(\"See PEP 518 for the detailed specification.\"),\n        )\n\n\nclass InvalidPyProjectBuildRequires(DiagnosticPipError):\n    \"\"\"Raised when pyproject.toml an invalid `build-system.requires`.\"\"\"\n\n    reference = \"invalid-pyproject-build-system-requires\"\n\n    def __init__(self, *, package: str, reason: str) -> None:\n        super().__init__(\n            message=f\"Can not process {escape(package)}\",\n            context=Text(\n                \"This package has an invalid `build-system.requires` key in \"\n                f\"pyproject.toml.\\n{reason}\"\n            ),\n            note_stmt=\"This is an issue with the package mentioned above, not pip.\",\n            hint_stmt=Text(\"See PEP 518 for the detailed specification.\"),\n        )\n\n\nclass NoneMetadataError(PipError):\n    \"\"\"Raised when accessing a Distribution's \"METADATA\" or \"PKG-INFO\".\n\n    This signifies an inconsistency, when the Distribution claims to have\n    the metadata file (if not, raise ``FileNotFoundError`` instead), but is\n    not actually able to produce its content. This may be due to permission\n    errors.\n    \"\"\"\n\n    def __init__(\n        self,\n        dist: \"BaseDistribution\",\n        metadata_name: str,\n    ) -> None:\n        \"\"\"\n        :param dist: A Distribution object.\n        :param metadata_name: The name of the metadata being accessed\n            (can be \"METADATA\" or \"PKG-INFO\").\n        \"\"\"\n        self.dist = dist\n        self.metadata_name = metadata_name\n\n    def __str__(self) -> str:\n        # Use `dist` in the error message because its stringification\n        # includes more information, like the version and location.\n        return f\"None {self.metadata_name} metadata found for distribution: {self.dist}\"\n\n\nclass UserInstallationInvalid(InstallationError):\n    \"\"\"A --user install is requested on an environment without user site.\"\"\"\n\n    def __str__(self) -> str:\n        return \"User base directory is not specified\"\n\n\nclass InvalidSchemeCombination(InstallationError):\n    def __str__(self) -> str:\n        before = \", \".join(str(a) for a in self.args[:-1])\n        return f\"Cannot set {before} and {self.args[-1]} together\"\n\n\nclass DistributionNotFound(InstallationError):\n    \"\"\"Raised when a distribution cannot be found to satisfy a requirement\"\"\"\n\n\nclass RequirementsFileParseError(InstallationError):\n    \"\"\"Raised when a general error occurs parsing a requirements file line.\"\"\"\n\n\nclass BestVersionAlreadyInstalled(PipError):\n    \"\"\"Raised when the most up-to-date version of a package is already\n    installed.\"\"\"\n\n\nclass BadCommand(PipError):\n    \"\"\"Raised when virtualenv or a command is not found\"\"\"\n\n\nclass CommandError(PipError):\n    \"\"\"Raised when there is an error in command-line arguments\"\"\"\n\n\nclass PreviousBuildDirError(PipError):\n    \"\"\"Raised when there's a previous conflicting build directory\"\"\"\n\n\nclass NetworkConnectionError(PipError):\n    \"\"\"HTTP connection error\"\"\"\n\n    def __init__(\n        self,\n        error_msg: str,\n        response: Optional[Response] = None,\n        request: Optional[Request] = None,\n    ) -> None:\n        \"\"\"\n        Initialize NetworkConnectionError with  `request` and `response`\n        objects.\n        \"\"\"\n        self.response = response\n        self.request = request\n        self.error_msg = error_msg\n        if (\n            self.response is not None\n            and not self.request\n            and hasattr(response, \"request\")\n        ):\n            self.request = self.response.request\n        super().__init__(error_msg, response, request)\n\n    def __str__(self) -> str:\n        return str(self.error_msg)\n\n\nclass InvalidWheelFilename(InstallationError):\n    \"\"\"Invalid wheel filename.\"\"\"\n\n\nclass UnsupportedWheel(InstallationError):\n    \"\"\"Unsupported wheel.\"\"\"\n\n\nclass InvalidWheel(InstallationError):\n    \"\"\"Invalid (e.g. corrupt) wheel.\"\"\"\n\n    def __init__(self, location: str, name: str):\n        self.location = location\n        self.name = name\n\n    def __str__(self) -> str:\n        return f\"Wheel '{self.name}' located at {self.location} is invalid.\"\n\n\nclass MetadataInconsistent(InstallationError):\n    \"\"\"Built metadata contains inconsistent information.\n\n    This is raised when the metadata contains values (e.g. name and version)\n    that do not match the information previously obtained from sdist filename,\n    user-supplied ``#egg=`` value, or an install requirement name.\n    \"\"\"\n\n    def __init__(\n        self, ireq: \"InstallRequirement\", field: str, f_val: str, m_val: str\n    ) -> None:\n        self.ireq = ireq\n        self.field = field\n        self.f_val = f_val\n        self.m_val = m_val\n\n    def __str__(self) -> str:\n        return (\n            f\"Requested {self.ireq} has inconsistent {self.field}: \"\n            f\"expected {self.f_val!r}, but metadata has {self.m_val!r}\"\n        )\n\n\nclass InstallationSubprocessError(DiagnosticPipError, InstallationError):\n    \"\"\"A subprocess call failed.\"\"\"\n\n    reference = \"subprocess-exited-with-error\"\n\n    def __init__(\n        self,\n        *,\n        command_description: str,\n        exit_code: int,\n        output_lines: Optional[List[str]],\n    ) -> None:\n        if output_lines is None:\n            output_prompt = Text(\"See above for output.\")\n        else:\n            output_prompt = (\n                Text.from_markup(f\"[red][{len(output_lines)} lines of output][/]\\n\")\n                + Text(\"\".join(output_lines))\n                + Text.from_markup(R\"[red]\\[end of output][/]\")\n            )\n\n        super().__init__(\n            message=(\n                f\"[green]{escape(command_description)}[/] did not run successfully.\\n\"\n                f\"exit code: {exit_code}\"\n            ),\n            context=output_prompt,\n            hint_stmt=None,\n            note_stmt=(\n                \"This error originates from a subprocess, and is likely not a \"\n                \"problem with pip.\"\n            ),\n        )\n\n        self.command_description = command_description\n        self.exit_code = exit_code\n\n    def __str__(self) -> str:\n        return f\"{self.command_description} exited with {self.exit_code}\"\n\n\nclass MetadataGenerationFailed(InstallationSubprocessError, InstallationError):\n    reference = \"metadata-generation-failed\"\n\n    def __init__(\n        self,\n        *,\n        package_details: str,\n    ) -> None:\n        super(InstallationSubprocessError, self).__init__(\n            message=\"Encountered error while generating package metadata.\",\n            context=escape(package_details),\n            hint_stmt=\"See above for details.\",\n            note_stmt=\"This is an issue with the package mentioned above, not pip.\",\n        )\n\n    def __str__(self) -> str:\n        return \"metadata generation failed\"\n\n\nclass HashErrors(InstallationError):\n    \"\"\"Multiple HashError instances rolled into one for reporting\"\"\"\n\n    def __init__(self) -> None:\n        self.errors: List[\"HashError\"] = []\n\n    def append(self, error: \"HashError\") -> None:\n        self.errors.append(error)\n\n    def __str__(self) -> str:\n        lines = []\n        self.errors.sort(key=lambda e: e.order)\n        for cls, errors_of_cls in groupby(self.errors, lambda e: e.__class__):\n            lines.append(cls.head)\n            lines.extend(e.body() for e in errors_of_cls)\n        if lines:\n            return \"\\n\".join(lines)\n        return \"\"\n\n    def __bool__(self) -> bool:\n        return bool(self.errors)\n\n\nclass HashError(InstallationError):\n    \"\"\"\n    A failure to verify a package against known-good hashes\n\n    :cvar order: An int sorting hash exception classes by difficulty of\n        recovery (lower being harder), so the user doesn't bother fretting\n        about unpinned packages when he has deeper issues, like VCS\n        dependencies, to deal with. Also keeps error reports in a\n        deterministic order.\n    :cvar head: A section heading for display above potentially many\n        exceptions of this kind\n    :ivar req: The InstallRequirement that triggered this error. This is\n        pasted on after the exception is instantiated, because it's not\n        typically available earlier.\n\n    \"\"\"\n\n    req: Optional[\"InstallRequirement\"] = None\n    head = \"\"\n    order: int = -1\n\n    def body(self) -> str:\n        \"\"\"Return a summary of me for display under the heading.\n\n        This default implementation simply prints a description of the\n        triggering requirement.\n\n        :param req: The InstallRequirement that provoked this error, with\n            its link already populated by the resolver's _populate_link().\n\n        \"\"\"\n        return f\"    {self._requirement_name()}\"\n\n    def __str__(self) -> str:\n        return f\"{self.head}\\n{self.body()}\"\n\n    def _requirement_name(self) -> str:\n        \"\"\"Return a description of the requirement that triggered me.\n\n        This default implementation returns long description of the req, with\n        line numbers\n\n        \"\"\"\n        return str(self.req) if self.req else \"unknown package\"\n\n\nclass VcsHashUnsupported(HashError):\n    \"\"\"A hash was provided for a version-control-system-based requirement, but\n    we don't have a method for hashing those.\"\"\"\n\n    order = 0\n    head = (\n        \"Can't verify hashes for these requirements because we don't \"\n        \"have a way to hash version control repositories:\"\n    )\n\n\nclass DirectoryUrlHashUnsupported(HashError):\n    \"\"\"A hash was provided for a version-control-system-based requirement, but\n    we don't have a method for hashing those.\"\"\"\n\n    order = 1\n    head = (\n        \"Can't verify hashes for these file:// requirements because they \"\n        \"point to directories:\"\n    )\n\n\nclass HashMissing(HashError):\n    \"\"\"A hash was needed for a requirement but is absent.\"\"\"\n\n    order = 2\n    head = (\n        \"Hashes are required in --require-hashes mode, but they are \"\n        \"missing from some requirements. Here is a list of those \"\n        \"requirements along with the hashes their downloaded archives \"\n        \"actually had. Add lines like these to your requirements files to \"\n        \"prevent tampering. (If you did not enable --require-hashes \"\n        \"manually, note that it turns on automatically when any package \"\n        \"has a hash.)\"\n    )\n\n    def __init__(self, gotten_hash: str) -> None:\n        \"\"\"\n        :param gotten_hash: The hash of the (possibly malicious) archive we\n            just downloaded\n        \"\"\"\n        self.gotten_hash = gotten_hash\n\n    def body(self) -> str:\n        # Dodge circular import.\n        from pip._internal.utils.hashes import FAVORITE_HASH\n\n        package = None\n        if self.req:\n            # In the case of URL-based requirements, display the original URL\n            # seen in the requirements file rather than the package name,\n            # so the output can be directly copied into the requirements file.\n            package = (\n                self.req.original_link\n                if self.req.is_direct\n                # In case someone feeds something downright stupid\n                # to InstallRequirement's constructor.\n                else getattr(self.req, \"req\", None)\n            )\n        return \"    {} --hash={}:{}\".format(\n            package or \"unknown package\", FAVORITE_HASH, self.gotten_hash\n        )\n\n\nclass HashUnpinned(HashError):\n    \"\"\"A requirement had a hash specified but was not pinned to a specific\n    version.\"\"\"\n\n    order = 3\n    head = (\n        \"In --require-hashes mode, all requirements must have their \"\n        \"versions pinned with ==. These do not:\"\n    )\n\n\nclass HashMismatch(HashError):\n    \"\"\"\n    Distribution file hash values don't match.\n\n    :ivar package_name: The name of the package that triggered the hash\n        mismatch. Feel free to write to this after the exception is raise to\n        improve its error message.\n\n    \"\"\"\n\n    order = 4\n    head = (\n        \"THESE PACKAGES DO NOT MATCH THE HASHES FROM THE REQUIREMENTS \"\n        \"FILE. If you have updated the package versions, please update \"\n        \"the hashes. Otherwise, examine the package contents carefully; \"\n        \"someone may have tampered with them.\"\n    )\n\n    def __init__(self, allowed: Dict[str, List[str]], gots: Dict[str, \"_Hash\"]) -> None:\n        \"\"\"\n        :param allowed: A dict of algorithm names pointing to lists of allowed\n            hex digests\n        :param gots: A dict of algorithm names pointing to hashes we\n            actually got from the files under suspicion\n        \"\"\"\n        self.allowed = allowed\n        self.gots = gots\n\n    def body(self) -> str:\n        return f\"    {self._requirement_name()}:\\n{self._hash_comparison()}\"\n\n    def _hash_comparison(self) -> str:\n        \"\"\"\n        Return a comparison of actual and expected hash values.\n\n        Example::\n\n               Expected sha256 abcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcde\n                            or 123451234512345123451234512345123451234512345\n                    Got        bcdefbcdefbcdefbcdefbcdefbcdefbcdefbcdefbcdef\n\n        \"\"\"\n\n        def hash_then_or(hash_name: str) -> \"chain[str]\":\n            # For now, all the decent hashes have 6-char names, so we can get\n            # away with hard-coding space literals.\n            return chain([hash_name], repeat(\"    or\"))\n\n        lines: List[str] = []\n        for hash_name, expecteds in self.allowed.items():\n            prefix = hash_then_or(hash_name)\n            lines.extend((f\"        Expected {next(prefix)} {e}\") for e in expecteds)\n            lines.append(\n                f\"             Got        {self.gots[hash_name].hexdigest()}\\n\"\n            )\n        return \"\\n\".join(lines)\n\n\nclass UnsupportedPythonVersion(InstallationError):\n    \"\"\"Unsupported python version according to Requires-Python package\n    metadata.\"\"\"\n\n\nclass ConfigurationFileCouldNotBeLoaded(ConfigurationError):\n    \"\"\"When there are errors while loading a configuration file\"\"\"\n\n    def __init__(\n        self,\n        reason: str = \"could not be loaded\",\n        fname: Optional[str] = None,\n        error: Optional[configparser.Error] = None,\n    ) -> None:\n        super().__init__(error)\n        self.reason = reason\n        self.fname = fname\n        self.error = error\n\n    def __str__(self) -> str:\n        if self.fname is not None:\n            message_part = f\" in {self.fname}.\"\n        else:\n            assert self.error is not None\n            message_part = f\".\\n{self.error}\\n\"\n        return f\"Configuration file {self.reason}{message_part}\"\n\n\n_DEFAULT_EXTERNALLY_MANAGED_ERROR = f\"\"\"\\\nThe Python environment under {sys.prefix} is managed externally, and may not be\nmanipulated by the user. Please use specific tooling from the distributor of\nthe Python installation to interact with this environment instead.\n\"\"\"\n\n\nclass ExternallyManagedEnvironment(DiagnosticPipError):\n    \"\"\"The current environment is externally managed.\n\n    This is raised when the current environment is externally managed, as\n    defined by `PEP 668`_. The ``EXTERNALLY-MANAGED`` configuration is checked\n    and displayed when the error is bubbled up to the user.\n\n    :param error: The error message read from ``EXTERNALLY-MANAGED``.\n    \"\"\"\n\n    reference = \"externally-managed-environment\"\n\n    def __init__(self, error: Optional[str]) -> None:\n        if error is None:\n            context = Text(_DEFAULT_EXTERNALLY_MANAGED_ERROR)\n        else:\n            context = Text(error)\n        super().__init__(\n            message=\"This environment is externally managed\",\n            context=context,\n            note_stmt=(\n                \"If you believe this is a mistake, please contact your \"\n                \"Python installation or OS distribution provider. \"\n                \"You can override this, at the risk of breaking your Python \"\n                \"installation or OS, by passing --break-system-packages.\"\n            ),\n            hint_stmt=Text(\"See PEP 668 for the detailed specification.\"),\n        )\n\n    @staticmethod\n    def _iter_externally_managed_error_keys() -> Iterator[str]:\n        # LC_MESSAGES is in POSIX, but not the C standard. The most common\n        # platform that does not implement this category is Windows, where\n        # using other categories for console message localization is equally\n        # unreliable, so we fall back to the locale-less vendor message. This\n        # can always be re-evaluated when a vendor proposes a new alternative.\n        try:\n            category = locale.LC_MESSAGES\n        except AttributeError:\n            lang: Optional[str] = None\n        else:\n            lang, _ = locale.getlocale(category)\n        if lang is not None:\n            yield f\"Error-{lang}\"\n            for sep in (\"-\", \"_\"):\n                before, found, _ = lang.partition(sep)\n                if not found:\n                    continue\n                yield f\"Error-{before}\"\n        yield \"Error\"\n\n    @classmethod\n    def from_config(\n        cls,\n        config: Union[pathlib.Path, str],\n    ) -> \"ExternallyManagedEnvironment\":\n        parser = configparser.ConfigParser(interpolation=None)\n        try:\n            parser.read(config, encoding=\"utf-8\")\n            section = parser[\"externally-managed\"]\n            for key in cls._iter_externally_managed_error_keys():\n                with contextlib.suppress(KeyError):\n                    return cls(section[key])\n        except KeyError:\n            pass\n        except (OSError, UnicodeDecodeError, configparser.ParsingError):\n            from pip._internal.utils._log import VERBOSE\n\n            exc_info = logger.isEnabledFor(VERBOSE)\n            logger.warning(\"Failed to read %s\", config, exc_info=exc_info)\n        return cls(None)\n"},"hash":"5fHaA0YrrB"}