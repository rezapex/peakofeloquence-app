{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:index:package_finder.py","body":"\"\"\"Routines related to PyPI, indexes\"\"\"\n\nimport enum\nimport functools\nimport itertools\nimport logging\nimport re\nfrom typing import TYPE_CHECKING, FrozenSet, Iterable, List, Optional, Set, Tuple, Union\n\nfrom pip._vendor.packaging import specifiers\nfrom pip._vendor.packaging.tags import Tag\nfrom pip._vendor.packaging.utils import canonicalize_name\nfrom pip._vendor.packaging.version import _BaseVersion\nfrom pip._vendor.packaging.version import parse as parse_version\n\nfrom pip._internal.exceptions import (\n    BestVersionAlreadyInstalled,\n    DistributionNotFound,\n    InvalidWheelFilename,\n    UnsupportedWheel,\n)\nfrom pip._internal.index.collector import LinkCollector, parse_links\nfrom pip._internal.models.candidate import InstallationCandidate\nfrom pip._internal.models.format_control import FormatControl\nfrom pip._internal.models.link import Link\nfrom pip._internal.models.search_scope import SearchScope\nfrom pip._internal.models.selection_prefs import SelectionPreferences\nfrom pip._internal.models.target_python import TargetPython\nfrom pip._internal.models.wheel import Wheel\nfrom pip._internal.req import InstallRequirement\nfrom pip._internal.utils._log import getLogger\nfrom pip._internal.utils.filetypes import WHEEL_EXTENSION\nfrom pip._internal.utils.hashes import Hashes\nfrom pip._internal.utils.logging import indent_log\nfrom pip._internal.utils.misc import build_netloc\nfrom pip._internal.utils.packaging import check_requires_python\nfrom pip._internal.utils.unpacking import SUPPORTED_EXTENSIONS\n\nif TYPE_CHECKING:\n    from pip._vendor.typing_extensions import TypeGuard\n\n__all__ = [\"FormatControl\", \"BestCandidateResult\", \"PackageFinder\"]\n\n\nlogger = getLogger(__name__)\n\nBuildTag = Union[Tuple[()], Tuple[int, str]]\nCandidateSortingKey = Tuple[int, int, int, _BaseVersion, Optional[int], BuildTag]\n\n\ndef _check_link_requires_python(\n    link: Link,\n    version_info: Tuple[int, int, int],\n    ignore_requires_python: bool = False,\n) -> bool:\n    \"\"\"\n    Return whether the given Python version is compatible with a link's\n    \"Requires-Python\" value.\n\n    :param version_info: A 3-tuple of ints representing the Python\n        major-minor-micro version to check.\n    :param ignore_requires_python: Whether to ignore the \"Requires-Python\"\n        value if the given Python version isn't compatible.\n    \"\"\"\n    try:\n        is_compatible = check_requires_python(\n            link.requires_python,\n            version_info=version_info,\n        )\n    except specifiers.InvalidSpecifier:\n        logger.debug(\n            \"Ignoring invalid Requires-Python (%r) for link: %s\",\n            link.requires_python,\n            link,\n        )\n    else:\n        if not is_compatible:\n            version = \".\".join(map(str, version_info))\n            if not ignore_requires_python:\n                logger.verbose(\n                    \"Link requires a different Python (%s not in: %r): %s\",\n                    version,\n                    link.requires_python,\n                    link,\n                )\n                return False\n\n            logger.debug(\n                \"Ignoring failed Requires-Python check (%s not in: %r) for link: %s\",\n                version,\n                link.requires_python,\n                link,\n            )\n\n    return True\n\n\nclass LinkType(enum.Enum):\n    candidate = enum.auto()\n    different_project = enum.auto()\n    yanked = enum.auto()\n    format_unsupported = enum.auto()\n    format_invalid = enum.auto()\n    platform_mismatch = enum.auto()\n    requires_python_mismatch = enum.auto()\n\n\nclass LinkEvaluator:\n\n    \"\"\"\n    Responsible for evaluating links for a particular project.\n    \"\"\"\n\n    _py_version_re = re.compile(r\"-py([123]\\.?[0-9]?)$\")\n\n    # Don't include an allow_yanked default value to make sure each call\n    # site considers whether yanked releases are allowed. This also causes\n    # that decision to be made explicit in the calling code, which helps\n    # people when reading the code.\n    def __init__(\n        self,\n        project_name: str,\n        canonical_name: str,\n        formats: FrozenSet[str],\n        target_python: TargetPython,\n        allow_yanked: bool,\n        ignore_requires_python: Optional[bool] = None,\n    ) -> None:\n        \"\"\"\n        :param project_name: The user supplied package name.\n        :param canonical_name: The canonical package name.\n        :param formats: The formats allowed for this package. Should be a set\n            with 'binary' or 'source' or both in it.\n        :param target_python: The target Python interpreter to use when\n            evaluating link compatibility. This is used, for example, to\n            check wheel compatibility, as well as when checking the Python\n            version, e.g. the Python version embedded in a link filename\n            (or egg fragment) and against an HTML link's optional PEP 503\n            \"data-requires-python\" attribute.\n        :param allow_yanked: Whether files marked as yanked (in the sense\n            of PEP 592) are permitted to be candidates for install.\n        :param ignore_requires_python: Whether to ignore incompatible\n            PEP 503 \"data-requires-python\" values in HTML links. Defaults\n            to False.\n        \"\"\"\n        if ignore_requires_python is None:\n            ignore_requires_python = False\n\n        self._allow_yanked = allow_yanked\n        self._canonical_name = canonical_name\n        self._ignore_requires_python = ignore_requires_python\n        self._formats = formats\n        self._target_python = target_python\n\n        self.project_name = project_name\n\n    def evaluate_link(self, link: Link) -> Tuple[LinkType, str]:\n        \"\"\"\n        Determine whether a link is a candidate for installation.\n\n        :return: A tuple (result, detail), where *result* is an enum\n            representing whether the evaluation found a candidate, or the reason\n            why one is not found. If a candidate is found, *detail* will be the\n            candidate's version string; if one is not found, it contains the\n            reason the link fails to qualify.\n        \"\"\"\n        version = None\n        if link.is_yanked and not self._allow_yanked:\n            reason = link.yanked_reason or \"<none given>\"\n            return (LinkType.yanked, f\"yanked for reason: {reason}\")\n\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n            ext = link.ext\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                return (LinkType.format_unsupported, \"not a file\")\n            if ext not in SUPPORTED_EXTENSIONS:\n                return (\n                    LinkType.format_unsupported,\n                    f\"unsupported archive format: {ext}\",\n                )\n            if \"binary\" not in self._formats and ext == WHEEL_EXTENSION:\n                reason = f\"No binaries permitted for {self.project_name}\"\n                return (LinkType.format_unsupported, reason)\n            if \"macosx10\" in link.path and ext == \".zip\":\n                return (LinkType.format_unsupported, \"macosx10 one\")\n            if ext == WHEEL_EXTENSION:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    return (\n                        LinkType.format_invalid,\n                        \"invalid wheel filename\",\n                    )\n                if canonicalize_name(wheel.name) != self._canonical_name:\n                    reason = f\"wrong project name (not {self.project_name})\"\n                    return (LinkType.different_project, reason)\n\n                supported_tags = self._target_python.get_unsorted_tags()\n                if not wheel.supported(supported_tags):\n                    # Include the wheel's tags in the reason string to\n                    # simplify troubleshooting compatibility issues.\n                    file_tags = \", \".join(wheel.get_formatted_file_tags())\n                    reason = (\n                        f\"none of the wheel's tags ({file_tags}) are compatible \"\n                        f\"(run pip debug --verbose to show compatible tags)\"\n                    )\n                    return (LinkType.platform_mismatch, reason)\n\n                version = wheel.version\n\n        # This should be up by the self.ok_binary check, but see issue 2700.\n        if \"source\" not in self._formats and ext != WHEEL_EXTENSION:\n            reason = f\"No sources permitted for {self.project_name}\"\n            return (LinkType.format_unsupported, reason)\n\n        if not version:\n            version = _extract_version_from_fragment(\n                egg_info,\n                self._canonical_name,\n            )\n        if not version:\n            reason = f\"Missing project version for {self.project_name}\"\n            return (LinkType.format_invalid, reason)\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[: match.start()]\n            py_version = match.group(1)\n            if py_version != self._target_python.py_version:\n                return (\n                    LinkType.platform_mismatch,\n                    \"Python version is incorrect\",\n                )\n\n        supports_python = _check_link_requires_python(\n            link,\n            version_info=self._target_python.py_version_info,\n            ignore_requires_python=self._ignore_requires_python,\n        )\n        if not supports_python:\n            reason = f\"{version} Requires-Python {link.requires_python}\"\n            return (LinkType.requires_python_mismatch, reason)\n\n        logger.debug(\"Found link %s, version: %s\", link, version)\n\n        return (LinkType.candidate, version)\n\n\ndef filter_unallowed_hashes(\n    candidates: List[InstallationCandidate],\n    hashes: Optional[Hashes],\n    project_name: str,\n) -> List[InstallationCandidate]:\n    \"\"\"\n    Filter out candidates whose hashes aren't allowed, and return a new\n    list of candidates.\n\n    If at least one candidate has an allowed hash, then all candidates with\n    either an allowed hash or no hash specified are returned.  Otherwise,\n    the given candidates are returned.\n\n    Including the candidates with no hash specified when there is a match\n    allows a warning to be logged if there is a more preferred candidate\n    with no hash specified.  Returning all candidates in the case of no\n    matches lets pip report the hash of the candidate that would otherwise\n    have been installed (e.g. permitting the user to more easily update\n    their requirements file with the desired hash).\n    \"\"\"\n    if not hashes:\n        logger.debug(\n            \"Given no hashes to check %s links for project %r: \"\n            \"discarding no candidates\",\n            len(candidates),\n            project_name,\n        )\n        # Make sure we're not returning back the given value.\n        return list(candidates)\n\n    matches_or_no_digest = []\n    # Collect the non-matches for logging purposes.\n    non_matches = []\n    match_count = 0\n    for candidate in candidates:\n        link = candidate.link\n        if not link.has_hash:\n            pass\n        elif link.is_hash_allowed(hashes=hashes):\n            match_count += 1\n        else:\n            non_matches.append(candidate)\n            continue\n\n        matches_or_no_digest.append(candidate)\n\n    if match_count:\n        filtered = matches_or_no_digest\n    else:\n        # Make sure we're not returning back the given value.\n        filtered = list(candidates)\n\n    if len(filtered) == len(candidates):\n        discard_message = \"discarding no candidates\"\n    else:\n        discard_message = \"discarding {} non-matches:\\n  {}\".format(\n            len(non_matches),\n            \"\\n  \".join(str(candidate.link) for candidate in non_matches),\n        )\n\n    logger.debug(\n        \"Checked %s links for project %r against %s hashes \"\n        \"(%s matches, %s no digest): %s\",\n        len(candidates),\n        project_name,\n        hashes.digest_count,\n        match_count,\n        len(matches_or_no_digest) - match_count,\n        discard_message,\n    )\n\n    return filtered\n\n\nclass CandidatePreferences:\n\n    \"\"\"\n    Encapsulates some of the preferences for filtering and sorting\n    InstallationCandidate objects.\n    \"\"\"\n\n    def __init__(\n        self,\n        prefer_binary: bool = False,\n        allow_all_prereleases: bool = False,\n    ) -> None:\n        \"\"\"\n        :param allow_all_prereleases: Whether to allow all pre-releases.\n        \"\"\"\n        self.allow_all_prereleases = allow_all_prereleases\n        self.prefer_binary = prefer_binary\n\n\nclass BestCandidateResult:\n    \"\"\"A collection of candidates, returned by `PackageFinder.find_best_candidate`.\n\n    This class is only intended to be instantiated by CandidateEvaluator's\n    `compute_best_candidate()` method.\n    \"\"\"\n\n    def __init__(\n        self,\n        candidates: List[InstallationCandidate],\n        applicable_candidates: List[InstallationCandidate],\n        best_candidate: Optional[InstallationCandidate],\n    ) -> None:\n        \"\"\"\n        :param candidates: A sequence of all available candidates found.\n        :param applicable_candidates: The applicable candidates.\n        :param best_candidate: The most preferred candidate found, or None\n            if no applicable candidates were found.\n        \"\"\"\n        assert set(applicable_candidates) <= set(candidates)\n\n        if best_candidate is None:\n            assert not applicable_candidates\n        else:\n            assert best_candidate in applicable_candidates\n\n        self._applicable_candidates = applicable_candidates\n        self._candidates = candidates\n\n        self.best_candidate = best_candidate\n\n    def iter_all(self) -> Iterable[InstallationCandidate]:\n        \"\"\"Iterate through all candidates.\"\"\"\n        return iter(self._candidates)\n\n    def iter_applicable(self) -> Iterable[InstallationCandidate]:\n        \"\"\"Iterate through the applicable candidates.\"\"\"\n        return iter(self._applicable_candidates)\n\n\nclass CandidateEvaluator:\n\n    \"\"\"\n    Responsible for filtering and sorting candidates for installation based\n    on what tags are valid.\n    \"\"\"\n\n    @classmethod\n    def create(\n        cls,\n        project_name: str,\n        target_python: Optional[TargetPython] = None,\n        prefer_binary: bool = False,\n        allow_all_prereleases: bool = False,\n        specifier: Optional[specifiers.BaseSpecifier] = None,\n        hashes: Optional[Hashes] = None,\n    ) -> \"CandidateEvaluator\":\n        \"\"\"Create a CandidateEvaluator object.\n\n        :param target_python: The target Python interpreter to use when\n            checking compatibility. If None (the default), a TargetPython\n            object will be constructed from the running Python.\n        :param specifier: An optional object implementing `filter`\n            (e.g. `packaging.specifiers.SpecifierSet`) to filter applicable\n            versions.\n        :param hashes: An optional collection of allowed hashes.\n        \"\"\"\n        if target_python is None:\n            target_python = TargetPython()\n        if specifier is None:\n            specifier = specifiers.SpecifierSet()\n\n        supported_tags = target_python.get_sorted_tags()\n\n        return cls(\n            project_name=project_name,\n            supported_tags=supported_tags,\n            specifier=specifier,\n            prefer_binary=prefer_binary,\n            allow_all_prereleases=allow_all_prereleases,\n            hashes=hashes,\n        )\n\n    def __init__(\n        self,\n        project_name: str,\n        supported_tags: List[Tag],\n        specifier: specifiers.BaseSpecifier,\n        prefer_binary: bool = False,\n        allow_all_prereleases: bool = False,\n        hashes: Optional[Hashes] = None,\n    ) -> None:\n        \"\"\"\n        :param supported_tags: The PEP 425 tags supported by the target\n            Python in order of preference (most preferred first).\n        \"\"\"\n        self._allow_all_prereleases = allow_all_prereleases\n        self._hashes = hashes\n        self._prefer_binary = prefer_binary\n        self._project_name = project_name\n        self._specifier = specifier\n        self._supported_tags = supported_tags\n        # Since the index of the tag in the _supported_tags list is used\n        # as a priority, precompute a map from tag to index/priority to be\n        # used in wheel.find_most_preferred_tag.\n        self._wheel_tag_preferences = {\n            tag: idx for idx, tag in enumerate(supported_tags)\n        }\n\n    def get_applicable_candidates(\n        self,\n        candidates: List[InstallationCandidate],\n    ) -> List[InstallationCandidate]:\n        \"\"\"\n        Return the applicable candidates from a list of candidates.\n        \"\"\"\n        # Using None infers from the specifier instead.\n        allow_prereleases = self._allow_all_prereleases or None\n        specifier = self._specifier\n        versions = {\n            str(v)\n            for v in specifier.filter(\n                # We turn the version object into a str here because otherwise\n                # when we're debundled but setuptools isn't, Python will see\n                # packaging.version.Version and\n                # pkg_resources._vendor.packaging.version.Version as different\n                # types. This way we'll use a str as a common data interchange\n                # format. If we stop using the pkg_resources provided specifier\n                # and start using our own, we can drop the cast to str().\n                (str(c.version) for c in candidates),\n                prereleases=allow_prereleases,\n            )\n        }\n\n        # Again, converting version to str to deal with debundling.\n        applicable_candidates = [c for c in candidates if str(c.version) in versions]\n\n        filtered_applicable_candidates = filter_unallowed_hashes(\n            candidates=applicable_candidates,\n            hashes=self._hashes,\n            project_name=self._project_name,\n        )\n\n        return sorted(filtered_applicable_candidates, key=self._sort_key)\n\n    def _sort_key(self, candidate: InstallationCandidate) -> CandidateSortingKey:\n        \"\"\"\n        Function to pass as the `key` argument to a call to sorted() to sort\n        InstallationCandidates by preference.\n\n        Returns a tuple such that tuples sorting as greater using Python's\n        default comparison operator are more preferred.\n\n        The preference is as follows:\n\n        First and foremost, candidates with allowed (matching) hashes are\n        always preferred over candidates without matching hashes. This is\n        because e.g. if the only candidate with an allowed hash is yanked,\n        we still want to use that candidate.\n\n        Second, excepting hash considerations, candidates that have been\n        yanked (in the sense of PEP 592) are always less preferred than\n        candidates that haven't been yanked. Then:\n\n        If not finding wheels, they are sorted by version only.\n        If finding wheels, then the sort order is by version, then:\n          1. existing installs\n          2. wheels ordered via Wheel.support_index_min(self._supported_tags)\n          3. source archives\n        If prefer_binary was set, then all wheels are sorted above sources.\n\n        Note: it was considered to embed this logic into the Link\n              comparison operators, but then different sdist links\n              with the same version, would have to be considered equal\n        \"\"\"\n        valid_tags = self._supported_tags\n        support_num = len(valid_tags)\n        build_tag: BuildTag = ()\n        binary_preference = 0\n        link = candidate.link\n        if link.is_wheel:\n            # can raise InvalidWheelFilename\n            wheel = Wheel(link.filename)\n            try:\n                pri = -(\n                    wheel.find_most_preferred_tag(\n                        valid_tags, self._wheel_tag_preferences\n                    )\n                )\n            except ValueError:\n                raise UnsupportedWheel(\n                    f\"{wheel.filename} is not a supported wheel for this platform. It \"\n                    \"can't be sorted.\"\n                )\n            if self._prefer_binary:\n                binary_preference = 1\n            if wheel.build_tag is not None:\n                match = re.match(r\"^(\\d+)(.*)$\", wheel.build_tag)\n                assert match is not None, \"guaranteed by filename validation\"\n                build_tag_groups = match.groups()\n                build_tag = (int(build_tag_groups[0]), build_tag_groups[1])\n        else:  # sdist\n            pri = -(support_num)\n        has_allowed_hash = int(link.is_hash_allowed(self._hashes))\n        yank_value = -1 * int(link.is_yanked)  # -1 for yanked.\n        return (\n            has_allowed_hash,\n            yank_value,\n            binary_preference,\n            candidate.version,\n            pri,\n            build_tag,\n        )\n\n    def sort_best_candidate(\n        self,\n        candidates: List[InstallationCandidate],\n    ) -> Optional[InstallationCandidate]:\n        \"\"\"\n        Return the best candidate per the instance's sort order, or None if\n        no candidate is acceptable.\n        \"\"\"\n        if not candidates:\n            return None\n        best_candidate = max(candidates, key=self._sort_key)\n        return best_candidate\n\n    def compute_best_candidate(\n        self,\n        candidates: List[InstallationCandidate],\n    ) -> BestCandidateResult:\n        \"\"\"\n        Compute and return a `BestCandidateResult` instance.\n        \"\"\"\n        applicable_candidates = self.get_applicable_candidates(candidates)\n\n        best_candidate = self.sort_best_candidate(applicable_candidates)\n\n        return BestCandidateResult(\n            candidates,\n            applicable_candidates=applicable_candidates,\n            best_candidate=best_candidate,\n        )\n\n\nclass PackageFinder:\n    \"\"\"This finds packages.\n\n    This is meant to match easy_install's technique for looking for\n    packages, by reading pages and looking for appropriate links.\n    \"\"\"\n\n    def __init__(\n        self,\n        link_collector: LinkCollector,\n        target_python: TargetPython,\n        allow_yanked: bool,\n        format_control: Optional[FormatControl] = None,\n        candidate_prefs: Optional[CandidatePreferences] = None,\n        ignore_requires_python: Optional[bool] = None,\n    ) -> None:\n        \"\"\"\n        This constructor is primarily meant to be used by the create() class\n        method and from tests.\n\n        :param format_control: A FormatControl object, used to control\n            the selection of source packages / binary packages when consulting\n            the index and links.\n        :param candidate_prefs: Options to use when creating a\n            CandidateEvaluator object.\n        \"\"\"\n        if candidate_prefs is None:\n            candidate_prefs = CandidatePreferences()\n\n        format_control = format_control or FormatControl(set(), set())\n\n        self._allow_yanked = allow_yanked\n        self._candidate_prefs = candidate_prefs\n        self._ignore_requires_python = ignore_requires_python\n        self._link_collector = link_collector\n        self._target_python = target_python\n\n        self.format_control = format_control\n\n        # These are boring links that have already been logged somehow.\n        self._logged_links: Set[Tuple[Link, LinkType, str]] = set()\n\n    # Don't include an allow_yanked default value to make sure each call\n    # site considers whether yanked releases are allowed. This also causes\n    # that decision to be made explicit in the calling code, which helps\n    # people when reading the code.\n    @classmethod\n    def create(\n        cls,\n        link_collector: LinkCollector,\n        selection_prefs: SelectionPreferences,\n        target_python: Optional[TargetPython] = None,\n    ) -> \"PackageFinder\":\n        \"\"\"Create a PackageFinder.\n\n        :param selection_prefs: The candidate selection preferences, as a\n            SelectionPreferences object.\n        :param target_python: The target Python interpreter to use when\n            checking compatibility. If None (the default), a TargetPython\n            object will be constructed from the running Python.\n        \"\"\"\n        if target_python is None:\n            target_python = TargetPython()\n\n        candidate_prefs = CandidatePreferences(\n            prefer_binary=selection_prefs.prefer_binary,\n            allow_all_prereleases=selection_prefs.allow_all_prereleases,\n        )\n\n        return cls(\n            candidate_prefs=candidate_prefs,\n            link_collector=link_collector,\n            target_python=target_python,\n            allow_yanked=selection_prefs.allow_yanked,\n            format_control=selection_prefs.format_control,\n            ignore_requires_python=selection_prefs.ignore_requires_python,\n        )\n\n    @property\n    def target_python(self) -> TargetPython:\n        return self._target_python\n\n    @property\n    def search_scope(self) -> SearchScope:\n        return self._link_collector.search_scope\n\n    @search_scope.setter\n    def search_scope(self, search_scope: SearchScope) -> None:\n        self._link_collector.search_scope = search_scope\n\n    @property\n    def find_links(self) -> List[str]:\n        return self._link_collector.find_links\n\n    @property\n    def index_urls(self) -> List[str]:\n        return self.search_scope.index_urls\n\n    @property\n    def trusted_hosts(self) -> Iterable[str]:\n        for host_port in self._link_collector.session.pip_trusted_origins:\n            yield build_netloc(*host_port)\n\n    @property\n    def allow_all_prereleases(self) -> bool:\n        return self._candidate_prefs.allow_all_prereleases\n\n    def set_allow_all_prereleases(self) -> None:\n        self._candidate_prefs.allow_all_prereleases = True\n\n    @property\n    def prefer_binary(self) -> bool:\n        return self._candidate_prefs.prefer_binary\n\n    def set_prefer_binary(self) -> None:\n        self._candidate_prefs.prefer_binary = True\n\n    def requires_python_skipped_reasons(self) -> List[str]:\n        reasons = {\n            detail\n            for _, result, detail in self._logged_links\n            if result == LinkType.requires_python_mismatch\n        }\n        return sorted(reasons)\n\n    def make_link_evaluator(self, project_name: str) -> LinkEvaluator:\n        canonical_name = canonicalize_name(project_name)\n        formats = self.format_control.get_allowed_formats(canonical_name)\n\n        return LinkEvaluator(\n            project_name=project_name,\n            canonical_name=canonical_name,\n            formats=formats,\n            target_python=self._target_python,\n            allow_yanked=self._allow_yanked,\n            ignore_requires_python=self._ignore_requires_python,\n        )\n\n    def _sort_links(self, links: Iterable[Link]) -> List[Link]:\n        \"\"\"\n        Returns elements of links in order, non-egg links first, egg links\n        second, while eliminating duplicates\n        \"\"\"\n        eggs, no_eggs = [], []\n        seen: Set[Link] = set()\n        for link in links:\n            if link not in seen:\n                seen.add(link)\n                if link.egg_fragment:\n                    eggs.append(link)\n                else:\n                    no_eggs.append(link)\n        return no_eggs + eggs\n\n    def _log_skipped_link(self, link: Link, result: LinkType, detail: str) -> None:\n        entry = (link, result, detail)\n        if entry not in self._logged_links:\n            # Put the link at the end so the reason is more visible and because\n            # the link string is usually very long.\n            logger.debug(\"Skipping link: %s: %s\", detail, link)\n            self._logged_links.add(entry)\n\n    def get_install_candidate(\n        self, link_evaluator: LinkEvaluator, link: Link\n    ) -> Optional[InstallationCandidate]:\n        \"\"\"\n        If the link is a candidate for install, convert it to an\n        InstallationCandidate and return it. Otherwise, return None.\n        \"\"\"\n        result, detail = link_evaluator.evaluate_link(link)\n        if result != LinkType.candidate:\n            self._log_skipped_link(link, result, detail)\n            return None\n\n        return InstallationCandidate(\n            name=link_evaluator.project_name,\n            link=link,\n            version=detail,\n        )\n\n    def evaluate_links(\n        self, link_evaluator: LinkEvaluator, links: Iterable[Link]\n    ) -> List[InstallationCandidate]:\n        \"\"\"\n        Convert links that are candidates to InstallationCandidate objects.\n        \"\"\"\n        candidates = []\n        for link in self._sort_links(links):\n            candidate = self.get_install_candidate(link_evaluator, link)\n            if candidate is not None:\n                candidates.append(candidate)\n\n        return candidates\n\n    def process_project_url(\n        self, project_url: Link, link_evaluator: LinkEvaluator\n    ) -> List[InstallationCandidate]:\n        logger.debug(\n            \"Fetching project page and analyzing links: %s\",\n            project_url,\n        )\n        index_response = self._link_collector.fetch_response(project_url)\n        if index_response is None:\n            return []\n\n        page_links = list(parse_links(index_response))\n\n        with indent_log():\n            package_links = self.evaluate_links(\n                link_evaluator,\n                links=page_links,\n            )\n\n        return package_links\n\n    @functools.lru_cache(maxsize=None)\n    def find_all_candidates(self, project_name: str) -> List[InstallationCandidate]:\n        \"\"\"Find all available InstallationCandidate for project_name\n\n        This checks index_urls and find_links.\n        All versions found are returned as an InstallationCandidate list.\n\n        See LinkEvaluator.evaluate_link() for details on which files\n        are accepted.\n        \"\"\"\n        link_evaluator = self.make_link_evaluator(project_name)\n\n        collected_sources = self._link_collector.collect_sources(\n            project_name=project_name,\n            candidates_from_page=functools.partial(\n                self.process_project_url,\n                link_evaluator=link_evaluator,\n            ),\n        )\n\n        page_candidates_it = itertools.chain.from_iterable(\n            source.page_candidates()\n            for sources in collected_sources\n            for source in sources\n            if source is not None\n        )\n        page_candidates = list(page_candidates_it)\n\n        file_links_it = itertools.chain.from_iterable(\n            source.file_links()\n            for sources in collected_sources\n            for source in sources\n            if source is not None\n        )\n        file_candidates = self.evaluate_links(\n            link_evaluator,\n            sorted(file_links_it, reverse=True),\n        )\n\n        if logger.isEnabledFor(logging.DEBUG) and file_candidates:\n            paths = []\n            for candidate in file_candidates:\n                assert candidate.link.url  # we need to have a URL\n                try:\n                    paths.append(candidate.link.file_path)\n                except Exception:\n                    paths.append(candidate.link.url)  # it's not a local file\n\n            logger.debug(\"Local files found: %s\", \", \".join(paths))\n\n        # This is an intentional priority ordering\n        return file_candidates + page_candidates\n\n    def make_candidate_evaluator(\n        self,\n        project_name: str,\n        specifier: Optional[specifiers.BaseSpecifier] = None,\n        hashes: Optional[Hashes] = None,\n    ) -> CandidateEvaluator:\n        \"\"\"Create a CandidateEvaluator object to use.\"\"\"\n        candidate_prefs = self._candidate_prefs\n        return CandidateEvaluator.create(\n            project_name=project_name,\n            target_python=self._target_python,\n            prefer_binary=candidate_prefs.prefer_binary,\n            allow_all_prereleases=candidate_prefs.allow_all_prereleases,\n            specifier=specifier,\n            hashes=hashes,\n        )\n\n    @functools.lru_cache(maxsize=None)\n    def find_best_candidate(\n        self,\n        project_name: str,\n        specifier: Optional[specifiers.BaseSpecifier] = None,\n        hashes: Optional[Hashes] = None,\n    ) -> BestCandidateResult:\n        \"\"\"Find matches for the given project and specifier.\n\n        :param specifier: An optional object implementing `filter`\n            (e.g. `packaging.specifiers.SpecifierSet`) to filter applicable\n            versions.\n\n        :return: A `BestCandidateResult` instance.\n        \"\"\"\n        candidates = self.find_all_candidates(project_name)\n        candidate_evaluator = self.make_candidate_evaluator(\n            project_name=project_name,\n            specifier=specifier,\n            hashes=hashes,\n        )\n        return candidate_evaluator.compute_best_candidate(candidates)\n\n    def find_requirement(\n        self, req: InstallRequirement, upgrade: bool\n    ) -> Optional[InstallationCandidate]:\n        \"\"\"Try to find a Link matching req\n\n        Expects req, an InstallRequirement and upgrade, a boolean\n        Returns a InstallationCandidate if found,\n        Raises DistributionNotFound or BestVersionAlreadyInstalled otherwise\n        \"\"\"\n        hashes = req.hashes(trust_internet=False)\n        best_candidate_result = self.find_best_candidate(\n            req.name,\n            specifier=req.specifier,\n            hashes=hashes,\n        )\n        best_candidate = best_candidate_result.best_candidate\n\n        installed_version: Optional[_BaseVersion] = None\n        if req.satisfied_by is not None:\n            installed_version = req.satisfied_by.version\n\n        def _format_versions(cand_iter: Iterable[InstallationCandidate]) -> str:\n            # This repeated parse_version and str() conversion is needed to\n            # handle different vendoring sources from pip and pkg_resources.\n            # If we stop using the pkg_resources provided specifier and start\n            # using our own, we can drop the cast to str().\n            return (\n                \", \".join(\n                    sorted(\n                        {str(c.version) for c in cand_iter},\n                        key=parse_version,\n                    )\n                )\n                or \"none\"\n            )\n\n        if installed_version is None and best_candidate is None:\n            logger.critical(\n                \"Could not find a version that satisfies the requirement %s \"\n                \"(from versions: %s)\",\n                req,\n                _format_versions(best_candidate_result.iter_all()),\n            )\n\n            raise DistributionNotFound(f\"No matching distribution found for {req}\")\n\n        def _should_install_candidate(\n            candidate: Optional[InstallationCandidate],\n        ) -> \"TypeGuard[InstallationCandidate]\":\n            if installed_version is None:\n                return True\n            if best_candidate is None:\n                return False\n            return best_candidate.version > installed_version\n\n        if not upgrade and installed_version is not None:\n            if _should_install_candidate(best_candidate):\n                logger.debug(\n                    \"Existing installed version (%s) satisfies requirement \"\n                    \"(most up-to-date version is %s)\",\n                    installed_version,\n                    best_candidate.version,\n                )\n            else:\n                logger.debug(\n                    \"Existing installed version (%s) is most up-to-date and \"\n                    \"satisfies requirement\",\n                    installed_version,\n                )\n            return None\n\n        if _should_install_candidate(best_candidate):\n            logger.debug(\n                \"Using version %s (newest of versions: %s)\",\n                best_candidate.version,\n                _format_versions(best_candidate_result.iter_applicable()),\n            )\n            return best_candidate\n\n        # We have an existing version, and its the best version\n        logger.debug(\n            \"Installed version (%s) is most up-to-date (past versions: %s)\",\n            installed_version,\n            _format_versions(best_candidate_result.iter_applicable()),\n        )\n        raise BestVersionAlreadyInstalled\n\n\ndef _find_name_version_sep(fragment: str, canonical_name: str) -> int:\n    \"\"\"Find the separator's index based on the package's canonical name.\n\n    :param fragment: A <package>+<version> filename \"fragment\" (stem) or\n        egg fragment.\n    :param canonical_name: The package's canonical name.\n\n    This function is needed since the canonicalized name does not necessarily\n    have the same length as the egg info's name part. An example::\n\n    >>> fragment = 'foo__bar-1.0'\n    >>> canonical_name = 'foo-bar'\n    >>> _find_name_version_sep(fragment, canonical_name)\n    8\n    \"\"\"\n    # Project name and version must be separated by one single dash. Find all\n    # occurrences of dashes; if the string in front of it matches the canonical\n    # name, this is the one separating the name and version parts.\n    for i, c in enumerate(fragment):\n        if c != \"-\":\n            continue\n        if canonicalize_name(fragment[:i]) == canonical_name:\n            return i\n    raise ValueError(f\"{fragment} does not match {canonical_name}\")\n\n\ndef _extract_version_from_fragment(fragment: str, canonical_name: str) -> Optional[str]:\n    \"\"\"Parse the version string from a <package>+<version> filename\n    \"fragment\" (stem) or egg fragment.\n\n    :param fragment: The string to parse. E.g. foo-2.1\n    :param canonical_name: The canonicalized name of the package this\n        belongs to.\n    \"\"\"\n    try:\n        version_start = _find_name_version_sep(fragment, canonical_name) + 1\n    except ValueError:\n        return None\n    version = fragment[version_start:]\n    if not version:\n        return None\n    return version\n"},"hash":"HPvcpt2qvp"}