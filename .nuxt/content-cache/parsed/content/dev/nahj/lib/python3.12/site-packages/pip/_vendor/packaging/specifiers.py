{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:packaging:specifiers.py","body":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport abc\nimport functools\nimport itertools\nimport re\nimport warnings\nfrom typing import (\n    Callable,\n    Dict,\n    Iterable,\n    Iterator,\n    List,\n    Optional,\n    Pattern,\n    Set,\n    Tuple,\n    TypeVar,\n    Union,\n)\n\nfrom .utils import canonicalize_version\nfrom .version import LegacyVersion, Version, parse\n\nParsedVersion = Union[Version, LegacyVersion]\nUnparsedVersion = Union[Version, LegacyVersion, str]\nVersionTypeVar = TypeVar(\"VersionTypeVar\", bound=UnparsedVersion)\nCallableOperator = Callable[[ParsedVersion, str], bool]\n\n\nclass InvalidSpecifier(ValueError):\n    \"\"\"\n    An invalid specifier was found, users should refer to PEP 440.\n    \"\"\"\n\n\nclass BaseSpecifier(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __str__(self) -> str:\n        \"\"\"\n        Returns the str representation of this Specifier like object. This\n        should be representative of the Specifier itself.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __hash__(self) -> int:\n        \"\"\"\n        Returns a hash value for this Specifier like object.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Returns a boolean representing whether or not the two Specifier like\n        objects are equal.\n        \"\"\"\n\n    @abc.abstractproperty\n    def prereleases(self) -> Optional[bool]:\n        \"\"\"\n        Returns whether or not pre-releases as a whole are allowed by this\n        specifier.\n        \"\"\"\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        \"\"\"\n        Sets whether or not pre-releases as a whole are allowed by this\n        specifier.\n        \"\"\"\n\n    @abc.abstractmethod\n    def contains(self, item: str, prereleases: Optional[bool] = None) -> bool:\n        \"\"\"\n        Determines if the given item is contained within this specifier.\n        \"\"\"\n\n    @abc.abstractmethod\n    def filter(\n        self, iterable: Iterable[VersionTypeVar], prereleases: Optional[bool] = None\n    ) -> Iterable[VersionTypeVar]:\n        \"\"\"\n        Takes an iterable of items and filters them so that only items which\n        are contained within this specifier are allowed in it.\n        \"\"\"\n\n\nclass _IndividualSpecifier(BaseSpecifier):\n\n    _operators: Dict[str, str] = {}\n    _regex: Pattern[str]\n\n    def __init__(self, spec: str = \"\", prereleases: Optional[bool] = None) -> None:\n        match = self._regex.search(spec)\n        if not match:\n            raise InvalidSpecifier(f\"Invalid specifier: '{spec}'\")\n\n        self._spec: Tuple[str, str] = (\n            match.group(\"operator\").strip(),\n            match.group(\"version\").strip(),\n        )\n\n        # Store whether or not this Specifier should accept prereleases\n        self._prereleases = prereleases\n\n    def __repr__(self) -> str:\n        pre = (\n            f\", prereleases={self.prereleases!r}\"\n            if self._prereleases is not None\n            else \"\"\n        )\n\n        return f\"<{self.__class__.__name__}({str(self)!r}{pre})>\"\n\n    def __str__(self) -> str:\n        return \"{}{}\".format(*self._spec)\n\n    @property\n    def _canonical_spec(self) -> Tuple[str, str]:\n        return self._spec[0], canonicalize_version(self._spec[1])\n\n    def __hash__(self) -> int:\n        return hash(self._canonical_spec)\n\n    def __eq__(self, other: object) -> bool:\n        if isinstance(other, str):\n            try:\n                other = self.__class__(str(other))\n            except InvalidSpecifier:\n                return NotImplemented\n        elif not isinstance(other, self.__class__):\n            return NotImplemented\n\n        return self._canonical_spec == other._canonical_spec\n\n    def _get_operator(self, op: str) -> CallableOperator:\n        operator_callable: CallableOperator = getattr(\n            self, f\"_compare_{self._operators[op]}\"\n        )\n        return operator_callable\n\n    def _coerce_version(self, version: UnparsedVersion) -> ParsedVersion:\n        if not isinstance(version, (LegacyVersion, Version)):\n            version = parse(version)\n        return version\n\n    @property\n    def operator(self) -> str:\n        return self._spec[0]\n\n    @property\n    def version(self) -> str:\n        return self._spec[1]\n\n    @property\n    def prereleases(self) -> Optional[bool]:\n        return self._prereleases\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        self._prereleases = value\n\n    def __contains__(self, item: str) -> bool:\n        return self.contains(item)\n\n    def contains(\n        self, item: UnparsedVersion, prereleases: Optional[bool] = None\n    ) -> bool:\n\n        # Determine if prereleases are to be allowed or not.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # Normalize item to a Version or LegacyVersion, this allows us to have\n        # a shortcut for ``\"2.0\" in Specifier(\">=2\")\n        normalized_item = self._coerce_version(item)\n\n        # Determine if we should be supporting prereleases in this specifier\n        # or not, if we do not support prereleases than we can short circuit\n        # logic if this version is a prereleases.\n        if normalized_item.is_prerelease and not prereleases:\n            return False\n\n        # Actually do the comparison to determine if this item is contained\n        # within this Specifier or not.\n        operator_callable: CallableOperator = self._get_operator(self.operator)\n        return operator_callable(normalized_item, self.version)\n\n    def filter(\n        self, iterable: Iterable[VersionTypeVar], prereleases: Optional[bool] = None\n    ) -> Iterable[VersionTypeVar]:\n\n        yielded = False\n        found_prereleases = []\n\n        kw = {\"prereleases\": prereleases if prereleases is not None else True}\n\n        # Attempt to iterate over all the values in the iterable and if any of\n        # them match, yield them.\n        for version in iterable:\n            parsed_version = self._coerce_version(version)\n\n            if self.contains(parsed_version, **kw):\n                # If our version is a prerelease, and we were not set to allow\n                # prereleases, then we'll store it for later in case nothing\n                # else matches this specifier.\n                if parsed_version.is_prerelease and not (\n                    prereleases or self.prereleases\n                ):\n                    found_prereleases.append(version)\n                # Either this is not a prerelease, or we should have been\n                # accepting prereleases from the beginning.\n                else:\n                    yielded = True\n                    yield version\n\n        # Now that we've iterated over everything, determine if we've yielded\n        # any values, and if we have not and we have any prereleases stored up\n        # then we will go ahead and yield the prereleases.\n        if not yielded and found_prereleases:\n            for version in found_prereleases:\n                yield version\n\n\nclass LegacySpecifier(_IndividualSpecifier):\n\n    _regex_str = r\"\"\"\n        (?P<operator>(==|!=|<=|>=|<|>))\n        \\s*\n        (?P<version>\n            [^,;\\s)]* # Since this is a \"legacy\" specifier, and the version\n                      # string can be just about anything, we match everything\n                      # except for whitespace, a semi-colon for marker support,\n                      # a closing paren since versions can be enclosed in\n                      # them, and a comma since it's a version separator.\n        )\n        \"\"\"\n\n    _regex = re.compile(r\"^\\s*\" + _regex_str + r\"\\s*$\", re.VERBOSE | re.IGNORECASE)\n\n    _operators = {\n        \"==\": \"equal\",\n        \"!=\": \"not_equal\",\n        \"<=\": \"less_than_equal\",\n        \">=\": \"greater_than_equal\",\n        \"<\": \"less_than\",\n        \">\": \"greater_than\",\n    }\n\n    def __init__(self, spec: str = \"\", prereleases: Optional[bool] = None) -> None:\n        super().__init__(spec, prereleases)\n\n        warnings.warn(\n            \"Creating a LegacyVersion has been deprecated and will be \"\n            \"removed in the next major release\",\n            DeprecationWarning,\n        )\n\n    def _coerce_version(self, version: UnparsedVersion) -> LegacyVersion:\n        if not isinstance(version, LegacyVersion):\n            version = LegacyVersion(str(version))\n        return version\n\n    def _compare_equal(self, prospective: LegacyVersion, spec: str) -> bool:\n        return prospective == self._coerce_version(spec)\n\n    def _compare_not_equal(self, prospective: LegacyVersion, spec: str) -> bool:\n        return prospective != self._coerce_version(spec)\n\n    def _compare_less_than_equal(self, prospective: LegacyVersion, spec: str) -> bool:\n        return prospective <= self._coerce_version(spec)\n\n    def _compare_greater_than_equal(\n        self, prospective: LegacyVersion, spec: str\n    ) -> bool:\n        return prospective >= self._coerce_version(spec)\n\n    def _compare_less_than(self, prospective: LegacyVersion, spec: str) -> bool:\n        return prospective < self._coerce_version(spec)\n\n    def _compare_greater_than(self, prospective: LegacyVersion, spec: str) -> bool:\n        return prospective > self._coerce_version(spec)\n\n\ndef _require_version_compare(\n    fn: Callable[[\"Specifier\", ParsedVersion, str], bool]\n) -> Callable[[\"Specifier\", ParsedVersion, str], bool]:\n    @functools.wraps(fn)\n    def wrapped(self: \"Specifier\", prospective: ParsedVersion, spec: str) -> bool:\n        if not isinstance(prospective, Version):\n            return False\n        return fn(self, prospective, spec)\n\n    return wrapped\n\n\nclass Specifier(_IndividualSpecifier):\n\n    _regex_str = r\"\"\"\n        (?P<operator>(~=|==|!=|<=|>=|<|>|===))\n        (?P<version>\n            (?:\n                # The identity operators allow for an escape hatch that will\n                # do an exact string match of the version you wish to install.\n                # This will not be parsed by PEP 440 and we cannot determine\n                # any semantic meaning from it. This operator is discouraged\n                # but included entirely as an escape hatch.\n                (?<====)  # Only match for the identity operator\n                \\s*\n                [^\\s]*    # We just match everything, except for whitespace\n                          # since we are only testing for strict identity.\n            )\n            |\n            (?:\n                # The (non)equality operators allow for wild card and local\n                # versions to be specified so we have to define these two\n                # operators separately to enable that.\n                (?<===|!=)            # Only match for equals and not equals\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)*   # release\n                (?:                   # pre release\n                    [-_\\.]?\n                    (a|b|c|rc|alpha|beta|pre|preview)\n                    [-_\\.]?\n                    [0-9]*\n                )?\n                (?:                   # post release\n                    (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                )?\n\n                # You cannot use a wild card and a dev or local version\n                # together so group them with a | and make them optional.\n                (?:\n                    (?:[-_\\.]?dev[-_\\.]?[0-9]*)?         # dev release\n                    (?:\\+[a-z0-9]+(?:[-_\\.][a-z0-9]+)*)? # local\n                    |\n                    \\.\\*  # Wild card syntax of .*\n                )?\n            )\n            |\n            (?:\n                # The compatible operator requires at least two digits in the\n                # release segment.\n                (?<=~=)               # Only match for the compatible operator\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)+   # release  (We have a + instead of a *)\n                (?:                   # pre release\n                    [-_\\.]?\n                    (a|b|c|rc|alpha|beta|pre|preview)\n                    [-_\\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                )?\n                (?:[-_\\.]?dev[-_\\.]?[0-9]*)?          # dev release\n            )\n            |\n            (?:\n                # All other operators only allow a sub set of what the\n                # (non)equality operators do. Specifically they do not allow\n                # local versions to be specified nor do they allow the prefix\n                # matching wild cards.\n                (?<!==|!=|~=)         # We have special cases for these\n                                      # operators so we want to make sure they\n                                      # don't match here.\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)*   # release\n                (?:                   # pre release\n                    [-_\\.]?\n                    (a|b|c|rc|alpha|beta|pre|preview)\n                    [-_\\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                )?\n                (?:[-_\\.]?dev[-_\\.]?[0-9]*)?          # dev release\n            )\n        )\n        \"\"\"\n\n    _regex = re.compile(r\"^\\s*\" + _regex_str + r\"\\s*$\", re.VERBOSE | re.IGNORECASE)\n\n    _operators = {\n        \"~=\": \"compatible\",\n        \"==\": \"equal\",\n        \"!=\": \"not_equal\",\n        \"<=\": \"less_than_equal\",\n        \">=\": \"greater_than_equal\",\n        \"<\": \"less_than\",\n        \">\": \"greater_than\",\n        \"===\": \"arbitrary\",\n    }\n\n    @_require_version_compare\n    def _compare_compatible(self, prospective: ParsedVersion, spec: str) -> bool:\n\n        # Compatible releases have an equivalent combination of >= and ==. That\n        # is that ~=2.2 is equivalent to >=2.2,==2.*. This allows us to\n        # implement this in terms of the other specifiers instead of\n        # implementing it ourselves. The only thing we need to do is construct\n        # the other specifiers.\n\n        # We want everything but the last item in the version, but we want to\n        # ignore suffix segments.\n        prefix = \".\".join(\n            list(itertools.takewhile(_is_not_suffix, _version_split(spec)))[:-1]\n        )\n\n        # Add the prefix notation to the end of our string\n        prefix += \".*\"\n\n        return self._get_operator(\">=\")(prospective, spec) and self._get_operator(\"==\")(\n            prospective, prefix\n        )\n\n    @_require_version_compare\n    def _compare_equal(self, prospective: ParsedVersion, spec: str) -> bool:\n\n        # We need special logic to handle prefix matching\n        if spec.endswith(\".*\"):\n            # In the case of prefix matching we want to ignore local segment.\n            prospective = Version(prospective.public)\n            # Split the spec out by dots, and pretend that there is an implicit\n            # dot in between a release segment and a pre-release segment.\n            split_spec = _version_split(spec[:-2])  # Remove the trailing .*\n\n            # Split the prospective version out by dots, and pretend that there\n            # is an implicit dot in between a release segment and a pre-release\n            # segment.\n            split_prospective = _version_split(str(prospective))\n\n            # Shorten the prospective version to be the same length as the spec\n            # so that we can determine if the specifier is a prefix of the\n            # prospective version or not.\n            shortened_prospective = split_prospective[: len(split_spec)]\n\n            # Pad out our two sides with zeros so that they both equal the same\n            # length.\n            padded_spec, padded_prospective = _pad_version(\n                split_spec, shortened_prospective\n            )\n\n            return padded_prospective == padded_spec\n        else:\n            # Convert our spec string into a Version\n            spec_version = Version(spec)\n\n            # If the specifier does not have a local segment, then we want to\n            # act as if the prospective version also does not have a local\n            # segment.\n            if not spec_version.local:\n                prospective = Version(prospective.public)\n\n            return prospective == spec_version\n\n    @_require_version_compare\n    def _compare_not_equal(self, prospective: ParsedVersion, spec: str) -> bool:\n        return not self._compare_equal(prospective, spec)\n\n    @_require_version_compare\n    def _compare_less_than_equal(self, prospective: ParsedVersion, spec: str) -> bool:\n\n        # NB: Local version identifiers are NOT permitted in the version\n        # specifier, so local version labels can be universally removed from\n        # the prospective version.\n        return Version(prospective.public) <= Version(spec)\n\n    @_require_version_compare\n    def _compare_greater_than_equal(\n        self, prospective: ParsedVersion, spec: str\n    ) -> bool:\n\n        # NB: Local version identifiers are NOT permitted in the version\n        # specifier, so local version labels can be universally removed from\n        # the prospective version.\n        return Version(prospective.public) >= Version(spec)\n\n    @_require_version_compare\n    def _compare_less_than(self, prospective: ParsedVersion, spec_str: str) -> bool:\n\n        # Convert our spec to a Version instance, since we'll want to work with\n        # it as a version.\n        spec = Version(spec_str)\n\n        # Check to see if the prospective version is less than the spec\n        # version. If it's not we can short circuit and just return False now\n        # instead of doing extra unneeded work.\n        if not prospective < spec:\n            return False\n\n        # This special case is here so that, unless the specifier itself\n        # includes is a pre-release version, that we do not accept pre-release\n        # versions for the version mentioned in the specifier (e.g. <3.1 should\n        # not match 3.1.dev0, but should match 3.0.dev0).\n        if not spec.is_prerelease and prospective.is_prerelease:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # If we've gotten to here, it means that prospective version is both\n        # less than the spec version *and* it's not a pre-release of the same\n        # version in the spec.\n        return True\n\n    @_require_version_compare\n    def _compare_greater_than(self, prospective: ParsedVersion, spec_str: str) -> bool:\n\n        # Convert our spec to a Version instance, since we'll want to work with\n        # it as a version.\n        spec = Version(spec_str)\n\n        # Check to see if the prospective version is greater than the spec\n        # version. If it's not we can short circuit and just return False now\n        # instead of doing extra unneeded work.\n        if not prospective > spec:\n            return False\n\n        # This special case is here so that, unless the specifier itself\n        # includes is a post-release version, that we do not accept\n        # post-release versions for the version mentioned in the specifier\n        # (e.g. >3.1 should not match 3.0.post0, but should match 3.2.post0).\n        if not spec.is_postrelease and prospective.is_postrelease:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # Ensure that we do not allow a local version of the version mentioned\n        # in the specifier, which is technically greater than, to match.\n        if prospective.local is not None:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # If we've gotten to here, it means that prospective version is both\n        # greater than the spec version *and* it's not a pre-release of the\n        # same version in the spec.\n        return True\n\n    def _compare_arbitrary(self, prospective: Version, spec: str) -> bool:\n        return str(prospective).lower() == str(spec).lower()\n\n    @property\n    def prereleases(self) -> bool:\n\n        # If there is an explicit prereleases set for this, then we'll just\n        # blindly use that.\n        if self._prereleases is not None:\n            return self._prereleases\n\n        # Look at all of our specifiers and determine if they are inclusive\n        # operators, and if they are if they are including an explicit\n        # prerelease.\n        operator, version = self._spec\n        if operator in [\"==\", \">=\", \"<=\", \"~=\", \"===\"]:\n            # The == specifier can include a trailing .*, if it does we\n            # want to remove before parsing.\n            if operator == \"==\" and version.endswith(\".*\"):\n                version = version[:-2]\n\n            # Parse the version, and if it is a pre-release than this\n            # specifier allows pre-releases.\n            if parse(version).is_prerelease:\n                return True\n\n        return False\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        self._prereleases = value\n\n\n_prefix_regex = re.compile(r\"^([0-9]+)((?:a|b|c|rc)[0-9]+)$\")\n\n\ndef _version_split(version: str) -> List[str]:\n    result: List[str] = []\n    for item in version.split(\".\"):\n        match = _prefix_regex.search(item)\n        if match:\n            result.extend(match.groups())\n        else:\n            result.append(item)\n    return result\n\n\ndef _is_not_suffix(segment: str) -> bool:\n    return not any(\n        segment.startswith(prefix) for prefix in (\"dev\", \"a\", \"b\", \"rc\", \"post\")\n    )\n\n\ndef _pad_version(left: List[str], right: List[str]) -> Tuple[List[str], List[str]]:\n    left_split, right_split = [], []\n\n    # Get the release segment of our versions\n    left_split.append(list(itertools.takewhile(lambda x: x.isdigit(), left)))\n    right_split.append(list(itertools.takewhile(lambda x: x.isdigit(), right)))\n\n    # Get the rest of our versions\n    left_split.append(left[len(left_split[0]) :])\n    right_split.append(right[len(right_split[0]) :])\n\n    # Insert our padding\n    left_split.insert(1, [\"0\"] * max(0, len(right_split[0]) - len(left_split[0])))\n    right_split.insert(1, [\"0\"] * max(0, len(left_split[0]) - len(right_split[0])))\n\n    return (list(itertools.chain(*left_split)), list(itertools.chain(*right_split)))\n\n\nclass SpecifierSet(BaseSpecifier):\n    def __init__(\n        self, specifiers: str = \"\", prereleases: Optional[bool] = None\n    ) -> None:\n\n        # Split on , to break each individual specifier into it's own item, and\n        # strip each item to remove leading/trailing whitespace.\n        split_specifiers = [s.strip() for s in specifiers.split(\",\") if s.strip()]\n\n        # Parsed each individual specifier, attempting first to make it a\n        # Specifier and falling back to a LegacySpecifier.\n        parsed: Set[_IndividualSpecifier] = set()\n        for specifier in split_specifiers:\n            try:\n                parsed.add(Specifier(specifier))\n            except InvalidSpecifier:\n                parsed.add(LegacySpecifier(specifier))\n\n        # Turn our parsed specifiers into a frozen set and save them for later.\n        self._specs = frozenset(parsed)\n\n        # Store our prereleases value so we can use it later to determine if\n        # we accept prereleases or not.\n        self._prereleases = prereleases\n\n    def __repr__(self) -> str:\n        pre = (\n            f\", prereleases={self.prereleases!r}\"\n            if self._prereleases is not None\n            else \"\"\n        )\n\n        return f\"<SpecifierSet({str(self)!r}{pre})>\"\n\n    def __str__(self) -> str:\n        return \",\".join(sorted(str(s) for s in self._specs))\n\n    def __hash__(self) -> int:\n        return hash(self._specs)\n\n    def __and__(self, other: Union[\"SpecifierSet\", str]) -> \"SpecifierSet\":\n        if isinstance(other, str):\n            other = SpecifierSet(other)\n        elif not isinstance(other, SpecifierSet):\n            return NotImplemented\n\n        specifier = SpecifierSet()\n        specifier._specs = frozenset(self._specs | other._specs)\n\n        if self._prereleases is None and other._prereleases is not None:\n            specifier._prereleases = other._prereleases\n        elif self._prereleases is not None and other._prereleases is None:\n            specifier._prereleases = self._prereleases\n        elif self._prereleases == other._prereleases:\n            specifier._prereleases = self._prereleases\n        else:\n            raise ValueError(\n                \"Cannot combine SpecifierSets with True and False prerelease \"\n                \"overrides.\"\n            )\n\n        return specifier\n\n    def __eq__(self, other: object) -> bool:\n        if isinstance(other, (str, _IndividualSpecifier)):\n            other = SpecifierSet(str(other))\n        elif not isinstance(other, SpecifierSet):\n            return NotImplemented\n\n        return self._specs == other._specs\n\n    def __len__(self) -> int:\n        return len(self._specs)\n\n    def __iter__(self) -> Iterator[_IndividualSpecifier]:\n        return iter(self._specs)\n\n    @property\n    def prereleases(self) -> Optional[bool]:\n\n        # If we have been given an explicit prerelease modifier, then we'll\n        # pass that through here.\n        if self._prereleases is not None:\n            return self._prereleases\n\n        # If we don't have any specifiers, and we don't have a forced value,\n        # then we'll just return None since we don't know if this should have\n        # pre-releases or not.\n        if not self._specs:\n            return None\n\n        # Otherwise we'll see if any of the given specifiers accept\n        # prereleases, if any of them do we'll return True, otherwise False.\n        return any(s.prereleases for s in self._specs)\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        self._prereleases = value\n\n    def __contains__(self, item: UnparsedVersion) -> bool:\n        return self.contains(item)\n\n    def contains(\n        self, item: UnparsedVersion, prereleases: Optional[bool] = None\n    ) -> bool:\n\n        # Ensure that our item is a Version or LegacyVersion instance.\n        if not isinstance(item, (LegacyVersion, Version)):\n            item = parse(item)\n\n        # Determine if we're forcing a prerelease or not, if we're not forcing\n        # one for this particular filter call, then we'll use whatever the\n        # SpecifierSet thinks for whether or not we should support prereleases.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # We can determine if we're going to allow pre-releases by looking to\n        # see if any of the underlying items supports them. If none of them do\n        # and this item is a pre-release then we do not allow it and we can\n        # short circuit that here.\n        # Note: This means that 1.0.dev1 would not be contained in something\n        #       like >=1.0.devabc however it would be in >=1.0.debabc,>0.0.dev0\n        if not prereleases and item.is_prerelease:\n            return False\n\n        # We simply dispatch to the underlying specs here to make sure that the\n        # given version is contained within all of them.\n        # Note: This use of all() here means that an empty set of specifiers\n        #       will always return True, this is an explicit design decision.\n        return all(s.contains(item, prereleases=prereleases) for s in self._specs)\n\n    def filter(\n        self, iterable: Iterable[VersionTypeVar], prereleases: Optional[bool] = None\n    ) -> Iterable[VersionTypeVar]:\n\n        # Determine if we're forcing a prerelease or not, if we're not forcing\n        # one for this particular filter call, then we'll use whatever the\n        # SpecifierSet thinks for whether or not we should support prereleases.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # If we have any specifiers, then we want to wrap our iterable in the\n        # filter method for each one, this will act as a logical AND amongst\n        # each specifier.\n        if self._specs:\n            for spec in self._specs:\n                iterable = spec.filter(iterable, prereleases=bool(prereleases))\n            return iterable\n        # If we do not have any specifiers, then we need to have a rough filter\n        # which will filter out any pre-releases, unless there are no final\n        # releases, and which will filter out LegacyVersion in general.\n        else:\n            filtered: List[VersionTypeVar] = []\n            found_prereleases: List[VersionTypeVar] = []\n\n            item: UnparsedVersion\n            parsed_version: Union[Version, LegacyVersion]\n\n            for item in iterable:\n                # Ensure that we some kind of Version class for this item.\n                if not isinstance(item, (LegacyVersion, Version)):\n                    parsed_version = parse(item)\n                else:\n                    parsed_version = item\n\n                # Filter out any item which is parsed as a LegacyVersion\n                if isinstance(parsed_version, LegacyVersion):\n                    continue\n\n                # Store any item which is a pre-release for later unless we've\n                # already found a final version or we are accepting prereleases\n                if parsed_version.is_prerelease and not prereleases:\n                    if not filtered:\n                        found_prereleases.append(item)\n                else:\n                    filtered.append(item)\n\n            # If we've found no items except for pre-releases, then we'll go\n            # ahead and use the pre-releases\n            if not filtered and found_prereleases and prereleases is None:\n                return found_prereleases\n\n            return filtered\n"},"hash":"8C2aRKEVGC"}