{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:cli:autocompletion.py","body":"\"\"\"Logic that powers autocompletion installed by ``pip completion``.\n\"\"\"\n\nimport optparse\nimport os\nimport sys\nfrom itertools import chain\nfrom typing import Any, Iterable, List, Optional\n\nfrom pip._internal.cli.main_parser import create_main_parser\nfrom pip._internal.commands import commands_dict, create_command\nfrom pip._internal.metadata import get_default_environment\n\n\ndef autocomplete() -> None:\n    \"\"\"Entry Point for completion of main and subcommand options.\"\"\"\n    # Don't complete if user hasn't sourced bash_completion file.\n    if \"PIP_AUTO_COMPLETE\" not in os.environ:\n        return\n    cwords = os.environ[\"COMP_WORDS\"].split()[1:]\n    cword = int(os.environ[\"COMP_CWORD\"])\n    try:\n        current = cwords[cword - 1]\n    except IndexError:\n        current = \"\"\n\n    parser = create_main_parser()\n    subcommands = list(commands_dict)\n    options = []\n\n    # subcommand\n    subcommand_name: Optional[str] = None\n    for word in cwords:\n        if word in subcommands:\n            subcommand_name = word\n            break\n    # subcommand options\n    if subcommand_name is not None:\n        # special case: 'help' subcommand has no options\n        if subcommand_name == \"help\":\n            sys.exit(1)\n        # special case: list locally installed dists for show and uninstall\n        should_list_installed = not current.startswith(\"-\") and subcommand_name in [\n            \"show\",\n            \"uninstall\",\n        ]\n        if should_list_installed:\n            env = get_default_environment()\n            lc = current.lower()\n            installed = [\n                dist.canonical_name\n                for dist in env.iter_installed_distributions(local_only=True)\n                if dist.canonical_name.startswith(lc)\n                and dist.canonical_name not in cwords[1:]\n            ]\n            # if there are no dists installed, fall back to option completion\n            if installed:\n                for dist in installed:\n                    print(dist)\n                sys.exit(1)\n\n        should_list_installables = (\n            not current.startswith(\"-\") and subcommand_name == \"install\"\n        )\n        if should_list_installables:\n            for path in auto_complete_paths(current, \"path\"):\n                print(path)\n            sys.exit(1)\n\n        subcommand = create_command(subcommand_name)\n\n        for opt in subcommand.parser.option_list_all:\n            if opt.help != optparse.SUPPRESS_HELP:\n                options += [\n                    (opt_str, opt.nargs) for opt_str in opt._long_opts + opt._short_opts\n                ]\n\n        # filter out previously specified options from available options\n        prev_opts = [x.split(\"=\")[0] for x in cwords[1 : cword - 1]]\n        options = [(x, v) for (x, v) in options if x not in prev_opts]\n        # filter options by current input\n        options = [(k, v) for k, v in options if k.startswith(current)]\n        # get completion type given cwords and available subcommand options\n        completion_type = get_path_completion_type(\n            cwords,\n            cword,\n            subcommand.parser.option_list_all,\n        )\n        # get completion files and directories if ``completion_type`` is\n        # ``<file>``, ``<dir>`` or ``<path>``\n        if completion_type:\n            paths = auto_complete_paths(current, completion_type)\n            options = [(path, 0) for path in paths]\n        for option in options:\n            opt_label = option[0]\n            # append '=' to options which require args\n            if option[1] and option[0][:2] == \"--\":\n                opt_label += \"=\"\n            print(opt_label)\n    else:\n        # show main parser options only when necessary\n\n        opts = [i.option_list for i in parser.option_groups]\n        opts.append(parser.option_list)\n        flattened_opts = chain.from_iterable(opts)\n        if current.startswith(\"-\"):\n            for opt in flattened_opts:\n                if opt.help != optparse.SUPPRESS_HELP:\n                    subcommands += opt._long_opts + opt._short_opts\n        else:\n            # get completion type given cwords and all available options\n            completion_type = get_path_completion_type(cwords, cword, flattened_opts)\n            if completion_type:\n                subcommands = list(auto_complete_paths(current, completion_type))\n\n        print(\" \".join([x for x in subcommands if x.startswith(current)]))\n    sys.exit(1)\n\n\ndef get_path_completion_type(\n    cwords: List[str], cword: int, opts: Iterable[Any]\n) -> Optional[str]:\n    \"\"\"Get the type of path completion (``file``, ``dir``, ``path`` or None)\n\n    :param cwords: same as the environmental variable ``COMP_WORDS``\n    :param cword: same as the environmental variable ``COMP_CWORD``\n    :param opts: The available options to check\n    :return: path completion type (``file``, ``dir``, ``path`` or None)\n    \"\"\"\n    if cword < 2 or not cwords[cword - 2].startswith(\"-\"):\n        return None\n    for opt in opts:\n        if opt.help == optparse.SUPPRESS_HELP:\n            continue\n        for o in str(opt).split(\"/\"):\n            if cwords[cword - 2].split(\"=\")[0] == o:\n                if not opt.metavar or any(\n                    x in (\"path\", \"file\", \"dir\") for x in opt.metavar.split(\"/\")\n                ):\n                    return opt.metavar\n    return None\n\n\ndef auto_complete_paths(current: str, completion_type: str) -> Iterable[str]:\n    \"\"\"If ``completion_type`` is ``file`` or ``path``, list all regular files\n    and directories starting with ``current``; otherwise only list directories\n    starting with ``current``.\n\n    :param current: The word to be completed\n    :param completion_type: path completion type(``file``, ``path`` or ``dir``)\n    :return: A generator of regular files and/or directories\n    \"\"\"\n    directory, filename = os.path.split(current)\n    current_path = os.path.abspath(directory)\n    # Don't complete paths if they can't be accessed\n    if not os.access(current_path, os.R_OK):\n        return\n    filename = os.path.normcase(filename)\n    # list all files that start with ``filename``\n    file_list = (\n        x for x in os.listdir(current_path) if os.path.normcase(x).startswith(filename)\n    )\n    for f in file_list:\n        opt = os.path.join(current_path, f)\n        comp_file = os.path.normcase(os.path.join(directory, f))\n        # complete regular files when there is not ``<dir>`` after option\n        # complete directories when there is ``<file>``, ``<path>`` or\n        # ``<dir>``after option\n        if completion_type != \"dir\" and os.path.isfile(opt):\n            yield comp_file\n        elif os.path.isdir(opt):\n            yield os.path.join(comp_file, \"\")\n"},"hash":"GTjqXCkI81"}