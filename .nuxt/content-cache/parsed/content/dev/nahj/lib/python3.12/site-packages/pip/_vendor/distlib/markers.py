{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:distlib:markers.py","body":"# -*- coding: utf-8 -*-\n#\n# Copyright (C) 2012-2023 Vinay Sajip.\n# Licensed to the Python Software Foundation under a contributor agreement.\n# See LICENSE.txt and CONTRIBUTORS.txt.\n#\n\"\"\"\nParser for the environment markers micro-language defined in PEP 508.\n\"\"\"\n\n# Note: In PEP 345, the micro-language was Python compatible, so the ast\n# module could be used to parse it. However, PEP 508 introduced operators such\n# as ~= and === which aren't in Python, necessitating a different approach.\n\nimport os\nimport re\nimport sys\nimport platform\n\nfrom .compat import string_types\nfrom .util import in_venv, parse_marker\nfrom .version import LegacyVersion as LV\n\n__all__ = ['interpret']\n\n_VERSION_PATTERN = re.compile(\n    r'((\\d+(\\.\\d+)*\\w*)|\\'(\\d+(\\.\\d+)*\\w*)\\'|\\\"(\\d+(\\.\\d+)*\\w*)\\\")')\n_VERSION_MARKERS = {'python_version', 'python_full_version'}\n\n\ndef _is_version_marker(s):\n    return isinstance(s, string_types) and s in _VERSION_MARKERS\n\n\ndef _is_literal(o):\n    if not isinstance(o, string_types) or not o:\n        return False\n    return o[0] in '\\'\"'\n\n\ndef _get_versions(s):\n    return {LV(m.groups()[0]) for m in _VERSION_PATTERN.finditer(s)}\n\n\nclass Evaluator(object):\n    \"\"\"\n    This class is used to evaluate marker expressions.\n    \"\"\"\n\n    operations = {\n        '==': lambda x, y: x == y,\n        '===': lambda x, y: x == y,\n        '~=': lambda x, y: x == y or x > y,\n        '!=': lambda x, y: x != y,\n        '<': lambda x, y: x < y,\n        '<=': lambda x, y: x == y or x < y,\n        '>': lambda x, y: x > y,\n        '>=': lambda x, y: x == y or x > y,\n        'and': lambda x, y: x and y,\n        'or': lambda x, y: x or y,\n        'in': lambda x, y: x in y,\n        'not in': lambda x, y: x not in y,\n    }\n\n    def evaluate(self, expr, context):\n        \"\"\"\n        Evaluate a marker expression returned by the :func:`parse_requirement`\n        function in the specified context.\n        \"\"\"\n        if isinstance(expr, string_types):\n            if expr[0] in '\\'\"':\n                result = expr[1:-1]\n            else:\n                if expr not in context:\n                    raise SyntaxError('unknown variable: %s' % expr)\n                result = context[expr]\n        else:\n            assert isinstance(expr, dict)\n            op = expr['op']\n            if op not in self.operations:\n                raise NotImplementedError('op not implemented: %s' % op)\n            elhs = expr['lhs']\n            erhs = expr['rhs']\n            if _is_literal(expr['lhs']) and _is_literal(expr['rhs']):\n                raise SyntaxError('invalid comparison: %s %s %s' %\n                                  (elhs, op, erhs))\n\n            lhs = self.evaluate(elhs, context)\n            rhs = self.evaluate(erhs, context)\n            if ((_is_version_marker(elhs) or _is_version_marker(erhs))\n                    and op in ('<', '<=', '>', '>=', '===', '==', '!=', '~=')):\n                lhs = LV(lhs)\n                rhs = LV(rhs)\n            elif _is_version_marker(elhs) and op in ('in', 'not in'):\n                lhs = LV(lhs)\n                rhs = _get_versions(rhs)\n            result = self.operations[op](lhs, rhs)\n        return result\n\n\n_DIGITS = re.compile(r'\\d+\\.\\d+')\n\n\ndef default_context():\n\n    def format_full_version(info):\n        version = '%s.%s.%s' % (info.major, info.minor, info.micro)\n        kind = info.releaselevel\n        if kind != 'final':\n            version += kind[0] + str(info.serial)\n        return version\n\n    if hasattr(sys, 'implementation'):\n        implementation_version = format_full_version(\n            sys.implementation.version)\n        implementation_name = sys.implementation.name\n    else:\n        implementation_version = '0'\n        implementation_name = ''\n\n    ppv = platform.python_version()\n    m = _DIGITS.match(ppv)\n    pv = m.group(0)\n    result = {\n        'implementation_name': implementation_name,\n        'implementation_version': implementation_version,\n        'os_name': os.name,\n        'platform_machine': platform.machine(),\n        'platform_python_implementation': platform.python_implementation(),\n        'platform_release': platform.release(),\n        'platform_system': platform.system(),\n        'platform_version': platform.version(),\n        'platform_in_venv': str(in_venv()),\n        'python_full_version': ppv,\n        'python_version': pv,\n        'sys_platform': sys.platform,\n    }\n    return result\n\n\nDEFAULT_CONTEXT = default_context()\ndel default_context\n\nevaluator = Evaluator()\n\n\ndef interpret(marker, execution_context=None):\n    \"\"\"\n    Interpret a marker and return a result depending on environment.\n\n    :param marker: The marker to interpret.\n    :type marker: str\n    :param execution_context: The context used for name lookup.\n    :type execution_context: mapping\n    \"\"\"\n    try:\n        expr, rest = parse_marker(marker)\n    except Exception as e:\n        raise SyntaxError('Unable to interpret marker syntax: %s: %s' %\n                          (marker, e))\n    if rest and rest[0] != '#':\n        raise SyntaxError('unexpected trailing data in marker: %s: %s' %\n                          (marker, rest))\n    context = dict(DEFAULT_CONTEXT)\n    if execution_context:\n        context.update(execution_context)\n    return evaluator.evaluate(expr, context)\n"},"hash":"gQxQKr0DyC"}