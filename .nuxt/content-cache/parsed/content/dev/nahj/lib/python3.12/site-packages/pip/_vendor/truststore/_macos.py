{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:truststore:_macos.py","body":"import contextlib\nimport ctypes\nimport platform\nimport ssl\nimport typing\nfrom ctypes import (\n    CDLL,\n    POINTER,\n    c_bool,\n    c_char_p,\n    c_int32,\n    c_long,\n    c_uint32,\n    c_ulong,\n    c_void_p,\n)\nfrom ctypes.util import find_library\n\nfrom ._ssl_constants import _set_ssl_context_verify_mode\n\n_mac_version = platform.mac_ver()[0]\n_mac_version_info = tuple(map(int, _mac_version.split(\".\")))\nif _mac_version_info < (10, 8):\n    raise ImportError(\n        f\"Only OS X 10.8 and newer are supported, not {_mac_version_info[0]}.{_mac_version_info[1]}\"\n    )\n\n\ndef _load_cdll(name: str, macos10_16_path: str) -> CDLL:\n    \"\"\"Loads a CDLL by name, falling back to known path on 10.16+\"\"\"\n    try:\n        # Big Sur is technically 11 but we use 10.16 due to the Big Sur\n        # beta being labeled as 10.16.\n        path: str | None\n        if _mac_version_info >= (10, 16):\n            path = macos10_16_path\n        else:\n            path = find_library(name)\n        if not path:\n            raise OSError  # Caught and reraised as 'ImportError'\n        return CDLL(path, use_errno=True)\n    except OSError:\n        raise ImportError(f\"The library {name} failed to load\") from None\n\n\nSecurity = _load_cdll(\n    \"Security\", \"/System/Library/Frameworks/Security.framework/Security\"\n)\nCoreFoundation = _load_cdll(\n    \"CoreFoundation\",\n    \"/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation\",\n)\n\nBoolean = c_bool\nCFIndex = c_long\nCFStringEncoding = c_uint32\nCFData = c_void_p\nCFString = c_void_p\nCFArray = c_void_p\nCFMutableArray = c_void_p\nCFError = c_void_p\nCFType = c_void_p\nCFTypeID = c_ulong\nCFTypeRef = POINTER(CFType)\nCFAllocatorRef = c_void_p\n\nOSStatus = c_int32\n\nCFErrorRef = POINTER(CFError)\nCFDataRef = POINTER(CFData)\nCFStringRef = POINTER(CFString)\nCFArrayRef = POINTER(CFArray)\nCFMutableArrayRef = POINTER(CFMutableArray)\nCFArrayCallBacks = c_void_p\nCFOptionFlags = c_uint32\n\nSecCertificateRef = POINTER(c_void_p)\nSecPolicyRef = POINTER(c_void_p)\nSecTrustRef = POINTER(c_void_p)\nSecTrustResultType = c_uint32\nSecTrustOptionFlags = c_uint32\n\ntry:\n    Security.SecCertificateCreateWithData.argtypes = [CFAllocatorRef, CFDataRef]\n    Security.SecCertificateCreateWithData.restype = SecCertificateRef\n\n    Security.SecCertificateCopyData.argtypes = [SecCertificateRef]\n    Security.SecCertificateCopyData.restype = CFDataRef\n\n    Security.SecCopyErrorMessageString.argtypes = [OSStatus, c_void_p]\n    Security.SecCopyErrorMessageString.restype = CFStringRef\n\n    Security.SecTrustSetAnchorCertificates.argtypes = [SecTrustRef, CFArrayRef]\n    Security.SecTrustSetAnchorCertificates.restype = OSStatus\n\n    Security.SecTrustSetAnchorCertificatesOnly.argtypes = [SecTrustRef, Boolean]\n    Security.SecTrustSetAnchorCertificatesOnly.restype = OSStatus\n\n    Security.SecTrustEvaluate.argtypes = [SecTrustRef, POINTER(SecTrustResultType)]\n    Security.SecTrustEvaluate.restype = OSStatus\n\n    Security.SecPolicyCreateRevocation.argtypes = [CFOptionFlags]\n    Security.SecPolicyCreateRevocation.restype = SecPolicyRef\n\n    Security.SecPolicyCreateSSL.argtypes = [Boolean, CFStringRef]\n    Security.SecPolicyCreateSSL.restype = SecPolicyRef\n\n    Security.SecTrustCreateWithCertificates.argtypes = [\n        CFTypeRef,\n        CFTypeRef,\n        POINTER(SecTrustRef),\n    ]\n    Security.SecTrustCreateWithCertificates.restype = OSStatus\n\n    Security.SecTrustGetTrustResult.argtypes = [\n        SecTrustRef,\n        POINTER(SecTrustResultType),\n    ]\n    Security.SecTrustGetTrustResult.restype = OSStatus\n\n    Security.SecTrustRef = SecTrustRef  # type: ignore[attr-defined]\n    Security.SecTrustResultType = SecTrustResultType  # type: ignore[attr-defined]\n    Security.OSStatus = OSStatus  # type: ignore[attr-defined]\n\n    kSecRevocationUseAnyAvailableMethod = 3\n    kSecRevocationRequirePositiveResponse = 8\n\n    CoreFoundation.CFRelease.argtypes = [CFTypeRef]\n    CoreFoundation.CFRelease.restype = None\n\n    CoreFoundation.CFGetTypeID.argtypes = [CFTypeRef]\n    CoreFoundation.CFGetTypeID.restype = CFTypeID\n\n    CoreFoundation.CFStringCreateWithCString.argtypes = [\n        CFAllocatorRef,\n        c_char_p,\n        CFStringEncoding,\n    ]\n    CoreFoundation.CFStringCreateWithCString.restype = CFStringRef\n\n    CoreFoundation.CFStringGetCStringPtr.argtypes = [CFStringRef, CFStringEncoding]\n    CoreFoundation.CFStringGetCStringPtr.restype = c_char_p\n\n    CoreFoundation.CFStringGetCString.argtypes = [\n        CFStringRef,\n        c_char_p,\n        CFIndex,\n        CFStringEncoding,\n    ]\n    CoreFoundation.CFStringGetCString.restype = c_bool\n\n    CoreFoundation.CFDataCreate.argtypes = [CFAllocatorRef, c_char_p, CFIndex]\n    CoreFoundation.CFDataCreate.restype = CFDataRef\n\n    CoreFoundation.CFDataGetLength.argtypes = [CFDataRef]\n    CoreFoundation.CFDataGetLength.restype = CFIndex\n\n    CoreFoundation.CFDataGetBytePtr.argtypes = [CFDataRef]\n    CoreFoundation.CFDataGetBytePtr.restype = c_void_p\n\n    CoreFoundation.CFArrayCreate.argtypes = [\n        CFAllocatorRef,\n        POINTER(CFTypeRef),\n        CFIndex,\n        CFArrayCallBacks,\n    ]\n    CoreFoundation.CFArrayCreate.restype = CFArrayRef\n\n    CoreFoundation.CFArrayCreateMutable.argtypes = [\n        CFAllocatorRef,\n        CFIndex,\n        CFArrayCallBacks,\n    ]\n    CoreFoundation.CFArrayCreateMutable.restype = CFMutableArrayRef\n\n    CoreFoundation.CFArrayAppendValue.argtypes = [CFMutableArrayRef, c_void_p]\n    CoreFoundation.CFArrayAppendValue.restype = None\n\n    CoreFoundation.CFArrayGetCount.argtypes = [CFArrayRef]\n    CoreFoundation.CFArrayGetCount.restype = CFIndex\n\n    CoreFoundation.CFArrayGetValueAtIndex.argtypes = [CFArrayRef, CFIndex]\n    CoreFoundation.CFArrayGetValueAtIndex.restype = c_void_p\n\n    CoreFoundation.CFErrorGetCode.argtypes = [CFErrorRef]\n    CoreFoundation.CFErrorGetCode.restype = CFIndex\n\n    CoreFoundation.CFErrorCopyDescription.argtypes = [CFErrorRef]\n    CoreFoundation.CFErrorCopyDescription.restype = CFStringRef\n\n    CoreFoundation.kCFAllocatorDefault = CFAllocatorRef.in_dll(  # type: ignore[attr-defined]\n        CoreFoundation, \"kCFAllocatorDefault\"\n    )\n    CoreFoundation.kCFTypeArrayCallBacks = c_void_p.in_dll(  # type: ignore[attr-defined]\n        CoreFoundation, \"kCFTypeArrayCallBacks\"\n    )\n\n    CoreFoundation.CFTypeRef = CFTypeRef  # type: ignore[attr-defined]\n    CoreFoundation.CFArrayRef = CFArrayRef  # type: ignore[attr-defined]\n    CoreFoundation.CFStringRef = CFStringRef  # type: ignore[attr-defined]\n    CoreFoundation.CFErrorRef = CFErrorRef  # type: ignore[attr-defined]\n\nexcept AttributeError:\n    raise ImportError(\"Error initializing ctypes\") from None\n\n\ndef _handle_osstatus(result: OSStatus, _: typing.Any, args: typing.Any) -> typing.Any:\n    \"\"\"\n    Raises an error if the OSStatus value is non-zero.\n    \"\"\"\n    if int(result) == 0:\n        return args\n\n    # Returns a CFString which we need to transform\n    # into a UTF-8 Python string.\n    error_message_cfstring = None\n    try:\n        error_message_cfstring = Security.SecCopyErrorMessageString(result, None)\n\n        # First step is convert the CFString into a C string pointer.\n        # We try the fast no-copy way first.\n        error_message_cfstring_c_void_p = ctypes.cast(\n            error_message_cfstring, ctypes.POINTER(ctypes.c_void_p)\n        )\n        message = CoreFoundation.CFStringGetCStringPtr(\n            error_message_cfstring_c_void_p, CFConst.kCFStringEncodingUTF8\n        )\n\n        # Quoting the Apple dev docs:\n        #\n        # \"A pointer to a C string or NULL if the internal\n        # storage of theString does not allow this to be\n        # returned efficiently.\"\n        #\n        # So we need to get our hands dirty.\n        if message is None:\n            buffer = ctypes.create_string_buffer(1024)\n            result = CoreFoundation.CFStringGetCString(\n                error_message_cfstring_c_void_p,\n                buffer,\n                1024,\n                CFConst.kCFStringEncodingUTF8,\n            )\n            if not result:\n                raise OSError(\"Error copying C string from CFStringRef\")\n            message = buffer.value\n\n    finally:\n        if error_message_cfstring is not None:\n            CoreFoundation.CFRelease(error_message_cfstring)\n\n    # If no message can be found for this status we come\n    # up with a generic one that forwards the status code.\n    if message is None or message == \"\":\n        message = f\"SecureTransport operation returned a non-zero OSStatus: {result}\"\n\n    raise ssl.SSLError(message)\n\n\nSecurity.SecTrustCreateWithCertificates.errcheck = _handle_osstatus  # type: ignore[assignment]\nSecurity.SecTrustSetAnchorCertificates.errcheck = _handle_osstatus  # type: ignore[assignment]\nSecurity.SecTrustGetTrustResult.errcheck = _handle_osstatus  # type: ignore[assignment]\n\n\nclass CFConst:\n    \"\"\"CoreFoundation constants\"\"\"\n\n    kCFStringEncodingUTF8 = CFStringEncoding(0x08000100)\n\n    errSecIncompleteCertRevocationCheck = -67635\n    errSecHostNameMismatch = -67602\n    errSecCertificateExpired = -67818\n    errSecNotTrusted = -67843\n\n\ndef _bytes_to_cf_data_ref(value: bytes) -> CFDataRef:  # type: ignore[valid-type]\n    return CoreFoundation.CFDataCreate(  # type: ignore[no-any-return]\n        CoreFoundation.kCFAllocatorDefault, value, len(value)\n    )\n\n\ndef _bytes_to_cf_string(value: bytes) -> CFString:\n    \"\"\"\n    Given a Python binary data, create a CFString.\n    The string must be CFReleased by the caller.\n    \"\"\"\n    c_str = ctypes.c_char_p(value)\n    cf_str = CoreFoundation.CFStringCreateWithCString(\n        CoreFoundation.kCFAllocatorDefault,\n        c_str,\n        CFConst.kCFStringEncodingUTF8,\n    )\n    return cf_str  # type: ignore[no-any-return]\n\n\ndef _cf_string_ref_to_str(cf_string_ref: CFStringRef) -> str | None:  # type: ignore[valid-type]\n    \"\"\"\n    Creates a Unicode string from a CFString object. Used entirely for error\n    reporting.\n    Yes, it annoys me quite a lot that this function is this complex.\n    \"\"\"\n\n    string = CoreFoundation.CFStringGetCStringPtr(\n        cf_string_ref, CFConst.kCFStringEncodingUTF8\n    )\n    if string is None:\n        buffer = ctypes.create_string_buffer(1024)\n        result = CoreFoundation.CFStringGetCString(\n            cf_string_ref, buffer, 1024, CFConst.kCFStringEncodingUTF8\n        )\n        if not result:\n            raise OSError(\"Error copying C string from CFStringRef\")\n        string = buffer.value\n    if string is not None:\n        string = string.decode(\"utf-8\")\n    return string  # type: ignore[no-any-return]\n\n\ndef _der_certs_to_cf_cert_array(certs: list[bytes]) -> CFMutableArrayRef:  # type: ignore[valid-type]\n    \"\"\"Builds a CFArray of SecCertificateRefs from a list of DER-encoded certificates.\n    Responsibility of the caller to call CoreFoundation.CFRelease on the CFArray.\n    \"\"\"\n    cf_array = CoreFoundation.CFArrayCreateMutable(\n        CoreFoundation.kCFAllocatorDefault,\n        0,\n        ctypes.byref(CoreFoundation.kCFTypeArrayCallBacks),\n    )\n    if not cf_array:\n        raise MemoryError(\"Unable to allocate memory!\")\n\n    for cert_data in certs:\n        cf_data = None\n        sec_cert_ref = None\n        try:\n            cf_data = _bytes_to_cf_data_ref(cert_data)\n            sec_cert_ref = Security.SecCertificateCreateWithData(\n                CoreFoundation.kCFAllocatorDefault, cf_data\n            )\n            CoreFoundation.CFArrayAppendValue(cf_array, sec_cert_ref)\n        finally:\n            if cf_data:\n                CoreFoundation.CFRelease(cf_data)\n            if sec_cert_ref:\n                CoreFoundation.CFRelease(sec_cert_ref)\n\n    return cf_array  # type: ignore[no-any-return]\n\n\n@contextlib.contextmanager\ndef _configure_context(ctx: ssl.SSLContext) -> typing.Iterator[None]:\n    check_hostname = ctx.check_hostname\n    verify_mode = ctx.verify_mode\n    ctx.check_hostname = False\n    _set_ssl_context_verify_mode(ctx, ssl.CERT_NONE)\n    try:\n        yield\n    finally:\n        ctx.check_hostname = check_hostname\n        _set_ssl_context_verify_mode(ctx, verify_mode)\n\n\ndef _verify_peercerts_impl(\n    ssl_context: ssl.SSLContext,\n    cert_chain: list[bytes],\n    server_hostname: str | None = None,\n) -> None:\n    certs = None\n    policies = None\n    trust = None\n    cf_error = None\n    try:\n        if server_hostname is not None:\n            cf_str_hostname = None\n            try:\n                cf_str_hostname = _bytes_to_cf_string(server_hostname.encode(\"ascii\"))\n                ssl_policy = Security.SecPolicyCreateSSL(True, cf_str_hostname)\n            finally:\n                if cf_str_hostname:\n                    CoreFoundation.CFRelease(cf_str_hostname)\n        else:\n            ssl_policy = Security.SecPolicyCreateSSL(True, None)\n\n        policies = ssl_policy\n        if ssl_context.verify_flags & ssl.VERIFY_CRL_CHECK_CHAIN:\n            # Add explicit policy requiring positive revocation checks\n            policies = CoreFoundation.CFArrayCreateMutable(\n                CoreFoundation.kCFAllocatorDefault,\n                0,\n                ctypes.byref(CoreFoundation.kCFTypeArrayCallBacks),\n            )\n            CoreFoundation.CFArrayAppendValue(policies, ssl_policy)\n            CoreFoundation.CFRelease(ssl_policy)\n            revocation_policy = Security.SecPolicyCreateRevocation(\n                kSecRevocationUseAnyAvailableMethod\n                | kSecRevocationRequirePositiveResponse\n            )\n            CoreFoundation.CFArrayAppendValue(policies, revocation_policy)\n            CoreFoundation.CFRelease(revocation_policy)\n        elif ssl_context.verify_flags & ssl.VERIFY_CRL_CHECK_LEAF:\n            raise NotImplementedError(\"VERIFY_CRL_CHECK_LEAF not implemented for macOS\")\n\n        certs = None\n        try:\n            certs = _der_certs_to_cf_cert_array(cert_chain)\n\n            # Now that we have certificates loaded and a SecPolicy\n            # we can finally create a SecTrust object!\n            trust = Security.SecTrustRef()\n            Security.SecTrustCreateWithCertificates(\n                certs, policies, ctypes.byref(trust)\n            )\n\n        finally:\n            # The certs are now being held by SecTrust so we can\n            # release our handles for the array.\n            if certs:\n                CoreFoundation.CFRelease(certs)\n\n        # If there are additional trust anchors to load we need to transform\n        # the list of DER-encoded certificates into a CFArray. Otherwise\n        # pass 'None' to signal that we only want system / fetched certificates.\n        ctx_ca_certs_der: list[bytes] | None = ssl_context.get_ca_certs(\n            binary_form=True\n        )\n        if ctx_ca_certs_der:\n            ctx_ca_certs = None\n            try:\n                ctx_ca_certs = _der_certs_to_cf_cert_array(cert_chain)\n                Security.SecTrustSetAnchorCertificates(trust, ctx_ca_certs)\n            finally:\n                if ctx_ca_certs:\n                    CoreFoundation.CFRelease(ctx_ca_certs)\n        else:\n            Security.SecTrustSetAnchorCertificates(trust, None)\n\n        cf_error = CoreFoundation.CFErrorRef()\n        sec_trust_eval_result = Security.SecTrustEvaluateWithError(\n            trust, ctypes.byref(cf_error)\n        )\n        # sec_trust_eval_result is a bool (0 or 1)\n        # where 1 means that the certs are trusted.\n        if sec_trust_eval_result == 1:\n            is_trusted = True\n        elif sec_trust_eval_result == 0:\n            is_trusted = False\n        else:\n            raise ssl.SSLError(\n                f\"Unknown result from Security.SecTrustEvaluateWithError: {sec_trust_eval_result!r}\"\n            )\n\n        cf_error_code = 0\n        if not is_trusted:\n            cf_error_code = CoreFoundation.CFErrorGetCode(cf_error)\n\n            # If the error is a known failure that we're\n            # explicitly okay with from SSLContext configuration\n            # we can set is_trusted accordingly.\n            if ssl_context.verify_mode != ssl.CERT_REQUIRED and (\n                cf_error_code == CFConst.errSecNotTrusted\n                or cf_error_code == CFConst.errSecCertificateExpired\n            ):\n                is_trusted = True\n            elif (\n                not ssl_context.check_hostname\n                and cf_error_code == CFConst.errSecHostNameMismatch\n            ):\n                is_trusted = True\n\n        # If we're still not trusted then we start to\n        # construct and raise the SSLCertVerificationError.\n        if not is_trusted:\n            cf_error_string_ref = None\n            try:\n                cf_error_string_ref = CoreFoundation.CFErrorCopyDescription(cf_error)\n\n                # Can this ever return 'None' if there's a CFError?\n                cf_error_message = (\n                    _cf_string_ref_to_str(cf_error_string_ref)\n                    or \"Certificate verification failed\"\n                )\n\n                # TODO: Not sure if we need the SecTrustResultType for anything?\n                # We only care whether or not it's a success or failure for now.\n                sec_trust_result_type = Security.SecTrustResultType()\n                Security.SecTrustGetTrustResult(\n                    trust, ctypes.byref(sec_trust_result_type)\n                )\n\n                err = ssl.SSLCertVerificationError(cf_error_message)\n                err.verify_message = cf_error_message\n                err.verify_code = cf_error_code\n                raise err\n            finally:\n                if cf_error_string_ref:\n                    CoreFoundation.CFRelease(cf_error_string_ref)\n\n    finally:\n        if policies:\n            CoreFoundation.CFRelease(policies)\n        if trust:\n            CoreFoundation.CFRelease(trust)\n"},"hash":"vZaoLN9GOi"}