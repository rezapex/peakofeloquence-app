{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:network:session.py","body":"\"\"\"PipSession and supporting code, containing all pip-specific\nnetwork request configuration and behavior.\n\"\"\"\n\nimport email.utils\nimport io\nimport ipaddress\nimport json\nimport logging\nimport mimetypes\nimport os\nimport platform\nimport shutil\nimport subprocess\nimport sys\nimport urllib.parse\nimport warnings\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Dict,\n    Generator,\n    List,\n    Mapping,\n    Optional,\n    Sequence,\n    Tuple,\n    Union,\n)\n\nfrom pip._vendor import requests, urllib3\nfrom pip._vendor.cachecontrol import CacheControlAdapter as _BaseCacheControlAdapter\nfrom pip._vendor.requests.adapters import DEFAULT_POOLBLOCK, BaseAdapter\nfrom pip._vendor.requests.adapters import HTTPAdapter as _BaseHTTPAdapter\nfrom pip._vendor.requests.models import PreparedRequest, Response\nfrom pip._vendor.requests.structures import CaseInsensitiveDict\nfrom pip._vendor.urllib3.connectionpool import ConnectionPool\nfrom pip._vendor.urllib3.exceptions import InsecureRequestWarning\n\nfrom pip import __version__\nfrom pip._internal.metadata import get_default_environment\nfrom pip._internal.models.link import Link\nfrom pip._internal.network.auth import MultiDomainBasicAuth\nfrom pip._internal.network.cache import SafeFileCache\n\n# Import ssl from compat so the initial import occurs in only one place.\nfrom pip._internal.utils.compat import has_tls\nfrom pip._internal.utils.glibc import libc_ver\nfrom pip._internal.utils.misc import build_url_from_netloc, parse_netloc\nfrom pip._internal.utils.urls import url_to_path\n\nif TYPE_CHECKING:\n    from ssl import SSLContext\n\n    from pip._vendor.urllib3.poolmanager import PoolManager\n\n\nlogger = logging.getLogger(__name__)\n\nSecureOrigin = Tuple[str, str, Optional[Union[int, str]]]\n\n\n# Ignore warning raised when using --trusted-host.\nwarnings.filterwarnings(\"ignore\", category=InsecureRequestWarning)\n\n\nSECURE_ORIGINS: List[SecureOrigin] = [\n    # protocol, hostname, port\n    # Taken from Chrome's list of secure origins (See: http://bit.ly/1qrySKC)\n    (\"https\", \"*\", \"*\"),\n    (\"*\", \"localhost\", \"*\"),\n    (\"*\", \"127.0.0.0/8\", \"*\"),\n    (\"*\", \"::1/128\", \"*\"),\n    (\"file\", \"*\", None),\n    # ssh is always secure.\n    (\"ssh\", \"*\", \"*\"),\n]\n\n\n# These are environment variables present when running under various\n# CI systems.  For each variable, some CI systems that use the variable\n# are indicated.  The collection was chosen so that for each of a number\n# of popular systems, at least one of the environment variables is used.\n# This list is used to provide some indication of and lower bound for\n# CI traffic to PyPI.  Thus, it is okay if the list is not comprehensive.\n# For more background, see: https://github.com/pypa/pip/issues/5499\nCI_ENVIRONMENT_VARIABLES = (\n    # Azure Pipelines\n    \"BUILD_BUILDID\",\n    # Jenkins\n    \"BUILD_ID\",\n    # AppVeyor, CircleCI, Codeship, Gitlab CI, Shippable, Travis CI\n    \"CI\",\n    # Explicit environment variable.\n    \"PIP_IS_CI\",\n)\n\n\ndef looks_like_ci() -> bool:\n    \"\"\"\n    Return whether it looks like pip is running under CI.\n    \"\"\"\n    # We don't use the method of checking for a tty (e.g. using isatty())\n    # because some CI systems mimic a tty (e.g. Travis CI).  Thus that\n    # method doesn't provide definitive information in either direction.\n    return any(name in os.environ for name in CI_ENVIRONMENT_VARIABLES)\n\n\ndef user_agent() -> str:\n    \"\"\"\n    Return a string representing the user agent.\n    \"\"\"\n    data: Dict[str, Any] = {\n        \"installer\": {\"name\": \"pip\", \"version\": __version__},\n        \"python\": platform.python_version(),\n        \"implementation\": {\n            \"name\": platform.python_implementation(),\n        },\n    }\n\n    if data[\"implementation\"][\"name\"] == \"CPython\":\n        data[\"implementation\"][\"version\"] = platform.python_version()\n    elif data[\"implementation\"][\"name\"] == \"PyPy\":\n        pypy_version_info = sys.pypy_version_info  # type: ignore\n        if pypy_version_info.releaselevel == \"final\":\n            pypy_version_info = pypy_version_info[:3]\n        data[\"implementation\"][\"version\"] = \".\".join(\n            [str(x) for x in pypy_version_info]\n        )\n    elif data[\"implementation\"][\"name\"] == \"Jython\":\n        # Complete Guess\n        data[\"implementation\"][\"version\"] = platform.python_version()\n    elif data[\"implementation\"][\"name\"] == \"IronPython\":\n        # Complete Guess\n        data[\"implementation\"][\"version\"] = platform.python_version()\n\n    if sys.platform.startswith(\"linux\"):\n        from pip._vendor import distro\n\n        linux_distribution = distro.name(), distro.version(), distro.codename()\n        distro_infos: Dict[str, Any] = dict(\n            filter(\n                lambda x: x[1],\n                zip([\"name\", \"version\", \"id\"], linux_distribution),\n            )\n        )\n        libc = dict(\n            filter(\n                lambda x: x[1],\n                zip([\"lib\", \"version\"], libc_ver()),\n            )\n        )\n        if libc:\n            distro_infos[\"libc\"] = libc\n        if distro_infos:\n            data[\"distro\"] = distro_infos\n\n    if sys.platform.startswith(\"darwin\") and platform.mac_ver()[0]:\n        data[\"distro\"] = {\"name\": \"macOS\", \"version\": platform.mac_ver()[0]}\n\n    if platform.system():\n        data.setdefault(\"system\", {})[\"name\"] = platform.system()\n\n    if platform.release():\n        data.setdefault(\"system\", {})[\"release\"] = platform.release()\n\n    if platform.machine():\n        data[\"cpu\"] = platform.machine()\n\n    if has_tls():\n        import _ssl as ssl\n\n        data[\"openssl_version\"] = ssl.OPENSSL_VERSION\n\n    setuptools_dist = get_default_environment().get_distribution(\"setuptools\")\n    if setuptools_dist is not None:\n        data[\"setuptools_version\"] = str(setuptools_dist.version)\n\n    if shutil.which(\"rustc\") is not None:\n        # If for any reason `rustc --version` fails, silently ignore it\n        try:\n            rustc_output = subprocess.check_output(\n                [\"rustc\", \"--version\"], stderr=subprocess.STDOUT, timeout=0.5\n            )\n        except Exception:\n            pass\n        else:\n            if rustc_output.startswith(b\"rustc \"):\n                # The format of `rustc --version` is:\n                # `b'rustc 1.52.1 (9bc8c42bb 2021-05-09)\\n'`\n                # We extract just the middle (1.52.1) part\n                data[\"rustc_version\"] = rustc_output.split(b\" \")[1].decode()\n\n    # Use None rather than False so as not to give the impression that\n    # pip knows it is not being run under CI.  Rather, it is a null or\n    # inconclusive result.  Also, we include some value rather than no\n    # value to make it easier to know that the check has been run.\n    data[\"ci\"] = True if looks_like_ci() else None\n\n    user_data = os.environ.get(\"PIP_USER_AGENT_USER_DATA\")\n    if user_data is not None:\n        data[\"user_data\"] = user_data\n\n    return \"{data[installer][name]}/{data[installer][version]} {json}\".format(\n        data=data,\n        json=json.dumps(data, separators=(\",\", \":\"), sort_keys=True),\n    )\n\n\nclass LocalFSAdapter(BaseAdapter):\n    def send(\n        self,\n        request: PreparedRequest,\n        stream: bool = False,\n        timeout: Optional[Union[float, Tuple[float, float]]] = None,\n        verify: Union[bool, str] = True,\n        cert: Optional[Union[str, Tuple[str, str]]] = None,\n        proxies: Optional[Mapping[str, str]] = None,\n    ) -> Response:\n        pathname = url_to_path(request.url)\n\n        resp = Response()\n        resp.status_code = 200\n        resp.url = request.url\n\n        try:\n            stats = os.stat(pathname)\n        except OSError as exc:\n            # format the exception raised as a io.BytesIO object,\n            # to return a better error message:\n            resp.status_code = 404\n            resp.reason = type(exc).__name__\n            resp.raw = io.BytesIO(f\"{resp.reason}: {exc}\".encode(\"utf8\"))\n        else:\n            modified = email.utils.formatdate(stats.st_mtime, usegmt=True)\n            content_type = mimetypes.guess_type(pathname)[0] or \"text/plain\"\n            resp.headers = CaseInsensitiveDict(\n                {\n                    \"Content-Type\": content_type,\n                    \"Content-Length\": stats.st_size,\n                    \"Last-Modified\": modified,\n                }\n            )\n\n            resp.raw = open(pathname, \"rb\")\n            resp.close = resp.raw.close\n\n        return resp\n\n    def close(self) -> None:\n        pass\n\n\nclass _SSLContextAdapterMixin:\n    \"\"\"Mixin to add the ``ssl_context`` constructor argument to HTTP adapters.\n\n    The additional argument is forwarded directly to the pool manager. This allows us\n    to dynamically decide what SSL store to use at runtime, which is used to implement\n    the optional ``truststore`` backend.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        ssl_context: Optional[\"SSLContext\"] = None,\n        **kwargs: Any,\n    ) -> None:\n        self._ssl_context = ssl_context\n        super().__init__(**kwargs)\n\n    def init_poolmanager(\n        self,\n        connections: int,\n        maxsize: int,\n        block: bool = DEFAULT_POOLBLOCK,\n        **pool_kwargs: Any,\n    ) -> \"PoolManager\":\n        if self._ssl_context is not None:\n            pool_kwargs.setdefault(\"ssl_context\", self._ssl_context)\n        return super().init_poolmanager(  # type: ignore[misc]\n            connections=connections,\n            maxsize=maxsize,\n            block=block,\n            **pool_kwargs,\n        )\n\n\nclass HTTPAdapter(_SSLContextAdapterMixin, _BaseHTTPAdapter):\n    pass\n\n\nclass CacheControlAdapter(_SSLContextAdapterMixin, _BaseCacheControlAdapter):\n    pass\n\n\nclass InsecureHTTPAdapter(HTTPAdapter):\n    def cert_verify(\n        self,\n        conn: ConnectionPool,\n        url: str,\n        verify: Union[bool, str],\n        cert: Optional[Union[str, Tuple[str, str]]],\n    ) -> None:\n        super().cert_verify(conn=conn, url=url, verify=False, cert=cert)\n\n\nclass InsecureCacheControlAdapter(CacheControlAdapter):\n    def cert_verify(\n        self,\n        conn: ConnectionPool,\n        url: str,\n        verify: Union[bool, str],\n        cert: Optional[Union[str, Tuple[str, str]]],\n    ) -> None:\n        super().cert_verify(conn=conn, url=url, verify=False, cert=cert)\n\n\nclass PipSession(requests.Session):\n    timeout: Optional[int] = None\n\n    def __init__(\n        self,\n        *args: Any,\n        retries: int = 0,\n        cache: Optional[str] = None,\n        trusted_hosts: Sequence[str] = (),\n        index_urls: Optional[List[str]] = None,\n        ssl_context: Optional[\"SSLContext\"] = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"\n        :param trusted_hosts: Domains not to emit warnings for when not using\n            HTTPS.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n\n        # Namespace the attribute with \"pip_\" just in case to prevent\n        # possible conflicts with the base class.\n        self.pip_trusted_origins: List[Tuple[str, Optional[int]]] = []\n\n        # Attach our User Agent to the request\n        self.headers[\"User-Agent\"] = user_agent()\n\n        # Attach our Authentication handler to the session\n        self.auth = MultiDomainBasicAuth(index_urls=index_urls)\n\n        # Create our urllib3.Retry instance which will allow us to customize\n        # how we handle retries.\n        retries = urllib3.Retry(\n            # Set the total number of retries that a particular request can\n            # have.\n            total=retries,\n            # A 503 error from PyPI typically means that the Fastly -> Origin\n            # connection got interrupted in some way. A 503 error in general\n            # is typically considered a transient error so we'll go ahead and\n            # retry it.\n            # A 500 may indicate transient error in Amazon S3\n            # A 502 may be a transient error from a CDN like CloudFlare or CloudFront\n            # A 520 or 527 - may indicate transient error in CloudFlare\n            status_forcelist=[500, 502, 503, 520, 527],\n            # Add a small amount of back off between failed requests in\n            # order to prevent hammering the service.\n            backoff_factor=0.25,\n        )  # type: ignore\n\n        # Our Insecure HTTPAdapter disables HTTPS validation. It does not\n        # support caching so we'll use it for all http:// URLs.\n        # If caching is disabled, we will also use it for\n        # https:// hosts that we've marked as ignoring\n        # TLS errors for (trusted-hosts).\n        insecure_adapter = InsecureHTTPAdapter(max_retries=retries)\n\n        # We want to _only_ cache responses on securely fetched origins or when\n        # the host is specified as trusted. We do this because\n        # we can't validate the response of an insecurely/untrusted fetched\n        # origin, and we don't want someone to be able to poison the cache and\n        # require manual eviction from the cache to fix it.\n        if cache:\n            secure_adapter = CacheControlAdapter(\n                cache=SafeFileCache(cache),\n                max_retries=retries,\n                ssl_context=ssl_context,\n            )\n            self._trusted_host_adapter = InsecureCacheControlAdapter(\n                cache=SafeFileCache(cache),\n                max_retries=retries,\n            )\n        else:\n            secure_adapter = HTTPAdapter(max_retries=retries, ssl_context=ssl_context)\n            self._trusted_host_adapter = insecure_adapter\n\n        self.mount(\"https://\", secure_adapter)\n        self.mount(\"http://\", insecure_adapter)\n\n        # Enable file:// urls\n        self.mount(\"file://\", LocalFSAdapter())\n\n        for host in trusted_hosts:\n            self.add_trusted_host(host, suppress_logging=True)\n\n    def update_index_urls(self, new_index_urls: List[str]) -> None:\n        \"\"\"\n        :param new_index_urls: New index urls to update the authentication\n            handler with.\n        \"\"\"\n        self.auth.index_urls = new_index_urls\n\n    def add_trusted_host(\n        self, host: str, source: Optional[str] = None, suppress_logging: bool = False\n    ) -> None:\n        \"\"\"\n        :param host: It is okay to provide a host that has previously been\n            added.\n        :param source: An optional source string, for logging where the host\n            string came from.\n        \"\"\"\n        if not suppress_logging:\n            msg = f\"adding trusted host: {host!r}\"\n            if source is not None:\n                msg += f\" (from {source})\"\n            logger.info(msg)\n\n        parsed_host, parsed_port = parse_netloc(host)\n        if parsed_host is None:\n            raise ValueError(f\"Trusted host URL must include a host part: {host!r}\")\n        if (parsed_host, parsed_port) not in self.pip_trusted_origins:\n            self.pip_trusted_origins.append((parsed_host, parsed_port))\n\n        self.mount(\n            build_url_from_netloc(host, scheme=\"http\") + \"/\", self._trusted_host_adapter\n        )\n        self.mount(build_url_from_netloc(host) + \"/\", self._trusted_host_adapter)\n        if not parsed_port:\n            self.mount(\n                build_url_from_netloc(host, scheme=\"http\") + \":\",\n                self._trusted_host_adapter,\n            )\n            # Mount wildcard ports for the same host.\n            self.mount(build_url_from_netloc(host) + \":\", self._trusted_host_adapter)\n\n    def iter_secure_origins(self) -> Generator[SecureOrigin, None, None]:\n        yield from SECURE_ORIGINS\n        for host, port in self.pip_trusted_origins:\n            yield (\"*\", host, \"*\" if port is None else port)\n\n    def is_secure_origin(self, location: Link) -> bool:\n        # Determine if this url used a secure transport mechanism\n        parsed = urllib.parse.urlparse(str(location))\n        origin_protocol, origin_host, origin_port = (\n            parsed.scheme,\n            parsed.hostname,\n            parsed.port,\n        )\n\n        # The protocol to use to see if the protocol matches.\n        # Don't count the repository type as part of the protocol: in\n        # cases such as \"git+ssh\", only use \"ssh\". (I.e., Only verify against\n        # the last scheme.)\n        origin_protocol = origin_protocol.rsplit(\"+\", 1)[-1]\n\n        # Determine if our origin is a secure origin by looking through our\n        # hardcoded list of secure origins, as well as any additional ones\n        # configured on this PackageFinder instance.\n        for secure_origin in self.iter_secure_origins():\n            secure_protocol, secure_host, secure_port = secure_origin\n            if origin_protocol != secure_protocol and secure_protocol != \"*\":\n                continue\n\n            try:\n                addr = ipaddress.ip_address(origin_host or \"\")\n                network = ipaddress.ip_network(secure_host)\n            except ValueError:\n                # We don't have both a valid address or a valid network, so\n                # we'll check this origin against hostnames.\n                if (\n                    origin_host\n                    and origin_host.lower() != secure_host.lower()\n                    and secure_host != \"*\"\n                ):\n                    continue\n            else:\n                # We have a valid address and network, so see if the address\n                # is contained within the network.\n                if addr not in network:\n                    continue\n\n            # Check to see if the port matches.\n            if (\n                origin_port != secure_port\n                and secure_port != \"*\"\n                and secure_port is not None\n            ):\n                continue\n\n            # If we've gotten here, then this origin matches the current\n            # secure origin and we should return True\n            return True\n\n        # If we've gotten to this point, then the origin isn't secure and we\n        # will not accept it as a valid location to search. We will however\n        # log a warning that we are ignoring it.\n        logger.warning(\n            \"The repository located at %s is not a trusted or secure host and \"\n            \"is being ignored. If this repository is available via HTTPS we \"\n            \"recommend you use HTTPS instead, otherwise you may silence \"\n            \"this warning and allow it anyway with '--trusted-host %s'.\",\n            origin_host,\n            origin_host,\n        )\n\n        return False\n\n    def request(self, method: str, url: str, *args: Any, **kwargs: Any) -> Response:\n        # Allow setting a default timeout on a session\n        kwargs.setdefault(\"timeout\", self.timeout)\n        # Allow setting a default proxies on a session\n        kwargs.setdefault(\"proxies\", self.proxies)\n\n        # Dispatch the actual request\n        return super().request(method, url, *args, **kwargs)\n"},"hash":"SrMl1ZO3Pf"}