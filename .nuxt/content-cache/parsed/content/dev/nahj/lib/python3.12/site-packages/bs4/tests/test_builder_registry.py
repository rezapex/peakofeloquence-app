{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:bs4:tests:test_builder_registry.py","body":"\"\"\"Tests of the builder registry.\"\"\"\n\nimport pytest\nimport warnings\n\nfrom bs4 import BeautifulSoup\nfrom bs4.builder import (\n    builder_registry as registry,\n    HTMLParserTreeBuilder,\n    TreeBuilderRegistry,\n)\n\nfrom . import (\n    HTML5LIB_PRESENT,\n    LXML_PRESENT,\n)\n\nif HTML5LIB_PRESENT:\n    from bs4.builder import HTML5TreeBuilder\n\nif LXML_PRESENT:\n    from bs4.builder import (\n        LXMLTreeBuilderForXML,\n        LXMLTreeBuilder,\n        )\n\n\n# TODO: Split out the lxml and html5lib tests into their own classes\n# and gate with pytest.mark.skipIf.\nclass TestBuiltInRegistry(object):\n    \"\"\"Test the built-in registry with the default builders registered.\"\"\"\n\n    def test_combination(self):\n        assert registry.lookup('strict', 'html') == HTMLParserTreeBuilder\n        if LXML_PRESENT:\n            assert registry.lookup('fast', 'html') == LXMLTreeBuilder\n            assert registry.lookup('permissive', 'xml') == LXMLTreeBuilderForXML\n        if HTML5LIB_PRESENT:\n            assert registry.lookup('html5lib', 'html') == HTML5TreeBuilder\n\n    def test_lookup_by_markup_type(self):\n        if LXML_PRESENT:\n            assert registry.lookup('html') == LXMLTreeBuilder\n            assert registry.lookup('xml') == LXMLTreeBuilderForXML\n        else:\n            assert registry.lookup('xml') == None\n            if HTML5LIB_PRESENT:\n                assert registry.lookup('html') == HTML5TreeBuilder\n            else:\n                assert registry.lookup('html') == HTMLParserTreeBuilder\n\n    def test_named_library(self):\n        if LXML_PRESENT:\n            assert registry.lookup('lxml', 'xml') == LXMLTreeBuilderForXML\n            assert registry.lookup('lxml', 'html') == LXMLTreeBuilder\n        if HTML5LIB_PRESENT:\n            assert registry.lookup('html5lib') == HTML5TreeBuilder\n\n        assert registry.lookup('html.parser') == HTMLParserTreeBuilder\n\n    def test_beautifulsoup_constructor_does_lookup(self):\n\n        with warnings.catch_warnings(record=True) as w:\n            # This will create a warning about not explicitly\n            # specifying a parser, but we'll ignore it.\n\n            # You can pass in a string.\n            BeautifulSoup(\"\", features=\"html\")\n            # Or a list of strings.\n            BeautifulSoup(\"\", features=[\"html\", \"fast\"])\n            pass\n            \n        # You'll get an exception if BS can't find an appropriate\n        # builder.\n        with pytest.raises(ValueError):\n            BeautifulSoup(\"\", features=\"no-such-feature\")\n\nclass TestRegistry(object):\n    \"\"\"Test the TreeBuilderRegistry class in general.\"\"\"\n\n    def setup_method(self):\n        self.registry = TreeBuilderRegistry()\n\n    def builder_for_features(self, *feature_list):\n        cls = type('Builder_' + '_'.join(feature_list),\n                   (object,), {'features' : feature_list})\n\n        self.registry.register(cls)\n        return cls\n\n    def test_register_with_no_features(self):\n        builder = self.builder_for_features()\n\n        # Since the builder advertises no features, you can't find it\n        # by looking up features.\n        assert self.registry.lookup('foo') is None\n\n        # But you can find it by doing a lookup with no features, if\n        # this happens to be the only registered builder.\n        assert self.registry.lookup() == builder\n\n    def test_register_with_features_makes_lookup_succeed(self):\n        builder = self.builder_for_features('foo', 'bar')\n        assert self.registry.lookup('foo') is builder\n        assert self.registry.lookup('bar') is builder\n\n    def test_lookup_fails_when_no_builder_implements_feature(self):\n        builder = self.builder_for_features('foo', 'bar')\n        assert self.registry.lookup('baz') is None\n\n    def test_lookup_gets_most_recent_registration_when_no_feature_specified(self):\n        builder1 = self.builder_for_features('foo')\n        builder2 = self.builder_for_features('bar')\n        assert self.registry.lookup() == builder2\n\n    def test_lookup_fails_when_no_tree_builders_registered(self):\n        assert self.registry.lookup() is None\n\n    def test_lookup_gets_most_recent_builder_supporting_all_features(self):\n        has_one = self.builder_for_features('foo')\n        has_the_other = self.builder_for_features('bar')\n        has_both_early = self.builder_for_features('foo', 'bar', 'baz')\n        has_both_late = self.builder_for_features('foo', 'bar', 'quux')\n        lacks_one = self.builder_for_features('bar')\n        has_the_other = self.builder_for_features('foo')\n\n        # There are two builders featuring 'foo' and 'bar', but\n        # the one that also features 'quux' was registered later.\n        assert self.registry.lookup('foo', 'bar') == has_both_late\n\n        # There is only one builder featuring 'foo', 'bar', and 'baz'.\n        assert self.registry.lookup('foo', 'bar', 'baz') == has_both_early\n\n    def test_lookup_fails_when_cannot_reconcile_requested_features(self):\n        builder1 = self.builder_for_features('foo', 'bar')\n        builder2 = self.builder_for_features('foo', 'baz')\n        assert self.registry.lookup('bar', 'baz') is None\n"},"hash":"ljXZjKcR5U"}