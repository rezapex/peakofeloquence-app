{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:locations:_distutils.py","body":"\"\"\"Locations where we look for configs, install stuff, etc\"\"\"\n\n# The following comment should be removed at some point in the future.\n# mypy: strict-optional=False\n\n# If pip's going to use distutils, it should not be using the copy that setuptools\n# might have injected into the environment. This is done by removing the injected\n# shim, if it's injected.\n#\n# See https://github.com/pypa/pip/issues/8761 for the original discussion and\n# rationale for why this is done within pip.\ntry:\n    __import__(\"_distutils_hack\").remove_shim()\nexcept (ImportError, AttributeError):\n    pass\n\nimport logging\nimport os\nimport sys\nfrom distutils.cmd import Command as DistutilsCommand\nfrom distutils.command.install import SCHEME_KEYS\nfrom distutils.command.install import install as distutils_install_command\nfrom distutils.sysconfig import get_python_lib\nfrom typing import Dict, List, Optional, Union, cast\n\nfrom pip._internal.models.scheme import Scheme\nfrom pip._internal.utils.compat import WINDOWS\nfrom pip._internal.utils.virtualenv import running_under_virtualenv\n\nfrom .base import get_major_minor_version\n\nlogger = logging.getLogger(__name__)\n\n\ndef distutils_scheme(\n    dist_name: str,\n    user: bool = False,\n    home: Optional[str] = None,\n    root: Optional[str] = None,\n    isolated: bool = False,\n    prefix: Optional[str] = None,\n    *,\n    ignore_config_files: bool = False,\n) -> Dict[str, str]:\n    \"\"\"\n    Return a distutils install scheme\n    \"\"\"\n    from distutils.dist import Distribution\n\n    dist_args: Dict[str, Union[str, List[str]]] = {\"name\": dist_name}\n    if isolated:\n        dist_args[\"script_args\"] = [\"--no-user-cfg\"]\n\n    d = Distribution(dist_args)\n    if not ignore_config_files:\n        try:\n            d.parse_config_files()\n        except UnicodeDecodeError:\n            paths = d.find_config_files()\n            logger.warning(\n                \"Ignore distutils configs in %s due to encoding errors.\",\n                \", \".join(os.path.basename(p) for p in paths),\n            )\n    obj: Optional[DistutilsCommand] = None\n    obj = d.get_command_obj(\"install\", create=True)\n    assert obj is not None\n    i = cast(distutils_install_command, obj)\n    # NOTE: setting user or home has the side-effect of creating the home dir\n    # or user base for installations during finalize_options()\n    # ideally, we'd prefer a scheme class that has no side-effects.\n    assert not (user and prefix), f\"user={user} prefix={prefix}\"\n    assert not (home and prefix), f\"home={home} prefix={prefix}\"\n    i.user = user or i.user\n    if user or home:\n        i.prefix = \"\"\n    i.prefix = prefix or i.prefix\n    i.home = home or i.home\n    i.root = root or i.root\n    i.finalize_options()\n\n    scheme = {}\n    for key in SCHEME_KEYS:\n        scheme[key] = getattr(i, \"install_\" + key)\n\n    # install_lib specified in setup.cfg should install *everything*\n    # into there (i.e. it takes precedence over both purelib and\n    # platlib).  Note, i.install_lib is *always* set after\n    # finalize_options(); we only want to override here if the user\n    # has explicitly requested it hence going back to the config\n    if \"install_lib\" in d.get_option_dict(\"install\"):\n        scheme.update({\"purelib\": i.install_lib, \"platlib\": i.install_lib})\n\n    if running_under_virtualenv():\n        if home:\n            prefix = home\n        elif user:\n            prefix = i.install_userbase\n        else:\n            prefix = i.prefix\n        scheme[\"headers\"] = os.path.join(\n            prefix,\n            \"include\",\n            \"site\",\n            f\"python{get_major_minor_version()}\",\n            dist_name,\n        )\n\n        if root is not None:\n            path_no_drive = os.path.splitdrive(os.path.abspath(scheme[\"headers\"]))[1]\n            scheme[\"headers\"] = os.path.join(root, path_no_drive[1:])\n\n    return scheme\n\n\ndef get_scheme(\n    dist_name: str,\n    user: bool = False,\n    home: Optional[str] = None,\n    root: Optional[str] = None,\n    isolated: bool = False,\n    prefix: Optional[str] = None,\n) -> Scheme:\n    \"\"\"\n    Get the \"scheme\" corresponding to the input parameters. The distutils\n    documentation provides the context for the available schemes:\n    https://docs.python.org/3/install/index.html#alternate-installation\n\n    :param dist_name: the name of the package to retrieve the scheme for, used\n        in the headers scheme path\n    :param user: indicates to use the \"user\" scheme\n    :param home: indicates to use the \"home\" scheme and provides the base\n        directory for the same\n    :param root: root under which other directories are re-based\n    :param isolated: equivalent to --no-user-cfg, i.e. do not consider\n        ~/.pydistutils.cfg (posix) or ~/pydistutils.cfg (non-posix) for\n        scheme paths\n    :param prefix: indicates to use the \"prefix\" scheme and provides the\n        base directory for the same\n    \"\"\"\n    scheme = distutils_scheme(dist_name, user, home, root, isolated, prefix)\n    return Scheme(\n        platlib=scheme[\"platlib\"],\n        purelib=scheme[\"purelib\"],\n        headers=scheme[\"headers\"],\n        scripts=scheme[\"scripts\"],\n        data=scheme[\"data\"],\n    )\n\n\ndef get_bin_prefix() -> str:\n    # XXX: In old virtualenv versions, sys.prefix can contain '..' components,\n    # so we need to call normpath to eliminate them.\n    prefix = os.path.normpath(sys.prefix)\n    if WINDOWS:\n        bin_py = os.path.join(prefix, \"Scripts\")\n        # buildout uses 'bin' on Windows too?\n        if not os.path.exists(bin_py):\n            bin_py = os.path.join(prefix, \"bin\")\n        return bin_py\n    # Forcing to use /usr/local/bin for standard macOS framework installs\n    # Also log to ~/Library/Logs/ for use with the Console.app log viewer\n    if sys.platform[:6] == \"darwin\" and prefix[:16] == \"/System/Library/\":\n        return \"/usr/local/bin\"\n    return os.path.join(prefix, \"bin\")\n\n\ndef get_purelib() -> str:\n    return get_python_lib(plat_specific=False)\n\n\ndef get_platlib() -> str:\n    return get_python_lib(plat_specific=True)\n"},"hash":"Azn05yGUmF"}