{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:chardet:sbcharsetprober.py","body":"######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Universal charset detector code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 2001\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#   Shy Shalom - original C code\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nfrom typing import Dict, List, NamedTuple, Optional, Union\n\nfrom .charsetprober import CharSetProber\nfrom .enums import CharacterCategory, ProbingState, SequenceLikelihood\n\n\nclass SingleByteCharSetModel(NamedTuple):\n    charset_name: str\n    language: str\n    char_to_order_map: Dict[int, int]\n    language_model: Dict[int, Dict[int, int]]\n    typical_positive_ratio: float\n    keep_ascii_letters: bool\n    alphabet: str\n\n\nclass SingleByteCharSetProber(CharSetProber):\n    SAMPLE_SIZE = 64\n    SB_ENOUGH_REL_THRESHOLD = 1024  # 0.25 * SAMPLE_SIZE^2\n    POSITIVE_SHORTCUT_THRESHOLD = 0.95\n    NEGATIVE_SHORTCUT_THRESHOLD = 0.05\n\n    def __init__(\n        self,\n        model: SingleByteCharSetModel,\n        is_reversed: bool = False,\n        name_prober: Optional[CharSetProber] = None,\n    ) -> None:\n        super().__init__()\n        self._model = model\n        # TRUE if we need to reverse every pair in the model lookup\n        self._reversed = is_reversed\n        # Optional auxiliary prober for name decision\n        self._name_prober = name_prober\n        self._last_order = 255\n        self._seq_counters: List[int] = []\n        self._total_seqs = 0\n        self._total_char = 0\n        self._control_char = 0\n        self._freq_char = 0\n        self.reset()\n\n    def reset(self) -> None:\n        super().reset()\n        # char order of last character\n        self._last_order = 255\n        self._seq_counters = [0] * SequenceLikelihood.get_num_categories()\n        self._total_seqs = 0\n        self._total_char = 0\n        self._control_char = 0\n        # characters that fall in our sampling range\n        self._freq_char = 0\n\n    @property\n    def charset_name(self) -> Optional[str]:\n        if self._name_prober:\n            return self._name_prober.charset_name\n        return self._model.charset_name\n\n    @property\n    def language(self) -> Optional[str]:\n        if self._name_prober:\n            return self._name_prober.language\n        return self._model.language\n\n    def feed(self, byte_str: Union[bytes, bytearray]) -> ProbingState:\n        # TODO: Make filter_international_words keep things in self.alphabet\n        if not self._model.keep_ascii_letters:\n            byte_str = self.filter_international_words(byte_str)\n        else:\n            byte_str = self.remove_xml_tags(byte_str)\n        if not byte_str:\n            return self.state\n        char_to_order_map = self._model.char_to_order_map\n        language_model = self._model.language_model\n        for char in byte_str:\n            order = char_to_order_map.get(char, CharacterCategory.UNDEFINED)\n            # XXX: This was SYMBOL_CAT_ORDER before, with a value of 250, but\n            #      CharacterCategory.SYMBOL is actually 253, so we use CONTROL\n            #      to make it closer to the original intent. The only difference\n            #      is whether or not we count digits and control characters for\n            #      _total_char purposes.\n            if order < CharacterCategory.CONTROL:\n                self._total_char += 1\n            if order < self.SAMPLE_SIZE:\n                self._freq_char += 1\n                if self._last_order < self.SAMPLE_SIZE:\n                    self._total_seqs += 1\n                    if not self._reversed:\n                        lm_cat = language_model[self._last_order][order]\n                    else:\n                        lm_cat = language_model[order][self._last_order]\n                    self._seq_counters[lm_cat] += 1\n            self._last_order = order\n\n        charset_name = self._model.charset_name\n        if self.state == ProbingState.DETECTING:\n            if self._total_seqs > self.SB_ENOUGH_REL_THRESHOLD:\n                confidence = self.get_confidence()\n                if confidence > self.POSITIVE_SHORTCUT_THRESHOLD:\n                    self.logger.debug(\n                        \"%s confidence = %s, we have a winner\", charset_name, confidence\n                    )\n                    self._state = ProbingState.FOUND_IT\n                elif confidence < self.NEGATIVE_SHORTCUT_THRESHOLD:\n                    self.logger.debug(\n                        \"%s confidence = %s, below negative shortcut threshold %s\",\n                        charset_name,\n                        confidence,\n                        self.NEGATIVE_SHORTCUT_THRESHOLD,\n                    )\n                    self._state = ProbingState.NOT_ME\n\n        return self.state\n\n    def get_confidence(self) -> float:\n        r = 0.01\n        if self._total_seqs > 0:\n            r = (\n                (\n                    self._seq_counters[SequenceLikelihood.POSITIVE]\n                    + 0.25 * self._seq_counters[SequenceLikelihood.LIKELY]\n                )\n                / self._total_seqs\n                / self._model.typical_positive_ratio\n            )\n            # The more control characters (proportionnaly to the size\n            # of the text), the less confident we become in the current\n            # charset.\n            r = r * (self._total_char - self._control_char) / self._total_char\n            r = r * self._freq_char / self._total_char\n            if r >= 1.0:\n                r = 0.99\n        return r\n"},"hash":"0YxiAdvNnk"}