{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:resolution:resolvelib:resolver.py","body":"import contextlib\nimport functools\nimport logging\nimport os\nfrom typing import TYPE_CHECKING, Dict, List, Optional, Set, Tuple, cast\n\nfrom pip._vendor.packaging.utils import canonicalize_name\nfrom pip._vendor.resolvelib import BaseReporter, ResolutionImpossible\nfrom pip._vendor.resolvelib import Resolver as RLResolver\nfrom pip._vendor.resolvelib.structs import DirectedGraph\n\nfrom pip._internal.cache import WheelCache\nfrom pip._internal.index.package_finder import PackageFinder\nfrom pip._internal.operations.prepare import RequirementPreparer\nfrom pip._internal.req.constructors import install_req_extend_extras\nfrom pip._internal.req.req_install import InstallRequirement\nfrom pip._internal.req.req_set import RequirementSet\nfrom pip._internal.resolution.base import BaseResolver, InstallRequirementProvider\nfrom pip._internal.resolution.resolvelib.provider import PipProvider\nfrom pip._internal.resolution.resolvelib.reporter import (\n    PipDebuggingReporter,\n    PipReporter,\n)\nfrom pip._internal.utils.packaging import get_requirement\n\nfrom .base import Candidate, Requirement\nfrom .factory import Factory\n\nif TYPE_CHECKING:\n    from pip._vendor.resolvelib.resolvers import Result as RLResult\n\n    Result = RLResult[Requirement, Candidate, str]\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass Resolver(BaseResolver):\n    _allowed_strategies = {\"eager\", \"only-if-needed\", \"to-satisfy-only\"}\n\n    def __init__(\n        self,\n        preparer: RequirementPreparer,\n        finder: PackageFinder,\n        wheel_cache: Optional[WheelCache],\n        make_install_req: InstallRequirementProvider,\n        use_user_site: bool,\n        ignore_dependencies: bool,\n        ignore_installed: bool,\n        ignore_requires_python: bool,\n        force_reinstall: bool,\n        upgrade_strategy: str,\n        py_version_info: Optional[Tuple[int, ...]] = None,\n    ):\n        super().__init__()\n        assert upgrade_strategy in self._allowed_strategies\n\n        self.factory = Factory(\n            finder=finder,\n            preparer=preparer,\n            make_install_req=make_install_req,\n            wheel_cache=wheel_cache,\n            use_user_site=use_user_site,\n            force_reinstall=force_reinstall,\n            ignore_installed=ignore_installed,\n            ignore_requires_python=ignore_requires_python,\n            py_version_info=py_version_info,\n        )\n        self.ignore_dependencies = ignore_dependencies\n        self.upgrade_strategy = upgrade_strategy\n        self._result: Optional[Result] = None\n\n    def resolve(\n        self, root_reqs: List[InstallRequirement], check_supported_wheels: bool\n    ) -> RequirementSet:\n        collected = self.factory.collect_root_requirements(root_reqs)\n        provider = PipProvider(\n            factory=self.factory,\n            constraints=collected.constraints,\n            ignore_dependencies=self.ignore_dependencies,\n            upgrade_strategy=self.upgrade_strategy,\n            user_requested=collected.user_requested,\n        )\n        if \"PIP_RESOLVER_DEBUG\" in os.environ:\n            reporter: BaseReporter = PipDebuggingReporter()\n        else:\n            reporter = PipReporter()\n        resolver: RLResolver[Requirement, Candidate, str] = RLResolver(\n            provider,\n            reporter,\n        )\n\n        try:\n            limit_how_complex_resolution_can_be = 200000\n            result = self._result = resolver.resolve(\n                collected.requirements, max_rounds=limit_how_complex_resolution_can_be\n            )\n\n        except ResolutionImpossible as e:\n            error = self.factory.get_installation_error(\n                cast(\"ResolutionImpossible[Requirement, Candidate]\", e),\n                collected.constraints,\n            )\n            raise error from e\n\n        req_set = RequirementSet(check_supported_wheels=check_supported_wheels)\n        # process candidates with extras last to ensure their base equivalent is\n        # already in the req_set if appropriate.\n        # Python's sort is stable so using a binary key function keeps relative order\n        # within both subsets.\n        for candidate in sorted(\n            result.mapping.values(), key=lambda c: c.name != c.project_name\n        ):\n            ireq = candidate.get_install_requirement()\n            if ireq is None:\n                if candidate.name != candidate.project_name:\n                    # extend existing req's extras\n                    with contextlib.suppress(KeyError):\n                        req = req_set.get_requirement(candidate.project_name)\n                        req_set.add_named_requirement(\n                            install_req_extend_extras(\n                                req, get_requirement(candidate.name).extras\n                            )\n                        )\n                continue\n\n            # Check if there is already an installation under the same name,\n            # and set a flag for later stages to uninstall it, if needed.\n            installed_dist = self.factory.get_dist_to_uninstall(candidate)\n            if installed_dist is None:\n                # There is no existing installation -- nothing to uninstall.\n                ireq.should_reinstall = False\n            elif self.factory.force_reinstall:\n                # The --force-reinstall flag is set -- reinstall.\n                ireq.should_reinstall = True\n            elif installed_dist.version != candidate.version:\n                # The installation is different in version -- reinstall.\n                ireq.should_reinstall = True\n            elif candidate.is_editable or installed_dist.editable:\n                # The incoming distribution is editable, or different in\n                # editable-ness to installation -- reinstall.\n                ireq.should_reinstall = True\n            elif candidate.source_link and candidate.source_link.is_file:\n                # The incoming distribution is under file://\n                if candidate.source_link.is_wheel:\n                    # is a local wheel -- do nothing.\n                    logger.info(\n                        \"%s is already installed with the same version as the \"\n                        \"provided wheel. Use --force-reinstall to force an \"\n                        \"installation of the wheel.\",\n                        ireq.name,\n                    )\n                    continue\n\n                # is a local sdist or path -- reinstall\n                ireq.should_reinstall = True\n            else:\n                continue\n\n            link = candidate.source_link\n            if link and link.is_yanked:\n                # The reason can contain non-ASCII characters, Unicode\n                # is required for Python 2.\n                msg = (\n                    \"The candidate selected for download or install is a \"\n                    \"yanked version: {name!r} candidate (version {version} \"\n                    \"at {link})\\nReason for being yanked: {reason}\"\n                ).format(\n                    name=candidate.name,\n                    version=candidate.version,\n                    link=link,\n                    reason=link.yanked_reason or \"<none given>\",\n                )\n                logger.warning(msg)\n\n            req_set.add_named_requirement(ireq)\n\n        reqs = req_set.all_requirements\n        self.factory.preparer.prepare_linked_requirements_more(reqs)\n        for req in reqs:\n            req.prepared = True\n            req.needs_more_preparation = False\n        return req_set\n\n    def get_installation_order(\n        self, req_set: RequirementSet\n    ) -> List[InstallRequirement]:\n        \"\"\"Get order for installation of requirements in RequirementSet.\n\n        The returned list contains a requirement before another that depends on\n        it. This helps ensure that the environment is kept consistent as they\n        get installed one-by-one.\n\n        The current implementation creates a topological ordering of the\n        dependency graph, giving more weight to packages with less\n        or no dependencies, while breaking any cycles in the graph at\n        arbitrary points. We make no guarantees about where the cycle\n        would be broken, other than it *would* be broken.\n        \"\"\"\n        assert self._result is not None, \"must call resolve() first\"\n\n        if not req_set.requirements:\n            # Nothing is left to install, so we do not need an order.\n            return []\n\n        graph = self._result.graph\n        weights = get_topological_weights(graph, set(req_set.requirements.keys()))\n\n        sorted_items = sorted(\n            req_set.requirements.items(),\n            key=functools.partial(_req_set_item_sorter, weights=weights),\n            reverse=True,\n        )\n        return [ireq for _, ireq in sorted_items]\n\n\ndef get_topological_weights(\n    graph: \"DirectedGraph[Optional[str]]\", requirement_keys: Set[str]\n) -> Dict[Optional[str], int]:\n    \"\"\"Assign weights to each node based on how \"deep\" they are.\n\n    This implementation may change at any point in the future without prior\n    notice.\n\n    We first simplify the dependency graph by pruning any leaves and giving them\n    the highest weight: a package without any dependencies should be installed\n    first. This is done again and again in the same way, giving ever less weight\n    to the newly found leaves. The loop stops when no leaves are left: all\n    remaining packages have at least one dependency left in the graph.\n\n    Then we continue with the remaining graph, by taking the length for the\n    longest path to any node from root, ignoring any paths that contain a single\n    node twice (i.e. cycles). This is done through a depth-first search through\n    the graph, while keeping track of the path to the node.\n\n    Cycles in the graph result would result in node being revisited while also\n    being on its own path. In this case, take no action. This helps ensure we\n    don't get stuck in a cycle.\n\n    When assigning weight, the longer path (i.e. larger length) is preferred.\n\n    We are only interested in the weights of packages that are in the\n    requirement_keys.\n    \"\"\"\n    path: Set[Optional[str]] = set()\n    weights: Dict[Optional[str], int] = {}\n\n    def visit(node: Optional[str]) -> None:\n        if node in path:\n            # We hit a cycle, so we'll break it here.\n            return\n\n        # Time to visit the children!\n        path.add(node)\n        for child in graph.iter_children(node):\n            visit(child)\n        path.remove(node)\n\n        if node not in requirement_keys:\n            return\n\n        last_known_parent_count = weights.get(node, 0)\n        weights[node] = max(last_known_parent_count, len(path))\n\n    # Simplify the graph, pruning leaves that have no dependencies.\n    # This is needed for large graphs (say over 200 packages) because the\n    # `visit` function is exponentially slower then, taking minutes.\n    # See https://github.com/pypa/pip/issues/10557\n    # We will loop until we explicitly break the loop.\n    while True:\n        leaves = set()\n        for key in graph:\n            if key is None:\n                continue\n            for _child in graph.iter_children(key):\n                # This means we have at least one child\n                break\n            else:\n                # No child.\n                leaves.add(key)\n        if not leaves:\n            # We are done simplifying.\n            break\n        # Calculate the weight for the leaves.\n        weight = len(graph) - 1\n        for leaf in leaves:\n            if leaf not in requirement_keys:\n                continue\n            weights[leaf] = weight\n        # Remove the leaves from the graph, making it simpler.\n        for leaf in leaves:\n            graph.remove(leaf)\n\n    # Visit the remaining graph.\n    # `None` is guaranteed to be the root node by resolvelib.\n    visit(None)\n\n    # Sanity check: all requirement keys should be in the weights,\n    # and no other keys should be in the weights.\n    difference = set(weights.keys()).difference(requirement_keys)\n    assert not difference, difference\n\n    return weights\n\n\ndef _req_set_item_sorter(\n    item: Tuple[str, InstallRequirement],\n    weights: Dict[Optional[str], int],\n) -> Tuple[int, str]:\n    \"\"\"Key function used to sort install requirements for installation.\n\n    Based on the \"weight\" mapping calculated in ``get_installation_order()``.\n    The canonical package name is returned as the second member as a tie-\n    breaker to ensure the result is predictable, which is useful in tests.\n    \"\"\"\n    name = canonicalize_name(item[0])\n    return weights[name], name\n"},"hash":"YMt03yCYvt"}