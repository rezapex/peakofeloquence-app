{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:rich:ansi.py","body":"import re\nimport sys\nfrom contextlib import suppress\nfrom typing import Iterable, NamedTuple, Optional\n\nfrom .color import Color\nfrom .style import Style\nfrom .text import Text\n\nre_ansi = re.compile(\n    r\"\"\"\n(?:\\x1b\\](.*?)\\x1b\\\\)|\n(?:\\x1b([(@-Z\\\\-_]|\\[[0-?]*[ -/]*[@-~]))\n\"\"\",\n    re.VERBOSE,\n)\n\n\nclass _AnsiToken(NamedTuple):\n    \"\"\"Result of ansi tokenized string.\"\"\"\n\n    plain: str = \"\"\n    sgr: Optional[str] = \"\"\n    osc: Optional[str] = \"\"\n\n\ndef _ansi_tokenize(ansi_text: str) -> Iterable[_AnsiToken]:\n    \"\"\"Tokenize a string in to plain text and ANSI codes.\n\n    Args:\n        ansi_text (str): A String containing ANSI codes.\n\n    Yields:\n        AnsiToken: A named tuple of (plain, sgr, osc)\n    \"\"\"\n\n    position = 0\n    sgr: Optional[str]\n    osc: Optional[str]\n    for match in re_ansi.finditer(ansi_text):\n        start, end = match.span(0)\n        osc, sgr = match.groups()\n        if start > position:\n            yield _AnsiToken(ansi_text[position:start])\n        if sgr:\n            if sgr == \"(\":\n                position = end + 1\n                continue\n            if sgr.endswith(\"m\"):\n                yield _AnsiToken(\"\", sgr[1:-1], osc)\n        else:\n            yield _AnsiToken(\"\", sgr, osc)\n        position = end\n    if position < len(ansi_text):\n        yield _AnsiToken(ansi_text[position:])\n\n\nSGR_STYLE_MAP = {\n    1: \"bold\",\n    2: \"dim\",\n    3: \"italic\",\n    4: \"underline\",\n    5: \"blink\",\n    6: \"blink2\",\n    7: \"reverse\",\n    8: \"conceal\",\n    9: \"strike\",\n    21: \"underline2\",\n    22: \"not dim not bold\",\n    23: \"not italic\",\n    24: \"not underline\",\n    25: \"not blink\",\n    26: \"not blink2\",\n    27: \"not reverse\",\n    28: \"not conceal\",\n    29: \"not strike\",\n    30: \"color(0)\",\n    31: \"color(1)\",\n    32: \"color(2)\",\n    33: \"color(3)\",\n    34: \"color(4)\",\n    35: \"color(5)\",\n    36: \"color(6)\",\n    37: \"color(7)\",\n    39: \"default\",\n    40: \"on color(0)\",\n    41: \"on color(1)\",\n    42: \"on color(2)\",\n    43: \"on color(3)\",\n    44: \"on color(4)\",\n    45: \"on color(5)\",\n    46: \"on color(6)\",\n    47: \"on color(7)\",\n    49: \"on default\",\n    51: \"frame\",\n    52: \"encircle\",\n    53: \"overline\",\n    54: \"not frame not encircle\",\n    55: \"not overline\",\n    90: \"color(8)\",\n    91: \"color(9)\",\n    92: \"color(10)\",\n    93: \"color(11)\",\n    94: \"color(12)\",\n    95: \"color(13)\",\n    96: \"color(14)\",\n    97: \"color(15)\",\n    100: \"on color(8)\",\n    101: \"on color(9)\",\n    102: \"on color(10)\",\n    103: \"on color(11)\",\n    104: \"on color(12)\",\n    105: \"on color(13)\",\n    106: \"on color(14)\",\n    107: \"on color(15)\",\n}\n\n\nclass AnsiDecoder:\n    \"\"\"Translate ANSI code in to styled Text.\"\"\"\n\n    def __init__(self) -> None:\n        self.style = Style.null()\n\n    def decode(self, terminal_text: str) -> Iterable[Text]:\n        \"\"\"Decode ANSI codes in an iterable of lines.\n\n        Args:\n            lines (Iterable[str]): An iterable of lines of terminal output.\n\n        Yields:\n            Text: Marked up Text.\n        \"\"\"\n        for line in terminal_text.splitlines():\n            yield self.decode_line(line)\n\n    def decode_line(self, line: str) -> Text:\n        \"\"\"Decode a line containing ansi codes.\n\n        Args:\n            line (str): A line of terminal output.\n\n        Returns:\n            Text: A Text instance marked up according to ansi codes.\n        \"\"\"\n        from_ansi = Color.from_ansi\n        from_rgb = Color.from_rgb\n        _Style = Style\n        text = Text()\n        append = text.append\n        line = line.rsplit(\"\\r\", 1)[-1]\n        for plain_text, sgr, osc in _ansi_tokenize(line):\n            if plain_text:\n                append(plain_text, self.style or None)\n            elif osc is not None:\n                if osc.startswith(\"8;\"):\n                    _params, semicolon, link = osc[2:].partition(\";\")\n                    if semicolon:\n                        self.style = self.style.update_link(link or None)\n            elif sgr is not None:\n                # Translate in to semi-colon separated codes\n                # Ignore invalid codes, because we want to be lenient\n                codes = [\n                    min(255, int(_code) if _code else 0)\n                    for _code in sgr.split(\";\")\n                    if _code.isdigit() or _code == \"\"\n                ]\n                iter_codes = iter(codes)\n                for code in iter_codes:\n                    if code == 0:\n                        # reset\n                        self.style = _Style.null()\n                    elif code in SGR_STYLE_MAP:\n                        # styles\n                        self.style += _Style.parse(SGR_STYLE_MAP[code])\n                    elif code == 38:\n                        # Â Foreground\n                        with suppress(StopIteration):\n                            color_type = next(iter_codes)\n                            if color_type == 5:\n                                self.style += _Style.from_color(\n                                    from_ansi(next(iter_codes))\n                                )\n                            elif color_type == 2:\n                                self.style += _Style.from_color(\n                                    from_rgb(\n                                        next(iter_codes),\n                                        next(iter_codes),\n                                        next(iter_codes),\n                                    )\n                                )\n                    elif code == 48:\n                        # Background\n                        with suppress(StopIteration):\n                            color_type = next(iter_codes)\n                            if color_type == 5:\n                                self.style += _Style.from_color(\n                                    None, from_ansi(next(iter_codes))\n                                )\n                            elif color_type == 2:\n                                self.style += _Style.from_color(\n                                    None,\n                                    from_rgb(\n                                        next(iter_codes),\n                                        next(iter_codes),\n                                        next(iter_codes),\n                                    ),\n                                )\n\n        return text\n\n\nif sys.platform != \"win32\" and __name__ == \"__main__\":  # pragma: no cover\n    import io\n    import os\n    import pty\n    import sys\n\n    decoder = AnsiDecoder()\n\n    stdout = io.BytesIO()\n\n    def read(fd: int) -> bytes:\n        data = os.read(fd, 1024)\n        stdout.write(data)\n        return data\n\n    pty.spawn(sys.argv[1:], read)\n\n    from .console import Console\n\n    console = Console(record=True)\n\n    stdout_result = stdout.getvalue().decode(\"utf-8\")\n    print(stdout_result)\n\n    for line in decoder.decode(stdout_result):\n        console.print(line)\n\n    console.save_html(\"stdout.html\")\n"},"hash":"301th15eXq"}