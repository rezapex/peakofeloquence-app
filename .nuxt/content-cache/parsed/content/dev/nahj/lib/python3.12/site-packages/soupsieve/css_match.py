{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:soupsieve:css_match.py","body":"\"\"\"CSS matcher.\"\"\"\nfrom __future__ import annotations\nfrom datetime import datetime\nfrom . import util\nimport re\nfrom . import css_types as ct\nimport unicodedata\nimport bs4  # type: ignore[import]\nfrom typing import Iterator, Iterable, Any, Callable, Sequence, cast  # noqa: F401\n\n# Empty tag pattern (whitespace okay)\nRE_NOT_EMPTY = re.compile('[^ \\t\\r\\n\\f]')\n\nRE_NOT_WS = re.compile('[^ \\t\\r\\n\\f]+')\n\n# Relationships\nREL_PARENT = ' '\nREL_CLOSE_PARENT = '>'\nREL_SIBLING = '~'\nREL_CLOSE_SIBLING = '+'\n\n# Relationships for :has() (forward looking)\nREL_HAS_PARENT = ': '\nREL_HAS_CLOSE_PARENT = ':>'\nREL_HAS_SIBLING = ':~'\nREL_HAS_CLOSE_SIBLING = ':+'\n\nNS_XHTML = 'http://www.w3.org/1999/xhtml'\nNS_XML = 'http://www.w3.org/XML/1998/namespace'\n\nDIR_FLAGS = ct.SEL_DIR_LTR | ct.SEL_DIR_RTL\nRANGES = ct.SEL_IN_RANGE | ct.SEL_OUT_OF_RANGE\n\nDIR_MAP = {\n    'ltr': ct.SEL_DIR_LTR,\n    'rtl': ct.SEL_DIR_RTL,\n    'auto': 0\n}\n\nRE_NUM = re.compile(r\"^(?P<value>-?(?:[0-9]{1,}(\\.[0-9]+)?|\\.[0-9]+))$\")\nRE_TIME = re.compile(r'^(?P<hour>[0-9]{2}):(?P<minutes>[0-9]{2})$')\nRE_MONTH = re.compile(r'^(?P<year>[0-9]{4,})-(?P<month>[0-9]{2})$')\nRE_WEEK = re.compile(r'^(?P<year>[0-9]{4,})-W(?P<week>[0-9]{2})$')\nRE_DATE = re.compile(r'^(?P<year>[0-9]{4,})-(?P<month>[0-9]{2})-(?P<day>[0-9]{2})$')\nRE_DATETIME = re.compile(\n    r'^(?P<year>[0-9]{4,})-(?P<month>[0-9]{2})-(?P<day>[0-9]{2})T(?P<hour>[0-9]{2}):(?P<minutes>[0-9]{2})$'\n)\nRE_WILD_STRIP = re.compile(r'(?:(?:-\\*-)(?:\\*(?:-|$))*|-\\*$)')\n\nMONTHS_30 = (4, 6, 9, 11)  # April, June, September, and November\nFEB = 2\nSHORT_MONTH = 30\nLONG_MONTH = 31\nFEB_MONTH = 28\nFEB_LEAP_MONTH = 29\nDAYS_IN_WEEK = 7\n\n\nclass _FakeParent:\n    \"\"\"\n    Fake parent class.\n\n    When we have a fragment with no `BeautifulSoup` document object,\n    we can't evaluate `nth` selectors properly.  Create a temporary\n    fake parent so we can traverse the root element as a child.\n    \"\"\"\n\n    def __init__(self, element: bs4.Tag) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self.contents = [element]\n\n    def __len__(self) -> bs4.PageElement:\n        \"\"\"Length.\"\"\"\n\n        return len(self.contents)\n\n\nclass _DocumentNav:\n    \"\"\"Navigate a Beautiful Soup document.\"\"\"\n\n    @classmethod\n    def assert_valid_input(cls, tag: Any) -> None:\n        \"\"\"Check if valid input tag or document.\"\"\"\n\n        # Fail on unexpected types.\n        if not cls.is_tag(tag):\n            raise TypeError(f\"Expected a BeautifulSoup 'Tag', but instead received type {type(tag)}\")\n\n    @staticmethod\n    def is_doc(obj: bs4.Tag) -> bool:\n        \"\"\"Is `BeautifulSoup` object.\"\"\"\n        return isinstance(obj, bs4.BeautifulSoup)\n\n    @staticmethod\n    def is_tag(obj: bs4.PageElement) -> bool:\n        \"\"\"Is tag.\"\"\"\n        return isinstance(obj, bs4.Tag)\n\n    @staticmethod\n    def is_declaration(obj: bs4.PageElement) -> bool:  # pragma: no cover\n        \"\"\"Is declaration.\"\"\"\n        return isinstance(obj, bs4.Declaration)\n\n    @staticmethod\n    def is_cdata(obj: bs4.PageElement) -> bool:\n        \"\"\"Is CDATA.\"\"\"\n        return isinstance(obj, bs4.CData)\n\n    @staticmethod\n    def is_processing_instruction(obj: bs4.PageElement) -> bool:  # pragma: no cover\n        \"\"\"Is processing instruction.\"\"\"\n        return isinstance(obj, bs4.ProcessingInstruction)\n\n    @staticmethod\n    def is_navigable_string(obj: bs4.PageElement) -> bool:\n        \"\"\"Is navigable string.\"\"\"\n        return isinstance(obj, bs4.NavigableString)\n\n    @staticmethod\n    def is_special_string(obj: bs4.PageElement) -> bool:\n        \"\"\"Is special string.\"\"\"\n        return isinstance(obj, (bs4.Comment, bs4.Declaration, bs4.CData, bs4.ProcessingInstruction, bs4.Doctype))\n\n    @classmethod\n    def is_content_string(cls, obj: bs4.PageElement) -> bool:\n        \"\"\"Check if node is content string.\"\"\"\n\n        return cls.is_navigable_string(obj) and not cls.is_special_string(obj)\n\n    @staticmethod\n    def create_fake_parent(el: bs4.Tag) -> _FakeParent:\n        \"\"\"Create fake parent for a given element.\"\"\"\n\n        return _FakeParent(el)\n\n    @staticmethod\n    def is_xml_tree(el: bs4.Tag) -> bool:\n        \"\"\"Check if element (or document) is from a XML tree.\"\"\"\n\n        return bool(el._is_xml)\n\n    def is_iframe(self, el: bs4.Tag) -> bool:\n        \"\"\"Check if element is an `iframe`.\"\"\"\n\n        return bool(\n            ((el.name if self.is_xml_tree(el) else util.lower(el.name)) == 'iframe') and\n            self.is_html_tag(el)  # type: ignore[attr-defined]\n        )\n\n    def is_root(self, el: bs4.Tag) -> bool:\n        \"\"\"\n        Return whether element is a root element.\n\n        We check that the element is the root of the tree (which we have already pre-calculated),\n        and we check if it is the root element under an `iframe`.\n        \"\"\"\n\n        root = self.root and self.root is el  # type: ignore[attr-defined]\n        if not root:\n            parent = self.get_parent(el)\n            root = parent is not None and self.is_html and self.is_iframe(parent)  # type: ignore[attr-defined]\n        return root\n\n    def get_contents(self, el: bs4.Tag, no_iframe: bool = False) -> Iterator[bs4.PageElement]:\n        \"\"\"Get contents or contents in reverse.\"\"\"\n        if not no_iframe or not self.is_iframe(el):\n            yield from el.contents\n\n    def get_children(\n        self,\n        el: bs4.Tag,\n        start: int | None = None,\n        reverse: bool = False,\n        tags: bool = True,\n        no_iframe: bool = False\n    ) -> Iterator[bs4.PageElement]:\n        \"\"\"Get children.\"\"\"\n\n        if not no_iframe or not self.is_iframe(el):\n            last = len(el.contents) - 1\n            if start is None:\n                index = last if reverse else 0\n            else:\n                index = start\n            end = -1 if reverse else last + 1\n            incr = -1 if reverse else 1\n\n            if 0 <= index <= last:\n                while index != end:\n                    node = el.contents[index]\n                    index += incr\n                    if not tags or self.is_tag(node):\n                        yield node\n\n    def get_descendants(\n        self,\n        el: bs4.Tag,\n        tags: bool = True,\n        no_iframe: bool = False\n    ) -> Iterator[bs4.PageElement]:\n        \"\"\"Get descendants.\"\"\"\n\n        if not no_iframe or not self.is_iframe(el):\n            next_good = None\n            for child in el.descendants:\n\n                if next_good is not None:\n                    if child is not next_good:\n                        continue\n                    next_good = None\n\n                is_tag = self.is_tag(child)\n\n                if no_iframe and is_tag and self.is_iframe(child):\n                    if child.next_sibling is not None:\n                        next_good = child.next_sibling\n                    else:\n                        last_child = child\n                        while self.is_tag(last_child) and last_child.contents:\n                            last_child = last_child.contents[-1]\n                        next_good = last_child.next_element\n                    yield child\n                    if next_good is None:\n                        break\n                    # Coverage isn't seeing this even though it's executed\n                    continue  # pragma: no cover\n\n                if not tags or is_tag:\n                    yield child\n\n    def get_parent(self, el: bs4.Tag, no_iframe: bool = False) -> bs4.Tag:\n        \"\"\"Get parent.\"\"\"\n\n        parent = el.parent\n        if no_iframe and parent is not None and self.is_iframe(parent):\n            parent = None\n        return parent\n\n    @staticmethod\n    def get_tag_name(el: bs4.Tag) -> str | None:\n        \"\"\"Get tag.\"\"\"\n\n        return cast('str | None', el.name)\n\n    @staticmethod\n    def get_prefix_name(el: bs4.Tag) -> str | None:\n        \"\"\"Get prefix.\"\"\"\n\n        return cast('str | None', el.prefix)\n\n    @staticmethod\n    def get_uri(el: bs4.Tag) -> str | None:\n        \"\"\"Get namespace `URI`.\"\"\"\n\n        return cast('str | None', el.namespace)\n\n    @classmethod\n    def get_next(cls, el: bs4.Tag, tags: bool = True) -> bs4.PageElement:\n        \"\"\"Get next sibling tag.\"\"\"\n\n        sibling = el.next_sibling\n        while tags and not cls.is_tag(sibling) and sibling is not None:\n            sibling = sibling.next_sibling\n        return sibling\n\n    @classmethod\n    def get_previous(cls, el: bs4.Tag, tags: bool = True) -> bs4.PageElement:\n        \"\"\"Get previous sibling tag.\"\"\"\n\n        sibling = el.previous_sibling\n        while tags and not cls.is_tag(sibling) and sibling is not None:\n            sibling = sibling.previous_sibling\n        return sibling\n\n    @staticmethod\n    def has_html_ns(el: bs4.Tag) -> bool:\n        \"\"\"\n        Check if element has an HTML namespace.\n\n        This is a bit different than whether a element is treated as having an HTML namespace,\n        like we do in the case of `is_html_tag`.\n        \"\"\"\n\n        ns = getattr(el, 'namespace') if el else None  # noqa: B009\n        return bool(ns and ns == NS_XHTML)\n\n    @staticmethod\n    def split_namespace(el: bs4.Tag, attr_name: str) -> tuple[str | None, str | None]:\n        \"\"\"Return namespace and attribute name without the prefix.\"\"\"\n\n        return getattr(attr_name, 'namespace', None), getattr(attr_name, 'name', None)\n\n    @classmethod\n    def normalize_value(cls, value: Any) -> str | Sequence[str]:\n        \"\"\"Normalize the value to be a string or list of strings.\"\"\"\n\n        # Treat `None` as empty string.\n        if value is None:\n            return ''\n\n        # Pass through strings\n        if (isinstance(value, str)):\n            return value\n\n        # If it's a byte string, convert it to Unicode, treating it as UTF-8.\n        if isinstance(value, bytes):\n            return value.decode(\"utf8\")\n\n        # BeautifulSoup supports sequences of attribute values, so make sure the children are strings.\n        if isinstance(value, Sequence):\n            new_value = []\n            for v in value:\n                if not isinstance(v, (str, bytes)) and isinstance(v, Sequence):\n                    # This is most certainly a user error and will crash and burn later.\n                    # To keep things working, we'll do what we do with all objects,\n                    # And convert them to strings.\n                    new_value.append(str(v))\n                else:\n                    # Convert the child to a string\n                    new_value.append(cast(str, cls.normalize_value(v)))\n            return new_value\n\n        # Try and make anything else a string\n        return str(value)\n\n    @classmethod\n    def get_attribute_by_name(\n        cls,\n        el: bs4.Tag,\n        name: str,\n        default: str | Sequence[str] | None = None\n    ) -> str | Sequence[str] | None:\n        \"\"\"Get attribute by name.\"\"\"\n\n        value = default\n        if el._is_xml:\n            try:\n                value = cls.normalize_value(el.attrs[name])\n            except KeyError:\n                pass\n        else:\n            for k, v in el.attrs.items():\n                if util.lower(k) == name:\n                    value = cls.normalize_value(v)\n                    break\n        return value\n\n    @classmethod\n    def iter_attributes(cls, el: bs4.Tag) -> Iterator[tuple[str, str | Sequence[str] | None]]:\n        \"\"\"Iterate attributes.\"\"\"\n\n        for k, v in el.attrs.items():\n            yield k, cls.normalize_value(v)\n\n    @classmethod\n    def get_classes(cls, el: bs4.Tag) -> Sequence[str]:\n        \"\"\"Get classes.\"\"\"\n\n        classes = cls.get_attribute_by_name(el, 'class', [])\n        if isinstance(classes, str):\n            classes = RE_NOT_WS.findall(classes)\n        return cast(Sequence[str], classes)\n\n    def get_text(self, el: bs4.Tag, no_iframe: bool = False) -> str:\n        \"\"\"Get text.\"\"\"\n\n        return ''.join(\n            [node for node in self.get_descendants(el, tags=False, no_iframe=no_iframe) if self.is_content_string(node)]\n        )\n\n    def get_own_text(self, el: bs4.Tag, no_iframe: bool = False) -> list[str]:\n        \"\"\"Get Own Text.\"\"\"\n\n        return [node for node in self.get_contents(el, no_iframe=no_iframe) if self.is_content_string(node)]\n\n\nclass Inputs:\n    \"\"\"Class for parsing and validating input items.\"\"\"\n\n    @staticmethod\n    def validate_day(year: int, month: int, day: int) -> bool:\n        \"\"\"Validate day.\"\"\"\n\n        max_days = LONG_MONTH\n        if month == FEB:\n            max_days = FEB_LEAP_MONTH if ((year % 4 == 0) and (year % 100 != 0)) or (year % 400 == 0) else FEB_MONTH\n        elif month in MONTHS_30:\n            max_days = SHORT_MONTH\n        return 1 <= day <= max_days\n\n    @staticmethod\n    def validate_week(year: int, week: int) -> bool:\n        \"\"\"Validate week.\"\"\"\n\n        max_week = datetime.strptime(f\"{12}-{31}-{year}\", \"%m-%d-%Y\").isocalendar()[1]\n        if max_week == 1:\n            max_week = 53\n        return 1 <= week <= max_week\n\n    @staticmethod\n    def validate_month(month: int) -> bool:\n        \"\"\"Validate month.\"\"\"\n\n        return 1 <= month <= 12\n\n    @staticmethod\n    def validate_year(year: int) -> bool:\n        \"\"\"Validate year.\"\"\"\n\n        return 1 <= year\n\n    @staticmethod\n    def validate_hour(hour: int) -> bool:\n        \"\"\"Validate hour.\"\"\"\n\n        return 0 <= hour <= 23\n\n    @staticmethod\n    def validate_minutes(minutes: int) -> bool:\n        \"\"\"Validate minutes.\"\"\"\n\n        return 0 <= minutes <= 59\n\n    @classmethod\n    def parse_value(cls, itype: str, value: str | None) -> tuple[float, ...] | None:\n        \"\"\"Parse the input value.\"\"\"\n\n        parsed = None  # type: tuple[float, ...] | None\n        if value is None:\n            return value\n        if itype == \"date\":\n            m = RE_DATE.match(value)\n            if m:\n                year = int(m.group('year'), 10)\n                month = int(m.group('month'), 10)\n                day = int(m.group('day'), 10)\n                if cls.validate_year(year) and cls.validate_month(month) and cls.validate_day(year, month, day):\n                    parsed = (year, month, day)\n        elif itype == \"month\":\n            m = RE_MONTH.match(value)\n            if m:\n                year = int(m.group('year'), 10)\n                month = int(m.group('month'), 10)\n                if cls.validate_year(year) and cls.validate_month(month):\n                    parsed = (year, month)\n        elif itype == \"week\":\n            m = RE_WEEK.match(value)\n            if m:\n                year = int(m.group('year'), 10)\n                week = int(m.group('week'), 10)\n                if cls.validate_year(year) and cls.validate_week(year, week):\n                    parsed = (year, week)\n        elif itype == \"time\":\n            m = RE_TIME.match(value)\n            if m:\n                hour = int(m.group('hour'), 10)\n                minutes = int(m.group('minutes'), 10)\n                if cls.validate_hour(hour) and cls.validate_minutes(minutes):\n                    parsed = (hour, minutes)\n        elif itype == \"datetime-local\":\n            m = RE_DATETIME.match(value)\n            if m:\n                year = int(m.group('year'), 10)\n                month = int(m.group('month'), 10)\n                day = int(m.group('day'), 10)\n                hour = int(m.group('hour'), 10)\n                minutes = int(m.group('minutes'), 10)\n                if (\n                    cls.validate_year(year) and cls.validate_month(month) and cls.validate_day(year, month, day) and\n                    cls.validate_hour(hour) and cls.validate_minutes(minutes)\n                ):\n                    parsed = (year, month, day, hour, minutes)\n        elif itype in (\"number\", \"range\"):\n            m = RE_NUM.match(value)\n            if m:\n                parsed = (float(m.group('value')),)\n        return parsed\n\n\nclass CSSMatch(_DocumentNav):\n    \"\"\"Perform CSS matching.\"\"\"\n\n    def __init__(\n        self,\n        selectors: ct.SelectorList,\n        scope: bs4.Tag,\n        namespaces: ct.Namespaces | None,\n        flags: int\n    ) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self.assert_valid_input(scope)\n        self.tag = scope\n        self.cached_meta_lang = []  # type: list[tuple[str, str]]\n        self.cached_default_forms = []  # type: list[tuple[bs4.Tag, bs4.Tag]]\n        self.cached_indeterminate_forms = []  # type: list[tuple[bs4.Tag, str, bool]]\n        self.selectors = selectors\n        self.namespaces = {} if namespaces is None else namespaces  # type: ct.Namespaces | dict[str, str]\n        self.flags = flags\n        self.iframe_restrict = False\n\n        # Find the root element for the whole tree\n        doc = scope\n        parent = self.get_parent(doc)\n        while parent:\n            doc = parent\n            parent = self.get_parent(doc)\n        root = None\n        if not self.is_doc(doc):\n            root = doc\n        else:\n            for child in self.get_children(doc):\n                root = child\n                break\n\n        self.root = root\n        self.scope = scope if scope is not doc else root\n        self.has_html_namespace = self.has_html_ns(root)\n\n        # A document can be both XML and HTML (XHTML)\n        self.is_xml = self.is_xml_tree(doc)\n        self.is_html = not self.is_xml or self.has_html_namespace\n\n    def supports_namespaces(self) -> bool:\n        \"\"\"Check if namespaces are supported in the HTML type.\"\"\"\n\n        return self.is_xml or self.has_html_namespace\n\n    def get_tag_ns(self, el: bs4.Tag) -> str:\n        \"\"\"Get tag namespace.\"\"\"\n\n        if self.supports_namespaces():\n            namespace = ''\n            ns = self.get_uri(el)\n            if ns:\n                namespace = ns\n        else:\n            namespace = NS_XHTML\n        return namespace\n\n    def is_html_tag(self, el: bs4.Tag) -> bool:\n        \"\"\"Check if tag is in HTML namespace.\"\"\"\n\n        return self.get_tag_ns(el) == NS_XHTML\n\n    def get_tag(self, el: bs4.Tag) -> str | None:\n        \"\"\"Get tag.\"\"\"\n\n        name = self.get_tag_name(el)\n        return util.lower(name) if name is not None and not self.is_xml else name\n\n    def get_prefix(self, el: bs4.Tag) -> str | None:\n        \"\"\"Get prefix.\"\"\"\n\n        prefix = self.get_prefix_name(el)\n        return util.lower(prefix) if prefix is not None and not self.is_xml else prefix\n\n    def find_bidi(self, el: bs4.Tag) -> int | None:\n        \"\"\"Get directionality from element text.\"\"\"\n\n        for node in self.get_children(el, tags=False):\n\n            # Analyze child text nodes\n            if self.is_tag(node):\n\n                # Avoid analyzing certain elements specified in the specification.\n                direction = DIR_MAP.get(util.lower(self.get_attribute_by_name(node, 'dir', '')), None)\n                if (\n                    self.get_tag(node) in ('bdi', 'script', 'style', 'textarea', 'iframe') or\n                    not self.is_html_tag(node) or\n                    direction is not None\n                ):\n                    continue  # pragma: no cover\n\n                # Check directionality of this node's text\n                value = self.find_bidi(node)\n                if value is not None:\n                    return value\n\n                # Direction could not be determined\n                continue  # pragma: no cover\n\n            # Skip `doctype` comments, etc.\n            if self.is_special_string(node):\n                continue\n\n            # Analyze text nodes for directionality.\n            for c in node:\n                bidi = unicodedata.bidirectional(c)\n                if bidi in ('AL', 'R', 'L'):\n                    return ct.SEL_DIR_LTR if bidi == 'L' else ct.SEL_DIR_RTL\n        return None\n\n    def extended_language_filter(self, lang_range: str, lang_tag: str) -> bool:\n        \"\"\"Filter the language tags.\"\"\"\n\n        match = True\n        lang_range = RE_WILD_STRIP.sub('-', lang_range).lower()\n        ranges = lang_range.split('-')\n        subtags = lang_tag.lower().split('-')\n        length = len(ranges)\n        slength = len(subtags)\n        rindex = 0\n        sindex = 0\n        r = ranges[rindex]\n        s = subtags[sindex]\n\n        # Empty specified language should match unspecified language attributes\n        if length == 1 and slength == 1 and not r and r == s:\n            return True\n\n        # Primary tag needs to match\n        if (r != '*' and r != s) or (r == '*' and slength == 1 and not s):\n            match = False\n\n        rindex += 1\n        sindex += 1\n\n        # Match until we run out of ranges\n        while match and rindex < length:\n            r = ranges[rindex]\n            try:\n                s = subtags[sindex]\n            except IndexError:\n                # Ran out of subtags,\n                # but we still have ranges\n                match = False\n                continue\n\n            # Empty range\n            if not r:\n                match = False\n                continue\n\n            # Matched range\n            elif s == r:\n                rindex += 1\n\n            # Implicit wildcard cannot match\n            # singletons\n            elif len(s) == 1:\n                match = False\n                continue\n\n            # Implicitly matched, so grab next subtag\n            sindex += 1\n\n        return match\n\n    def match_attribute_name(\n        self,\n        el: bs4.Tag,\n        attr: str,\n        prefix: str | None\n    ) -> str | Sequence[str] | None:\n        \"\"\"Match attribute name and return value if it exists.\"\"\"\n\n        value = None\n        if self.supports_namespaces():\n            value = None\n            # If we have not defined namespaces, we can't very well find them, so don't bother trying.\n            if prefix:\n                ns = self.namespaces.get(prefix)\n                if ns is None and prefix != '*':\n                    return None\n            else:\n                ns = None\n\n            for k, v in self.iter_attributes(el):\n\n                # Get attribute parts\n                namespace, name = self.split_namespace(el, k)\n\n                # Can't match a prefix attribute as we haven't specified one to match\n                # Try to match it normally as a whole `p:a` as selector may be trying `p\\:a`.\n                if ns is None:\n                    if (self.is_xml and attr == k) or (not self.is_xml and util.lower(attr) == util.lower(k)):\n                        value = v\n                        break\n                    # Coverage is not finding this even though it is executed.\n                    # Adding a print statement before this (and erasing coverage) causes coverage to find the line.\n                    # Ignore the false positive message.\n                    continue  # pragma: no cover\n\n                # We can't match our desired prefix attribute as the attribute doesn't have a prefix\n                if namespace is None or ns != namespace and prefix != '*':\n                    continue\n\n                # The attribute doesn't match.\n                if (util.lower(attr) != util.lower(name)) if not self.is_xml else (attr != name):\n                    continue\n\n                value = v\n                break\n        else:\n            for k, v in self.iter_attributes(el):\n                if util.lower(attr) != util.lower(k):\n                    continue\n                value = v\n                break\n        return value\n\n    def match_namespace(self, el: bs4.Tag, tag: ct.SelectorTag) -> bool:\n        \"\"\"Match the namespace of the element.\"\"\"\n\n        match = True\n        namespace = self.get_tag_ns(el)\n        default_namespace = self.namespaces.get('')\n        tag_ns = '' if tag.prefix is None else self.namespaces.get(tag.prefix)\n        # We must match the default namespace if one is not provided\n        if tag.prefix is None and (default_namespace is not None and namespace != default_namespace):\n            match = False\n        # If we specified `|tag`, we must not have a namespace.\n        elif (tag.prefix is not None and tag.prefix == '' and namespace):\n            match = False\n        # Verify prefix matches\n        elif (\n            tag.prefix and\n            tag.prefix != '*' and (tag_ns is None or namespace != tag_ns)\n        ):\n            match = False\n        return match\n\n    def match_attributes(self, el: bs4.Tag, attributes: tuple[ct.SelectorAttribute, ...]) -> bool:\n        \"\"\"Match attributes.\"\"\"\n\n        match = True\n        if attributes:\n            for a in attributes:\n                temp = self.match_attribute_name(el, a.attribute, a.prefix)\n                pattern = a.xml_type_pattern if self.is_xml and a.xml_type_pattern else a.pattern\n                if temp is None:\n                    match = False\n                    break\n                value = temp if isinstance(temp, str) else ' '.join(temp)\n                if pattern is None:\n                    continue\n                elif pattern.match(value) is None:\n                    match = False\n                    break\n        return match\n\n    def match_tagname(self, el: bs4.Tag, tag: ct.SelectorTag) -> bool:\n        \"\"\"Match tag name.\"\"\"\n\n        name = (util.lower(tag.name) if not self.is_xml and tag.name is not None else tag.name)\n        return not (\n            name is not None and\n            name not in (self.get_tag(el), '*')\n        )\n\n    def match_tag(self, el: bs4.Tag, tag: ct.SelectorTag | None) -> bool:\n        \"\"\"Match the tag.\"\"\"\n\n        match = True\n        if tag is not None:\n            # Verify namespace\n            if not self.match_namespace(el, tag):\n                match = False\n            if not self.match_tagname(el, tag):\n                match = False\n        return match\n\n    def match_past_relations(self, el: bs4.Tag, relation: ct.SelectorList) -> bool:\n        \"\"\"Match past relationship.\"\"\"\n\n        found = False\n        # I don't think this can ever happen, but it makes `mypy` happy\n        if isinstance(relation[0], ct.SelectorNull):  # pragma: no cover\n            return found\n\n        if relation[0].rel_type == REL_PARENT:\n            parent = self.get_parent(el, no_iframe=self.iframe_restrict)\n            while not found and parent:\n                found = self.match_selectors(parent, relation)\n                parent = self.get_parent(parent, no_iframe=self.iframe_restrict)\n        elif relation[0].rel_type == REL_CLOSE_PARENT:\n            parent = self.get_parent(el, no_iframe=self.iframe_restrict)\n            if parent:\n                found = self.match_selectors(parent, relation)\n        elif relation[0].rel_type == REL_SIBLING:\n            sibling = self.get_previous(el)\n            while not found and sibling:\n                found = self.match_selectors(sibling, relation)\n                sibling = self.get_previous(sibling)\n        elif relation[0].rel_type == REL_CLOSE_SIBLING:\n            sibling = self.get_previous(el)\n            if sibling and self.is_tag(sibling):\n                found = self.match_selectors(sibling, relation)\n        return found\n\n    def match_future_child(self, parent: bs4.Tag, relation: ct.SelectorList, recursive: bool = False) -> bool:\n        \"\"\"Match future child.\"\"\"\n\n        match = False\n        if recursive:\n            children = self.get_descendants  # type: Callable[..., Iterator[bs4.Tag]]\n        else:\n            children = self.get_children\n        for child in children(parent, no_iframe=self.iframe_restrict):\n            match = self.match_selectors(child, relation)\n            if match:\n                break\n        return match\n\n    def match_future_relations(self, el: bs4.Tag, relation: ct.SelectorList) -> bool:\n        \"\"\"Match future relationship.\"\"\"\n\n        found = False\n        # I don't think this can ever happen, but it makes `mypy` happy\n        if isinstance(relation[0], ct.SelectorNull):  # pragma: no cover\n            return found\n\n        if relation[0].rel_type == REL_HAS_PARENT:\n            found = self.match_future_child(el, relation, True)\n        elif relation[0].rel_type == REL_HAS_CLOSE_PARENT:\n            found = self.match_future_child(el, relation)\n        elif relation[0].rel_type == REL_HAS_SIBLING:\n            sibling = self.get_next(el)\n            while not found and sibling:\n                found = self.match_selectors(sibling, relation)\n                sibling = self.get_next(sibling)\n        elif relation[0].rel_type == REL_HAS_CLOSE_SIBLING:\n            sibling = self.get_next(el)\n            if sibling and self.is_tag(sibling):\n                found = self.match_selectors(sibling, relation)\n        return found\n\n    def match_relations(self, el: bs4.Tag, relation: ct.SelectorList) -> bool:\n        \"\"\"Match relationship to other elements.\"\"\"\n\n        found = False\n\n        if isinstance(relation[0], ct.SelectorNull) or relation[0].rel_type is None:\n            return found\n\n        if relation[0].rel_type.startswith(':'):\n            found = self.match_future_relations(el, relation)\n        else:\n            found = self.match_past_relations(el, relation)\n\n        return found\n\n    def match_id(self, el: bs4.Tag, ids: tuple[str, ...]) -> bool:\n        \"\"\"Match element's ID.\"\"\"\n\n        found = True\n        for i in ids:\n            if i != self.get_attribute_by_name(el, 'id', ''):\n                found = False\n                break\n        return found\n\n    def match_classes(self, el: bs4.Tag, classes: tuple[str, ...]) -> bool:\n        \"\"\"Match element's classes.\"\"\"\n\n        current_classes = self.get_classes(el)\n        found = True\n        for c in classes:\n            if c not in current_classes:\n                found = False\n                break\n        return found\n\n    def match_root(self, el: bs4.Tag) -> bool:\n        \"\"\"Match element as root.\"\"\"\n\n        is_root = self.is_root(el)\n        if is_root:\n            sibling = self.get_previous(el, tags=False)\n            while is_root and sibling is not None:\n                if (\n                    self.is_tag(sibling) or (self.is_content_string(sibling) and sibling.strip()) or\n                    self.is_cdata(sibling)\n                ):\n                    is_root = False\n                else:\n                    sibling = self.get_previous(sibling, tags=False)\n        if is_root:\n            sibling = self.get_next(el, tags=False)\n            while is_root and sibling is not None:\n                if (\n                    self.is_tag(sibling) or (self.is_content_string(sibling) and sibling.strip()) or\n                    self.is_cdata(sibling)\n                ):\n                    is_root = False\n                else:\n                    sibling = self.get_next(sibling, tags=False)\n        return is_root\n\n    def match_scope(self, el: bs4.Tag) -> bool:\n        \"\"\"Match element as scope.\"\"\"\n\n        return self.scope is el\n\n    def match_nth_tag_type(self, el: bs4.Tag, child: bs4.Tag) -> bool:\n        \"\"\"Match tag type for `nth` matches.\"\"\"\n\n        return (\n            (self.get_tag(child) == self.get_tag(el)) and\n            (self.get_tag_ns(child) == self.get_tag_ns(el))\n        )\n\n    def match_nth(self, el: bs4.Tag, nth: bs4.Tag) -> bool:\n        \"\"\"Match `nth` elements.\"\"\"\n\n        matched = True\n\n        for n in nth:\n            matched = False\n            if n.selectors and not self.match_selectors(el, n.selectors):\n                break\n            parent = self.get_parent(el)\n            if parent is None:\n                parent = self.create_fake_parent(el)\n            last = n.last\n            last_index = len(parent) - 1\n            index = last_index if last else 0\n            relative_index = 0\n            a = n.a\n            b = n.b\n            var = n.n\n            count = 0\n            count_incr = 1\n            factor = -1 if last else 1\n            idx = last_idx = a * count + b if var else a\n\n            # We can only adjust bounds within a variable index\n            if var:\n                # Abort if our nth index is out of bounds and only getting further out of bounds as we increment.\n                # Otherwise, increment to try to get in bounds.\n                adjust = None\n                while idx < 1 or idx > last_index:\n                    if idx < 0:\n                        diff_low = 0 - idx\n                        if adjust is not None and adjust == 1:\n                            break\n                        adjust = -1\n                        count += count_incr\n                        idx = last_idx = a * count + b if var else a\n                        diff = 0 - idx\n                        if diff >= diff_low:\n                            break\n                    else:\n                        diff_high = idx - last_index\n                        if adjust is not None and adjust == -1:\n                            break\n                        adjust = 1\n                        count += count_incr\n                        idx = last_idx = a * count + b if var else a\n                        diff = idx - last_index\n                        if diff >= diff_high:\n                            break\n                        diff_high = diff\n\n                # If a < 0, our count is working backwards, so floor the index by increasing the count.\n                # Find the count that yields the lowest, in bound value and use that.\n                # Lastly reverse count increment so that we'll increase our index.\n                lowest = count\n                if a < 0:\n                    while idx >= 1:\n                        lowest = count\n                        count += count_incr\n                        idx = last_idx = a * count + b if var else a\n                    count_incr = -1\n                count = lowest\n                idx = last_idx = a * count + b if var else a\n\n            # Evaluate elements while our calculated nth index is still in range\n            while 1 <= idx <= last_index + 1:\n                child = None\n                # Evaluate while our child index is still in range.\n                for child in self.get_children(parent, start=index, reverse=factor < 0, tags=False):\n                    index += factor\n                    if not self.is_tag(child):\n                        continue\n                    # Handle `of S` in `nth-child`\n                    if n.selectors and not self.match_selectors(child, n.selectors):\n                        continue\n                    # Handle `of-type`\n                    if n.of_type and not self.match_nth_tag_type(el, child):\n                        continue\n                    relative_index += 1\n                    if relative_index == idx:\n                        if child is el:\n                            matched = True\n                        else:\n                            break\n                    if child is el:\n                        break\n                if child is el:\n                    break\n                last_idx = idx\n                count += count_incr\n                if count < 0:\n                    # Count is counting down and has now ventured into invalid territory.\n                    break\n                idx = a * count + b if var else a\n                if last_idx == idx:\n                    break\n            if not matched:\n                break\n        return matched\n\n    def match_empty(self, el: bs4.Tag) -> bool:\n        \"\"\"Check if element is empty (if requested).\"\"\"\n\n        is_empty = True\n        for child in self.get_children(el, tags=False):\n            if self.is_tag(child):\n                is_empty = False\n                break\n            elif self.is_content_string(child) and RE_NOT_EMPTY.search(child):\n                is_empty = False\n                break\n        return is_empty\n\n    def match_subselectors(self, el: bs4.Tag, selectors: tuple[ct.SelectorList, ...]) -> bool:\n        \"\"\"Match selectors.\"\"\"\n\n        match = True\n        for sel in selectors:\n            if not self.match_selectors(el, sel):\n                match = False\n        return match\n\n    def match_contains(self, el: bs4.Tag, contains: tuple[ct.SelectorContains, ...]) -> bool:\n        \"\"\"Match element if it contains text.\"\"\"\n\n        match = True\n        content = None  # type: str | Sequence[str] | None\n        for contain_list in contains:\n            if content is None:\n                if contain_list.own:\n                    content = self.get_own_text(el, no_iframe=self.is_html)\n                else:\n                    content = self.get_text(el, no_iframe=self.is_html)\n            found = False\n            for text in contain_list.text:\n                if contain_list.own:\n                    for c in content:\n                        if text in c:\n                            found = True\n                            break\n                    if found:\n                        break\n                else:\n                    if text in content:\n                        found = True\n                        break\n            if not found:\n                match = False\n        return match\n\n    def match_default(self, el: bs4.Tag) -> bool:\n        \"\"\"Match default.\"\"\"\n\n        match = False\n\n        # Find this input's form\n        form = None\n        parent = self.get_parent(el, no_iframe=True)\n        while parent and form is None:\n            if self.get_tag(parent) == 'form' and self.is_html_tag(parent):\n                form = parent\n            else:\n                parent = self.get_parent(parent, no_iframe=True)\n\n        # Look in form cache to see if we've already located its default button\n        found_form = False\n        for f, t in self.cached_default_forms:\n            if f is form:\n                found_form = True\n                if t is el:\n                    match = True\n                break\n\n        # We didn't have the form cached, so look for its default button\n        if not found_form:\n            for child in self.get_descendants(form, no_iframe=True):\n                name = self.get_tag(child)\n                # Can't do nested forms (haven't figured out why we never hit this)\n                if name == 'form':  # pragma: no cover\n                    break\n                if name in ('input', 'button'):\n                    v = self.get_attribute_by_name(child, 'type', '')\n                    if v and util.lower(v) == 'submit':\n                        self.cached_default_forms.append((form, child))\n                        if el is child:\n                            match = True\n                        break\n        return match\n\n    def match_indeterminate(self, el: bs4.Tag) -> bool:\n        \"\"\"Match default.\"\"\"\n\n        match = False\n        name = cast(str, self.get_attribute_by_name(el, 'name'))\n\n        def get_parent_form(el: bs4.Tag) -> bs4.Tag | None:\n            \"\"\"Find this input's form.\"\"\"\n            form = None\n            parent = self.get_parent(el, no_iframe=True)\n            while form is None:\n                if self.get_tag(parent) == 'form' and self.is_html_tag(parent):\n                    form = parent\n                    break\n                last_parent = parent\n                parent = self.get_parent(parent, no_iframe=True)\n                if parent is None:\n                    form = last_parent\n                    break\n            return form\n\n        form = get_parent_form(el)\n\n        # Look in form cache to see if we've already evaluated that its fellow radio buttons are indeterminate\n        found_form = False\n        for f, n, i in self.cached_indeterminate_forms:\n            if f is form and n == name:\n                found_form = True\n                if i is True:\n                    match = True\n                break\n\n        # We didn't have the form cached, so validate that the radio button is indeterminate\n        if not found_form:\n            checked = False\n            for child in self.get_descendants(form, no_iframe=True):\n                if child is el:\n                    continue\n                tag_name = self.get_tag(child)\n                if tag_name == 'input':\n                    is_radio = False\n                    check = False\n                    has_name = False\n                    for k, v in self.iter_attributes(child):\n                        if util.lower(k) == 'type' and util.lower(v) == 'radio':\n                            is_radio = True\n                        elif util.lower(k) == 'name' and v == name:\n                            has_name = True\n                        elif util.lower(k) == 'checked':\n                            check = True\n                        if is_radio and check and has_name and get_parent_form(child) is form:\n                            checked = True\n                            break\n                if checked:\n                    break\n            if not checked:\n                match = True\n            self.cached_indeterminate_forms.append((form, name, match))\n\n        return match\n\n    def match_lang(self, el: bs4.Tag, langs: tuple[ct.SelectorLang, ...]) -> bool:\n        \"\"\"Match languages.\"\"\"\n\n        match = False\n        has_ns = self.supports_namespaces()\n        root = self.root\n        has_html_namespace = self.has_html_namespace\n\n        # Walk parents looking for `lang` (HTML) or `xml:lang` XML property.\n        parent = el\n        found_lang = None\n        last = None\n        while not found_lang:\n            has_html_ns = self.has_html_ns(parent)\n            for k, v in self.iter_attributes(parent):\n                attr_ns, attr = self.split_namespace(parent, k)\n                if (\n                    ((not has_ns or has_html_ns) and (util.lower(k) if not self.is_xml else k) == 'lang') or\n                    (\n                        has_ns and not has_html_ns and attr_ns == NS_XML and\n                        (util.lower(attr) if not self.is_xml and attr is not None else attr) == 'lang'\n                    )\n                ):\n                    found_lang = v\n                    break\n            last = parent\n            parent = self.get_parent(parent, no_iframe=self.is_html)\n\n            if parent is None:\n                root = last\n                has_html_namespace = self.has_html_ns(root)\n                parent = last\n                break\n\n        # Use cached meta language.\n        if found_lang is None and self.cached_meta_lang:\n            for cache in self.cached_meta_lang:\n                if root is cache[0]:\n                    found_lang = cache[1]\n\n        # If we couldn't find a language, and the document is HTML, look to meta to determine language.\n        if found_lang is None and (not self.is_xml or (has_html_namespace and root.name == 'html')):\n            # Find head\n            found = False\n            for tag in ('html', 'head'):\n                found = False\n                for child in self.get_children(parent, no_iframe=self.is_html):\n                    if self.get_tag(child) == tag and self.is_html_tag(child):\n                        found = True\n                        parent = child\n                        break\n                if not found:  # pragma: no cover\n                    break\n\n            # Search meta tags\n            if found:\n                for child in parent:\n                    if self.is_tag(child) and self.get_tag(child) == 'meta' and self.is_html_tag(parent):\n                        c_lang = False\n                        content = None\n                        for k, v in self.iter_attributes(child):\n                            if util.lower(k) == 'http-equiv' and util.lower(v) == 'content-language':\n                                c_lang = True\n                            if util.lower(k) == 'content':\n                                content = v\n                            if c_lang and content:\n                                found_lang = content\n                                self.cached_meta_lang.append((cast(str, root), cast(str, found_lang)))\n                                break\n                    if found_lang is not None:\n                        break\n                if found_lang is None:\n                    self.cached_meta_lang.append((cast(str, root), ''))\n\n        # If we determined a language, compare.\n        if found_lang is not None:\n            for patterns in langs:\n                match = False\n                for pattern in patterns:\n                    if self.extended_language_filter(pattern, cast(str, found_lang)):\n                        match = True\n                if not match:\n                    break\n\n        return match\n\n    def match_dir(self, el: bs4.Tag, directionality: int) -> bool:\n        \"\"\"Check directionality.\"\"\"\n\n        # If we have to match both left and right, we can't match either.\n        if directionality & ct.SEL_DIR_LTR and directionality & ct.SEL_DIR_RTL:\n            return False\n\n        if el is None or not self.is_html_tag(el):\n            return False\n\n        # Element has defined direction of left to right or right to left\n        direction = DIR_MAP.get(util.lower(self.get_attribute_by_name(el, 'dir', '')), None)\n        if direction not in (None, 0):\n            return direction == directionality\n\n        # Element is the document element (the root) and no direction assigned, assume left to right.\n        is_root = self.is_root(el)\n        if is_root and direction is None:\n            return ct.SEL_DIR_LTR == directionality\n\n        # If `input[type=telephone]` and no direction is assigned, assume left to right.\n        name = self.get_tag(el)\n        is_input = name == 'input'\n        is_textarea = name == 'textarea'\n        is_bdi = name == 'bdi'\n        itype = util.lower(self.get_attribute_by_name(el, 'type', '')) if is_input else ''\n        if is_input and itype == 'tel' and direction is None:\n            return ct.SEL_DIR_LTR == directionality\n\n        # Auto handling for text inputs\n        if ((is_input and itype in ('text', 'search', 'tel', 'url', 'email')) or is_textarea) and direction == 0:\n            if is_textarea:\n                value = ''.join(node for node in self.get_contents(el, no_iframe=True) if self.is_content_string(node))\n            else:\n                value = cast(str, self.get_attribute_by_name(el, 'value', ''))\n            if value:\n                for c in value:\n                    bidi = unicodedata.bidirectional(c)\n                    if bidi in ('AL', 'R', 'L'):\n                        direction = ct.SEL_DIR_LTR if bidi == 'L' else ct.SEL_DIR_RTL\n                        return direction == directionality\n                # Assume left to right\n                return ct.SEL_DIR_LTR == directionality\n            elif is_root:\n                return ct.SEL_DIR_LTR == directionality\n            return self.match_dir(self.get_parent(el, no_iframe=True), directionality)\n\n        # Auto handling for `bdi` and other non text inputs.\n        if (is_bdi and direction is None) or direction == 0:\n            direction = self.find_bidi(el)\n            if direction is not None:\n                return direction == directionality\n            elif is_root:\n                return ct.SEL_DIR_LTR == directionality\n            return self.match_dir(self.get_parent(el, no_iframe=True), directionality)\n\n        # Match parents direction\n        return self.match_dir(self.get_parent(el, no_iframe=True), directionality)\n\n    def match_range(self, el: bs4.Tag, condition: int) -> bool:\n        \"\"\"\n        Match range.\n\n        Behavior is modeled after what we see in browsers. Browsers seem to evaluate\n        if the value is out of range, and if not, it is in range. So a missing value\n        will not evaluate out of range; therefore, value is in range. Personally, I\n        feel like this should evaluate as neither in or out of range.\n        \"\"\"\n\n        out_of_range = False\n\n        itype = util.lower(self.get_attribute_by_name(el, 'type'))\n        mn = Inputs.parse_value(itype, cast(str, self.get_attribute_by_name(el, 'min', None)))\n        mx = Inputs.parse_value(itype, cast(str, self.get_attribute_by_name(el, 'max', None)))\n\n        # There is no valid min or max, so we cannot evaluate a range\n        if mn is None and mx is None:\n            return False\n\n        value = Inputs.parse_value(itype, cast(str, self.get_attribute_by_name(el, 'value', None)))\n        if value is not None:\n            if itype in (\"date\", \"datetime-local\", \"month\", \"week\", \"number\", \"range\"):\n                if mn is not None and value < mn:\n                    out_of_range = True\n                if not out_of_range and mx is not None and value > mx:\n                    out_of_range = True\n            elif itype == \"time\":\n                if mn is not None and mx is not None and mn > mx:\n                    # Time is periodic, so this is a reversed/discontinuous range\n                    if value < mn and value > mx:\n                        out_of_range = True\n                else:\n                    if mn is not None and value < mn:\n                        out_of_range = True\n                    if not out_of_range and mx is not None and value > mx:\n                        out_of_range = True\n\n        return not out_of_range if condition & ct.SEL_IN_RANGE else out_of_range\n\n    def match_defined(self, el: bs4.Tag) -> bool:\n        \"\"\"\n        Match defined.\n\n        `:defined` is related to custom elements in a browser.\n\n        - If the document is XML (not XHTML), all tags will match.\n        - Tags that are not custom (don't have a hyphen) are marked defined.\n        - If the tag has a prefix (without or without a namespace), it will not match.\n\n        This is of course requires the parser to provide us with the proper prefix and namespace info,\n        if it doesn't, there is nothing we can do.\n        \"\"\"\n\n        name = self.get_tag(el)\n        return (\n            name is not None and (\n                name.find('-') == -1 or\n                name.find(':') != -1 or\n                self.get_prefix(el) is not None\n            )\n        )\n\n    def match_placeholder_shown(self, el: bs4.Tag) -> bool:\n        \"\"\"\n        Match placeholder shown according to HTML spec.\n\n        - text area should be checked if they have content. A single newline does not count as content.\n\n        \"\"\"\n\n        match = False\n        content = self.get_text(el)\n        if content in ('', '\\n'):\n            match = True\n\n        return match\n\n    def match_selectors(self, el: bs4.Tag, selectors: ct.SelectorList) -> bool:\n        \"\"\"Check if element matches one of the selectors.\"\"\"\n\n        match = False\n        is_not = selectors.is_not\n        is_html = selectors.is_html\n\n        # Internal selector lists that use the HTML flag, will automatically get the `html` namespace.\n        if is_html:\n            namespaces = self.namespaces\n            iframe_restrict = self.iframe_restrict\n            self.namespaces = {'html': NS_XHTML}\n            self.iframe_restrict = True\n\n        if not is_html or self.is_html:\n            for selector in selectors:\n                match = is_not\n                # We have a un-matchable situation (like `:focus` as you can focus an element in this environment)\n                if isinstance(selector, ct.SelectorNull):\n                    continue\n                # Verify tag matches\n                if not self.match_tag(el, selector.tag):\n                    continue\n                # Verify tag is defined\n                if selector.flags & ct.SEL_DEFINED and not self.match_defined(el):\n                    continue\n                # Verify element is root\n                if selector.flags & ct.SEL_ROOT and not self.match_root(el):\n                    continue\n                # Verify element is scope\n                if selector.flags & ct.SEL_SCOPE and not self.match_scope(el):\n                    continue\n                # Verify element has placeholder shown\n                if selector.flags & ct.SEL_PLACEHOLDER_SHOWN and not self.match_placeholder_shown(el):\n                    continue\n                # Verify `nth` matches\n                if not self.match_nth(el, selector.nth):\n                    continue\n                if selector.flags & ct.SEL_EMPTY and not self.match_empty(el):\n                    continue\n                # Verify id matches\n                if selector.ids and not self.match_id(el, selector.ids):\n                    continue\n                # Verify classes match\n                if selector.classes and not self.match_classes(el, selector.classes):\n                    continue\n                # Verify attribute(s) match\n                if not self.match_attributes(el, selector.attributes):\n                    continue\n                # Verify ranges\n                if selector.flags & RANGES and not self.match_range(el, selector.flags & RANGES):\n                    continue\n                # Verify language patterns\n                if selector.lang and not self.match_lang(el, selector.lang):\n                    continue\n                # Verify pseudo selector patterns\n                if selector.selectors and not self.match_subselectors(el, selector.selectors):\n                    continue\n                # Verify relationship selectors\n                if selector.relation and not self.match_relations(el, selector.relation):\n                    continue\n                # Validate that the current default selector match corresponds to the first submit button in the form\n                if selector.flags & ct.SEL_DEFAULT and not self.match_default(el):\n                    continue\n                # Validate that the unset radio button is among radio buttons with the same name in a form that are\n                # also not set.\n                if selector.flags & ct.SEL_INDETERMINATE and not self.match_indeterminate(el):\n                    continue\n                # Validate element directionality\n                if selector.flags & DIR_FLAGS and not self.match_dir(el, selector.flags & DIR_FLAGS):\n                    continue\n                # Validate that the tag contains the specified text.\n                if selector.contains and not self.match_contains(el, selector.contains):\n                    continue\n                match = not is_not\n                break\n\n        # Restore actual namespaces being used for external selector lists\n        if is_html:\n            self.namespaces = namespaces\n            self.iframe_restrict = iframe_restrict\n\n        return match\n\n    def select(self, limit: int = 0) -> Iterator[bs4.Tag]:\n        \"\"\"Match all tags under the targeted tag.\"\"\"\n\n        lim = None if limit < 1 else limit\n\n        for child in self.get_descendants(self.tag):\n            if self.match(child):\n                yield child\n                if lim is not None:\n                    lim -= 1\n                    if lim < 1:\n                        break\n\n    def closest(self) -> bs4.Tag | None:\n        \"\"\"Match closest ancestor.\"\"\"\n\n        current = self.tag\n        closest = None\n        while closest is None and current is not None:\n            if self.match(current):\n                closest = current\n            else:\n                current = self.get_parent(current)\n        return closest\n\n    def filter(self) -> list[bs4.Tag]:  # noqa A001\n        \"\"\"Filter tag's children.\"\"\"\n\n        return [tag for tag in self.get_contents(self.tag) if not self.is_navigable_string(tag) and self.match(tag)]\n\n    def match(self, el: bs4.Tag) -> bool:\n        \"\"\"Match.\"\"\"\n\n        return not self.is_doc(el) and self.is_tag(el) and self.match_selectors(el, self.selectors)\n\n\nclass SoupSieve(ct.Immutable):\n    \"\"\"Compiled Soup Sieve selector matching object.\"\"\"\n\n    pattern: str\n    selectors: ct.SelectorList\n    namespaces: ct.Namespaces | None\n    custom: dict[str, str]\n    flags: int\n\n    __slots__ = (\"pattern\", \"selectors\", \"namespaces\", \"custom\", \"flags\", \"_hash\")\n\n    def __init__(\n        self,\n        pattern: str,\n        selectors: ct.SelectorList,\n        namespaces: ct.Namespaces | None,\n        custom: ct.CustomSelectors | None,\n        flags: int\n    ):\n        \"\"\"Initialize.\"\"\"\n\n        super().__init__(\n            pattern=pattern,\n            selectors=selectors,\n            namespaces=namespaces,\n            custom=custom,\n            flags=flags\n        )\n\n    def match(self, tag: bs4.Tag) -> bool:\n        \"\"\"Match.\"\"\"\n\n        return CSSMatch(self.selectors, tag, self.namespaces, self.flags).match(tag)\n\n    def closest(self, tag: bs4.Tag) -> bs4.Tag:\n        \"\"\"Match closest ancestor.\"\"\"\n\n        return CSSMatch(self.selectors, tag, self.namespaces, self.flags).closest()\n\n    def filter(self, iterable: Iterable[bs4.Tag]) -> list[bs4.Tag]:  # noqa A001\n        \"\"\"\n        Filter.\n\n        `CSSMatch` can cache certain searches for tags of the same document,\n        so if we are given a tag, all tags are from the same document,\n        and we can take advantage of the optimization.\n\n        Any other kind of iterable could have tags from different documents or detached tags,\n        so for those, we use a new `CSSMatch` for each item in the iterable.\n        \"\"\"\n\n        if CSSMatch.is_tag(iterable):\n            return CSSMatch(self.selectors, iterable, self.namespaces, self.flags).filter()\n        else:\n            return [node for node in iterable if not CSSMatch.is_navigable_string(node) and self.match(node)]\n\n    def select_one(self, tag: bs4.Tag) -> bs4.Tag:\n        \"\"\"Select a single tag.\"\"\"\n\n        tags = self.select(tag, limit=1)\n        return tags[0] if tags else None\n\n    def select(self, tag: bs4.Tag, limit: int = 0) -> list[bs4.Tag]:\n        \"\"\"Select the specified tags.\"\"\"\n\n        return list(self.iselect(tag, limit))\n\n    def iselect(self, tag: bs4.Tag, limit: int = 0) -> Iterator[bs4.Tag]:\n        \"\"\"Iterate the specified tags.\"\"\"\n\n        yield from CSSMatch(self.selectors, tag, self.namespaces, self.flags).select(limit)\n\n    def __repr__(self) -> str:  # pragma: no cover\n        \"\"\"Representation.\"\"\"\n\n        return (\n            f\"SoupSieve(pattern={self.pattern!r}, namespaces={self.namespaces!r}, \"\n            f\"custom={self.custom!r}, flags={self.flags!r})\"\n        )\n\n    __str__ = __repr__\n\n\nct.pickle_register(SoupSieve)\n"},"hash":"t4o55xucxS"}