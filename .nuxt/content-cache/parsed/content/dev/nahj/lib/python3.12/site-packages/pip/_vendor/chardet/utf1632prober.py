{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:chardet:utf1632prober.py","body":"######################## BEGIN LICENSE BLOCK ########################\n#\n# Contributor(s):\n#   Jason Zavaglia\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\nfrom typing import List, Union\n\nfrom .charsetprober import CharSetProber\nfrom .enums import ProbingState\n\n\nclass UTF1632Prober(CharSetProber):\n    \"\"\"\n    This class simply looks for occurrences of zero bytes, and infers\n    whether the file is UTF16 or UTF32 (low-endian or big-endian)\n    For instance, files looking like ( \\0 \\0 \\0 [nonzero] )+\n    have a good probability to be UTF32BE.  Files looking like ( \\0 [nonzero] )+\n    may be guessed to be UTF16BE, and inversely for little-endian varieties.\n    \"\"\"\n\n    # how many logical characters to scan before feeling confident of prediction\n    MIN_CHARS_FOR_DETECTION = 20\n    # a fixed constant ratio of expected zeros or non-zeros in modulo-position.\n    EXPECTED_RATIO = 0.94\n\n    def __init__(self) -> None:\n        super().__init__()\n        self.position = 0\n        self.zeros_at_mod = [0] * 4\n        self.nonzeros_at_mod = [0] * 4\n        self._state = ProbingState.DETECTING\n        self.quad = [0, 0, 0, 0]\n        self.invalid_utf16be = False\n        self.invalid_utf16le = False\n        self.invalid_utf32be = False\n        self.invalid_utf32le = False\n        self.first_half_surrogate_pair_detected_16be = False\n        self.first_half_surrogate_pair_detected_16le = False\n        self.reset()\n\n    def reset(self) -> None:\n        super().reset()\n        self.position = 0\n        self.zeros_at_mod = [0] * 4\n        self.nonzeros_at_mod = [0] * 4\n        self._state = ProbingState.DETECTING\n        self.invalid_utf16be = False\n        self.invalid_utf16le = False\n        self.invalid_utf32be = False\n        self.invalid_utf32le = False\n        self.first_half_surrogate_pair_detected_16be = False\n        self.first_half_surrogate_pair_detected_16le = False\n        self.quad = [0, 0, 0, 0]\n\n    @property\n    def charset_name(self) -> str:\n        if self.is_likely_utf32be():\n            return \"utf-32be\"\n        if self.is_likely_utf32le():\n            return \"utf-32le\"\n        if self.is_likely_utf16be():\n            return \"utf-16be\"\n        if self.is_likely_utf16le():\n            return \"utf-16le\"\n        # default to something valid\n        return \"utf-16\"\n\n    @property\n    def language(self) -> str:\n        return \"\"\n\n    def approx_32bit_chars(self) -> float:\n        return max(1.0, self.position / 4.0)\n\n    def approx_16bit_chars(self) -> float:\n        return max(1.0, self.position / 2.0)\n\n    def is_likely_utf32be(self) -> bool:\n        approx_chars = self.approx_32bit_chars()\n        return approx_chars >= self.MIN_CHARS_FOR_DETECTION and (\n            self.zeros_at_mod[0] / approx_chars > self.EXPECTED_RATIO\n            and self.zeros_at_mod[1] / approx_chars > self.EXPECTED_RATIO\n            and self.zeros_at_mod[2] / approx_chars > self.EXPECTED_RATIO\n            and self.nonzeros_at_mod[3] / approx_chars > self.EXPECTED_RATIO\n            and not self.invalid_utf32be\n        )\n\n    def is_likely_utf32le(self) -> bool:\n        approx_chars = self.approx_32bit_chars()\n        return approx_chars >= self.MIN_CHARS_FOR_DETECTION and (\n            self.nonzeros_at_mod[0] / approx_chars > self.EXPECTED_RATIO\n            and self.zeros_at_mod[1] / approx_chars > self.EXPECTED_RATIO\n            and self.zeros_at_mod[2] / approx_chars > self.EXPECTED_RATIO\n            and self.zeros_at_mod[3] / approx_chars > self.EXPECTED_RATIO\n            and not self.invalid_utf32le\n        )\n\n    def is_likely_utf16be(self) -> bool:\n        approx_chars = self.approx_16bit_chars()\n        return approx_chars >= self.MIN_CHARS_FOR_DETECTION and (\n            (self.nonzeros_at_mod[1] + self.nonzeros_at_mod[3]) / approx_chars\n            > self.EXPECTED_RATIO\n            and (self.zeros_at_mod[0] + self.zeros_at_mod[2]) / approx_chars\n            > self.EXPECTED_RATIO\n            and not self.invalid_utf16be\n        )\n\n    def is_likely_utf16le(self) -> bool:\n        approx_chars = self.approx_16bit_chars()\n        return approx_chars >= self.MIN_CHARS_FOR_DETECTION and (\n            (self.nonzeros_at_mod[0] + self.nonzeros_at_mod[2]) / approx_chars\n            > self.EXPECTED_RATIO\n            and (self.zeros_at_mod[1] + self.zeros_at_mod[3]) / approx_chars\n            > self.EXPECTED_RATIO\n            and not self.invalid_utf16le\n        )\n\n    def validate_utf32_characters(self, quad: List[int]) -> None:\n        \"\"\"\n        Validate if the quad of bytes is valid UTF-32.\n\n        UTF-32 is valid in the range 0x00000000 - 0x0010FFFF\n        excluding 0x0000D800 - 0x0000DFFF\n\n        https://en.wikipedia.org/wiki/UTF-32\n        \"\"\"\n        if (\n            quad[0] != 0\n            or quad[1] > 0x10\n            or (quad[0] == 0 and quad[1] == 0 and 0xD8 <= quad[2] <= 0xDF)\n        ):\n            self.invalid_utf32be = True\n        if (\n            quad[3] != 0\n            or quad[2] > 0x10\n            or (quad[3] == 0 and quad[2] == 0 and 0xD8 <= quad[1] <= 0xDF)\n        ):\n            self.invalid_utf32le = True\n\n    def validate_utf16_characters(self, pair: List[int]) -> None:\n        \"\"\"\n        Validate if the pair of bytes is  valid UTF-16.\n\n        UTF-16 is valid in the range 0x0000 - 0xFFFF excluding 0xD800 - 0xFFFF\n        with an exception for surrogate pairs, which must be in the range\n        0xD800-0xDBFF followed by 0xDC00-0xDFFF\n\n        https://en.wikipedia.org/wiki/UTF-16\n        \"\"\"\n        if not self.first_half_surrogate_pair_detected_16be:\n            if 0xD8 <= pair[0] <= 0xDB:\n                self.first_half_surrogate_pair_detected_16be = True\n            elif 0xDC <= pair[0] <= 0xDF:\n                self.invalid_utf16be = True\n        else:\n            if 0xDC <= pair[0] <= 0xDF:\n                self.first_half_surrogate_pair_detected_16be = False\n            else:\n                self.invalid_utf16be = True\n\n        if not self.first_half_surrogate_pair_detected_16le:\n            if 0xD8 <= pair[1] <= 0xDB:\n                self.first_half_surrogate_pair_detected_16le = True\n            elif 0xDC <= pair[1] <= 0xDF:\n                self.invalid_utf16le = True\n        else:\n            if 0xDC <= pair[1] <= 0xDF:\n                self.first_half_surrogate_pair_detected_16le = False\n            else:\n                self.invalid_utf16le = True\n\n    def feed(self, byte_str: Union[bytes, bytearray]) -> ProbingState:\n        for c in byte_str:\n            mod4 = self.position % 4\n            self.quad[mod4] = c\n            if mod4 == 3:\n                self.validate_utf32_characters(self.quad)\n                self.validate_utf16_characters(self.quad[0:2])\n                self.validate_utf16_characters(self.quad[2:4])\n            if c == 0:\n                self.zeros_at_mod[mod4] += 1\n            else:\n                self.nonzeros_at_mod[mod4] += 1\n            self.position += 1\n        return self.state\n\n    @property\n    def state(self) -> ProbingState:\n        if self._state in {ProbingState.NOT_ME, ProbingState.FOUND_IT}:\n            # terminal, decided states\n            return self._state\n        if self.get_confidence() > 0.80:\n            self._state = ProbingState.FOUND_IT\n        elif self.position > 4 * 1024:\n            # if we get to 4kb into the file, and we can't conclude it's UTF,\n            # let's give up\n            self._state = ProbingState.NOT_ME\n        return self._state\n\n    def get_confidence(self) -> float:\n        return (\n            0.85\n            if (\n                self.is_likely_utf16le()\n                or self.is_likely_utf16be()\n                or self.is_likely_utf32le()\n                or self.is_likely_utf32be()\n            )\n            else 0.00\n        )\n"},"hash":"uuLGxs93ch"}