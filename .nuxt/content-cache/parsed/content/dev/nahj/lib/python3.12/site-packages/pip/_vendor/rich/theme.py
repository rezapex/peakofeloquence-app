{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:rich:theme.py","body":"import configparser\nfrom typing import Dict, List, IO, Mapping, Optional\n\nfrom .default_styles import DEFAULT_STYLES\nfrom .style import Style, StyleType\n\n\nclass Theme:\n    \"\"\"A container for style information, used by :class:`~rich.console.Console`.\n\n    Args:\n        styles (Dict[str, Style], optional): A mapping of style names on to styles. Defaults to None for a theme with no styles.\n        inherit (bool, optional): Inherit default styles. Defaults to True.\n    \"\"\"\n\n    styles: Dict[str, Style]\n\n    def __init__(\n        self, styles: Optional[Mapping[str, StyleType]] = None, inherit: bool = True\n    ):\n        self.styles = DEFAULT_STYLES.copy() if inherit else {}\n        if styles is not None:\n            self.styles.update(\n                {\n                    name: style if isinstance(style, Style) else Style.parse(style)\n                    for name, style in styles.items()\n                }\n            )\n\n    @property\n    def config(self) -> str:\n        \"\"\"Get contents of a config file for this theme.\"\"\"\n        config = \"[styles]\\n\" + \"\\n\".join(\n            f\"{name} = {style}\" for name, style in sorted(self.styles.items())\n        )\n        return config\n\n    @classmethod\n    def from_file(\n        cls, config_file: IO[str], source: Optional[str] = None, inherit: bool = True\n    ) -> \"Theme\":\n        \"\"\"Load a theme from a text mode file.\n\n        Args:\n            config_file (IO[str]): An open conf file.\n            source (str, optional): The filename of the open file. Defaults to None.\n            inherit (bool, optional): Inherit default styles. Defaults to True.\n\n        Returns:\n            Theme: A New theme instance.\n        \"\"\"\n        config = configparser.ConfigParser()\n        config.read_file(config_file, source=source)\n        styles = {name: Style.parse(value) for name, value in config.items(\"styles\")}\n        theme = Theme(styles, inherit=inherit)\n        return theme\n\n    @classmethod\n    def read(\n        cls, path: str, inherit: bool = True, encoding: Optional[str] = None\n    ) -> \"Theme\":\n        \"\"\"Read a theme from a path.\n\n        Args:\n            path (str): Path to a config file readable by Python configparser module.\n            inherit (bool, optional): Inherit default styles. Defaults to True.\n            encoding (str, optional): Encoding of the config file. Defaults to None.\n\n        Returns:\n            Theme: A new theme instance.\n        \"\"\"\n        with open(path, \"rt\", encoding=encoding) as config_file:\n            return cls.from_file(config_file, source=path, inherit=inherit)\n\n\nclass ThemeStackError(Exception):\n    \"\"\"Base exception for errors related to the theme stack.\"\"\"\n\n\nclass ThemeStack:\n    \"\"\"A stack of themes.\n\n    Args:\n        theme (Theme): A theme instance\n    \"\"\"\n\n    def __init__(self, theme: Theme) -> None:\n        self._entries: List[Dict[str, Style]] = [theme.styles]\n        self.get = self._entries[-1].get\n\n    def push_theme(self, theme: Theme, inherit: bool = True) -> None:\n        \"\"\"Push a theme on the top of the stack.\n\n        Args:\n            theme (Theme): A Theme instance.\n            inherit (boolean, optional): Inherit styles from current top of stack.\n        \"\"\"\n        styles: Dict[str, Style]\n        styles = (\n            {**self._entries[-1], **theme.styles} if inherit else theme.styles.copy()\n        )\n        self._entries.append(styles)\n        self.get = self._entries[-1].get\n\n    def pop_theme(self) -> None:\n        \"\"\"Pop (and discard) the top-most theme.\"\"\"\n        if len(self._entries) == 1:\n            raise ThemeStackError(\"Unable to pop base theme\")\n        self._entries.pop()\n        self.get = self._entries[-1].get\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    theme = Theme()\n    print(theme.config)\n"},"hash":"jZCNUUqC5P"}