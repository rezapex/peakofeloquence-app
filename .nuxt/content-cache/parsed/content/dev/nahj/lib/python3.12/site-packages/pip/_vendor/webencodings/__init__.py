{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:webencodings:__init__.py","body":"# coding: utf-8\n\"\"\"\n\n    webencodings\n    ~~~~~~~~~~~~\n\n    This is a Python implementation of the `WHATWG Encoding standard\n    <http://encoding.spec.whatwg.org/>`. See README for details.\n\n    :copyright: Copyright 2012 by Simon Sapin\n    :license: BSD, see LICENSE for details.\n\n\"\"\"\n\nfrom __future__ import unicode_literals\n\nimport codecs\n\nfrom .labels import LABELS\n\n\nVERSION = '0.5.1'\n\n\n# Some names in Encoding are not valid Python aliases. Remap these.\nPYTHON_NAMES = {\n    'iso-8859-8-i': 'iso-8859-8',\n    'x-mac-cyrillic': 'mac-cyrillic',\n    'macintosh': 'mac-roman',\n    'windows-874': 'cp874'}\n\nCACHE = {}\n\n\ndef ascii_lower(string):\n    r\"\"\"Transform (only) ASCII letters to lower case: A-Z is mapped to a-z.\n\n    :param string: An Unicode string.\n    :returns: A new Unicode string.\n\n    This is used for `ASCII case-insensitive\n    <http://encoding.spec.whatwg.org/#ascii-case-insensitive>`_\n    matching of encoding labels.\n    The same matching is also used, among other things,\n    for `CSS keywords <http://dev.w3.org/csswg/css-values/#keywords>`_.\n\n    This is different from the :meth:`~py:str.lower` method of Unicode strings\n    which also affect non-ASCII characters,\n    sometimes mapping them into the ASCII range:\n\n        >>> keyword = u'Bac\\N{KELVIN SIGN}ground'\n        >>> assert keyword.lower() == u'background'\n        >>> assert ascii_lower(keyword) != keyword.lower()\n        >>> assert ascii_lower(keyword) == u'bac\\N{KELVIN SIGN}ground'\n\n    \"\"\"\n    # This turns out to be faster than unicode.translate()\n    return string.encode('utf8').lower().decode('utf8')\n\n\ndef lookup(label):\n    \"\"\"\n    Look for an encoding by its label.\n    This is the spec’s `get an encoding\n    <http://encoding.spec.whatwg.org/#concept-encoding-get>`_ algorithm.\n    Supported labels are listed there.\n\n    :param label: A string.\n    :returns:\n        An :class:`Encoding` object, or :obj:`None` for an unknown label.\n\n    \"\"\"\n    # Only strip ASCII whitespace: U+0009, U+000A, U+000C, U+000D, and U+0020.\n    label = ascii_lower(label.strip('\\t\\n\\f\\r '))\n    name = LABELS.get(label)\n    if name is None:\n        return None\n    encoding = CACHE.get(name)\n    if encoding is None:\n        if name == 'x-user-defined':\n            from .x_user_defined import codec_info\n        else:\n            python_name = PYTHON_NAMES.get(name, name)\n            # Any python_name value that gets to here should be valid.\n            codec_info = codecs.lookup(python_name)\n        encoding = Encoding(name, codec_info)\n        CACHE[name] = encoding\n    return encoding\n\n\ndef _get_encoding(encoding_or_label):\n    \"\"\"\n    Accept either an encoding object or label.\n\n    :param encoding: An :class:`Encoding` object or a label string.\n    :returns: An :class:`Encoding` object.\n    :raises: :exc:`~exceptions.LookupError` for an unknown label.\n\n    \"\"\"\n    if hasattr(encoding_or_label, 'codec_info'):\n        return encoding_or_label\n\n    encoding = lookup(encoding_or_label)\n    if encoding is None:\n        raise LookupError('Unknown encoding label: %r' % encoding_or_label)\n    return encoding\n\n\nclass Encoding(object):\n    \"\"\"Reresents a character encoding such as UTF-8,\n    that can be used for decoding or encoding.\n\n    .. attribute:: name\n\n        Canonical name of the encoding\n\n    .. attribute:: codec_info\n\n        The actual implementation of the encoding,\n        a stdlib :class:`~codecs.CodecInfo` object.\n        See :func:`codecs.register`.\n\n    \"\"\"\n    def __init__(self, name, codec_info):\n        self.name = name\n        self.codec_info = codec_info\n\n    def __repr__(self):\n        return '<Encoding %s>' % self.name\n\n\n#: The UTF-8 encoding. Should be used for new content and formats.\nUTF8 = lookup('utf-8')\n\n_UTF16LE = lookup('utf-16le')\n_UTF16BE = lookup('utf-16be')\n\n\ndef decode(input, fallback_encoding, errors='replace'):\n    \"\"\"\n    Decode a single string.\n\n    :param input: A byte string\n    :param fallback_encoding:\n        An :class:`Encoding` object or a label string.\n        The encoding to use if :obj:`input` does note have a BOM.\n    :param errors: Type of error handling. See :func:`codecs.register`.\n    :raises: :exc:`~exceptions.LookupError` for an unknown encoding label.\n    :return:\n        A ``(output, encoding)`` tuple of an Unicode string\n        and an :obj:`Encoding`.\n\n    \"\"\"\n    # Fail early if `encoding` is an invalid label.\n    fallback_encoding = _get_encoding(fallback_encoding)\n    bom_encoding, input = _detect_bom(input)\n    encoding = bom_encoding or fallback_encoding\n    return encoding.codec_info.decode(input, errors)[0], encoding\n\n\ndef _detect_bom(input):\n    \"\"\"Return (bom_encoding, input), with any BOM removed from the input.\"\"\"\n    if input.startswith(b'\\xFF\\xFE'):\n        return _UTF16LE, input[2:]\n    if input.startswith(b'\\xFE\\xFF'):\n        return _UTF16BE, input[2:]\n    if input.startswith(b'\\xEF\\xBB\\xBF'):\n        return UTF8, input[3:]\n    return None, input\n\n\ndef encode(input, encoding=UTF8, errors='strict'):\n    \"\"\"\n    Encode a single string.\n\n    :param input: An Unicode string.\n    :param encoding: An :class:`Encoding` object or a label string.\n    :param errors: Type of error handling. See :func:`codecs.register`.\n    :raises: :exc:`~exceptions.LookupError` for an unknown encoding label.\n    :return: A byte string.\n\n    \"\"\"\n    return _get_encoding(encoding).codec_info.encode(input, errors)[0]\n\n\ndef iter_decode(input, fallback_encoding, errors='replace'):\n    \"\"\"\n    \"Pull\"-based decoder.\n\n    :param input:\n        An iterable of byte strings.\n\n        The input is first consumed just enough to determine the encoding\n        based on the precense of a BOM,\n        then consumed on demand when the return value is.\n    :param fallback_encoding:\n        An :class:`Encoding` object or a label string.\n        The encoding to use if :obj:`input` does note have a BOM.\n    :param errors: Type of error handling. See :func:`codecs.register`.\n    :raises: :exc:`~exceptions.LookupError` for an unknown encoding label.\n    :returns:\n        An ``(output, encoding)`` tuple.\n        :obj:`output` is an iterable of Unicode strings,\n        :obj:`encoding` is the :obj:`Encoding` that is being used.\n\n    \"\"\"\n\n    decoder = IncrementalDecoder(fallback_encoding, errors)\n    generator = _iter_decode_generator(input, decoder)\n    encoding = next(generator)\n    return generator, encoding\n\n\ndef _iter_decode_generator(input, decoder):\n    \"\"\"Return a generator that first yields the :obj:`Encoding`,\n    then yields output chukns as Unicode strings.\n\n    \"\"\"\n    decode = decoder.decode\n    input = iter(input)\n    for chunck in input:\n        output = decode(chunck)\n        if output:\n            assert decoder.encoding is not None\n            yield decoder.encoding\n            yield output\n            break\n    else:\n        # Input exhausted without determining the encoding\n        output = decode(b'', final=True)\n        assert decoder.encoding is not None\n        yield decoder.encoding\n        if output:\n            yield output\n        return\n\n    for chunck in input:\n        output = decode(chunck)\n        if output:\n            yield output\n    output = decode(b'', final=True)\n    if output:\n        yield output\n\n\ndef iter_encode(input, encoding=UTF8, errors='strict'):\n    \"\"\"\n    “Pull”-based encoder.\n\n    :param input: An iterable of Unicode strings.\n    :param encoding: An :class:`Encoding` object or a label string.\n    :param errors: Type of error handling. See :func:`codecs.register`.\n    :raises: :exc:`~exceptions.LookupError` for an unknown encoding label.\n    :returns: An iterable of byte strings.\n\n    \"\"\"\n    # Fail early if `encoding` is an invalid label.\n    encode = IncrementalEncoder(encoding, errors).encode\n    return _iter_encode_generator(input, encode)\n\n\ndef _iter_encode_generator(input, encode):\n    for chunck in input:\n        output = encode(chunck)\n        if output:\n            yield output\n    output = encode('', final=True)\n    if output:\n        yield output\n\n\nclass IncrementalDecoder(object):\n    \"\"\"\n    “Push”-based decoder.\n\n    :param fallback_encoding:\n        An :class:`Encoding` object or a label string.\n        The encoding to use if :obj:`input` does note have a BOM.\n    :param errors: Type of error handling. See :func:`codecs.register`.\n    :raises: :exc:`~exceptions.LookupError` for an unknown encoding label.\n\n    \"\"\"\n    def __init__(self, fallback_encoding, errors='replace'):\n        # Fail early if `encoding` is an invalid label.\n        self._fallback_encoding = _get_encoding(fallback_encoding)\n        self._errors = errors\n        self._buffer = b''\n        self._decoder = None\n        #: The actual :class:`Encoding` that is being used,\n        #: or :obj:`None` if that is not determined yet.\n        #: (Ie. if there is not enough input yet to determine\n        #: if there is a BOM.)\n        self.encoding = None  # Not known yet.\n\n    def decode(self, input, final=False):\n        \"\"\"Decode one chunk of the input.\n\n        :param input: A byte string.\n        :param final:\n            Indicate that no more input is available.\n            Must be :obj:`True` if this is the last call.\n        :returns: An Unicode string.\n\n        \"\"\"\n        decoder = self._decoder\n        if decoder is not None:\n            return decoder(input, final)\n\n        input = self._buffer + input\n        encoding, input = _detect_bom(input)\n        if encoding is None:\n            if len(input) < 3 and not final:  # Not enough data yet.\n                self._buffer = input\n                return ''\n            else:  # No BOM\n                encoding = self._fallback_encoding\n        decoder = encoding.codec_info.incrementaldecoder(self._errors).decode\n        self._decoder = decoder\n        self.encoding = encoding\n        return decoder(input, final)\n\n\nclass IncrementalEncoder(object):\n    \"\"\"\n    “Push”-based encoder.\n\n    :param encoding: An :class:`Encoding` object or a label string.\n    :param errors: Type of error handling. See :func:`codecs.register`.\n    :raises: :exc:`~exceptions.LookupError` for an unknown encoding label.\n\n    .. method:: encode(input, final=False)\n\n        :param input: An Unicode string.\n        :param final:\n            Indicate that no more input is available.\n            Must be :obj:`True` if this is the last call.\n        :returns: A byte string.\n\n    \"\"\"\n    def __init__(self, encoding=UTF8, errors='strict'):\n        encoding = _get_encoding(encoding)\n        self.encode = encoding.codec_info.incrementalencoder(errors).encode\n"},"hash":"eOBhkfyDW2"}