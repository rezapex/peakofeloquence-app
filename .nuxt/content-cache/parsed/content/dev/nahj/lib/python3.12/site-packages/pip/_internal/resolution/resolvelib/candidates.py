{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:resolution:resolvelib:candidates.py","body":"import logging\nimport sys\nfrom typing import TYPE_CHECKING, Any, FrozenSet, Iterable, Optional, Tuple, Union, cast\n\nfrom pip._vendor.packaging.utils import NormalizedName, canonicalize_name\nfrom pip._vendor.packaging.version import Version\n\nfrom pip._internal.exceptions import (\n    HashError,\n    InstallationSubprocessError,\n    MetadataInconsistent,\n)\nfrom pip._internal.metadata import BaseDistribution\nfrom pip._internal.models.link import Link, links_equivalent\nfrom pip._internal.models.wheel import Wheel\nfrom pip._internal.req.constructors import (\n    install_req_from_editable,\n    install_req_from_line,\n)\nfrom pip._internal.req.req_install import InstallRequirement\nfrom pip._internal.utils.direct_url_helpers import direct_url_from_link\nfrom pip._internal.utils.misc import normalize_version_info\n\nfrom .base import Candidate, CandidateVersion, Requirement, format_name\n\nif TYPE_CHECKING:\n    from .factory import Factory\n\nlogger = logging.getLogger(__name__)\n\nBaseCandidate = Union[\n    \"AlreadyInstalledCandidate\",\n    \"EditableCandidate\",\n    \"LinkCandidate\",\n]\n\n# Avoid conflicting with the PyPI package \"Python\".\nREQUIRES_PYTHON_IDENTIFIER = cast(NormalizedName, \"<Python from Requires-Python>\")\n\n\ndef as_base_candidate(candidate: Candidate) -> Optional[BaseCandidate]:\n    \"\"\"The runtime version of BaseCandidate.\"\"\"\n    base_candidate_classes = (\n        AlreadyInstalledCandidate,\n        EditableCandidate,\n        LinkCandidate,\n    )\n    if isinstance(candidate, base_candidate_classes):\n        return candidate\n    return None\n\n\ndef make_install_req_from_link(\n    link: Link, template: InstallRequirement\n) -> InstallRequirement:\n    assert not template.editable, \"template is editable\"\n    if template.req:\n        line = str(template.req)\n    else:\n        line = link.url\n    ireq = install_req_from_line(\n        line,\n        user_supplied=template.user_supplied,\n        comes_from=template.comes_from,\n        use_pep517=template.use_pep517,\n        isolated=template.isolated,\n        constraint=template.constraint,\n        global_options=template.global_options,\n        hash_options=template.hash_options,\n        config_settings=template.config_settings,\n    )\n    ireq.original_link = template.original_link\n    ireq.link = link\n    ireq.extras = template.extras\n    return ireq\n\n\ndef make_install_req_from_editable(\n    link: Link, template: InstallRequirement\n) -> InstallRequirement:\n    assert template.editable, \"template not editable\"\n    ireq = install_req_from_editable(\n        link.url,\n        user_supplied=template.user_supplied,\n        comes_from=template.comes_from,\n        use_pep517=template.use_pep517,\n        isolated=template.isolated,\n        constraint=template.constraint,\n        permit_editable_wheels=template.permit_editable_wheels,\n        global_options=template.global_options,\n        hash_options=template.hash_options,\n        config_settings=template.config_settings,\n    )\n    ireq.extras = template.extras\n    return ireq\n\n\ndef _make_install_req_from_dist(\n    dist: BaseDistribution, template: InstallRequirement\n) -> InstallRequirement:\n    if template.req:\n        line = str(template.req)\n    elif template.link:\n        line = f\"{dist.canonical_name} @ {template.link.url}\"\n    else:\n        line = f\"{dist.canonical_name}=={dist.version}\"\n    ireq = install_req_from_line(\n        line,\n        user_supplied=template.user_supplied,\n        comes_from=template.comes_from,\n        use_pep517=template.use_pep517,\n        isolated=template.isolated,\n        constraint=template.constraint,\n        global_options=template.global_options,\n        hash_options=template.hash_options,\n        config_settings=template.config_settings,\n    )\n    ireq.satisfied_by = dist\n    return ireq\n\n\nclass _InstallRequirementBackedCandidate(Candidate):\n    \"\"\"A candidate backed by an ``InstallRequirement``.\n\n    This represents a package request with the target not being already\n    in the environment, and needs to be fetched and installed. The backing\n    ``InstallRequirement`` is responsible for most of the leg work; this\n    class exposes appropriate information to the resolver.\n\n    :param link: The link passed to the ``InstallRequirement``. The backing\n        ``InstallRequirement`` will use this link to fetch the distribution.\n    :param source_link: The link this candidate \"originates\" from. This is\n        different from ``link`` when the link is found in the wheel cache.\n        ``link`` would point to the wheel cache, while this points to the\n        found remote link (e.g. from pypi.org).\n    \"\"\"\n\n    dist: BaseDistribution\n    is_installed = False\n\n    def __init__(\n        self,\n        link: Link,\n        source_link: Link,\n        ireq: InstallRequirement,\n        factory: \"Factory\",\n        name: Optional[NormalizedName] = None,\n        version: Optional[CandidateVersion] = None,\n    ) -> None:\n        self._link = link\n        self._source_link = source_link\n        self._factory = factory\n        self._ireq = ireq\n        self._name = name\n        self._version = version\n        self.dist = self._prepare()\n\n    def __str__(self) -> str:\n        return f\"{self.name} {self.version}\"\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({str(self._link)!r})\"\n\n    def __hash__(self) -> int:\n        return hash((self.__class__, self._link))\n\n    def __eq__(self, other: Any) -> bool:\n        if isinstance(other, self.__class__):\n            return links_equivalent(self._link, other._link)\n        return False\n\n    @property\n    def source_link(self) -> Optional[Link]:\n        return self._source_link\n\n    @property\n    def project_name(self) -> NormalizedName:\n        \"\"\"The normalised name of the project the candidate refers to\"\"\"\n        if self._name is None:\n            self._name = self.dist.canonical_name\n        return self._name\n\n    @property\n    def name(self) -> str:\n        return self.project_name\n\n    @property\n    def version(self) -> CandidateVersion:\n        if self._version is None:\n            self._version = self.dist.version\n        return self._version\n\n    def format_for_error(self) -> str:\n        return \"{} {} (from {})\".format(\n            self.name,\n            self.version,\n            self._link.file_path if self._link.is_file else self._link,\n        )\n\n    def _prepare_distribution(self) -> BaseDistribution:\n        raise NotImplementedError(\"Override in subclass\")\n\n    def _check_metadata_consistency(self, dist: BaseDistribution) -> None:\n        \"\"\"Check for consistency of project name and version of dist.\"\"\"\n        if self._name is not None and self._name != dist.canonical_name:\n            raise MetadataInconsistent(\n                self._ireq,\n                \"name\",\n                self._name,\n                dist.canonical_name,\n            )\n        if self._version is not None and self._version != dist.version:\n            raise MetadataInconsistent(\n                self._ireq,\n                \"version\",\n                str(self._version),\n                str(dist.version),\n            )\n\n    def _prepare(self) -> BaseDistribution:\n        try:\n            dist = self._prepare_distribution()\n        except HashError as e:\n            # Provide HashError the underlying ireq that caused it. This\n            # provides context for the resulting error message to show the\n            # offending line to the user.\n            e.req = self._ireq\n            raise\n        except InstallationSubprocessError as exc:\n            # The output has been presented already, so don't duplicate it.\n            exc.context = \"See above for output.\"\n            raise\n\n        self._check_metadata_consistency(dist)\n        return dist\n\n    def iter_dependencies(self, with_requires: bool) -> Iterable[Optional[Requirement]]:\n        requires = self.dist.iter_dependencies() if with_requires else ()\n        for r in requires:\n            yield from self._factory.make_requirements_from_spec(str(r), self._ireq)\n        yield self._factory.make_requires_python_requirement(self.dist.requires_python)\n\n    def get_install_requirement(self) -> Optional[InstallRequirement]:\n        return self._ireq\n\n\nclass LinkCandidate(_InstallRequirementBackedCandidate):\n    is_editable = False\n\n    def __init__(\n        self,\n        link: Link,\n        template: InstallRequirement,\n        factory: \"Factory\",\n        name: Optional[NormalizedName] = None,\n        version: Optional[CandidateVersion] = None,\n    ) -> None:\n        source_link = link\n        cache_entry = factory.get_wheel_cache_entry(source_link, name)\n        if cache_entry is not None:\n            logger.debug(\"Using cached wheel link: %s\", cache_entry.link)\n            link = cache_entry.link\n        ireq = make_install_req_from_link(link, template)\n        assert ireq.link == link\n        if ireq.link.is_wheel and not ireq.link.is_file:\n            wheel = Wheel(ireq.link.filename)\n            wheel_name = canonicalize_name(wheel.name)\n            assert name == wheel_name, f\"{name!r} != {wheel_name!r} for wheel\"\n            # Version may not be present for PEP 508 direct URLs\n            if version is not None:\n                wheel_version = Version(wheel.version)\n                assert version == wheel_version, \"{!r} != {!r} for wheel {}\".format(\n                    version, wheel_version, name\n                )\n\n        if cache_entry is not None:\n            assert ireq.link.is_wheel\n            assert ireq.link.is_file\n            if cache_entry.persistent and template.link is template.original_link:\n                ireq.cached_wheel_source_link = source_link\n            if cache_entry.origin is not None:\n                ireq.download_info = cache_entry.origin\n            else:\n                # Legacy cache entry that does not have origin.json.\n                # download_info may miss the archive_info.hashes field.\n                ireq.download_info = direct_url_from_link(\n                    source_link, link_is_in_wheel_cache=cache_entry.persistent\n                )\n\n        super().__init__(\n            link=link,\n            source_link=source_link,\n            ireq=ireq,\n            factory=factory,\n            name=name,\n            version=version,\n        )\n\n    def _prepare_distribution(self) -> BaseDistribution:\n        preparer = self._factory.preparer\n        return preparer.prepare_linked_requirement(self._ireq, parallel_builds=True)\n\n\nclass EditableCandidate(_InstallRequirementBackedCandidate):\n    is_editable = True\n\n    def __init__(\n        self,\n        link: Link,\n        template: InstallRequirement,\n        factory: \"Factory\",\n        name: Optional[NormalizedName] = None,\n        version: Optional[CandidateVersion] = None,\n    ) -> None:\n        super().__init__(\n            link=link,\n            source_link=link,\n            ireq=make_install_req_from_editable(link, template),\n            factory=factory,\n            name=name,\n            version=version,\n        )\n\n    def _prepare_distribution(self) -> BaseDistribution:\n        return self._factory.preparer.prepare_editable_requirement(self._ireq)\n\n\nclass AlreadyInstalledCandidate(Candidate):\n    is_installed = True\n    source_link = None\n\n    def __init__(\n        self,\n        dist: BaseDistribution,\n        template: InstallRequirement,\n        factory: \"Factory\",\n    ) -> None:\n        self.dist = dist\n        self._ireq = _make_install_req_from_dist(dist, template)\n        self._factory = factory\n        self._version = None\n\n        # This is just logging some messages, so we can do it eagerly.\n        # The returned dist would be exactly the same as self.dist because we\n        # set satisfied_by in _make_install_req_from_dist.\n        # TODO: Supply reason based on force_reinstall and upgrade_strategy.\n        skip_reason = \"already satisfied\"\n        factory.preparer.prepare_installed_requirement(self._ireq, skip_reason)\n\n    def __str__(self) -> str:\n        return str(self.dist)\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({self.dist!r})\"\n\n    def __hash__(self) -> int:\n        return hash((self.__class__, self.name, self.version))\n\n    def __eq__(self, other: Any) -> bool:\n        if isinstance(other, self.__class__):\n            return self.name == other.name and self.version == other.version\n        return False\n\n    @property\n    def project_name(self) -> NormalizedName:\n        return self.dist.canonical_name\n\n    @property\n    def name(self) -> str:\n        return self.project_name\n\n    @property\n    def version(self) -> CandidateVersion:\n        if self._version is None:\n            self._version = self.dist.version\n        return self._version\n\n    @property\n    def is_editable(self) -> bool:\n        return self.dist.editable\n\n    def format_for_error(self) -> str:\n        return f\"{self.name} {self.version} (Installed)\"\n\n    def iter_dependencies(self, with_requires: bool) -> Iterable[Optional[Requirement]]:\n        if not with_requires:\n            return\n        for r in self.dist.iter_dependencies():\n            yield from self._factory.make_requirements_from_spec(str(r), self._ireq)\n\n    def get_install_requirement(self) -> Optional[InstallRequirement]:\n        return None\n\n\nclass ExtrasCandidate(Candidate):\n    \"\"\"A candidate that has 'extras', indicating additional dependencies.\n\n    Requirements can be for a project with dependencies, something like\n    foo[extra].  The extras don't affect the project/version being installed\n    directly, but indicate that we need additional dependencies. We model that\n    by having an artificial ExtrasCandidate that wraps the \"base\" candidate.\n\n    The ExtrasCandidate differs from the base in the following ways:\n\n    1. It has a unique name, of the form foo[extra]. This causes the resolver\n       to treat it as a separate node in the dependency graph.\n    2. When we're getting the candidate's dependencies,\n       a) We specify that we want the extra dependencies as well.\n       b) We add a dependency on the base candidate.\n          See below for why this is needed.\n    3. We return None for the underlying InstallRequirement, as the base\n       candidate will provide it, and we don't want to end up with duplicates.\n\n    The dependency on the base candidate is needed so that the resolver can't\n    decide that it should recommend foo[extra1] version 1.0 and foo[extra2]\n    version 2.0. Having those candidates depend on foo=1.0 and foo=2.0\n    respectively forces the resolver to recognise that this is a conflict.\n    \"\"\"\n\n    def __init__(\n        self,\n        base: BaseCandidate,\n        extras: FrozenSet[str],\n        *,\n        comes_from: Optional[InstallRequirement] = None,\n    ) -> None:\n        \"\"\"\n        :param comes_from: the InstallRequirement that led to this candidate if it\n            differs from the base's InstallRequirement. This will often be the\n            case in the sense that this candidate's requirement has the extras\n            while the base's does not. Unlike the InstallRequirement backed\n            candidates, this requirement is used solely for reporting purposes,\n            it does not do any leg work.\n        \"\"\"\n        self.base = base\n        self.extras = frozenset(canonicalize_name(e) for e in extras)\n        # If any extras are requested in their non-normalized forms, keep track\n        # of their raw values. This is needed when we look up dependencies\n        # since PEP 685 has not been implemented for marker-matching, and using\n        # the non-normalized extra for lookup ensures the user can select a\n        # non-normalized extra in a package with its non-normalized form.\n        # TODO: Remove this attribute when packaging is upgraded to support the\n        # marker comparison logic specified in PEP 685.\n        self._unnormalized_extras = extras.difference(self.extras)\n        self._comes_from = comes_from if comes_from is not None else self.base._ireq\n\n    def __str__(self) -> str:\n        name, rest = str(self.base).split(\" \", 1)\n        return \"{}[{}] {}\".format(name, \",\".join(self.extras), rest)\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}(base={self.base!r}, extras={self.extras!r})\"\n\n    def __hash__(self) -> int:\n        return hash((self.base, self.extras))\n\n    def __eq__(self, other: Any) -> bool:\n        if isinstance(other, self.__class__):\n            return self.base == other.base and self.extras == other.extras\n        return False\n\n    @property\n    def project_name(self) -> NormalizedName:\n        return self.base.project_name\n\n    @property\n    def name(self) -> str:\n        \"\"\"The normalised name of the project the candidate refers to\"\"\"\n        return format_name(self.base.project_name, self.extras)\n\n    @property\n    def version(self) -> CandidateVersion:\n        return self.base.version\n\n    def format_for_error(self) -> str:\n        return \"{} [{}]\".format(\n            self.base.format_for_error(), \", \".join(sorted(self.extras))\n        )\n\n    @property\n    def is_installed(self) -> bool:\n        return self.base.is_installed\n\n    @property\n    def is_editable(self) -> bool:\n        return self.base.is_editable\n\n    @property\n    def source_link(self) -> Optional[Link]:\n        return self.base.source_link\n\n    def _warn_invalid_extras(\n        self,\n        requested: FrozenSet[str],\n        valid: FrozenSet[str],\n    ) -> None:\n        \"\"\"Emit warnings for invalid extras being requested.\n\n        This emits a warning for each requested extra that is not in the\n        candidate's ``Provides-Extra`` list.\n        \"\"\"\n        invalid_extras_to_warn = frozenset(\n            extra\n            for extra in requested\n            if extra not in valid\n            # If an extra is requested in an unnormalized form, skip warning\n            # about the normalized form being missing.\n            and extra in self.extras\n        )\n        if not invalid_extras_to_warn:\n            return\n        for extra in sorted(invalid_extras_to_warn):\n            logger.warning(\n                \"%s %s does not provide the extra '%s'\",\n                self.base.name,\n                self.version,\n                extra,\n            )\n\n    def _calculate_valid_requested_extras(self) -> FrozenSet[str]:\n        \"\"\"Get a list of valid extras requested by this candidate.\n\n        The user (or upstream dependant) may have specified extras that the\n        candidate doesn't support. Any unsupported extras are dropped, and each\n        cause a warning to be logged here.\n        \"\"\"\n        requested_extras = self.extras.union(self._unnormalized_extras)\n        valid_extras = frozenset(\n            extra\n            for extra in requested_extras\n            if self.base.dist.is_extra_provided(extra)\n        )\n        self._warn_invalid_extras(requested_extras, valid_extras)\n        return valid_extras\n\n    def iter_dependencies(self, with_requires: bool) -> Iterable[Optional[Requirement]]:\n        factory = self.base._factory\n\n        # Add a dependency on the exact base\n        # (See note 2b in the class docstring)\n        yield factory.make_requirement_from_candidate(self.base)\n        if not with_requires:\n            return\n\n        valid_extras = self._calculate_valid_requested_extras()\n        for r in self.base.dist.iter_dependencies(valid_extras):\n            yield from factory.make_requirements_from_spec(\n                str(r),\n                self._comes_from,\n                valid_extras,\n            )\n\n    def get_install_requirement(self) -> Optional[InstallRequirement]:\n        # We don't return anything here, because we always\n        # depend on the base candidate, and we'll get the\n        # install requirement from that.\n        return None\n\n\nclass RequiresPythonCandidate(Candidate):\n    is_installed = False\n    source_link = None\n\n    def __init__(self, py_version_info: Optional[Tuple[int, ...]]) -> None:\n        if py_version_info is not None:\n            version_info = normalize_version_info(py_version_info)\n        else:\n            version_info = sys.version_info[:3]\n        self._version = Version(\".\".join(str(c) for c in version_info))\n\n    # We don't need to implement __eq__() and __ne__() since there is always\n    # only one RequiresPythonCandidate in a resolution, i.e. the host Python.\n    # The built-in object.__eq__() and object.__ne__() do exactly what we want.\n\n    def __str__(self) -> str:\n        return f\"Python {self._version}\"\n\n    @property\n    def project_name(self) -> NormalizedName:\n        return REQUIRES_PYTHON_IDENTIFIER\n\n    @property\n    def name(self) -> str:\n        return REQUIRES_PYTHON_IDENTIFIER\n\n    @property\n    def version(self) -> CandidateVersion:\n        return self._version\n\n    def format_for_error(self) -> str:\n        return f\"Python {self.version}\"\n\n    def iter_dependencies(self, with_requires: bool) -> Iterable[Optional[Requirement]]:\n        return ()\n\n    def get_install_requirement(self) -> Optional[InstallRequirement]:\n        return None\n"},"hash":"bgz0cIDskv"}