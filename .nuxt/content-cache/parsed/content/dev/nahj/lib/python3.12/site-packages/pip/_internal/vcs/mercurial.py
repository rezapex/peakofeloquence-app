{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:vcs:mercurial.py","body":"import configparser\nimport logging\nimport os\nfrom typing import List, Optional, Tuple\n\nfrom pip._internal.exceptions import BadCommand, InstallationError\nfrom pip._internal.utils.misc import HiddenText, display_path\nfrom pip._internal.utils.subprocess import make_command\nfrom pip._internal.utils.urls import path_to_url\nfrom pip._internal.vcs.versioncontrol import (\n    RevOptions,\n    VersionControl,\n    find_path_to_project_root_from_repo_root,\n    vcs,\n)\n\nlogger = logging.getLogger(__name__)\n\n\nclass Mercurial(VersionControl):\n    name = \"hg\"\n    dirname = \".hg\"\n    repo_name = \"clone\"\n    schemes = (\n        \"hg+file\",\n        \"hg+http\",\n        \"hg+https\",\n        \"hg+ssh\",\n        \"hg+static-http\",\n    )\n\n    @staticmethod\n    def get_base_rev_args(rev: str) -> List[str]:\n        return [f\"--rev={rev}\"]\n\n    def fetch_new(\n        self, dest: str, url: HiddenText, rev_options: RevOptions, verbosity: int\n    ) -> None:\n        rev_display = rev_options.to_display()\n        logger.info(\n            \"Cloning hg %s%s to %s\",\n            url,\n            rev_display,\n            display_path(dest),\n        )\n        if verbosity <= 0:\n            flags: Tuple[str, ...] = (\"--quiet\",)\n        elif verbosity == 1:\n            flags = ()\n        elif verbosity == 2:\n            flags = (\"--verbose\",)\n        else:\n            flags = (\"--verbose\", \"--debug\")\n        self.run_command(make_command(\"clone\", \"--noupdate\", *flags, url, dest))\n        self.run_command(\n            make_command(\"update\", *flags, rev_options.to_args()),\n            cwd=dest,\n        )\n\n    def switch(self, dest: str, url: HiddenText, rev_options: RevOptions) -> None:\n        repo_config = os.path.join(dest, self.dirname, \"hgrc\")\n        config = configparser.RawConfigParser()\n        try:\n            config.read(repo_config)\n            config.set(\"paths\", \"default\", url.secret)\n            with open(repo_config, \"w\") as config_file:\n                config.write(config_file)\n        except (OSError, configparser.NoSectionError) as exc:\n            logger.warning(\"Could not switch Mercurial repository to %s: %s\", url, exc)\n        else:\n            cmd_args = make_command(\"update\", \"-q\", rev_options.to_args())\n            self.run_command(cmd_args, cwd=dest)\n\n    def update(self, dest: str, url: HiddenText, rev_options: RevOptions) -> None:\n        self.run_command([\"pull\", \"-q\"], cwd=dest)\n        cmd_args = make_command(\"update\", \"-q\", rev_options.to_args())\n        self.run_command(cmd_args, cwd=dest)\n\n    @classmethod\n    def get_remote_url(cls, location: str) -> str:\n        url = cls.run_command(\n            [\"showconfig\", \"paths.default\"],\n            show_stdout=False,\n            stdout_only=True,\n            cwd=location,\n        ).strip()\n        if cls._is_local_repository(url):\n            url = path_to_url(url)\n        return url.strip()\n\n    @classmethod\n    def get_revision(cls, location: str) -> str:\n        \"\"\"\n        Return the repository-local changeset revision number, as an integer.\n        \"\"\"\n        current_revision = cls.run_command(\n            [\"parents\", \"--template={rev}\"],\n            show_stdout=False,\n            stdout_only=True,\n            cwd=location,\n        ).strip()\n        return current_revision\n\n    @classmethod\n    def get_requirement_revision(cls, location: str) -> str:\n        \"\"\"\n        Return the changeset identification hash, as a 40-character\n        hexadecimal string\n        \"\"\"\n        current_rev_hash = cls.run_command(\n            [\"parents\", \"--template={node}\"],\n            show_stdout=False,\n            stdout_only=True,\n            cwd=location,\n        ).strip()\n        return current_rev_hash\n\n    @classmethod\n    def is_commit_id_equal(cls, dest: str, name: Optional[str]) -> bool:\n        \"\"\"Always assume the versions don't match\"\"\"\n        return False\n\n    @classmethod\n    def get_subdirectory(cls, location: str) -> Optional[str]:\n        \"\"\"\n        Return the path to Python project root, relative to the repo root.\n        Return None if the project root is in the repo root.\n        \"\"\"\n        # find the repo root\n        repo_root = cls.run_command(\n            [\"root\"], show_stdout=False, stdout_only=True, cwd=location\n        ).strip()\n        if not os.path.isabs(repo_root):\n            repo_root = os.path.abspath(os.path.join(location, repo_root))\n        return find_path_to_project_root_from_repo_root(location, repo_root)\n\n    @classmethod\n    def get_repository_root(cls, location: str) -> Optional[str]:\n        loc = super().get_repository_root(location)\n        if loc:\n            return loc\n        try:\n            r = cls.run_command(\n                [\"root\"],\n                cwd=location,\n                show_stdout=False,\n                stdout_only=True,\n                on_returncode=\"raise\",\n                log_failed_cmd=False,\n            )\n        except BadCommand:\n            logger.debug(\n                \"could not determine if %s is under hg control \"\n                \"because hg is not available\",\n                location,\n            )\n            return None\n        except InstallationError:\n            return None\n        return os.path.normpath(r.rstrip(\"\\r\\n\"))\n\n\nvcs.register(Mercurial)\n"},"hash":"r7lkEfQMd8"}