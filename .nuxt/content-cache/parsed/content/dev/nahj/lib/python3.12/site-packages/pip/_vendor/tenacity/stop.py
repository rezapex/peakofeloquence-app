{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:tenacity:stop.py","body":"# Copyright 2016â€“2021 Julien Danjou\n# Copyright 2016 Joshua Harlow\n# Copyright 2013-2014 Ray Holder\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport abc\nimport typing\n\nfrom pip._vendor.tenacity import _utils\n\nif typing.TYPE_CHECKING:\n    import threading\n\n    from pip._vendor.tenacity import RetryCallState\n\n\nclass stop_base(abc.ABC):\n    \"\"\"Abstract base class for stop strategies.\"\"\"\n\n    @abc.abstractmethod\n    def __call__(self, retry_state: \"RetryCallState\") -> bool:\n        pass\n\n    def __and__(self, other: \"stop_base\") -> \"stop_all\":\n        return stop_all(self, other)\n\n    def __or__(self, other: \"stop_base\") -> \"stop_any\":\n        return stop_any(self, other)\n\n\nStopBaseT = typing.Union[stop_base, typing.Callable[[\"RetryCallState\"], bool]]\n\n\nclass stop_any(stop_base):\n    \"\"\"Stop if any of the stop condition is valid.\"\"\"\n\n    def __init__(self, *stops: stop_base) -> None:\n        self.stops = stops\n\n    def __call__(self, retry_state: \"RetryCallState\") -> bool:\n        return any(x(retry_state) for x in self.stops)\n\n\nclass stop_all(stop_base):\n    \"\"\"Stop if all the stop conditions are valid.\"\"\"\n\n    def __init__(self, *stops: stop_base) -> None:\n        self.stops = stops\n\n    def __call__(self, retry_state: \"RetryCallState\") -> bool:\n        return all(x(retry_state) for x in self.stops)\n\n\nclass _stop_never(stop_base):\n    \"\"\"Never stop.\"\"\"\n\n    def __call__(self, retry_state: \"RetryCallState\") -> bool:\n        return False\n\n\nstop_never = _stop_never()\n\n\nclass stop_when_event_set(stop_base):\n    \"\"\"Stop when the given event is set.\"\"\"\n\n    def __init__(self, event: \"threading.Event\") -> None:\n        self.event = event\n\n    def __call__(self, retry_state: \"RetryCallState\") -> bool:\n        return self.event.is_set()\n\n\nclass stop_after_attempt(stop_base):\n    \"\"\"Stop when the previous attempt >= max_attempt.\"\"\"\n\n    def __init__(self, max_attempt_number: int) -> None:\n        self.max_attempt_number = max_attempt_number\n\n    def __call__(self, retry_state: \"RetryCallState\") -> bool:\n        return retry_state.attempt_number >= self.max_attempt_number\n\n\nclass stop_after_delay(stop_base):\n    \"\"\"Stop when the time from the first attempt >= limit.\"\"\"\n\n    def __init__(self, max_delay: _utils.time_unit_type) -> None:\n        self.max_delay = _utils.to_seconds(max_delay)\n\n    def __call__(self, retry_state: \"RetryCallState\") -> bool:\n        if retry_state.seconds_since_start is None:\n            raise RuntimeError(\"__call__() called but seconds_since_start is not set\")\n        return retry_state.seconds_since_start >= self.max_delay\n"},"hash":"k2ZjsJ5xDs"}