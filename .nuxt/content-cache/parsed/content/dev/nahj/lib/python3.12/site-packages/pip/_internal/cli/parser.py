{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:cli:parser.py","body":"\"\"\"Base option parser setup\"\"\"\n\nimport logging\nimport optparse\nimport shutil\nimport sys\nimport textwrap\nfrom contextlib import suppress\nfrom typing import Any, Dict, Generator, List, Tuple\n\nfrom pip._internal.cli.status_codes import UNKNOWN_ERROR\nfrom pip._internal.configuration import Configuration, ConfigurationError\nfrom pip._internal.utils.misc import redact_auth_from_url, strtobool\n\nlogger = logging.getLogger(__name__)\n\n\nclass PrettyHelpFormatter(optparse.IndentedHelpFormatter):\n    \"\"\"A prettier/less verbose help formatter for optparse.\"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        # help position must be aligned with __init__.parseopts.description\n        kwargs[\"max_help_position\"] = 30\n        kwargs[\"indent_increment\"] = 1\n        kwargs[\"width\"] = shutil.get_terminal_size()[0] - 2\n        super().__init__(*args, **kwargs)\n\n    def format_option_strings(self, option: optparse.Option) -> str:\n        return self._format_option_strings(option)\n\n    def _format_option_strings(\n        self, option: optparse.Option, mvarfmt: str = \" <{}>\", optsep: str = \", \"\n    ) -> str:\n        \"\"\"\n        Return a comma-separated list of option strings and metavars.\n\n        :param option:  tuple of (short opt, long opt), e.g: ('-f', '--format')\n        :param mvarfmt: metavar format string\n        :param optsep:  separator\n        \"\"\"\n        opts = []\n\n        if option._short_opts:\n            opts.append(option._short_opts[0])\n        if option._long_opts:\n            opts.append(option._long_opts[0])\n        if len(opts) > 1:\n            opts.insert(1, optsep)\n\n        if option.takes_value():\n            assert option.dest is not None\n            metavar = option.metavar or option.dest.lower()\n            opts.append(mvarfmt.format(metavar.lower()))\n\n        return \"\".join(opts)\n\n    def format_heading(self, heading: str) -> str:\n        if heading == \"Options\":\n            return \"\"\n        return heading + \":\\n\"\n\n    def format_usage(self, usage: str) -> str:\n        \"\"\"\n        Ensure there is only one newline between usage and the first heading\n        if there is no description.\n        \"\"\"\n        msg = \"\\nUsage: {}\\n\".format(self.indent_lines(textwrap.dedent(usage), \"  \"))\n        return msg\n\n    def format_description(self, description: str) -> str:\n        # leave full control over description to us\n        if description:\n            if hasattr(self.parser, \"main\"):\n                label = \"Commands\"\n            else:\n                label = \"Description\"\n            # some doc strings have initial newlines, some don't\n            description = description.lstrip(\"\\n\")\n            # some doc strings have final newlines and spaces, some don't\n            description = description.rstrip()\n            # dedent, then reindent\n            description = self.indent_lines(textwrap.dedent(description), \"  \")\n            description = f\"{label}:\\n{description}\\n\"\n            return description\n        else:\n            return \"\"\n\n    def format_epilog(self, epilog: str) -> str:\n        # leave full control over epilog to us\n        if epilog:\n            return epilog\n        else:\n            return \"\"\n\n    def indent_lines(self, text: str, indent: str) -> str:\n        new_lines = [indent + line for line in text.split(\"\\n\")]\n        return \"\\n\".join(new_lines)\n\n\nclass UpdatingDefaultsHelpFormatter(PrettyHelpFormatter):\n    \"\"\"Custom help formatter for use in ConfigOptionParser.\n\n    This is updates the defaults before expanding them, allowing\n    them to show up correctly in the help listing.\n\n    Also redact auth from url type options\n    \"\"\"\n\n    def expand_default(self, option: optparse.Option) -> str:\n        default_values = None\n        if self.parser is not None:\n            assert isinstance(self.parser, ConfigOptionParser)\n            self.parser._update_defaults(self.parser.defaults)\n            assert option.dest is not None\n            default_values = self.parser.defaults.get(option.dest)\n        help_text = super().expand_default(option)\n\n        if default_values and option.metavar == \"URL\":\n            if isinstance(default_values, str):\n                default_values = [default_values]\n\n            # If its not a list, we should abort and just return the help text\n            if not isinstance(default_values, list):\n                default_values = []\n\n            for val in default_values:\n                help_text = help_text.replace(val, redact_auth_from_url(val))\n\n        return help_text\n\n\nclass CustomOptionParser(optparse.OptionParser):\n    def insert_option_group(\n        self, idx: int, *args: Any, **kwargs: Any\n    ) -> optparse.OptionGroup:\n        \"\"\"Insert an OptionGroup at a given position.\"\"\"\n        group = self.add_option_group(*args, **kwargs)\n\n        self.option_groups.pop()\n        self.option_groups.insert(idx, group)\n\n        return group\n\n    @property\n    def option_list_all(self) -> List[optparse.Option]:\n        \"\"\"Get a list of all options, including those in option groups.\"\"\"\n        res = self.option_list[:]\n        for i in self.option_groups:\n            res.extend(i.option_list)\n\n        return res\n\n\nclass ConfigOptionParser(CustomOptionParser):\n    \"\"\"Custom option parser which updates its defaults by checking the\n    configuration files and environmental variables\"\"\"\n\n    def __init__(\n        self,\n        *args: Any,\n        name: str,\n        isolated: bool = False,\n        **kwargs: Any,\n    ) -> None:\n        self.name = name\n        self.config = Configuration(isolated)\n\n        assert self.name\n        super().__init__(*args, **kwargs)\n\n    def check_default(self, option: optparse.Option, key: str, val: Any) -> Any:\n        try:\n            return option.check_value(key, val)\n        except optparse.OptionValueError as exc:\n            print(f\"An error occurred during configuration: {exc}\")\n            sys.exit(3)\n\n    def _get_ordered_configuration_items(\n        self,\n    ) -> Generator[Tuple[str, Any], None, None]:\n        # Configuration gives keys in an unordered manner. Order them.\n        override_order = [\"global\", self.name, \":env:\"]\n\n        # Pool the options into different groups\n        section_items: Dict[str, List[Tuple[str, Any]]] = {\n            name: [] for name in override_order\n        }\n        for section_key, val in self.config.items():\n            # ignore empty values\n            if not val:\n                logger.debug(\n                    \"Ignoring configuration key '%s' as it's value is empty.\",\n                    section_key,\n                )\n                continue\n\n            section, key = section_key.split(\".\", 1)\n            if section in override_order:\n                section_items[section].append((key, val))\n\n        # Yield each group in their override order\n        for section in override_order:\n            for key, val in section_items[section]:\n                yield key, val\n\n    def _update_defaults(self, defaults: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Updates the given defaults with values from the config files and\n        the environ. Does a little special handling for certain types of\n        options (lists).\"\"\"\n\n        # Accumulate complex default state.\n        self.values = optparse.Values(self.defaults)\n        late_eval = set()\n        # Then set the options with those values\n        for key, val in self._get_ordered_configuration_items():\n            # '--' because configuration supports only long names\n            option = self.get_option(\"--\" + key)\n\n            # Ignore options not present in this parser. E.g. non-globals put\n            # in [global] by users that want them to apply to all applicable\n            # commands.\n            if option is None:\n                continue\n\n            assert option.dest is not None\n\n            if option.action in (\"store_true\", \"store_false\"):\n                try:\n                    val = strtobool(val)\n                except ValueError:\n                    self.error(\n                        f\"{val} is not a valid value for {key} option, \"\n                        \"please specify a boolean value like yes/no, \"\n                        \"true/false or 1/0 instead.\"\n                    )\n            elif option.action == \"count\":\n                with suppress(ValueError):\n                    val = strtobool(val)\n                with suppress(ValueError):\n                    val = int(val)\n                if not isinstance(val, int) or val < 0:\n                    self.error(\n                        f\"{val} is not a valid value for {key} option, \"\n                        \"please instead specify either a non-negative integer \"\n                        \"or a boolean value like yes/no or false/true \"\n                        \"which is equivalent to 1/0.\"\n                    )\n            elif option.action == \"append\":\n                val = val.split()\n                val = [self.check_default(option, key, v) for v in val]\n            elif option.action == \"callback\":\n                assert option.callback is not None\n                late_eval.add(option.dest)\n                opt_str = option.get_opt_string()\n                val = option.convert_value(opt_str, val)\n                # From take_action\n                args = option.callback_args or ()\n                kwargs = option.callback_kwargs or {}\n                option.callback(option, opt_str, val, self, *args, **kwargs)\n            else:\n                val = self.check_default(option, key, val)\n\n            defaults[option.dest] = val\n\n        for key in late_eval:\n            defaults[key] = getattr(self.values, key)\n        self.values = None\n        return defaults\n\n    def get_default_values(self) -> optparse.Values:\n        \"\"\"Overriding to make updating the defaults after instantiation of\n        the option parser possible, _update_defaults() does the dirty work.\"\"\"\n        if not self.process_default_values:\n            # Old, pre-Optik 1.5 behaviour.\n            return optparse.Values(self.defaults)\n\n        # Load the configuration, or error out in case of an error\n        try:\n            self.config.load()\n        except ConfigurationError as err:\n            self.exit(UNKNOWN_ERROR, str(err))\n\n        defaults = self._update_defaults(self.defaults.copy())  # ours\n        for option in self._get_all_options():\n            assert option.dest is not None\n            default = defaults.get(option.dest)\n            if isinstance(default, str):\n                opt_str = option.get_opt_string()\n                defaults[option.dest] = option.check_value(opt_str, default)\n        return optparse.Values(defaults)\n\n    def error(self, msg: str) -> None:\n        self.print_usage(sys.stderr)\n        self.exit(UNKNOWN_ERROR, f\"{msg}\\n\")\n"},"hash":"ZjtOhvcVxP"}