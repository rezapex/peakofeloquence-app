{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:operations:freeze.py","body":"import collections\nimport logging\nimport os\nfrom typing import Container, Dict, Generator, Iterable, List, NamedTuple, Optional, Set\n\nfrom pip._vendor.packaging.utils import canonicalize_name\nfrom pip._vendor.packaging.version import Version\n\nfrom pip._internal.exceptions import BadCommand, InstallationError\nfrom pip._internal.metadata import BaseDistribution, get_environment\nfrom pip._internal.req.constructors import (\n    install_req_from_editable,\n    install_req_from_line,\n)\nfrom pip._internal.req.req_file import COMMENT_RE\nfrom pip._internal.utils.direct_url_helpers import direct_url_as_pep440_direct_reference\n\nlogger = logging.getLogger(__name__)\n\n\nclass _EditableInfo(NamedTuple):\n    requirement: str\n    comments: List[str]\n\n\ndef freeze(\n    requirement: Optional[List[str]] = None,\n    local_only: bool = False,\n    user_only: bool = False,\n    paths: Optional[List[str]] = None,\n    isolated: bool = False,\n    exclude_editable: bool = False,\n    skip: Container[str] = (),\n) -> Generator[str, None, None]:\n    installations: Dict[str, FrozenRequirement] = {}\n\n    dists = get_environment(paths).iter_installed_distributions(\n        local_only=local_only,\n        skip=(),\n        user_only=user_only,\n    )\n    for dist in dists:\n        req = FrozenRequirement.from_dist(dist)\n        if exclude_editable and req.editable:\n            continue\n        installations[req.canonical_name] = req\n\n    if requirement:\n        # the options that don't get turned into an InstallRequirement\n        # should only be emitted once, even if the same option is in multiple\n        # requirements files, so we need to keep track of what has been emitted\n        # so that we don't emit it again if it's seen again\n        emitted_options: Set[str] = set()\n        # keep track of which files a requirement is in so that we can\n        # give an accurate warning if a requirement appears multiple times.\n        req_files: Dict[str, List[str]] = collections.defaultdict(list)\n        for req_file_path in requirement:\n            with open(req_file_path) as req_file:\n                for line in req_file:\n                    if (\n                        not line.strip()\n                        or line.strip().startswith(\"#\")\n                        or line.startswith(\n                            (\n                                \"-r\",\n                                \"--requirement\",\n                                \"-f\",\n                                \"--find-links\",\n                                \"-i\",\n                                \"--index-url\",\n                                \"--pre\",\n                                \"--trusted-host\",\n                                \"--process-dependency-links\",\n                                \"--extra-index-url\",\n                                \"--use-feature\",\n                            )\n                        )\n                    ):\n                        line = line.rstrip()\n                        if line not in emitted_options:\n                            emitted_options.add(line)\n                            yield line\n                        continue\n\n                    if line.startswith(\"-e\") or line.startswith(\"--editable\"):\n                        if line.startswith(\"-e\"):\n                            line = line[2:].strip()\n                        else:\n                            line = line[len(\"--editable\") :].strip().lstrip(\"=\")\n                        line_req = install_req_from_editable(\n                            line,\n                            isolated=isolated,\n                        )\n                    else:\n                        line_req = install_req_from_line(\n                            COMMENT_RE.sub(\"\", line).strip(),\n                            isolated=isolated,\n                        )\n\n                    if not line_req.name:\n                        logger.info(\n                            \"Skipping line in requirement file [%s] because \"\n                            \"it's not clear what it would install: %s\",\n                            req_file_path,\n                            line.strip(),\n                        )\n                        logger.info(\n                            \"  (add #egg=PackageName to the URL to avoid\"\n                            \" this warning)\"\n                        )\n                    else:\n                        line_req_canonical_name = canonicalize_name(line_req.name)\n                        if line_req_canonical_name not in installations:\n                            # either it's not installed, or it is installed\n                            # but has been processed already\n                            if not req_files[line_req.name]:\n                                logger.warning(\n                                    \"Requirement file [%s] contains %s, but \"\n                                    \"package %r is not installed\",\n                                    req_file_path,\n                                    COMMENT_RE.sub(\"\", line).strip(),\n                                    line_req.name,\n                                )\n                            else:\n                                req_files[line_req.name].append(req_file_path)\n                        else:\n                            yield str(installations[line_req_canonical_name]).rstrip()\n                            del installations[line_req_canonical_name]\n                            req_files[line_req.name].append(req_file_path)\n\n        # Warn about requirements that were included multiple times (in a\n        # single requirements file or in different requirements files).\n        for name, files in req_files.items():\n            if len(files) > 1:\n                logger.warning(\n                    \"Requirement %s included multiple times [%s]\",\n                    name,\n                    \", \".join(sorted(set(files))),\n                )\n\n        yield (\"## The following requirements were added by pip freeze:\")\n    for installation in sorted(installations.values(), key=lambda x: x.name.lower()):\n        if installation.canonical_name not in skip:\n            yield str(installation).rstrip()\n\n\ndef _format_as_name_version(dist: BaseDistribution) -> str:\n    dist_version = dist.version\n    if isinstance(dist_version, Version):\n        return f\"{dist.raw_name}=={dist_version}\"\n    return f\"{dist.raw_name}==={dist_version}\"\n\n\ndef _get_editable_info(dist: BaseDistribution) -> _EditableInfo:\n    \"\"\"\n    Compute and return values (req, comments) for use in\n    FrozenRequirement.from_dist().\n    \"\"\"\n    editable_project_location = dist.editable_project_location\n    assert editable_project_location\n    location = os.path.normcase(os.path.abspath(editable_project_location))\n\n    from pip._internal.vcs import RemoteNotFoundError, RemoteNotValidError, vcs\n\n    vcs_backend = vcs.get_backend_for_dir(location)\n\n    if vcs_backend is None:\n        display = _format_as_name_version(dist)\n        logger.debug(\n            'No VCS found for editable requirement \"%s\" in: %r',\n            display,\n            location,\n        )\n        return _EditableInfo(\n            requirement=location,\n            comments=[f\"# Editable install with no version control ({display})\"],\n        )\n\n    vcs_name = type(vcs_backend).__name__\n\n    try:\n        req = vcs_backend.get_src_requirement(location, dist.raw_name)\n    except RemoteNotFoundError:\n        display = _format_as_name_version(dist)\n        return _EditableInfo(\n            requirement=location,\n            comments=[f\"# Editable {vcs_name} install with no remote ({display})\"],\n        )\n    except RemoteNotValidError as ex:\n        display = _format_as_name_version(dist)\n        return _EditableInfo(\n            requirement=location,\n            comments=[\n                f\"# Editable {vcs_name} install ({display}) with either a deleted \"\n                f\"local remote or invalid URI:\",\n                f\"# '{ex.url}'\",\n            ],\n        )\n    except BadCommand:\n        logger.warning(\n            \"cannot determine version of editable source in %s \"\n            \"(%s command not found in path)\",\n            location,\n            vcs_backend.name,\n        )\n        return _EditableInfo(requirement=location, comments=[])\n    except InstallationError as exc:\n        logger.warning(\"Error when trying to get requirement for VCS system %s\", exc)\n    else:\n        return _EditableInfo(requirement=req, comments=[])\n\n    logger.warning(\"Could not determine repository location of %s\", location)\n\n    return _EditableInfo(\n        requirement=location,\n        comments=[\"## !! Could not determine repository location\"],\n    )\n\n\nclass FrozenRequirement:\n    def __init__(\n        self,\n        name: str,\n        req: str,\n        editable: bool,\n        comments: Iterable[str] = (),\n    ) -> None:\n        self.name = name\n        self.canonical_name = canonicalize_name(name)\n        self.req = req\n        self.editable = editable\n        self.comments = comments\n\n    @classmethod\n    def from_dist(cls, dist: BaseDistribution) -> \"FrozenRequirement\":\n        editable = dist.editable\n        if editable:\n            req, comments = _get_editable_info(dist)\n        else:\n            comments = []\n            direct_url = dist.direct_url\n            if direct_url:\n                # if PEP 610 metadata is present, use it\n                req = direct_url_as_pep440_direct_reference(direct_url, dist.raw_name)\n            else:\n                # name==version requirement\n                req = _format_as_name_version(dist)\n\n        return cls(dist.raw_name, req, editable, comments=comments)\n\n    def __str__(self) -> str:\n        req = self.req\n        if self.editable:\n            req = f\"-e {req}\"\n        return \"\\n\".join(list(self.comments) + [str(req)]) + \"\\n\"\n"},"hash":"LX9yaDdXZs"}