{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:bs4:tests:test_html5lib.py","body":"\"\"\"Tests to ensure that the html5lib tree builder generates good trees.\"\"\"\n\nimport pytest\nimport warnings\n\nfrom bs4 import BeautifulSoup\nfrom bs4.element import SoupStrainer\nfrom . import (\n    HTML5LIB_PRESENT,\n    HTML5TreeBuilderSmokeTest,\n    SoupTest,\n)\n\n@pytest.mark.skipif(\n    not HTML5LIB_PRESENT,\n    reason=\"html5lib seems not to be present, not testing its tree builder.\"\n)\nclass TestHTML5LibBuilder(SoupTest, HTML5TreeBuilderSmokeTest):\n    \"\"\"See ``HTML5TreeBuilderSmokeTest``.\"\"\"\n\n    @property\n    def default_builder(self):\n        from bs4.builder import HTML5TreeBuilder\n        return HTML5TreeBuilder\n\n    def test_soupstrainer(self):\n        # The html5lib tree builder does not support SoupStrainers.\n        strainer = SoupStrainer(\"b\")\n        markup = \"<p>A <b>bold</b> statement.</p>\"\n        with warnings.catch_warnings(record=True) as w:\n            soup = BeautifulSoup(markup, \"html5lib\", parse_only=strainer)\n        assert soup.decode() == self.document_for(markup)\n\n        [warning] = w\n        assert warning.filename == __file__\n        assert \"the html5lib tree builder doesn't support parse_only\" in str(warning.message)\n\n    def test_correctly_nested_tables(self):\n        \"\"\"html5lib inserts <tbody> tags where other parsers don't.\"\"\"\n        markup = ('<table id=\"1\">'\n                  '<tr>'\n                  \"<td>Here's another table:\"\n                  '<table id=\"2\">'\n                  '<tr><td>foo</td></tr>'\n                  '</table></td>')\n\n        self.assert_soup(\n            markup,\n            '<table id=\"1\"><tbody><tr><td>Here\\'s another table:'\n            '<table id=\"2\"><tbody><tr><td>foo</td></tr></tbody></table>'\n            '</td></tr></tbody></table>')\n\n        self.assert_soup(\n            \"<table><thead><tr><td>Foo</td></tr></thead>\"\n            \"<tbody><tr><td>Bar</td></tr></tbody>\"\n            \"<tfoot><tr><td>Baz</td></tr></tfoot></table>\")\n\n    def test_xml_declaration_followed_by_doctype(self):\n        markup = '''<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE html>\n<html>\n  <head>\n  </head>\n  <body>\n   <p>foo</p>\n  </body>\n</html>'''\n        soup = self.soup(markup)\n        # Verify that we can reach the <p> tag; this means the tree is connected.\n        assert b\"<p>foo</p>\" == soup.p.encode()\n\n    def test_reparented_markup(self):\n        markup = '<p><em>foo</p>\\n<p>bar<a></a></em></p>'\n        soup = self.soup(markup)\n        assert \"<body><p><em>foo</em></p><em>\\n</em><p><em>bar<a></a></em></p></body>\" == soup.body.decode()\n        assert 2 == len(soup.find_all('p'))\n\n\n    def test_reparented_markup_ends_with_whitespace(self):\n        markup = '<p><em>foo</p>\\n<p>bar<a></a></em></p>\\n'\n        soup = self.soup(markup)\n        assert \"<body><p><em>foo</em></p><em>\\n</em><p><em>bar<a></a></em></p>\\n</body>\" == soup.body.decode()\n        assert 2 == len(soup.find_all('p'))\n\n    def test_reparented_markup_containing_identical_whitespace_nodes(self):\n        \"\"\"Verify that we keep the two whitespace nodes in this\n        document distinct when reparenting the adjacent <tbody> tags.\n        \"\"\"\n        markup = '<table> <tbody><tbody><ims></tbody> </table>'\n        soup = self.soup(markup)\n        space1, space2 = soup.find_all(string=' ')\n        tbody1, tbody2 = soup.find_all('tbody')\n        assert space1.next_element is tbody1\n        assert tbody2.next_element is space2\n\n    def test_reparented_markup_containing_children(self):\n        markup = '<div><a>aftermath<p><noscript>target</noscript>aftermath</a></p></div>'\n        soup = self.soup(markup)\n        noscript = soup.noscript\n        assert \"target\" == noscript.next_element\n        target = soup.find(string='target')\n\n        # The 'aftermath' string was duplicated; we want the second one.\n        final_aftermath = soup.find_all(string='aftermath')[-1]\n\n        # The <noscript> tag was moved beneath a copy of the <a> tag,\n        # but the 'target' string within is still connected to the\n        # (second) 'aftermath' string.\n        assert final_aftermath == target.next_element\n        assert target == final_aftermath.previous_element\n        \n    def test_processing_instruction(self):\n        \"\"\"Processing instructions become comments.\"\"\"\n        markup = b\"\"\"<?PITarget PIContent?>\"\"\"\n        soup = self.soup(markup)\n        assert str(soup).startswith(\"<!--?PITarget PIContent?-->\")\n\n    def test_cloned_multivalue_node(self):\n        markup = b\"\"\"<a class=\"my_class\"><p></a>\"\"\"\n        soup = self.soup(markup)\n        a1, a2 = soup.find_all('a')\n        assert a1 == a2\n        assert a1 is not a2\n\n    def test_foster_parenting(self):\n        markup = b\"\"\"<table><td></tbody>A\"\"\"\n        soup = self.soup(markup)\n        assert \"<body>A<table><tbody><tr><td></td></tr></tbody></table></body>\" == soup.body.decode()\n\n    def test_extraction(self):\n        \"\"\"\n        Test that extraction does not destroy the tree.\n\n        https://bugs.launchpad.net/beautifulsoup/+bug/1782928\n        \"\"\"\n\n        markup = \"\"\"\n<html><head></head>\n<style>\n</style><script></script><body><p>hello</p></body></html>\n\"\"\"\n        soup = self.soup(markup)\n        [s.extract() for s in soup('script')]\n        [s.extract() for s in soup('style')]\n\n        assert len(soup.find_all(\"p\")) == 1\n\n    def test_empty_comment(self):\n        \"\"\"\n        Test that empty comment does not break structure.\n\n        https://bugs.launchpad.net/beautifulsoup/+bug/1806598\n        \"\"\"\n\n        markup = \"\"\"\n<html>\n<body>\n<form>\n<!----><input type=\"text\">\n</form>\n</body>\n</html>\n\"\"\"\n        soup = self.soup(markup)\n        inputs = []\n        for form in soup.find_all('form'):\n            inputs.extend(form.find_all('input'))\n        assert len(inputs) == 1\n\n    def test_tracking_line_numbers(self):\n        # The html.parser TreeBuilder keeps track of line number and\n        # position of each element.\n        markup = \"\\n   <p>\\n\\n<sourceline>\\n<b>text</b></sourceline><sourcepos></p>\"\n        soup = self.soup(markup)\n        assert 2 == soup.p.sourceline\n        assert 5 == soup.p.sourcepos\n        assert \"sourceline\" == soup.p.find('sourceline').name\n\n        # You can deactivate this behavior.\n        soup = self.soup(markup, store_line_numbers=False)\n        assert \"sourceline\" == soup.p.sourceline.name\n        assert \"sourcepos\" == soup.p.sourcepos.name\n\n    def test_special_string_containers(self):\n        # The html5lib tree builder doesn't support this standard feature,\n        # because there's no way of knowing, when a string is created,\n        # where in the tree it will eventually end up.\n        pass\n\n    def test_html5_attributes(self):\n        # The html5lib TreeBuilder can convert any entity named in\n        # the HTML5 spec to a sequence of Unicode characters, and\n        # convert those Unicode characters to a (potentially\n        # different) named entity on the way out.\n        #\n        # This is a copy of the same test from\n        # HTMLParserTreeBuilderSmokeTest.  It's not in the superclass\n        # because the lxml HTML TreeBuilder _doesn't_ work this way.\n        for input_element, output_unicode, output_element in (\n                (\"&RightArrowLeftArrow;\", '\\u21c4', b'&rlarr;'),\n                ('&models;', '\\u22a7', b'&models;'),\n                ('&Nfr;', '\\U0001d511', b'&Nfr;'),\n                ('&ngeqq;', '\\u2267\\u0338', b'&ngeqq;'),\n                ('&not;', '\\xac', b'&not;'),\n                ('&Not;', '\\u2aec', b'&Not;'),\n                ('&quot;', '\"', b'\"'),\n                ('&there4;', '\\u2234', b'&there4;'),\n                ('&Therefore;', '\\u2234', b'&there4;'),\n                ('&therefore;', '\\u2234', b'&there4;'),\n                (\"&fjlig;\", 'fj', b'fj'),                \n                (\"&sqcup;\", '\\u2294', b'&sqcup;'),\n                (\"&sqcups;\", '\\u2294\\ufe00', b'&sqcups;'),\n                (\"&apos;\", \"'\", b\"'\"),\n                (\"&verbar;\", \"|\", b\"|\"),\n        ):\n            markup = '<div>%s</div>' % input_element\n            div = self.soup(markup).div\n            without_element = div.encode()\n            expect = b\"<div>%s</div>\" % output_unicode.encode(\"utf8\")\n            assert without_element == expect\n\n            with_element = div.encode(formatter=\"html\")\n            expect = b\"<div>%s</div>\" % output_element\n            assert with_element == expect\n"},"hash":"MTpjIVY7xT"}