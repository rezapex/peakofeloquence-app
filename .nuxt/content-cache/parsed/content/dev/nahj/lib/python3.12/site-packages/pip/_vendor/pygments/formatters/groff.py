{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:pygments:formatters:groff.py","body":"\"\"\"\n    pygments.formatters.groff\n    ~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Formatter for groff output.\n\n    :copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.\n    :license: BSD, see LICENSE for details.\n\"\"\"\n\nimport math\nfrom pip._vendor.pygments.formatter import Formatter\nfrom pip._vendor.pygments.util import get_bool_opt, get_int_opt\n\n__all__ = ['GroffFormatter']\n\n\nclass GroffFormatter(Formatter):\n    \"\"\"\n    Format tokens with groff escapes to change their color and font style.\n\n    .. versionadded:: 2.11\n\n    Additional options accepted:\n\n    `style`\n        The style to use, can be a string or a Style subclass (default:\n        ``'default'``).\n\n    `monospaced`\n        If set to true, monospace font will be used (default: ``true``).\n\n    `linenos`\n        If set to true, print the line numbers (default: ``false``).\n\n    `wrap`\n        Wrap lines to the specified number of characters. Disabled if set to 0\n        (default: ``0``).\n    \"\"\"\n\n    name = 'groff'\n    aliases = ['groff','troff','roff']\n    filenames = []\n\n    def __init__(self, **options):\n        Formatter.__init__(self, **options)\n\n        self.monospaced = get_bool_opt(options, 'monospaced', True)\n        self.linenos = get_bool_opt(options, 'linenos', False)\n        self._lineno = 0\n        self.wrap = get_int_opt(options, 'wrap', 0)\n        self._linelen = 0\n\n        self.styles = {}\n        self._make_styles()\n\n\n    def _make_styles(self):\n        regular = '\\\\f[CR]' if self.monospaced else '\\\\f[R]'\n        bold = '\\\\f[CB]' if self.monospaced else '\\\\f[B]'\n        italic = '\\\\f[CI]' if self.monospaced else '\\\\f[I]'\n\n        for ttype, ndef in self.style:\n            start = end = ''\n            if ndef['color']:\n                start += '\\\\m[%s]' % ndef['color']\n                end = '\\\\m[]' + end\n            if ndef['bold']:\n                start += bold\n                end = regular + end\n            if ndef['italic']:\n                start += italic\n                end = regular + end\n            if ndef['bgcolor']:\n                start += '\\\\M[%s]' % ndef['bgcolor']\n                end = '\\\\M[]' + end\n\n            self.styles[ttype] = start, end\n\n\n    def _define_colors(self, outfile):\n        colors = set()\n        for _, ndef in self.style:\n            if ndef['color'] is not None:\n                colors.add(ndef['color'])\n\n        for color in sorted(colors):\n            outfile.write('.defcolor ' + color + ' rgb #' + color + '\\n')\n\n\n    def _write_lineno(self, outfile):\n        self._lineno += 1\n        outfile.write(\"%s% 4d \" % (self._lineno != 1 and '\\n' or '', self._lineno))\n\n\n    def _wrap_line(self, line):\n        length = len(line.rstrip('\\n'))\n        space = '     ' if self.linenos else ''\n        newline = ''\n\n        if length > self.wrap:\n            for i in range(0, math.floor(length / self.wrap)):\n                chunk = line[i*self.wrap:i*self.wrap+self.wrap]\n                newline += (chunk + '\\n' + space)\n            remainder = length % self.wrap\n            if remainder > 0:\n                newline += line[-remainder-1:]\n                self._linelen = remainder\n        elif self._linelen + length > self.wrap:\n            newline = ('\\n' + space) + line\n            self._linelen = length\n        else:\n            newline = line\n            self._linelen += length\n\n        return newline\n\n\n    def _escape_chars(self, text):\n        text = text.replace('\\\\', '\\\\[u005C]'). \\\n                    replace('.', '\\\\[char46]'). \\\n                    replace('\\'', '\\\\[u0027]'). \\\n                    replace('`', '\\\\[u0060]'). \\\n                    replace('~', '\\\\[u007E]')\n        copy = text\n\n        for char in copy:\n            if len(char) != len(char.encode()):\n                uni = char.encode('unicode_escape') \\\n                    .decode()[1:] \\\n                    .replace('x', 'u00') \\\n                    .upper()\n                text = text.replace(char, '\\\\[u' + uni[1:] + ']')\n\n        return text\n\n\n    def format_unencoded(self, tokensource, outfile):\n        self._define_colors(outfile)\n\n        outfile.write('.nf\\n\\\\f[CR]\\n')\n\n        if self.linenos:\n            self._write_lineno(outfile)\n\n        for ttype, value in tokensource:\n            while ttype not in self.styles:\n                ttype = ttype.parent\n            start, end = self.styles[ttype]\n\n            for line in value.splitlines(True):\n                if self.wrap > 0:\n                    line = self._wrap_line(line)\n\n                if start and end:\n                    text = self._escape_chars(line.rstrip('\\n'))\n                    if text != '':\n                        outfile.write(''.join((start, text, end)))\n                else:\n                    outfile.write(self._escape_chars(line.rstrip('\\n')))\n\n                if line.endswith('\\n'):\n                    if self.linenos:\n                        self._write_lineno(outfile)\n                        self._linelen = 0\n                    else:\n                        outfile.write('\\n')\n                        self._linelen = 0\n\n        outfile.write('\\n.fi')\n"},"hash":"pt7B9Z2Xa1"}