{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:bs4:tests:test_htmlparser.py","body":"\"\"\"Tests to ensure that the html.parser tree builder generates good\ntrees.\"\"\"\n\nfrom pdb import set_trace\nimport pickle\nimport pytest\nimport warnings\nfrom bs4.builder import (\n    HTMLParserTreeBuilder,\n    ParserRejectedMarkup,\n    XMLParsedAsHTMLWarning,\n)\nfrom bs4.builder._htmlparser import BeautifulSoupHTMLParser\nfrom . import SoupTest, HTMLTreeBuilderSmokeTest\n\nclass TestHTMLParserTreeBuilder(SoupTest, HTMLTreeBuilderSmokeTest):\n\n    default_builder = HTMLParserTreeBuilder\n\n    def test_rejected_input(self):\n        # Python's html.parser will occasionally reject markup,\n        # especially when there is a problem with the initial DOCTYPE\n        # declaration. Different versions of Python sound the alarm in\n        # different ways, but Beautiful Soup consistently raises\n        # errors as ParserRejectedMarkup exceptions.\n        bad_markup = [\n            # https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=28873\n            # https://github.com/guidovranken/python-library-fuzzers/blob/master/corp-html/519e5b4269a01185a0d5e76295251921da2f0700\n            # https://github.com/python/cpython/issues/81928\n            b'\\n<![\\xff\\xfe\\xfe\\xcd\\x00',\n\n            #https://github.com/guidovranken/python-library-fuzzers/blob/master/corp-html/de32aa55785be29bbc72a1a8e06b00611fb3d9f8\n            # https://github.com/python/cpython/issues/78661\n            #\n            b'<![n\\x00',\n            b\"<![UNKNOWN[]]>\",\n        ]\n        for markup in bad_markup:\n            with pytest.raises(ParserRejectedMarkup):\n                soup = self.soup(markup)\n    \n    def test_namespaced_system_doctype(self):\n        # html.parser can't handle namespaced doctypes, so skip this one.\n        pass\n\n    def test_namespaced_public_doctype(self):\n        # html.parser can't handle namespaced doctypes, so skip this one.\n        pass\n\n    def test_builder_is_pickled(self):\n        \"\"\"Unlike most tree builders, HTMLParserTreeBuilder and will\n        be restored after pickling.\n        \"\"\"\n        tree = self.soup(\"<a><b>foo</a>\")\n        dumped = pickle.dumps(tree, 2)\n        loaded = pickle.loads(dumped)\n        assert isinstance(loaded.builder, type(tree.builder))\n\n    def test_redundant_empty_element_closing_tags(self):\n        self.assert_soup('<br></br><br></br><br></br>', \"<br/><br/><br/>\")\n        self.assert_soup('</br></br></br>', \"\")\n\n    def test_empty_element(self):\n        # This verifies that any buffered data present when the parser\n        # finishes working is handled.\n        self.assert_soup(\"foo &# bar\", \"foo &amp;# bar\")\n\n    def test_tracking_line_numbers(self):\n        # The html.parser TreeBuilder keeps track of line number and\n        # position of each element.\n        markup = \"\\n   <p>\\n\\n<sourceline>\\n<b>text</b></sourceline><sourcepos></p>\"\n        soup = self.soup(markup)\n        assert 2 == soup.p.sourceline\n        assert 3 == soup.p.sourcepos\n        assert \"sourceline\" == soup.p.find('sourceline').name\n\n        # You can deactivate this behavior.\n        soup = self.soup(markup, store_line_numbers=False)\n        assert \"sourceline\" == soup.p.sourceline.name\n        assert \"sourcepos\" == soup.p.sourcepos.name\n\n    def test_on_duplicate_attribute(self):\n        # The html.parser tree builder has a variety of ways of\n        # handling a tag that contains the same attribute multiple times.\n\n        markup = '<a class=\"cls\" href=\"url1\" href=\"url2\" href=\"url3\" id=\"id\">'\n\n        # If you don't provide any particular value for\n        # on_duplicate_attribute, later values replace earlier values.\n        soup = self.soup(markup)\n        assert \"url3\" == soup.a['href']\n        assert [\"cls\"] == soup.a['class']\n        assert \"id\" == soup.a['id']\n        \n        # You can also get this behavior explicitly.\n        def assert_attribute(on_duplicate_attribute, expected):\n            soup = self.soup(\n                markup, on_duplicate_attribute=on_duplicate_attribute\n            )\n            assert expected == soup.a['href']\n\n            # Verify that non-duplicate attributes are treated normally.\n            assert [\"cls\"] == soup.a['class']\n            assert \"id\" == soup.a['id']\n        assert_attribute(None, \"url3\")\n        assert_attribute(BeautifulSoupHTMLParser.REPLACE, \"url3\")\n\n        # You can ignore subsequent values in favor of the first.\n        assert_attribute(BeautifulSoupHTMLParser.IGNORE, \"url1\")\n\n        # And you can pass in a callable that does whatever you want.\n        def accumulate(attrs, key, value):\n            if not isinstance(attrs[key], list):\n                attrs[key] = [attrs[key]]\n            attrs[key].append(value)\n        assert_attribute(accumulate, [\"url1\", \"url2\", \"url3\"])            \n\n    def test_html5_attributes(self):\n        # The html.parser TreeBuilder can convert any entity named in\n        # the HTML5 spec to a sequence of Unicode characters, and\n        # convert those Unicode characters to a (potentially\n        # different) named entity on the way out.\n        for input_element, output_unicode, output_element in (\n                (\"&RightArrowLeftArrow;\", '\\u21c4', b'&rlarr;'),\n                ('&models;', '\\u22a7', b'&models;'),\n                ('&Nfr;', '\\U0001d511', b'&Nfr;'),\n                ('&ngeqq;', '\\u2267\\u0338', b'&ngeqq;'),\n                ('&not;', '\\xac', b'&not;'),\n                ('&Not;', '\\u2aec', b'&Not;'),\n                ('&quot;', '\"', b'\"'),\n                ('&there4;', '\\u2234', b'&there4;'),\n                ('&Therefore;', '\\u2234', b'&there4;'),\n                ('&therefore;', '\\u2234', b'&there4;'),\n                (\"&fjlig;\", 'fj', b'fj'),                \n                (\"&sqcup;\", '\\u2294', b'&sqcup;'),\n                (\"&sqcups;\", '\\u2294\\ufe00', b'&sqcups;'),\n                (\"&apos;\", \"'\", b\"'\"),\n                (\"&verbar;\", \"|\", b\"|\"),\n        ):\n            markup = '<div>%s</div>' % input_element\n            div = self.soup(markup).div\n            without_element = div.encode()\n            expect = b\"<div>%s</div>\" % output_unicode.encode(\"utf8\")\n            assert without_element == expect\n\n            with_element = div.encode(formatter=\"html\")\n            expect = b\"<div>%s</div>\" % output_element\n            assert with_element == expect\n"},"hash":"skMxTLQB34"}