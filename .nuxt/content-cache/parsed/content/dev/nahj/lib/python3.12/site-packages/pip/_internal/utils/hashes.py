{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:utils:hashes.py","body":"import hashlib\nfrom typing import TYPE_CHECKING, BinaryIO, Dict, Iterable, List, Optional\n\nfrom pip._internal.exceptions import HashMismatch, HashMissing, InstallationError\nfrom pip._internal.utils.misc import read_chunks\n\nif TYPE_CHECKING:\n    from hashlib import _Hash\n\n    # NoReturn introduced in 3.6.2; imported only for type checking to maintain\n    # pip compatibility with older patch versions of Python 3.6\n    from typing import NoReturn\n\n\n# The recommended hash algo of the moment. Change this whenever the state of\n# the art changes; it won't hurt backward compatibility.\nFAVORITE_HASH = \"sha256\"\n\n\n# Names of hashlib algorithms allowed by the --hash option and ``pip hash``\n# Currently, those are the ones at least as collision-resistant as sha256.\nSTRONG_HASHES = [\"sha256\", \"sha384\", \"sha512\"]\n\n\nclass Hashes:\n    \"\"\"A wrapper that builds multiple hashes at once and checks them against\n    known-good values\n\n    \"\"\"\n\n    def __init__(self, hashes: Optional[Dict[str, List[str]]] = None) -> None:\n        \"\"\"\n        :param hashes: A dict of algorithm names pointing to lists of allowed\n            hex digests\n        \"\"\"\n        allowed = {}\n        if hashes is not None:\n            for alg, keys in hashes.items():\n                # Make sure values are always sorted (to ease equality checks)\n                allowed[alg] = sorted(keys)\n        self._allowed = allowed\n\n    def __and__(self, other: \"Hashes\") -> \"Hashes\":\n        if not isinstance(other, Hashes):\n            return NotImplemented\n\n        # If either of the Hashes object is entirely empty (i.e. no hash\n        # specified at all), all hashes from the other object are allowed.\n        if not other:\n            return self\n        if not self:\n            return other\n\n        # Otherwise only hashes that present in both objects are allowed.\n        new = {}\n        for alg, values in other._allowed.items():\n            if alg not in self._allowed:\n                continue\n            new[alg] = [v for v in values if v in self._allowed[alg]]\n        return Hashes(new)\n\n    @property\n    def digest_count(self) -> int:\n        return sum(len(digests) for digests in self._allowed.values())\n\n    def is_hash_allowed(self, hash_name: str, hex_digest: str) -> bool:\n        \"\"\"Return whether the given hex digest is allowed.\"\"\"\n        return hex_digest in self._allowed.get(hash_name, [])\n\n    def check_against_chunks(self, chunks: Iterable[bytes]) -> None:\n        \"\"\"Check good hashes against ones built from iterable of chunks of\n        data.\n\n        Raise HashMismatch if none match.\n\n        \"\"\"\n        gots = {}\n        for hash_name in self._allowed.keys():\n            try:\n                gots[hash_name] = hashlib.new(hash_name)\n            except (ValueError, TypeError):\n                raise InstallationError(f\"Unknown hash name: {hash_name}\")\n\n        for chunk in chunks:\n            for hash in gots.values():\n                hash.update(chunk)\n\n        for hash_name, got in gots.items():\n            if got.hexdigest() in self._allowed[hash_name]:\n                return\n        self._raise(gots)\n\n    def _raise(self, gots: Dict[str, \"_Hash\"]) -> \"NoReturn\":\n        raise HashMismatch(self._allowed, gots)\n\n    def check_against_file(self, file: BinaryIO) -> None:\n        \"\"\"Check good hashes against a file-like object\n\n        Raise HashMismatch if none match.\n\n        \"\"\"\n        return self.check_against_chunks(read_chunks(file))\n\n    def check_against_path(self, path: str) -> None:\n        with open(path, \"rb\") as file:\n            return self.check_against_file(file)\n\n    def has_one_of(self, hashes: Dict[str, str]) -> bool:\n        \"\"\"Return whether any of the given hashes are allowed.\"\"\"\n        for hash_name, hex_digest in hashes.items():\n            if self.is_hash_allowed(hash_name, hex_digest):\n                return True\n        return False\n\n    def __bool__(self) -> bool:\n        \"\"\"Return whether I know any known-good hashes.\"\"\"\n        return bool(self._allowed)\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Hashes):\n            return NotImplemented\n        return self._allowed == other._allowed\n\n    def __hash__(self) -> int:\n        return hash(\n            \",\".join(\n                sorted(\n                    \":\".join((alg, digest))\n                    for alg, digest_list in self._allowed.items()\n                    for digest in digest_list\n                )\n            )\n        )\n\n\nclass MissingHashes(Hashes):\n    \"\"\"A workalike for Hashes used when we're missing a hash for a requirement\n\n    It computes the actual hash of the requirement and raises a HashMissing\n    exception showing it to the user.\n\n    \"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Don't offer the ``hashes`` kwarg.\"\"\"\n        # Pass our favorite hash in to generate a \"gotten hash\". With the\n        # empty list, it will never match, so an error will always raise.\n        super().__init__(hashes={FAVORITE_HASH: []})\n\n    def _raise(self, gots: Dict[str, \"_Hash\"]) -> \"NoReturn\":\n        raise HashMissing(gots[FAVORITE_HASH].hexdigest())\n"},"hash":"lNtQjw629k"}