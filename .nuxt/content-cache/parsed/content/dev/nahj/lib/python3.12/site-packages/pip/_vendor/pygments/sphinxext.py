{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:pygments:sphinxext.py","body":"\"\"\"\n    pygments.sphinxext\n    ~~~~~~~~~~~~~~~~~~\n\n    Sphinx extension to generate automatic documentation of lexers,\n    formatters and filters.\n\n    :copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.\n    :license: BSD, see LICENSE for details.\n\"\"\"\n\nimport sys\n\nfrom docutils import nodes\nfrom docutils.statemachine import ViewList\nfrom docutils.parsers.rst import Directive\nfrom sphinx.util.nodes import nested_parse_with_titles\n\n\nMODULEDOC = '''\n.. module:: %s\n\n%s\n%s\n'''\n\nLEXERDOC = '''\n.. class:: %s\n\n    :Short names: %s\n    :Filenames:   %s\n    :MIME types:  %s\n\n    %s\n\n'''\n\nFMTERDOC = '''\n.. class:: %s\n\n    :Short names: %s\n    :Filenames: %s\n\n    %s\n\n'''\n\nFILTERDOC = '''\n.. class:: %s\n\n    :Name: %s\n\n    %s\n\n'''\n\n\nclass PygmentsDoc(Directive):\n    \"\"\"\n    A directive to collect all lexers/formatters/filters and generate\n    autoclass directives for them.\n    \"\"\"\n    has_content = False\n    required_arguments = 1\n    optional_arguments = 0\n    final_argument_whitespace = False\n    option_spec = {}\n\n    def run(self):\n        self.filenames = set()\n        if self.arguments[0] == 'lexers':\n            out = self.document_lexers()\n        elif self.arguments[0] == 'formatters':\n            out = self.document_formatters()\n        elif self.arguments[0] == 'filters':\n            out = self.document_filters()\n        elif self.arguments[0] == 'lexers_overview':\n            out = self.document_lexers_overview()\n        else:\n            raise Exception('invalid argument for \"pygmentsdoc\" directive')\n        node = nodes.compound()\n        vl = ViewList(out.split('\\n'), source='')\n        nested_parse_with_titles(self.state, vl, node)\n        for fn in self.filenames:\n            self.state.document.settings.record_dependencies.add(fn)\n        return node.children\n\n    def document_lexers_overview(self):\n        \"\"\"Generate a tabular overview of all lexers.\n\n        The columns are the lexer name, the extensions handled by this lexer\n        (or \"None\"), the aliases and a link to the lexer class.\"\"\"\n        from pip._vendor.pygments.lexers._mapping import LEXERS\n        from pip._vendor.pygments.lexers import find_lexer_class\n        out = []\n\n        table = []\n\n        def format_link(name, url):\n            if url:\n                return f'`{name} <{url}>`_'\n            return name\n\n        for classname, data in sorted(LEXERS.items(), key=lambda x: x[1][1].lower()):\n            lexer_cls = find_lexer_class(data[1])\n            extensions = lexer_cls.filenames + lexer_cls.alias_filenames\n\n            table.append({\n                'name': format_link(data[1], lexer_cls.url),\n                'extensions': ', '.join(extensions).replace('*', '\\\\*').replace('_', '\\\\') or 'None',\n                'aliases': ', '.join(data[2]),\n                'class': f'{data[0]}.{classname}'\n            })\n\n        column_names = ['name', 'extensions', 'aliases', 'class']\n        column_lengths = [max([len(row[column]) for row in table if row[column]])\n                          for column in column_names]\n\n        def write_row(*columns):\n            \"\"\"Format a table row\"\"\"\n            out = []\n            for l, c in zip(column_lengths, columns):\n                if c:\n                    out.append(c.ljust(l))\n                else:\n                    out.append(' '*l)\n\n            return ' '.join(out)\n\n        def write_seperator():\n            \"\"\"Write a table separator row\"\"\"\n            sep = ['='*c for c in column_lengths]\n            return write_row(*sep)\n\n        out.append(write_seperator())\n        out.append(write_row('Name', 'Extension(s)', 'Short name(s)', 'Lexer class'))\n        out.append(write_seperator())\n        for row in table:\n            out.append(write_row(\n                row['name'],\n                row['extensions'],\n                row['aliases'],\n                f':class:`~{row[\"class\"]}`'))\n        out.append(write_seperator())\n\n        return '\\n'.join(out)\n\n    def document_lexers(self):\n        from pip._vendor.pygments.lexers._mapping import LEXERS\n        out = []\n        modules = {}\n        moduledocstrings = {}\n        for classname, data in sorted(LEXERS.items(), key=lambda x: x[0]):\n            module = data[0]\n            mod = __import__(module, None, None, [classname])\n            self.filenames.add(mod.__file__)\n            cls = getattr(mod, classname)\n            if not cls.__doc__:\n                print(\"Warning: %s does not have a docstring.\" % classname)\n            docstring = cls.__doc__\n            if isinstance(docstring, bytes):\n                docstring = docstring.decode('utf8')\n            modules.setdefault(module, []).append((\n                classname,\n                ', '.join(data[2]) or 'None',\n                ', '.join(data[3]).replace('*', '\\\\*').replace('_', '\\\\') or 'None',\n                ', '.join(data[4]) or 'None',\n                docstring))\n            if module not in moduledocstrings:\n                moddoc = mod.__doc__\n                if isinstance(moddoc, bytes):\n                    moddoc = moddoc.decode('utf8')\n                moduledocstrings[module] = moddoc\n\n        for module, lexers in sorted(modules.items(), key=lambda x: x[0]):\n            if moduledocstrings[module] is None:\n                raise Exception(\"Missing docstring for %s\" % (module,))\n            heading = moduledocstrings[module].splitlines()[4].strip().rstrip('.')\n            out.append(MODULEDOC % (module, heading, '-'*len(heading)))\n            for data in lexers:\n                out.append(LEXERDOC % data)\n\n        return ''.join(out)\n\n    def document_formatters(self):\n        from pip._vendor.pygments.formatters import FORMATTERS\n\n        out = []\n        for classname, data in sorted(FORMATTERS.items(), key=lambda x: x[0]):\n            module = data[0]\n            mod = __import__(module, None, None, [classname])\n            self.filenames.add(mod.__file__)\n            cls = getattr(mod, classname)\n            docstring = cls.__doc__\n            if isinstance(docstring, bytes):\n                docstring = docstring.decode('utf8')\n            heading = cls.__name__\n            out.append(FMTERDOC % (heading, ', '.join(data[2]) or 'None',\n                                   ', '.join(data[3]).replace('*', '\\\\*') or 'None',\n                                   docstring))\n        return ''.join(out)\n\n    def document_filters(self):\n        from pip._vendor.pygments.filters import FILTERS\n\n        out = []\n        for name, cls in FILTERS.items():\n            self.filenames.add(sys.modules[cls.__module__].__file__)\n            docstring = cls.__doc__\n            if isinstance(docstring, bytes):\n                docstring = docstring.decode('utf8')\n            out.append(FILTERDOC % (cls.__name__, name, docstring))\n        return ''.join(out)\n\n\ndef setup(app):\n    app.add_directive('pygmentsdoc', PygmentsDoc)\n"},"hash":"DEgwbqDmpq"}