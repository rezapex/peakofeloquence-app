{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:network:download.py","body":"\"\"\"Download files with progress indicators.\n\"\"\"\nimport email.message\nimport logging\nimport mimetypes\nimport os\nfrom typing import Iterable, Optional, Tuple\n\nfrom pip._vendor.requests.models import CONTENT_CHUNK_SIZE, Response\n\nfrom pip._internal.cli.progress_bars import get_download_progress_renderer\nfrom pip._internal.exceptions import NetworkConnectionError\nfrom pip._internal.models.index import PyPI\nfrom pip._internal.models.link import Link\nfrom pip._internal.network.cache import is_from_cache\nfrom pip._internal.network.session import PipSession\nfrom pip._internal.network.utils import HEADERS, raise_for_status, response_chunks\nfrom pip._internal.utils.misc import format_size, redact_auth_from_url, splitext\n\nlogger = logging.getLogger(__name__)\n\n\ndef _get_http_response_size(resp: Response) -> Optional[int]:\n    try:\n        return int(resp.headers[\"content-length\"])\n    except (ValueError, KeyError, TypeError):\n        return None\n\n\ndef _prepare_download(\n    resp: Response,\n    link: Link,\n    progress_bar: str,\n) -> Iterable[bytes]:\n    total_length = _get_http_response_size(resp)\n\n    if link.netloc == PyPI.file_storage_domain:\n        url = link.show_url\n    else:\n        url = link.url_without_fragment\n\n    logged_url = redact_auth_from_url(url)\n\n    if total_length:\n        logged_url = f\"{logged_url} ({format_size(total_length)})\"\n\n    if is_from_cache(resp):\n        logger.info(\"Using cached %s\", logged_url)\n    else:\n        logger.info(\"Downloading %s\", logged_url)\n\n    if logger.getEffectiveLevel() > logging.INFO:\n        show_progress = False\n    elif is_from_cache(resp):\n        show_progress = False\n    elif not total_length:\n        show_progress = True\n    elif total_length > (40 * 1000):\n        show_progress = True\n    else:\n        show_progress = False\n\n    chunks = response_chunks(resp, CONTENT_CHUNK_SIZE)\n\n    if not show_progress:\n        return chunks\n\n    renderer = get_download_progress_renderer(bar_type=progress_bar, size=total_length)\n    return renderer(chunks)\n\n\ndef sanitize_content_filename(filename: str) -> str:\n    \"\"\"\n    Sanitize the \"filename\" value from a Content-Disposition header.\n    \"\"\"\n    return os.path.basename(filename)\n\n\ndef parse_content_disposition(content_disposition: str, default_filename: str) -> str:\n    \"\"\"\n    Parse the \"filename\" value from a Content-Disposition header, and\n    return the default filename if the result is empty.\n    \"\"\"\n    m = email.message.Message()\n    m[\"content-type\"] = content_disposition\n    filename = m.get_param(\"filename\")\n    if filename:\n        # We need to sanitize the filename to prevent directory traversal\n        # in case the filename contains \"..\" path parts.\n        filename = sanitize_content_filename(str(filename))\n    return filename or default_filename\n\n\ndef _get_http_response_filename(resp: Response, link: Link) -> str:\n    \"\"\"Get an ideal filename from the given HTTP response, falling back to\n    the link filename if not provided.\n    \"\"\"\n    filename = link.filename  # fallback\n    # Have a look at the Content-Disposition header for a better guess\n    content_disposition = resp.headers.get(\"content-disposition\")\n    if content_disposition:\n        filename = parse_content_disposition(content_disposition, filename)\n    ext: Optional[str] = splitext(filename)[1]\n    if not ext:\n        ext = mimetypes.guess_extension(resp.headers.get(\"content-type\", \"\"))\n        if ext:\n            filename += ext\n    if not ext and link.url != resp.url:\n        ext = os.path.splitext(resp.url)[1]\n        if ext:\n            filename += ext\n    return filename\n\n\ndef _http_get_download(session: PipSession, link: Link) -> Response:\n    target_url = link.url.split(\"#\", 1)[0]\n    resp = session.get(target_url, headers=HEADERS, stream=True)\n    raise_for_status(resp)\n    return resp\n\n\nclass Downloader:\n    def __init__(\n        self,\n        session: PipSession,\n        progress_bar: str,\n    ) -> None:\n        self._session = session\n        self._progress_bar = progress_bar\n\n    def __call__(self, link: Link, location: str) -> Tuple[str, str]:\n        \"\"\"Download the file given by link into location.\"\"\"\n        try:\n            resp = _http_get_download(self._session, link)\n        except NetworkConnectionError as e:\n            assert e.response is not None\n            logger.critical(\n                \"HTTP error %s while getting %s\", e.response.status_code, link\n            )\n            raise\n\n        filename = _get_http_response_filename(resp, link)\n        filepath = os.path.join(location, filename)\n\n        chunks = _prepare_download(resp, link, self._progress_bar)\n        with open(filepath, \"wb\") as content_file:\n            for chunk in chunks:\n                content_file.write(chunk)\n        content_type = resp.headers.get(\"Content-Type\", \"\")\n        return filepath, content_type\n\n\nclass BatchDownloader:\n    def __init__(\n        self,\n        session: PipSession,\n        progress_bar: str,\n    ) -> None:\n        self._session = session\n        self._progress_bar = progress_bar\n\n    def __call__(\n        self, links: Iterable[Link], location: str\n    ) -> Iterable[Tuple[Link, Tuple[str, str]]]:\n        \"\"\"Download the files given by links into location.\"\"\"\n        for link in links:\n            try:\n                resp = _http_get_download(self._session, link)\n            except NetworkConnectionError as e:\n                assert e.response is not None\n                logger.critical(\n                    \"HTTP error %s while getting %s\",\n                    e.response.status_code,\n                    link,\n                )\n                raise\n\n            filename = _get_http_response_filename(resp, link)\n            filepath = os.path.join(location, filename)\n\n            chunks = _prepare_download(resp, link, self._progress_bar)\n            with open(filepath, \"wb\") as content_file:\n                for chunk in chunks:\n                    content_file.write(chunk)\n            content_type = resp.headers.get(\"Content-Type\", \"\")\n            yield link, (filepath, content_type)\n"},"hash":"EAWnE2yAdu"}