{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:commands:completion.py","body":"import sys\nimport textwrap\nfrom optparse import Values\nfrom typing import List\n\nfrom pip._internal.cli.base_command import Command\nfrom pip._internal.cli.status_codes import SUCCESS\nfrom pip._internal.utils.misc import get_prog\n\nBASE_COMPLETION = \"\"\"\n# pip {shell} completion start{script}# pip {shell} completion end\n\"\"\"\n\nCOMPLETION_SCRIPTS = {\n    \"bash\": \"\"\"\n        _pip_completion()\n        {{\n            COMPREPLY=( $( COMP_WORDS=\"${{COMP_WORDS[*]}}\" \\\\\n                           COMP_CWORD=$COMP_CWORD \\\\\n                           PIP_AUTO_COMPLETE=1 $1 2>/dev/null ) )\n        }}\n        complete -o default -F _pip_completion {prog}\n    \"\"\",\n    \"zsh\": \"\"\"\n        #compdef -P pip[0-9.]#\n        __pip() {{\n          compadd $( COMP_WORDS=\"$words[*]\" \\\\\n                     COMP_CWORD=$((CURRENT-1)) \\\\\n                     PIP_AUTO_COMPLETE=1 $words[1] 2>/dev/null )\n        }}\n        if [[ $zsh_eval_context[-1] == loadautofunc ]]; then\n          # autoload from fpath, call function directly\n          __pip \"$@\"\n        else\n          # eval/source/. command, register function for later\n          compdef __pip -P 'pip[0-9.]#'\n        fi\n    \"\"\",\n    \"fish\": \"\"\"\n        function __fish_complete_pip\n            set -lx COMP_WORDS (commandline -o) \"\"\n            set -lx COMP_CWORD ( \\\\\n                math (contains -i -- (commandline -t) $COMP_WORDS)-1 \\\\\n            )\n            set -lx PIP_AUTO_COMPLETE 1\n            string split \\\\  -- (eval $COMP_WORDS[1])\n        end\n        complete -fa \"(__fish_complete_pip)\" -c {prog}\n    \"\"\",\n    \"powershell\": \"\"\"\n        if ((Test-Path Function:\\\\TabExpansion) -and -not `\n            (Test-Path Function:\\\\_pip_completeBackup)) {{\n            Rename-Item Function:\\\\TabExpansion _pip_completeBackup\n        }}\n        function TabExpansion($line, $lastWord) {{\n            $lastBlock = [regex]::Split($line, '[|;]')[-1].TrimStart()\n            if ($lastBlock.StartsWith(\"{prog} \")) {{\n                $Env:COMP_WORDS=$lastBlock\n                $Env:COMP_CWORD=$lastBlock.Split().Length - 1\n                $Env:PIP_AUTO_COMPLETE=1\n                (& {prog}).Split()\n                Remove-Item Env:COMP_WORDS\n                Remove-Item Env:COMP_CWORD\n                Remove-Item Env:PIP_AUTO_COMPLETE\n            }}\n            elseif (Test-Path Function:\\\\_pip_completeBackup) {{\n                # Fall back on existing tab expansion\n                _pip_completeBackup $line $lastWord\n            }}\n        }}\n    \"\"\",\n}\n\n\nclass CompletionCommand(Command):\n    \"\"\"A helper command to be used for command completion.\"\"\"\n\n    ignore_require_venv = True\n\n    def add_options(self) -> None:\n        self.cmd_opts.add_option(\n            \"--bash\",\n            \"-b\",\n            action=\"store_const\",\n            const=\"bash\",\n            dest=\"shell\",\n            help=\"Emit completion code for bash\",\n        )\n        self.cmd_opts.add_option(\n            \"--zsh\",\n            \"-z\",\n            action=\"store_const\",\n            const=\"zsh\",\n            dest=\"shell\",\n            help=\"Emit completion code for zsh\",\n        )\n        self.cmd_opts.add_option(\n            \"--fish\",\n            \"-f\",\n            action=\"store_const\",\n            const=\"fish\",\n            dest=\"shell\",\n            help=\"Emit completion code for fish\",\n        )\n        self.cmd_opts.add_option(\n            \"--powershell\",\n            \"-p\",\n            action=\"store_const\",\n            const=\"powershell\",\n            dest=\"shell\",\n            help=\"Emit completion code for powershell\",\n        )\n\n        self.parser.insert_option_group(0, self.cmd_opts)\n\n    def run(self, options: Values, args: List[str]) -> int:\n        \"\"\"Prints the completion code of the given shell\"\"\"\n        shells = COMPLETION_SCRIPTS.keys()\n        shell_options = [\"--\" + shell for shell in sorted(shells)]\n        if options.shell in shells:\n            script = textwrap.dedent(\n                COMPLETION_SCRIPTS.get(options.shell, \"\").format(prog=get_prog())\n            )\n            print(BASE_COMPLETION.format(script=script, shell=options.shell))\n            return SUCCESS\n        else:\n            sys.stderr.write(\n                \"ERROR: You must pass {}\\n\".format(\" or \".join(shell_options))\n            )\n            return SUCCESS\n"},"hash":"fNxch9bFv0"}