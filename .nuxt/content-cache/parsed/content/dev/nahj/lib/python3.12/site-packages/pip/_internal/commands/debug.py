{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:commands:debug.py","body":"import importlib.resources\nimport locale\nimport logging\nimport os\nimport sys\nfrom optparse import Values\nfrom types import ModuleType\nfrom typing import Any, Dict, List, Optional\n\nimport pip._vendor\nfrom pip._vendor.certifi import where\nfrom pip._vendor.packaging.version import parse as parse_version\n\nfrom pip._internal.cli import cmdoptions\nfrom pip._internal.cli.base_command import Command\nfrom pip._internal.cli.cmdoptions import make_target_python\nfrom pip._internal.cli.status_codes import SUCCESS\nfrom pip._internal.configuration import Configuration\nfrom pip._internal.metadata import get_environment\nfrom pip._internal.utils.logging import indent_log\nfrom pip._internal.utils.misc import get_pip_version\n\nlogger = logging.getLogger(__name__)\n\n\ndef show_value(name: str, value: Any) -> None:\n    logger.info(\"%s: %s\", name, value)\n\n\ndef show_sys_implementation() -> None:\n    logger.info(\"sys.implementation:\")\n    implementation_name = sys.implementation.name\n    with indent_log():\n        show_value(\"name\", implementation_name)\n\n\ndef create_vendor_txt_map() -> Dict[str, str]:\n    with importlib.resources.open_text(\"pip._vendor\", \"vendor.txt\") as f:\n        # Purge non version specifying lines.\n        # Also, remove any space prefix or suffixes (including comments).\n        lines = [\n            line.strip().split(\" \", 1)[0] for line in f.readlines() if \"==\" in line\n        ]\n\n    # Transform into \"module\" -> version dict.\n    return dict(line.split(\"==\", 1) for line in lines)\n\n\ndef get_module_from_module_name(module_name: str) -> Optional[ModuleType]:\n    # Module name can be uppercase in vendor.txt for some reason...\n    module_name = module_name.lower().replace(\"-\", \"_\")\n    # PATCH: setuptools is actually only pkg_resources.\n    if module_name == \"setuptools\":\n        module_name = \"pkg_resources\"\n\n    try:\n        __import__(f\"pip._vendor.{module_name}\", globals(), locals(), level=0)\n        return getattr(pip._vendor, module_name)\n    except ImportError:\n        # We allow 'truststore' to fail to import due\n        # to being unavailable on Python 3.9 and earlier.\n        if module_name == \"truststore\" and sys.version_info < (3, 10):\n            return None\n        raise\n\n\ndef get_vendor_version_from_module(module_name: str) -> Optional[str]:\n    module = get_module_from_module_name(module_name)\n    version = getattr(module, \"__version__\", None)\n\n    if module and not version:\n        # Try to find version in debundled module info.\n        assert module.__file__ is not None\n        env = get_environment([os.path.dirname(module.__file__)])\n        dist = env.get_distribution(module_name)\n        if dist:\n            version = str(dist.version)\n\n    return version\n\n\ndef show_actual_vendor_versions(vendor_txt_versions: Dict[str, str]) -> None:\n    \"\"\"Log the actual version and print extra info if there is\n    a conflict or if the actual version could not be imported.\n    \"\"\"\n    for module_name, expected_version in vendor_txt_versions.items():\n        extra_message = \"\"\n        actual_version = get_vendor_version_from_module(module_name)\n        if not actual_version:\n            extra_message = (\n                \" (Unable to locate actual module version, using\"\n                \" vendor.txt specified version)\"\n            )\n            actual_version = expected_version\n        elif parse_version(actual_version) != parse_version(expected_version):\n            extra_message = (\n                \" (CONFLICT: vendor.txt suggests version should\"\n                f\" be {expected_version})\"\n            )\n        logger.info(\"%s==%s%s\", module_name, actual_version, extra_message)\n\n\ndef show_vendor_versions() -> None:\n    logger.info(\"vendored library versions:\")\n\n    vendor_txt_versions = create_vendor_txt_map()\n    with indent_log():\n        show_actual_vendor_versions(vendor_txt_versions)\n\n\ndef show_tags(options: Values) -> None:\n    tag_limit = 10\n\n    target_python = make_target_python(options)\n    tags = target_python.get_sorted_tags()\n\n    # Display the target options that were explicitly provided.\n    formatted_target = target_python.format_given()\n    suffix = \"\"\n    if formatted_target:\n        suffix = f\" (target: {formatted_target})\"\n\n    msg = f\"Compatible tags: {len(tags)}{suffix}\"\n    logger.info(msg)\n\n    if options.verbose < 1 and len(tags) > tag_limit:\n        tags_limited = True\n        tags = tags[:tag_limit]\n    else:\n        tags_limited = False\n\n    with indent_log():\n        for tag in tags:\n            logger.info(str(tag))\n\n        if tags_limited:\n            msg = f\"...\\n[First {tag_limit} tags shown. Pass --verbose to show all.]\"\n            logger.info(msg)\n\n\ndef ca_bundle_info(config: Configuration) -> str:\n    levels = {key.split(\".\", 1)[0] for key, _ in config.items()}\n    if not levels:\n        return \"Not specified\"\n\n    levels_that_override_global = [\"install\", \"wheel\", \"download\"]\n    global_overriding_level = [\n        level for level in levels if level in levels_that_override_global\n    ]\n    if not global_overriding_level:\n        return \"global\"\n\n    if \"global\" in levels:\n        levels.remove(\"global\")\n    return \", \".join(levels)\n\n\nclass DebugCommand(Command):\n    \"\"\"\n    Display debug information.\n    \"\"\"\n\n    usage = \"\"\"\n      %prog <options>\"\"\"\n    ignore_require_venv = True\n\n    def add_options(self) -> None:\n        cmdoptions.add_target_python_options(self.cmd_opts)\n        self.parser.insert_option_group(0, self.cmd_opts)\n        self.parser.config.load()\n\n    def run(self, options: Values, args: List[str]) -> int:\n        logger.warning(\n            \"This command is only meant for debugging. \"\n            \"Do not use this with automation for parsing and getting these \"\n            \"details, since the output and options of this command may \"\n            \"change without notice.\"\n        )\n        show_value(\"pip version\", get_pip_version())\n        show_value(\"sys.version\", sys.version)\n        show_value(\"sys.executable\", sys.executable)\n        show_value(\"sys.getdefaultencoding\", sys.getdefaultencoding())\n        show_value(\"sys.getfilesystemencoding\", sys.getfilesystemencoding())\n        show_value(\n            \"locale.getpreferredencoding\",\n            locale.getpreferredencoding(),\n        )\n        show_value(\"sys.platform\", sys.platform)\n        show_sys_implementation()\n\n        show_value(\"'cert' config value\", ca_bundle_info(self.parser.config))\n        show_value(\"REQUESTS_CA_BUNDLE\", os.environ.get(\"REQUESTS_CA_BUNDLE\"))\n        show_value(\"CURL_CA_BUNDLE\", os.environ.get(\"CURL_CA_BUNDLE\"))\n        show_value(\"pip._vendor.certifi.where()\", where())\n        show_value(\"pip._vendor.DEBUNDLED\", pip._vendor.DEBUNDLED)\n\n        show_vendor_versions()\n\n        show_tags(options)\n\n        return SUCCESS\n"},"hash":"TaJ5dk7wu2"}