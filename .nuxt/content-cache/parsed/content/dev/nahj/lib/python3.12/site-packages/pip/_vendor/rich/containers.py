{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:rich:containers.py","body":"from itertools import zip_longest\nfrom typing import (\n    Iterator,\n    Iterable,\n    List,\n    Optional,\n    Union,\n    overload,\n    TypeVar,\n    TYPE_CHECKING,\n)\n\nif TYPE_CHECKING:\n    from .console import (\n        Console,\n        ConsoleOptions,\n        JustifyMethod,\n        OverflowMethod,\n        RenderResult,\n        RenderableType,\n    )\n    from .text import Text\n\nfrom .cells import cell_len\nfrom .measure import Measurement\n\nT = TypeVar(\"T\")\n\n\nclass Renderables:\n    \"\"\"A list subclass which renders its contents to the console.\"\"\"\n\n    def __init__(\n        self, renderables: Optional[Iterable[\"RenderableType\"]] = None\n    ) -> None:\n        self._renderables: List[\"RenderableType\"] = (\n            list(renderables) if renderables is not None else []\n        )\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        \"\"\"Console render method to insert line-breaks.\"\"\"\n        yield from self._renderables\n\n    def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"Measurement\":\n        dimensions = [\n            Measurement.get(console, options, renderable)\n            for renderable in self._renderables\n        ]\n        if not dimensions:\n            return Measurement(1, 1)\n        _min = max(dimension.minimum for dimension in dimensions)\n        _max = max(dimension.maximum for dimension in dimensions)\n        return Measurement(_min, _max)\n\n    def append(self, renderable: \"RenderableType\") -> None:\n        self._renderables.append(renderable)\n\n    def __iter__(self) -> Iterable[\"RenderableType\"]:\n        return iter(self._renderables)\n\n\nclass Lines:\n    \"\"\"A list subclass which can render to the console.\"\"\"\n\n    def __init__(self, lines: Iterable[\"Text\"] = ()) -> None:\n        self._lines: List[\"Text\"] = list(lines)\n\n    def __repr__(self) -> str:\n        return f\"Lines({self._lines!r})\"\n\n    def __iter__(self) -> Iterator[\"Text\"]:\n        return iter(self._lines)\n\n    @overload\n    def __getitem__(self, index: int) -> \"Text\":\n        ...\n\n    @overload\n    def __getitem__(self, index: slice) -> List[\"Text\"]:\n        ...\n\n    def __getitem__(self, index: Union[slice, int]) -> Union[\"Text\", List[\"Text\"]]:\n        return self._lines[index]\n\n    def __setitem__(self, index: int, value: \"Text\") -> \"Lines\":\n        self._lines[index] = value\n        return self\n\n    def __len__(self) -> int:\n        return self._lines.__len__()\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        \"\"\"Console render method to insert line-breaks.\"\"\"\n        yield from self._lines\n\n    def append(self, line: \"Text\") -> None:\n        self._lines.append(line)\n\n    def extend(self, lines: Iterable[\"Text\"]) -> None:\n        self._lines.extend(lines)\n\n    def pop(self, index: int = -1) -> \"Text\":\n        return self._lines.pop(index)\n\n    def justify(\n        self,\n        console: \"Console\",\n        width: int,\n        justify: \"JustifyMethod\" = \"left\",\n        overflow: \"OverflowMethod\" = \"fold\",\n    ) -> None:\n        \"\"\"Justify and overflow text to a given width.\n\n        Args:\n            console (Console): Console instance.\n            width (int): Number of characters per line.\n            justify (str, optional): Default justify method for text: \"left\", \"center\", \"full\" or \"right\". Defaults to \"left\".\n            overflow (str, optional): Default overflow for text: \"crop\", \"fold\", or \"ellipsis\". Defaults to \"fold\".\n\n        \"\"\"\n        from .text import Text\n\n        if justify == \"left\":\n            for line in self._lines:\n                line.truncate(width, overflow=overflow, pad=True)\n        elif justify == \"center\":\n            for line in self._lines:\n                line.rstrip()\n                line.truncate(width, overflow=overflow)\n                line.pad_left((width - cell_len(line.plain)) // 2)\n                line.pad_right(width - cell_len(line.plain))\n        elif justify == \"right\":\n            for line in self._lines:\n                line.rstrip()\n                line.truncate(width, overflow=overflow)\n                line.pad_left(width - cell_len(line.plain))\n        elif justify == \"full\":\n            for line_index, line in enumerate(self._lines):\n                if line_index == len(self._lines) - 1:\n                    break\n                words = line.split(\" \")\n                words_size = sum(cell_len(word.plain) for word in words)\n                num_spaces = len(words) - 1\n                spaces = [1 for _ in range(num_spaces)]\n                index = 0\n                if spaces:\n                    while words_size + num_spaces < width:\n                        spaces[len(spaces) - index - 1] += 1\n                        num_spaces += 1\n                        index = (index + 1) % len(spaces)\n                tokens: List[Text] = []\n                for index, (word, next_word) in enumerate(\n                    zip_longest(words, words[1:])\n                ):\n                    tokens.append(word)\n                    if index < len(spaces):\n                        style = word.get_style_at_offset(console, -1)\n                        next_style = next_word.get_style_at_offset(console, 0)\n                        space_style = style if style == next_style else line.style\n                        tokens.append(Text(\" \" * spaces[index], style=space_style))\n                self[line_index] = Text(\"\").join(tokens)\n"},"hash":"BpWjEhteuD"}