{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:models:search_scope.py","body":"import itertools\nimport logging\nimport os\nimport posixpath\nimport urllib.parse\nfrom typing import List\n\nfrom pip._vendor.packaging.utils import canonicalize_name\n\nfrom pip._internal.models.index import PyPI\nfrom pip._internal.utils.compat import has_tls\nfrom pip._internal.utils.misc import normalize_path, redact_auth_from_url\n\nlogger = logging.getLogger(__name__)\n\n\nclass SearchScope:\n\n    \"\"\"\n    Encapsulates the locations that pip is configured to search.\n    \"\"\"\n\n    __slots__ = [\"find_links\", \"index_urls\", \"no_index\"]\n\n    @classmethod\n    def create(\n        cls,\n        find_links: List[str],\n        index_urls: List[str],\n        no_index: bool,\n    ) -> \"SearchScope\":\n        \"\"\"\n        Create a SearchScope object after normalizing the `find_links`.\n        \"\"\"\n        # Build find_links. If an argument starts with ~, it may be\n        # a local file relative to a home directory. So try normalizing\n        # it and if it exists, use the normalized version.\n        # This is deliberately conservative - it might be fine just to\n        # blindly normalize anything starting with a ~...\n        built_find_links: List[str] = []\n        for link in find_links:\n            if link.startswith(\"~\"):\n                new_link = normalize_path(link)\n                if os.path.exists(new_link):\n                    link = new_link\n            built_find_links.append(link)\n\n        # If we don't have TLS enabled, then WARN if anyplace we're looking\n        # relies on TLS.\n        if not has_tls():\n            for link in itertools.chain(index_urls, built_find_links):\n                parsed = urllib.parse.urlparse(link)\n                if parsed.scheme == \"https\":\n                    logger.warning(\n                        \"pip is configured with locations that require \"\n                        \"TLS/SSL, however the ssl module in Python is not \"\n                        \"available.\"\n                    )\n                    break\n\n        return cls(\n            find_links=built_find_links,\n            index_urls=index_urls,\n            no_index=no_index,\n        )\n\n    def __init__(\n        self,\n        find_links: List[str],\n        index_urls: List[str],\n        no_index: bool,\n    ) -> None:\n        self.find_links = find_links\n        self.index_urls = index_urls\n        self.no_index = no_index\n\n    def get_formatted_locations(self) -> str:\n        lines = []\n        redacted_index_urls = []\n        if self.index_urls and self.index_urls != [PyPI.simple_url]:\n            for url in self.index_urls:\n                redacted_index_url = redact_auth_from_url(url)\n\n                # Parse the URL\n                purl = urllib.parse.urlsplit(redacted_index_url)\n\n                # URL is generally invalid if scheme and netloc is missing\n                # there are issues with Python and URL parsing, so this test\n                # is a bit crude. See bpo-20271, bpo-23505. Python doesn't\n                # always parse invalid URLs correctly - it should raise\n                # exceptions for malformed URLs\n                if not purl.scheme and not purl.netloc:\n                    logger.warning(\n                        'The index url \"%s\" seems invalid, please provide a scheme.',\n                        redacted_index_url,\n                    )\n\n                redacted_index_urls.append(redacted_index_url)\n\n            lines.append(\n                \"Looking in indexes: {}\".format(\", \".join(redacted_index_urls))\n            )\n\n        if self.find_links:\n            lines.append(\n                \"Looking in links: {}\".format(\n                    \", \".join(redact_auth_from_url(url) for url in self.find_links)\n                )\n            )\n        return \"\\n\".join(lines)\n\n    def get_index_urls_locations(self, project_name: str) -> List[str]:\n        \"\"\"Returns the locations found via self.index_urls\n\n        Checks the url_name on the main (first in the list) index and\n        use this url_name to produce all locations\n        \"\"\"\n\n        def mkurl_pypi_url(url: str) -> str:\n            loc = posixpath.join(\n                url, urllib.parse.quote(canonicalize_name(project_name))\n            )\n            # For maximum compatibility with easy_install, ensure the path\n            # ends in a trailing slash.  Although this isn't in the spec\n            # (and PyPI can handle it without the slash) some other index\n            # implementations might break if they relied on easy_install's\n            # behavior.\n            if not loc.endswith(\"/\"):\n                loc = loc + \"/\"\n            return loc\n\n        return [mkurl_pypi_url(url) for url in self.index_urls]\n"},"hash":"V8B6YsJaNb"}