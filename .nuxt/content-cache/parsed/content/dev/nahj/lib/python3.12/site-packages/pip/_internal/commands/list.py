{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:commands:list.py","body":"import json\nimport logging\nfrom optparse import Values\nfrom typing import TYPE_CHECKING, Generator, List, Optional, Sequence, Tuple, cast\n\nfrom pip._vendor.packaging.utils import canonicalize_name\n\nfrom pip._internal.cli import cmdoptions\nfrom pip._internal.cli.req_command import IndexGroupCommand\nfrom pip._internal.cli.status_codes import SUCCESS\nfrom pip._internal.exceptions import CommandError\nfrom pip._internal.index.collector import LinkCollector\nfrom pip._internal.index.package_finder import PackageFinder\nfrom pip._internal.metadata import BaseDistribution, get_environment\nfrom pip._internal.models.selection_prefs import SelectionPreferences\nfrom pip._internal.network.session import PipSession\nfrom pip._internal.utils.compat import stdlib_pkgs\nfrom pip._internal.utils.misc import tabulate, write_output\n\nif TYPE_CHECKING:\n    from pip._internal.metadata.base import DistributionVersion\n\n    class _DistWithLatestInfo(BaseDistribution):\n        \"\"\"Give the distribution object a couple of extra fields.\n\n        These will be populated during ``get_outdated()``. This is dirty but\n        makes the rest of the code much cleaner.\n        \"\"\"\n\n        latest_version: DistributionVersion\n        latest_filetype: str\n\n    _ProcessedDists = Sequence[_DistWithLatestInfo]\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass ListCommand(IndexGroupCommand):\n    \"\"\"\n    List installed packages, including editables.\n\n    Packages are listed in a case-insensitive sorted order.\n    \"\"\"\n\n    ignore_require_venv = True\n    usage = \"\"\"\n      %prog [options]\"\"\"\n\n    def add_options(self) -> None:\n        self.cmd_opts.add_option(\n            \"-o\",\n            \"--outdated\",\n            action=\"store_true\",\n            default=False,\n            help=\"List outdated packages\",\n        )\n        self.cmd_opts.add_option(\n            \"-u\",\n            \"--uptodate\",\n            action=\"store_true\",\n            default=False,\n            help=\"List uptodate packages\",\n        )\n        self.cmd_opts.add_option(\n            \"-e\",\n            \"--editable\",\n            action=\"store_true\",\n            default=False,\n            help=\"List editable projects.\",\n        )\n        self.cmd_opts.add_option(\n            \"-l\",\n            \"--local\",\n            action=\"store_true\",\n            default=False,\n            help=(\n                \"If in a virtualenv that has global access, do not list \"\n                \"globally-installed packages.\"\n            ),\n        )\n        self.cmd_opts.add_option(\n            \"--user\",\n            dest=\"user\",\n            action=\"store_true\",\n            default=False,\n            help=\"Only output packages installed in user-site.\",\n        )\n        self.cmd_opts.add_option(cmdoptions.list_path())\n        self.cmd_opts.add_option(\n            \"--pre\",\n            action=\"store_true\",\n            default=False,\n            help=(\n                \"Include pre-release and development versions. By default, \"\n                \"pip only finds stable versions.\"\n            ),\n        )\n\n        self.cmd_opts.add_option(\n            \"--format\",\n            action=\"store\",\n            dest=\"list_format\",\n            default=\"columns\",\n            choices=(\"columns\", \"freeze\", \"json\"),\n            help=(\n                \"Select the output format among: columns (default), freeze, or json. \"\n                \"The 'freeze' format cannot be used with the --outdated option.\"\n            ),\n        )\n\n        self.cmd_opts.add_option(\n            \"--not-required\",\n            action=\"store_true\",\n            dest=\"not_required\",\n            help=\"List packages that are not dependencies of installed packages.\",\n        )\n\n        self.cmd_opts.add_option(\n            \"--exclude-editable\",\n            action=\"store_false\",\n            dest=\"include_editable\",\n            help=\"Exclude editable package from output.\",\n        )\n        self.cmd_opts.add_option(\n            \"--include-editable\",\n            action=\"store_true\",\n            dest=\"include_editable\",\n            help=\"Include editable package from output.\",\n            default=True,\n        )\n        self.cmd_opts.add_option(cmdoptions.list_exclude())\n        index_opts = cmdoptions.make_option_group(cmdoptions.index_group, self.parser)\n\n        self.parser.insert_option_group(0, index_opts)\n        self.parser.insert_option_group(0, self.cmd_opts)\n\n    def _build_package_finder(\n        self, options: Values, session: PipSession\n    ) -> PackageFinder:\n        \"\"\"\n        Create a package finder appropriate to this list command.\n        \"\"\"\n        link_collector = LinkCollector.create(session, options=options)\n\n        # Pass allow_yanked=False to ignore yanked versions.\n        selection_prefs = SelectionPreferences(\n            allow_yanked=False,\n            allow_all_prereleases=options.pre,\n        )\n\n        return PackageFinder.create(\n            link_collector=link_collector,\n            selection_prefs=selection_prefs,\n        )\n\n    def run(self, options: Values, args: List[str]) -> int:\n        if options.outdated and options.uptodate:\n            raise CommandError(\"Options --outdated and --uptodate cannot be combined.\")\n\n        if options.outdated and options.list_format == \"freeze\":\n            raise CommandError(\n                \"List format 'freeze' cannot be used with the --outdated option.\"\n            )\n\n        cmdoptions.check_list_path_option(options)\n\n        skip = set(stdlib_pkgs)\n        if options.excludes:\n            skip.update(canonicalize_name(n) for n in options.excludes)\n\n        packages: \"_ProcessedDists\" = [\n            cast(\"_DistWithLatestInfo\", d)\n            for d in get_environment(options.path).iter_installed_distributions(\n                local_only=options.local,\n                user_only=options.user,\n                editables_only=options.editable,\n                include_editables=options.include_editable,\n                skip=skip,\n            )\n        ]\n\n        # get_not_required must be called firstly in order to find and\n        # filter out all dependencies correctly. Otherwise a package\n        # can't be identified as requirement because some parent packages\n        # could be filtered out before.\n        if options.not_required:\n            packages = self.get_not_required(packages, options)\n\n        if options.outdated:\n            packages = self.get_outdated(packages, options)\n        elif options.uptodate:\n            packages = self.get_uptodate(packages, options)\n\n        self.output_package_listing(packages, options)\n        return SUCCESS\n\n    def get_outdated(\n        self, packages: \"_ProcessedDists\", options: Values\n    ) -> \"_ProcessedDists\":\n        return [\n            dist\n            for dist in self.iter_packages_latest_infos(packages, options)\n            if dist.latest_version > dist.version\n        ]\n\n    def get_uptodate(\n        self, packages: \"_ProcessedDists\", options: Values\n    ) -> \"_ProcessedDists\":\n        return [\n            dist\n            for dist in self.iter_packages_latest_infos(packages, options)\n            if dist.latest_version == dist.version\n        ]\n\n    def get_not_required(\n        self, packages: \"_ProcessedDists\", options: Values\n    ) -> \"_ProcessedDists\":\n        dep_keys = {\n            canonicalize_name(dep.name)\n            for dist in packages\n            for dep in (dist.iter_dependencies() or ())\n        }\n\n        # Create a set to remove duplicate packages, and cast it to a list\n        # to keep the return type consistent with get_outdated and\n        # get_uptodate\n        return list({pkg for pkg in packages if pkg.canonical_name not in dep_keys})\n\n    def iter_packages_latest_infos(\n        self, packages: \"_ProcessedDists\", options: Values\n    ) -> Generator[\"_DistWithLatestInfo\", None, None]:\n        with self._build_session(options) as session:\n            finder = self._build_package_finder(options, session)\n\n            def latest_info(\n                dist: \"_DistWithLatestInfo\",\n            ) -> Optional[\"_DistWithLatestInfo\"]:\n                all_candidates = finder.find_all_candidates(dist.canonical_name)\n                if not options.pre:\n                    # Remove prereleases\n                    all_candidates = [\n                        candidate\n                        for candidate in all_candidates\n                        if not candidate.version.is_prerelease\n                    ]\n\n                evaluator = finder.make_candidate_evaluator(\n                    project_name=dist.canonical_name,\n                )\n                best_candidate = evaluator.sort_best_candidate(all_candidates)\n                if best_candidate is None:\n                    return None\n\n                remote_version = best_candidate.version\n                if best_candidate.link.is_wheel:\n                    typ = \"wheel\"\n                else:\n                    typ = \"sdist\"\n                dist.latest_version = remote_version\n                dist.latest_filetype = typ\n                return dist\n\n            for dist in map(latest_info, packages):\n                if dist is not None:\n                    yield dist\n\n    def output_package_listing(\n        self, packages: \"_ProcessedDists\", options: Values\n    ) -> None:\n        packages = sorted(\n            packages,\n            key=lambda dist: dist.canonical_name,\n        )\n        if options.list_format == \"columns\" and packages:\n            data, header = format_for_columns(packages, options)\n            self.output_package_listing_columns(data, header)\n        elif options.list_format == \"freeze\":\n            for dist in packages:\n                if options.verbose >= 1:\n                    write_output(\n                        \"%s==%s (%s)\", dist.raw_name, dist.version, dist.location\n                    )\n                else:\n                    write_output(\"%s==%s\", dist.raw_name, dist.version)\n        elif options.list_format == \"json\":\n            write_output(format_for_json(packages, options))\n\n    def output_package_listing_columns(\n        self, data: List[List[str]], header: List[str]\n    ) -> None:\n        # insert the header first: we need to know the size of column names\n        if len(data) > 0:\n            data.insert(0, header)\n\n        pkg_strings, sizes = tabulate(data)\n\n        # Create and add a separator.\n        if len(data) > 0:\n            pkg_strings.insert(1, \" \".join(\"-\" * x for x in sizes))\n\n        for val in pkg_strings:\n            write_output(val)\n\n\ndef format_for_columns(\n    pkgs: \"_ProcessedDists\", options: Values\n) -> Tuple[List[List[str]], List[str]]:\n    \"\"\"\n    Convert the package data into something usable\n    by output_package_listing_columns.\n    \"\"\"\n    header = [\"Package\", \"Version\"]\n\n    running_outdated = options.outdated\n    if running_outdated:\n        header.extend([\"Latest\", \"Type\"])\n\n    has_editables = any(x.editable for x in pkgs)\n    if has_editables:\n        header.append(\"Editable project location\")\n\n    if options.verbose >= 1:\n        header.append(\"Location\")\n    if options.verbose >= 1:\n        header.append(\"Installer\")\n\n    data = []\n    for proj in pkgs:\n        # if we're working on the 'outdated' list, separate out the\n        # latest_version and type\n        row = [proj.raw_name, str(proj.version)]\n\n        if running_outdated:\n            row.append(str(proj.latest_version))\n            row.append(proj.latest_filetype)\n\n        if has_editables:\n            row.append(proj.editable_project_location or \"\")\n\n        if options.verbose >= 1:\n            row.append(proj.location or \"\")\n        if options.verbose >= 1:\n            row.append(proj.installer)\n\n        data.append(row)\n\n    return data, header\n\n\ndef format_for_json(packages: \"_ProcessedDists\", options: Values) -> str:\n    data = []\n    for dist in packages:\n        info = {\n            \"name\": dist.raw_name,\n            \"version\": str(dist.version),\n        }\n        if options.verbose >= 1:\n            info[\"location\"] = dist.location or \"\"\n            info[\"installer\"] = dist.installer\n        if options.outdated:\n            info[\"latest_version\"] = str(dist.latest_version)\n            info[\"latest_filetype\"] = dist.latest_filetype\n        editable_project_location = dist.editable_project_location\n        if editable_project_location:\n            info[\"editable_project_location\"] = editable_project_location\n        data.append(info)\n    return json.dumps(data)\n"},"hash":"kfHrVqSS9m"}