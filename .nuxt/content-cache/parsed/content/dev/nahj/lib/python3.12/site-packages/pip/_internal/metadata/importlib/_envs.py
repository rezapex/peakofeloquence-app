{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:metadata:importlib:_envs.py","body":"import functools\nimport importlib.metadata\nimport logging\nimport os\nimport pathlib\nimport sys\nimport zipfile\nimport zipimport\nfrom typing import Iterator, List, Optional, Sequence, Set, Tuple\n\nfrom pip._vendor.packaging.utils import NormalizedName, canonicalize_name\n\nfrom pip._internal.metadata.base import BaseDistribution, BaseEnvironment\nfrom pip._internal.models.wheel import Wheel\nfrom pip._internal.utils.deprecation import deprecated\nfrom pip._internal.utils.filetypes import WHEEL_EXTENSION\n\nfrom ._compat import BadMetadata, BasePath, get_dist_name, get_info_location\nfrom ._dists import Distribution\n\nlogger = logging.getLogger(__name__)\n\n\ndef _looks_like_wheel(location: str) -> bool:\n    if not location.endswith(WHEEL_EXTENSION):\n        return False\n    if not os.path.isfile(location):\n        return False\n    if not Wheel.wheel_file_re.match(os.path.basename(location)):\n        return False\n    return zipfile.is_zipfile(location)\n\n\nclass _DistributionFinder:\n    \"\"\"Finder to locate distributions.\n\n    The main purpose of this class is to memoize found distributions' names, so\n    only one distribution is returned for each package name. At lot of pip code\n    assumes this (because it is setuptools's behavior), and not doing the same\n    can potentially cause a distribution in lower precedence path to override a\n    higher precedence one if the caller is not careful.\n\n    Eventually we probably want to make it possible to see lower precedence\n    installations as well. It's useful feature, after all.\n    \"\"\"\n\n    FoundResult = Tuple[importlib.metadata.Distribution, Optional[BasePath]]\n\n    def __init__(self) -> None:\n        self._found_names: Set[NormalizedName] = set()\n\n    def _find_impl(self, location: str) -> Iterator[FoundResult]:\n        \"\"\"Find distributions in a location.\"\"\"\n        # Skip looking inside a wheel. Since a package inside a wheel is not\n        # always valid (due to .data directories etc.), its .dist-info entry\n        # should not be considered an installed distribution.\n        if _looks_like_wheel(location):\n            return\n        # To know exactly where we find a distribution, we have to feed in the\n        # paths one by one, instead of dumping the list to importlib.metadata.\n        for dist in importlib.metadata.distributions(path=[location]):\n            info_location = get_info_location(dist)\n            try:\n                raw_name = get_dist_name(dist)\n            except BadMetadata as e:\n                logger.warning(\"Skipping %s due to %s\", info_location, e.reason)\n                continue\n            normalized_name = canonicalize_name(raw_name)\n            if normalized_name in self._found_names:\n                continue\n            self._found_names.add(normalized_name)\n            yield dist, info_location\n\n    def find(self, location: str) -> Iterator[BaseDistribution]:\n        \"\"\"Find distributions in a location.\n\n        The path can be either a directory, or a ZIP archive.\n        \"\"\"\n        for dist, info_location in self._find_impl(location):\n            if info_location is None:\n                installed_location: Optional[BasePath] = None\n            else:\n                installed_location = info_location.parent\n            yield Distribution(dist, info_location, installed_location)\n\n    def find_linked(self, location: str) -> Iterator[BaseDistribution]:\n        \"\"\"Read location in egg-link files and return distributions in there.\n\n        The path should be a directory; otherwise this returns nothing. This\n        follows how setuptools does this for compatibility. The first non-empty\n        line in the egg-link is read as a path (resolved against the egg-link's\n        containing directory if relative). Distributions found at that linked\n        location are returned.\n        \"\"\"\n        path = pathlib.Path(location)\n        if not path.is_dir():\n            return\n        for child in path.iterdir():\n            if child.suffix != \".egg-link\":\n                continue\n            with child.open() as f:\n                lines = (line.strip() for line in f)\n                target_rel = next((line for line in lines if line), \"\")\n            if not target_rel:\n                continue\n            target_location = str(path.joinpath(target_rel))\n            for dist, info_location in self._find_impl(target_location):\n                yield Distribution(dist, info_location, path)\n\n    def _find_eggs_in_dir(self, location: str) -> Iterator[BaseDistribution]:\n        from pip._vendor.pkg_resources import find_distributions\n\n        from pip._internal.metadata import pkg_resources as legacy\n\n        with os.scandir(location) as it:\n            for entry in it:\n                if not entry.name.endswith(\".egg\"):\n                    continue\n                for dist in find_distributions(entry.path):\n                    yield legacy.Distribution(dist)\n\n    def _find_eggs_in_zip(self, location: str) -> Iterator[BaseDistribution]:\n        from pip._vendor.pkg_resources import find_eggs_in_zip\n\n        from pip._internal.metadata import pkg_resources as legacy\n\n        try:\n            importer = zipimport.zipimporter(location)\n        except zipimport.ZipImportError:\n            return\n        for dist in find_eggs_in_zip(importer, location):\n            yield legacy.Distribution(dist)\n\n    def find_eggs(self, location: str) -> Iterator[BaseDistribution]:\n        \"\"\"Find eggs in a location.\n\n        This actually uses the old *pkg_resources* backend. We likely want to\n        deprecate this so we can eventually remove the *pkg_resources*\n        dependency entirely. Before that, this should first emit a deprecation\n        warning for some versions when using the fallback since importing\n        *pkg_resources* is slow for those who don't need it.\n        \"\"\"\n        if os.path.isdir(location):\n            yield from self._find_eggs_in_dir(location)\n        if zipfile.is_zipfile(location):\n            yield from self._find_eggs_in_zip(location)\n\n\n@functools.lru_cache(maxsize=None)  # Warn a distribution exactly once.\ndef _emit_egg_deprecation(location: Optional[str]) -> None:\n    deprecated(\n        reason=f\"Loading egg at {location} is deprecated.\",\n        replacement=\"to use pip for package installation.\",\n        gone_in=\"24.3\",\n        issue=12330,\n    )\n\n\nclass Environment(BaseEnvironment):\n    def __init__(self, paths: Sequence[str]) -> None:\n        self._paths = paths\n\n    @classmethod\n    def default(cls) -> BaseEnvironment:\n        return cls(sys.path)\n\n    @classmethod\n    def from_paths(cls, paths: Optional[List[str]]) -> BaseEnvironment:\n        if paths is None:\n            return cls(sys.path)\n        return cls(paths)\n\n    def _iter_distributions(self) -> Iterator[BaseDistribution]:\n        finder = _DistributionFinder()\n        for location in self._paths:\n            yield from finder.find(location)\n            for dist in finder.find_eggs(location):\n                _emit_egg_deprecation(dist.location)\n                yield dist\n            # This must go last because that's how pkg_resources tie-breaks.\n            yield from finder.find_linked(location)\n\n    def get_distribution(self, name: str) -> Optional[BaseDistribution]:\n        matches = (\n            distribution\n            for distribution in self.iter_all_distributions()\n            if distribution.canonical_name == canonicalize_name(name)\n        )\n        return next(matches, None)\n"},"hash":"DBIga5QVnj"}