{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:packaging:_manylinux.py","body":"import collections\nimport functools\nimport os\nimport re\nimport struct\nimport sys\nimport warnings\nfrom typing import IO, Dict, Iterator, NamedTuple, Optional, Tuple\n\n\n# Python does not provide platform information at sufficient granularity to\n# identify the architecture of the running executable in some cases, so we\n# determine it dynamically by reading the information from the running\n# process. This only applies on Linux, which uses the ELF format.\nclass _ELFFileHeader:\n    # https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#File_header\n    class _InvalidELFFileHeader(ValueError):\n        \"\"\"\n        An invalid ELF file header was found.\n        \"\"\"\n\n    ELF_MAGIC_NUMBER = 0x7F454C46\n    ELFCLASS32 = 1\n    ELFCLASS64 = 2\n    ELFDATA2LSB = 1\n    ELFDATA2MSB = 2\n    EM_386 = 3\n    EM_S390 = 22\n    EM_ARM = 40\n    EM_X86_64 = 62\n    EF_ARM_ABIMASK = 0xFF000000\n    EF_ARM_ABI_VER5 = 0x05000000\n    EF_ARM_ABI_FLOAT_HARD = 0x00000400\n\n    def __init__(self, file: IO[bytes]) -> None:\n        def unpack(fmt: str) -> int:\n            try:\n                data = file.read(struct.calcsize(fmt))\n                result: Tuple[int, ...] = struct.unpack(fmt, data)\n            except struct.error:\n                raise _ELFFileHeader._InvalidELFFileHeader()\n            return result[0]\n\n        self.e_ident_magic = unpack(\">I\")\n        if self.e_ident_magic != self.ELF_MAGIC_NUMBER:\n            raise _ELFFileHeader._InvalidELFFileHeader()\n        self.e_ident_class = unpack(\"B\")\n        if self.e_ident_class not in {self.ELFCLASS32, self.ELFCLASS64}:\n            raise _ELFFileHeader._InvalidELFFileHeader()\n        self.e_ident_data = unpack(\"B\")\n        if self.e_ident_data not in {self.ELFDATA2LSB, self.ELFDATA2MSB}:\n            raise _ELFFileHeader._InvalidELFFileHeader()\n        self.e_ident_version = unpack(\"B\")\n        self.e_ident_osabi = unpack(\"B\")\n        self.e_ident_abiversion = unpack(\"B\")\n        self.e_ident_pad = file.read(7)\n        format_h = \"<H\" if self.e_ident_data == self.ELFDATA2LSB else \">H\"\n        format_i = \"<I\" if self.e_ident_data == self.ELFDATA2LSB else \">I\"\n        format_q = \"<Q\" if self.e_ident_data == self.ELFDATA2LSB else \">Q\"\n        format_p = format_i if self.e_ident_class == self.ELFCLASS32 else format_q\n        self.e_type = unpack(format_h)\n        self.e_machine = unpack(format_h)\n        self.e_version = unpack(format_i)\n        self.e_entry = unpack(format_p)\n        self.e_phoff = unpack(format_p)\n        self.e_shoff = unpack(format_p)\n        self.e_flags = unpack(format_i)\n        self.e_ehsize = unpack(format_h)\n        self.e_phentsize = unpack(format_h)\n        self.e_phnum = unpack(format_h)\n        self.e_shentsize = unpack(format_h)\n        self.e_shnum = unpack(format_h)\n        self.e_shstrndx = unpack(format_h)\n\n\ndef _get_elf_header() -> Optional[_ELFFileHeader]:\n    try:\n        with open(sys.executable, \"rb\") as f:\n            elf_header = _ELFFileHeader(f)\n    except (OSError, TypeError, _ELFFileHeader._InvalidELFFileHeader):\n        return None\n    return elf_header\n\n\ndef _is_linux_armhf() -> bool:\n    # hard-float ABI can be detected from the ELF header of the running\n    # process\n    # https://static.docs.arm.com/ihi0044/g/aaelf32.pdf\n    elf_header = _get_elf_header()\n    if elf_header is None:\n        return False\n    result = elf_header.e_ident_class == elf_header.ELFCLASS32\n    result &= elf_header.e_ident_data == elf_header.ELFDATA2LSB\n    result &= elf_header.e_machine == elf_header.EM_ARM\n    result &= (\n        elf_header.e_flags & elf_header.EF_ARM_ABIMASK\n    ) == elf_header.EF_ARM_ABI_VER5\n    result &= (\n        elf_header.e_flags & elf_header.EF_ARM_ABI_FLOAT_HARD\n    ) == elf_header.EF_ARM_ABI_FLOAT_HARD\n    return result\n\n\ndef _is_linux_i686() -> bool:\n    elf_header = _get_elf_header()\n    if elf_header is None:\n        return False\n    result = elf_header.e_ident_class == elf_header.ELFCLASS32\n    result &= elf_header.e_ident_data == elf_header.ELFDATA2LSB\n    result &= elf_header.e_machine == elf_header.EM_386\n    return result\n\n\ndef _have_compatible_abi(arch: str) -> bool:\n    if arch == \"armv7l\":\n        return _is_linux_armhf()\n    if arch == \"i686\":\n        return _is_linux_i686()\n    return arch in {\"x86_64\", \"aarch64\", \"ppc64\", \"ppc64le\", \"s390x\"}\n\n\n# If glibc ever changes its major version, we need to know what the last\n# minor version was, so we can build the complete list of all versions.\n# For now, guess what the highest minor version might be, assume it will\n# be 50 for testing. Once this actually happens, update the dictionary\n# with the actual value.\n_LAST_GLIBC_MINOR: Dict[int, int] = collections.defaultdict(lambda: 50)\n\n\nclass _GLibCVersion(NamedTuple):\n    major: int\n    minor: int\n\n\ndef _glibc_version_string_confstr() -> Optional[str]:\n    \"\"\"\n    Primary implementation of glibc_version_string using os.confstr.\n    \"\"\"\n    # os.confstr is quite a bit faster than ctypes.DLL. It's also less likely\n    # to be broken or missing. This strategy is used in the standard library\n    # platform module.\n    # https://github.com/python/cpython/blob/fcf1d003bf4f0100c/Lib/platform.py#L175-L183\n    try:\n        # os.confstr(\"CS_GNU_LIBC_VERSION\") returns a string like \"glibc 2.17\".\n        version_string = os.confstr(\"CS_GNU_LIBC_VERSION\")\n        assert version_string is not None\n        _, version = version_string.split()\n    except (AssertionError, AttributeError, OSError, ValueError):\n        # os.confstr() or CS_GNU_LIBC_VERSION not available (or a bad value)...\n        return None\n    return version\n\n\ndef _glibc_version_string_ctypes() -> Optional[str]:\n    \"\"\"\n    Fallback implementation of glibc_version_string using ctypes.\n    \"\"\"\n    try:\n        import ctypes\n    except ImportError:\n        return None\n\n    # ctypes.CDLL(None) internally calls dlopen(NULL), and as the dlopen\n    # manpage says, \"If filename is NULL, then the returned handle is for the\n    # main program\". This way we can let the linker do the work to figure out\n    # which libc our process is actually using.\n    #\n    # We must also handle the special case where the executable is not a\n    # dynamically linked executable. This can occur when using musl libc,\n    # for example. In this situation, dlopen() will error, leading to an\n    # OSError. Interestingly, at least in the case of musl, there is no\n    # errno set on the OSError. The single string argument used to construct\n    # OSError comes from libc itself and is therefore not portable to\n    # hard code here. In any case, failure to call dlopen() means we\n    # can proceed, so we bail on our attempt.\n    try:\n        process_namespace = ctypes.CDLL(None)\n    except OSError:\n        return None\n\n    try:\n        gnu_get_libc_version = process_namespace.gnu_get_libc_version\n    except AttributeError:\n        # Symbol doesn't exist -> therefore, we are not linked to\n        # glibc.\n        return None\n\n    # Call gnu_get_libc_version, which returns a string like \"2.5\"\n    gnu_get_libc_version.restype = ctypes.c_char_p\n    version_str: str = gnu_get_libc_version()\n    # py2 / py3 compatibility:\n    if not isinstance(version_str, str):\n        version_str = version_str.decode(\"ascii\")\n\n    return version_str\n\n\ndef _glibc_version_string() -> Optional[str]:\n    \"\"\"Returns glibc version string, or None if not using glibc.\"\"\"\n    return _glibc_version_string_confstr() or _glibc_version_string_ctypes()\n\n\ndef _parse_glibc_version(version_str: str) -> Tuple[int, int]:\n    \"\"\"Parse glibc version.\n\n    We use a regexp instead of str.split because we want to discard any\n    random junk that might come after the minor version -- this might happen\n    in patched/forked versions of glibc (e.g. Linaro's version of glibc\n    uses version strings like \"2.20-2014.11\"). See gh-3588.\n    \"\"\"\n    m = re.match(r\"(?P<major>[0-9]+)\\.(?P<minor>[0-9]+)\", version_str)\n    if not m:\n        warnings.warn(\n            \"Expected glibc version with 2 components major.minor,\"\n            \" got: %s\" % version_str,\n            RuntimeWarning,\n        )\n        return -1, -1\n    return int(m.group(\"major\")), int(m.group(\"minor\"))\n\n\n@functools.lru_cache()\ndef _get_glibc_version() -> Tuple[int, int]:\n    version_str = _glibc_version_string()\n    if version_str is None:\n        return (-1, -1)\n    return _parse_glibc_version(version_str)\n\n\n# From PEP 513, PEP 600\ndef _is_compatible(name: str, arch: str, version: _GLibCVersion) -> bool:\n    sys_glibc = _get_glibc_version()\n    if sys_glibc < version:\n        return False\n    # Check for presence of _manylinux module.\n    try:\n        import _manylinux  # noqa\n    except ImportError:\n        return True\n    if hasattr(_manylinux, \"manylinux_compatible\"):\n        result = _manylinux.manylinux_compatible(version[0], version[1], arch)\n        if result is not None:\n            return bool(result)\n        return True\n    if version == _GLibCVersion(2, 5):\n        if hasattr(_manylinux, \"manylinux1_compatible\"):\n            return bool(_manylinux.manylinux1_compatible)\n    if version == _GLibCVersion(2, 12):\n        if hasattr(_manylinux, \"manylinux2010_compatible\"):\n            return bool(_manylinux.manylinux2010_compatible)\n    if version == _GLibCVersion(2, 17):\n        if hasattr(_manylinux, \"manylinux2014_compatible\"):\n            return bool(_manylinux.manylinux2014_compatible)\n    return True\n\n\n_LEGACY_MANYLINUX_MAP = {\n    # CentOS 7 w/ glibc 2.17 (PEP 599)\n    (2, 17): \"manylinux2014\",\n    # CentOS 6 w/ glibc 2.12 (PEP 571)\n    (2, 12): \"manylinux2010\",\n    # CentOS 5 w/ glibc 2.5 (PEP 513)\n    (2, 5): \"manylinux1\",\n}\n\n\ndef platform_tags(linux: str, arch: str) -> Iterator[str]:\n    if not _have_compatible_abi(arch):\n        return\n    # Oldest glibc to be supported regardless of architecture is (2, 17).\n    too_old_glibc2 = _GLibCVersion(2, 16)\n    if arch in {\"x86_64\", \"i686\"}:\n        # On x86/i686 also oldest glibc to be supported is (2, 5).\n        too_old_glibc2 = _GLibCVersion(2, 4)\n    current_glibc = _GLibCVersion(*_get_glibc_version())\n    glibc_max_list = [current_glibc]\n    # We can assume compatibility across glibc major versions.\n    # https://sourceware.org/bugzilla/show_bug.cgi?id=24636\n    #\n    # Build a list of maximum glibc versions so that we can\n    # output the canonical list of all glibc from current_glibc\n    # down to too_old_glibc2, including all intermediary versions.\n    for glibc_major in range(current_glibc.major - 1, 1, -1):\n        glibc_minor = _LAST_GLIBC_MINOR[glibc_major]\n        glibc_max_list.append(_GLibCVersion(glibc_major, glibc_minor))\n    for glibc_max in glibc_max_list:\n        if glibc_max.major == too_old_glibc2.major:\n            min_minor = too_old_glibc2.minor\n        else:\n            # For other glibc major versions oldest supported is (x, 0).\n            min_minor = -1\n        for glibc_minor in range(glibc_max.minor, min_minor, -1):\n            glibc_version = _GLibCVersion(glibc_max.major, glibc_minor)\n            tag = \"manylinux_{}_{}\".format(*glibc_version)\n            if _is_compatible(tag, arch, glibc_version):\n                yield linux.replace(\"linux\", tag)\n            # Handle the legacy manylinux1, manylinux2010, manylinux2014 tags.\n            if glibc_version in _LEGACY_MANYLINUX_MAP:\n                legacy_tag = _LEGACY_MANYLINUX_MAP[glibc_version]\n                if _is_compatible(legacy_tag, arch, glibc_version):\n                    yield linux.replace(\"linux\", legacy_tag)\n"},"hash":"04iz3dTIcW"}