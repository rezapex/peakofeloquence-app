{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:chardet:cli:chardetect.py","body":"\"\"\"\nScript which takes one or more file paths and reports on their detected\nencodings\n\nExample::\n\n    % chardetect somefile someotherfile\n    somefile: windows-1252 with confidence 0.5\n    someotherfile: ascii with confidence 1.0\n\nIf no paths are provided, it takes its input from stdin.\n\n\"\"\"\n\n\nimport argparse\nimport sys\nfrom typing import Iterable, List, Optional\n\nfrom .. import __version__\nfrom ..universaldetector import UniversalDetector\n\n\ndef description_of(\n    lines: Iterable[bytes],\n    name: str = \"stdin\",\n    minimal: bool = False,\n    should_rename_legacy: bool = False,\n) -> Optional[str]:\n    \"\"\"\n    Return a string describing the probable encoding of a file or\n    list of strings.\n\n    :param lines: The lines to get the encoding of.\n    :type lines: Iterable of bytes\n    :param name: Name of file or collection of lines\n    :type name: str\n    :param should_rename_legacy:  Should we rename legacy encodings to\n                                  their more modern equivalents?\n    :type should_rename_legacy:   ``bool``\n    \"\"\"\n    u = UniversalDetector(should_rename_legacy=should_rename_legacy)\n    for line in lines:\n        line = bytearray(line)\n        u.feed(line)\n        # shortcut out of the loop to save reading further - particularly useful if we read a BOM.\n        if u.done:\n            break\n    u.close()\n    result = u.result\n    if minimal:\n        return result[\"encoding\"]\n    if result[\"encoding\"]:\n        return f'{name}: {result[\"encoding\"]} with confidence {result[\"confidence\"]}'\n    return f\"{name}: no result\"\n\n\ndef main(argv: Optional[List[str]] = None) -> None:\n    \"\"\"\n    Handles command line arguments and gets things started.\n\n    :param argv: List of arguments, as if specified on the command-line.\n                 If None, ``sys.argv[1:]`` is used instead.\n    :type argv: list of str\n    \"\"\"\n    # Get command line arguments\n    parser = argparse.ArgumentParser(\n        description=(\n            \"Takes one or more file paths and reports their detected encodings\"\n        )\n    )\n    parser.add_argument(\n        \"input\",\n        help=\"File whose encoding we would like to determine. (default: stdin)\",\n        type=argparse.FileType(\"rb\"),\n        nargs=\"*\",\n        default=[sys.stdin.buffer],\n    )\n    parser.add_argument(\n        \"--minimal\",\n        help=\"Print only the encoding to standard output\",\n        action=\"store_true\",\n    )\n    parser.add_argument(\n        \"-l\",\n        \"--legacy\",\n        help=\"Rename legacy encodings to more modern ones.\",\n        action=\"store_true\",\n    )\n    parser.add_argument(\n        \"--version\", action=\"version\", version=f\"%(prog)s {__version__}\"\n    )\n    args = parser.parse_args(argv)\n\n    for f in args.input:\n        if f.isatty():\n            print(\n                \"You are running chardetect interactively. Press \"\n                \"CTRL-D twice at the start of a blank line to signal the \"\n                \"end of your input. If you want help, run chardetect \"\n                \"--help\\n\",\n                file=sys.stderr,\n            )\n        print(\n            description_of(\n                f, f.name, minimal=args.minimal, should_rename_legacy=args.legacy\n            )\n        )\n\n\nif __name__ == \"__main__\":\n    main()\n"},"hash":"iPIV5X1mbU"}