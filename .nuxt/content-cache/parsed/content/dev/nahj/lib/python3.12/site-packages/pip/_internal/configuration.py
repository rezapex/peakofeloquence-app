{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:configuration.py","body":"\"\"\"Configuration management setup\n\nSome terminology:\n- name\n  As written in config files.\n- value\n  Value associated with a name\n- key\n  Name combined with it's section (section.name)\n- variant\n  A single word describing where the configuration key-value pair came from\n\"\"\"\n\nimport configparser\nimport locale\nimport os\nimport sys\nfrom typing import Any, Dict, Iterable, List, NewType, Optional, Tuple\n\nfrom pip._internal.exceptions import (\n    ConfigurationError,\n    ConfigurationFileCouldNotBeLoaded,\n)\nfrom pip._internal.utils import appdirs\nfrom pip._internal.utils.compat import WINDOWS\nfrom pip._internal.utils.logging import getLogger\nfrom pip._internal.utils.misc import ensure_dir, enum\n\nRawConfigParser = configparser.RawConfigParser  # Shorthand\nKind = NewType(\"Kind\", str)\n\nCONFIG_BASENAME = \"pip.ini\" if WINDOWS else \"pip.conf\"\nENV_NAMES_IGNORED = \"version\", \"help\"\n\n# The kinds of configurations there are.\nkinds = enum(\n    USER=\"user\",  # User Specific\n    GLOBAL=\"global\",  # System Wide\n    SITE=\"site\",  # [Virtual] Environment Specific\n    ENV=\"env\",  # from PIP_CONFIG_FILE\n    ENV_VAR=\"env-var\",  # from Environment Variables\n)\nOVERRIDE_ORDER = kinds.GLOBAL, kinds.USER, kinds.SITE, kinds.ENV, kinds.ENV_VAR\nVALID_LOAD_ONLY = kinds.USER, kinds.GLOBAL, kinds.SITE\n\nlogger = getLogger(__name__)\n\n\n# NOTE: Maybe use the optionx attribute to normalize keynames.\ndef _normalize_name(name: str) -> str:\n    \"\"\"Make a name consistent regardless of source (environment or file)\"\"\"\n    name = name.lower().replace(\"_\", \"-\")\n    if name.startswith(\"--\"):\n        name = name[2:]  # only prefer long opts\n    return name\n\n\ndef _disassemble_key(name: str) -> List[str]:\n    if \".\" not in name:\n        error_message = (\n            \"Key does not contain dot separated section and key. \"\n            f\"Perhaps you wanted to use 'global.{name}' instead?\"\n        )\n        raise ConfigurationError(error_message)\n    return name.split(\".\", 1)\n\n\ndef get_configuration_files() -> Dict[Kind, List[str]]:\n    global_config_files = [\n        os.path.join(path, CONFIG_BASENAME) for path in appdirs.site_config_dirs(\"pip\")\n    ]\n\n    site_config_file = os.path.join(sys.prefix, CONFIG_BASENAME)\n    legacy_config_file = os.path.join(\n        os.path.expanduser(\"~\"),\n        \"pip\" if WINDOWS else \".pip\",\n        CONFIG_BASENAME,\n    )\n    new_config_file = os.path.join(appdirs.user_config_dir(\"pip\"), CONFIG_BASENAME)\n    return {\n        kinds.GLOBAL: global_config_files,\n        kinds.SITE: [site_config_file],\n        kinds.USER: [legacy_config_file, new_config_file],\n    }\n\n\nclass Configuration:\n    \"\"\"Handles management of configuration.\n\n    Provides an interface to accessing and managing configuration files.\n\n    This class converts provides an API that takes \"section.key-name\" style\n    keys and stores the value associated with it as \"key-name\" under the\n    section \"section\".\n\n    This allows for a clean interface wherein the both the section and the\n    key-name are preserved in an easy to manage form in the configuration files\n    and the data stored is also nice.\n    \"\"\"\n\n    def __init__(self, isolated: bool, load_only: Optional[Kind] = None) -> None:\n        super().__init__()\n\n        if load_only is not None and load_only not in VALID_LOAD_ONLY:\n            raise ConfigurationError(\n                \"Got invalid value for load_only - should be one of {}\".format(\n                    \", \".join(map(repr, VALID_LOAD_ONLY))\n                )\n            )\n        self.isolated = isolated\n        self.load_only = load_only\n\n        # Because we keep track of where we got the data from\n        self._parsers: Dict[Kind, List[Tuple[str, RawConfigParser]]] = {\n            variant: [] for variant in OVERRIDE_ORDER\n        }\n        self._config: Dict[Kind, Dict[str, Any]] = {\n            variant: {} for variant in OVERRIDE_ORDER\n        }\n        self._modified_parsers: List[Tuple[str, RawConfigParser]] = []\n\n    def load(self) -> None:\n        \"\"\"Loads configuration from configuration files and environment\"\"\"\n        self._load_config_files()\n        if not self.isolated:\n            self._load_environment_vars()\n\n    def get_file_to_edit(self) -> Optional[str]:\n        \"\"\"Returns the file with highest priority in configuration\"\"\"\n        assert self.load_only is not None, \"Need to be specified a file to be editing\"\n\n        try:\n            return self._get_parser_to_modify()[0]\n        except IndexError:\n            return None\n\n    def items(self) -> Iterable[Tuple[str, Any]]:\n        \"\"\"Returns key-value pairs like dict.items() representing the loaded\n        configuration\n        \"\"\"\n        return self._dictionary.items()\n\n    def get_value(self, key: str) -> Any:\n        \"\"\"Get a value from the configuration.\"\"\"\n        orig_key = key\n        key = _normalize_name(key)\n        try:\n            return self._dictionary[key]\n        except KeyError:\n            # disassembling triggers a more useful error message than simply\n            # \"No such key\" in the case that the key isn't in the form command.option\n            _disassemble_key(key)\n            raise ConfigurationError(f\"No such key - {orig_key}\")\n\n    def set_value(self, key: str, value: Any) -> None:\n        \"\"\"Modify a value in the configuration.\"\"\"\n        key = _normalize_name(key)\n        self._ensure_have_load_only()\n\n        assert self.load_only\n        fname, parser = self._get_parser_to_modify()\n\n        if parser is not None:\n            section, name = _disassemble_key(key)\n\n            # Modify the parser and the configuration\n            if not parser.has_section(section):\n                parser.add_section(section)\n            parser.set(section, name, value)\n\n        self._config[self.load_only][key] = value\n        self._mark_as_modified(fname, parser)\n\n    def unset_value(self, key: str) -> None:\n        \"\"\"Unset a value in the configuration.\"\"\"\n        orig_key = key\n        key = _normalize_name(key)\n        self._ensure_have_load_only()\n\n        assert self.load_only\n        if key not in self._config[self.load_only]:\n            raise ConfigurationError(f\"No such key - {orig_key}\")\n\n        fname, parser = self._get_parser_to_modify()\n\n        if parser is not None:\n            section, name = _disassemble_key(key)\n            if not (\n                parser.has_section(section) and parser.remove_option(section, name)\n            ):\n                # The option was not removed.\n                raise ConfigurationError(\n                    \"Fatal Internal error [id=1]. Please report as a bug.\"\n                )\n\n            # The section may be empty after the option was removed.\n            if not parser.items(section):\n                parser.remove_section(section)\n            self._mark_as_modified(fname, parser)\n\n        del self._config[self.load_only][key]\n\n    def save(self) -> None:\n        \"\"\"Save the current in-memory state.\"\"\"\n        self._ensure_have_load_only()\n\n        for fname, parser in self._modified_parsers:\n            logger.info(\"Writing to %s\", fname)\n\n            # Ensure directory exists.\n            ensure_dir(os.path.dirname(fname))\n\n            # Ensure directory's permission(need to be writeable)\n            try:\n                with open(fname, \"w\") as f:\n                    parser.write(f)\n            except OSError as error:\n                raise ConfigurationError(\n                    f\"An error occurred while writing to the configuration file \"\n                    f\"{fname}: {error}\"\n                )\n\n    #\n    # Private routines\n    #\n\n    def _ensure_have_load_only(self) -> None:\n        if self.load_only is None:\n            raise ConfigurationError(\"Needed a specific file to be modifying.\")\n        logger.debug(\"Will be working with %s variant only\", self.load_only)\n\n    @property\n    def _dictionary(self) -> Dict[str, Any]:\n        \"\"\"A dictionary representing the loaded configuration.\"\"\"\n        # NOTE: Dictionaries are not populated if not loaded. So, conditionals\n        #       are not needed here.\n        retval = {}\n\n        for variant in OVERRIDE_ORDER:\n            retval.update(self._config[variant])\n\n        return retval\n\n    def _load_config_files(self) -> None:\n        \"\"\"Loads configuration from configuration files\"\"\"\n        config_files = dict(self.iter_config_files())\n        if config_files[kinds.ENV][0:1] == [os.devnull]:\n            logger.debug(\n                \"Skipping loading configuration files due to \"\n                \"environment's PIP_CONFIG_FILE being os.devnull\"\n            )\n            return\n\n        for variant, files in config_files.items():\n            for fname in files:\n                # If there's specific variant set in `load_only`, load only\n                # that variant, not the others.\n                if self.load_only is not None and variant != self.load_only:\n                    logger.debug(\"Skipping file '%s' (variant: %s)\", fname, variant)\n                    continue\n\n                parser = self._load_file(variant, fname)\n\n                # Keeping track of the parsers used\n                self._parsers[variant].append((fname, parser))\n\n    def _load_file(self, variant: Kind, fname: str) -> RawConfigParser:\n        logger.verbose(\"For variant '%s', will try loading '%s'\", variant, fname)\n        parser = self._construct_parser(fname)\n\n        for section in parser.sections():\n            items = parser.items(section)\n            self._config[variant].update(self._normalized_keys(section, items))\n\n        return parser\n\n    def _construct_parser(self, fname: str) -> RawConfigParser:\n        parser = configparser.RawConfigParser()\n        # If there is no such file, don't bother reading it but create the\n        # parser anyway, to hold the data.\n        # Doing this is useful when modifying and saving files, where we don't\n        # need to construct a parser.\n        if os.path.exists(fname):\n            locale_encoding = locale.getpreferredencoding(False)\n            try:\n                parser.read(fname, encoding=locale_encoding)\n            except UnicodeDecodeError:\n                # See https://github.com/pypa/pip/issues/4963\n                raise ConfigurationFileCouldNotBeLoaded(\n                    reason=f\"contains invalid {locale_encoding} characters\",\n                    fname=fname,\n                )\n            except configparser.Error as error:\n                # See https://github.com/pypa/pip/issues/4893\n                raise ConfigurationFileCouldNotBeLoaded(error=error)\n        return parser\n\n    def _load_environment_vars(self) -> None:\n        \"\"\"Loads configuration from environment variables\"\"\"\n        self._config[kinds.ENV_VAR].update(\n            self._normalized_keys(\":env:\", self.get_environ_vars())\n        )\n\n    def _normalized_keys(\n        self, section: str, items: Iterable[Tuple[str, Any]]\n    ) -> Dict[str, Any]:\n        \"\"\"Normalizes items to construct a dictionary with normalized keys.\n\n        This routine is where the names become keys and are made the same\n        regardless of source - configuration files or environment.\n        \"\"\"\n        normalized = {}\n        for name, val in items:\n            key = section + \".\" + _normalize_name(name)\n            normalized[key] = val\n        return normalized\n\n    def get_environ_vars(self) -> Iterable[Tuple[str, str]]:\n        \"\"\"Returns a generator with all environmental vars with prefix PIP_\"\"\"\n        for key, val in os.environ.items():\n            if key.startswith(\"PIP_\"):\n                name = key[4:].lower()\n                if name not in ENV_NAMES_IGNORED:\n                    yield name, val\n\n    # XXX: This is patched in the tests.\n    def iter_config_files(self) -> Iterable[Tuple[Kind, List[str]]]:\n        \"\"\"Yields variant and configuration files associated with it.\n\n        This should be treated like items of a dictionary. The order\n        here doesn't affect what gets overridden. That is controlled\n        by OVERRIDE_ORDER. However this does control the order they are\n        displayed to the user. It's probably most ergononmic to display\n        things in the same order as OVERRIDE_ORDER\n        \"\"\"\n        # SMELL: Move the conditions out of this function\n\n        env_config_file = os.environ.get(\"PIP_CONFIG_FILE\", None)\n        config_files = get_configuration_files()\n\n        yield kinds.GLOBAL, config_files[kinds.GLOBAL]\n\n        # per-user config is not loaded when env_config_file exists\n        should_load_user_config = not self.isolated and not (\n            env_config_file and os.path.exists(env_config_file)\n        )\n        if should_load_user_config:\n            # The legacy config file is overridden by the new config file\n            yield kinds.USER, config_files[kinds.USER]\n\n        # virtualenv config\n        yield kinds.SITE, config_files[kinds.SITE]\n\n        if env_config_file is not None:\n            yield kinds.ENV, [env_config_file]\n        else:\n            yield kinds.ENV, []\n\n    def get_values_in_config(self, variant: Kind) -> Dict[str, Any]:\n        \"\"\"Get values present in a config file\"\"\"\n        return self._config[variant]\n\n    def _get_parser_to_modify(self) -> Tuple[str, RawConfigParser]:\n        # Determine which parser to modify\n        assert self.load_only\n        parsers = self._parsers[self.load_only]\n        if not parsers:\n            # This should not happen if everything works correctly.\n            raise ConfigurationError(\n                \"Fatal Internal error [id=2]. Please report as a bug.\"\n            )\n\n        # Use the highest priority parser.\n        return parsers[-1]\n\n    # XXX: This is patched in the tests.\n    def _mark_as_modified(self, fname: str, parser: RawConfigParser) -> None:\n        file_parser_tuple = (fname, parser)\n        if file_parser_tuple not in self._modified_parsers:\n            self._modified_parsers.append(file_parser_tuple)\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({self._dictionary!r})\"\n"},"hash":"Fl6T0WMs7F"}