{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:bs4:tests:test_tag.py","body":"import warnings\nfrom bs4.element import (\n    Comment,\n    NavigableString,\n)\nfrom . import SoupTest\n\nclass TestTag(SoupTest):\n    \"\"\"Test various methods of Tag which aren't so complicated they\n    need their own classes.\n    \"\"\"\n\n    def test__should_pretty_print(self):\n        # Test the rules about when a tag should be pretty-printed.\n        tag = self.soup(\"\").new_tag(\"a_tag\")\n\n        # No list of whitespace-preserving tags -> pretty-print\n        tag._preserve_whitespace_tags = None\n        assert True == tag._should_pretty_print(0)\n\n        # List exists but tag is not on the list -> pretty-print\n        tag.preserve_whitespace_tags = [\"some_other_tag\"]\n        assert True == tag._should_pretty_print(1)\n\n        # Indent level is None -> don't pretty-print\n        assert False == tag._should_pretty_print(None)\n        \n        # Tag is on the whitespace-preserving list -> don't pretty-print\n        tag.preserve_whitespace_tags = [\"some_other_tag\", \"a_tag\"]\n        assert False == tag._should_pretty_print(1)\n    \n    def test_len(self):\n        \"\"\"The length of a Tag is its number of children.\"\"\"\n        soup = self.soup(\"<top>1<b>2</b>3</top>\")\n\n        # The BeautifulSoup object itself contains one element: the\n        # <top> tag.\n        assert len(soup.contents) == 1\n        assert len(soup) == 1\n\n        # The <top> tag contains three elements: the text node \"1\", the\n        # <b> tag, and the text node \"3\".\n        assert len(soup.top) == 3\n        assert len(soup.top.contents) == 3\n\n    def test_member_access_invokes_find(self):\n        \"\"\"Accessing a Python member .foo invokes find('foo')\"\"\"\n        soup = self.soup('<b><i></i></b>')\n        assert soup.b == soup.find('b')\n        assert soup.b.i == soup.find('b').find('i')\n        assert soup.a == None\n\n    def test_deprecated_member_access(self):\n        soup = self.soup('<b><i></i></b>')\n        with warnings.catch_warnings(record=True) as w:\n            tag = soup.bTag\n        assert soup.b == tag\n        assert '.bTag is deprecated, use .find(\"b\") instead. If you really were looking for a tag called bTag, use .find(\"bTag\")' == str(w[0].message)\n\n    def test_has_attr(self):\n        \"\"\"has_attr() checks for the presence of an attribute.\n\n        Please note note: has_attr() is different from\n        __in__. has_attr() checks the tag's attributes and __in__\n        checks the tag's chidlren.\n        \"\"\"\n        soup = self.soup(\"<foo attr='bar'>\")\n        assert soup.foo.has_attr('attr')\n        assert not soup.foo.has_attr('attr2')\n\n    def test_attributes_come_out_in_alphabetical_order(self):\n        markup = '<b a=\"1\" z=\"5\" m=\"3\" f=\"2\" y=\"4\"></b>'\n        self.assertSoupEquals(markup, '<b a=\"1\" f=\"2\" m=\"3\" y=\"4\" z=\"5\"></b>')\n\n    def test_string(self):\n        # A Tag that contains only a text node makes that node\n        # available as .string.\n        soup = self.soup(\"<b>foo</b>\")\n        assert soup.b.string == 'foo'\n\n    def test_empty_tag_has_no_string(self):\n        # A Tag with no children has no .stirng.\n        soup = self.soup(\"<b></b>\")\n        assert soup.b.string == None\n\n    def test_tag_with_multiple_children_has_no_string(self):\n        # A Tag with no children has no .string.\n        soup = self.soup(\"<a>foo<b></b><b></b></b>\")\n        assert soup.b.string == None\n\n        soup = self.soup(\"<a>foo<b></b>bar</b>\")\n        assert soup.b.string == None\n\n        # Even if all the children are strings, due to trickery,\n        # it won't work--but this would be a good optimization.\n        soup = self.soup(\"<a>foo</b>\")\n        soup.a.insert(1, \"bar\")\n        assert soup.a.string == None\n\n    def test_tag_with_recursive_string_has_string(self):\n        # A Tag with a single child which has a .string inherits that\n        # .string.\n        soup = self.soup(\"<a><b>foo</b></a>\")\n        assert soup.a.string == \"foo\"\n        assert soup.string == \"foo\"\n\n    def test_lack_of_string(self):\n        \"\"\"Only a Tag containing a single text node has a .string.\"\"\"\n        soup = self.soup(\"<b>f<i>e</i>o</b>\")\n        assert soup.b.string is None\n\n        soup = self.soup(\"<b></b>\")\n        assert soup.b.string is None\n\n    def test_all_text(self):\n        \"\"\"Tag.text and Tag.get_text(sep=u\"\") -> all child text, concatenated\"\"\"\n        soup = self.soup(\"<a>a<b>r</b>   <r> t </r></a>\")\n        assert soup.a.text == \"ar  t \"\n        assert soup.a.get_text(strip=True) == \"art\"\n        assert soup.a.get_text(\",\") == \"a,r, , t \"\n        assert soup.a.get_text(\",\", strip=True) == \"a,r,t\"\n\n    def test_get_text_ignores_special_string_containers(self):\n        soup = self.soup(\"foo<!--IGNORE-->bar\")\n        assert soup.get_text() == \"foobar\"\n\n        assert soup.get_text(types=(NavigableString, Comment)) == \"fooIGNOREbar\"\n        assert soup.get_text(types=None) == \"fooIGNOREbar\"\n\n        soup = self.soup(\"foo<style>CSS</style><script>Javascript</script>bar\")\n        assert soup.get_text() == \"foobar\"\n        \n    def test_all_strings_ignores_special_string_containers(self):\n        soup = self.soup(\"foo<!--IGNORE-->bar\")\n        assert ['foo', 'bar'] == list(soup.strings)\n\n        soup = self.soup(\"foo<style>CSS</style><script>Javascript</script>bar\")\n        assert ['foo', 'bar'] == list(soup.strings)\n\n    def test_string_methods_inside_special_string_container_tags(self):\n        # Strings inside tags like <script> are generally ignored by\n        # methods like get_text, because they're not what humans\n        # consider 'text'. But if you call get_text on the <script>\n        # tag itself, those strings _are_ considered to be 'text',\n        # because there's nothing else you might be looking for.\n        \n        style = self.soup(\"<div>a<style>Some CSS</style></div>\")\n        template = self.soup(\"<div>a<template><p>Templated <b>text</b>.</p><!--With a comment.--></template></div>\")\n        script = self.soup(\"<div>a<script><!--a comment-->Some text</script></div>\")\n        \n        assert style.div.get_text() == \"a\"\n        assert list(style.div.strings) == [\"a\"]\n        assert style.div.style.get_text() == \"Some CSS\"\n        assert list(style.div.style.strings) == ['Some CSS']\n        \n        # The comment is not picked up here. That's because it was\n        # parsed into a Comment object, which is not considered\n        # interesting by template.strings.\n        assert template.div.get_text() == \"a\"\n        assert list(template.div.strings) == [\"a\"]\n        assert template.div.template.get_text() == \"Templated text.\"\n        assert list(template.div.template.strings) == [\"Templated \", \"text\", \".\"]\n\n        # The comment is included here, because it didn't get parsed\n        # into a Comment object--it's part of the Script string.\n        assert script.div.get_text() == \"a\"\n        assert list(script.div.strings) == [\"a\"]\n        assert script.div.script.get_text() == \"<!--a comment-->Some text\"\n        assert list(script.div.script.strings) == ['<!--a comment-->Some text']\n\n\nclass TestMultiValuedAttributes(SoupTest):\n    \"\"\"Test the behavior of multi-valued attributes like 'class'.\n\n    The values of such attributes are always presented as lists.\n    \"\"\"\n\n    def test_single_value_becomes_list(self):\n        soup = self.soup(\"<a class='foo'>\")\n        assert [\"foo\"] ==soup.a['class']\n\n    def test_multiple_values_becomes_list(self):\n        soup = self.soup(\"<a class='foo bar'>\")\n        assert [\"foo\", \"bar\"] == soup.a['class']\n\n    def test_multiple_values_separated_by_weird_whitespace(self):\n        soup = self.soup(\"<a class='foo\\tbar\\nbaz'>\")\n        assert [\"foo\", \"bar\", \"baz\"] ==soup.a['class']\n\n    def test_attributes_joined_into_string_on_output(self):\n        soup = self.soup(\"<a class='foo\\tbar'>\")\n        assert b'<a class=\"foo bar\"></a>' == soup.a.encode()\n\n    def test_get_attribute_list(self):\n        soup = self.soup(\"<a id='abc def'>\")\n        assert ['abc def'] == soup.a.get_attribute_list('id')\n        \n    def test_accept_charset(self):\n        soup = self.soup('<form accept-charset=\"ISO-8859-1 UTF-8\">')\n        assert ['ISO-8859-1', 'UTF-8'] == soup.form['accept-charset']\n\n    def test_cdata_attribute_applying_only_to_one_tag(self):\n        data = '<a accept-charset=\"ISO-8859-1 UTF-8\"></a>'\n        soup = self.soup(data)\n        # We saw in another test that accept-charset is a cdata-list\n        # attribute for the <form> tag. But it's not a cdata-list\n        # attribute for any other tag.\n        assert 'ISO-8859-1 UTF-8' == soup.a['accept-charset']\n\n    def test_customization(self):\n        # It's possible to change which attributes of which tags\n        # are treated as multi-valued attributes.\n        #\n        # Here, 'id' is a multi-valued attribute and 'class' is not.\n        #\n        # TODO: This code is in the builder and should be tested there.\n        soup = self.soup(\n            '<a class=\"foo\" id=\"bar\">', multi_valued_attributes={ '*' : 'id' }\n        )\n        assert soup.a['class'] == 'foo'\n        assert soup.a['id'] == ['bar']\n\n    def test_hidden_tag_is_invisible(self):\n        # Setting .hidden on a tag makes it invisible in output, but\n        # leaves its contents visible.\n        #\n        # This is not a documented or supported feature of Beautiful\n        # Soup (e.g. NavigableString doesn't support .hidden even\n        # though it could), but some people use it and it's not\n        # hurting anything to verify that it keeps working.\n        #\n        soup = self.soup('<div id=\"1\"><span id=\"2\">a string</span></div>')\n        soup.span.hidden = True\n        assert '<div id=\"1\">a string</div>' == str(soup.div)\n"},"hash":"B0BIjOgsyu"}