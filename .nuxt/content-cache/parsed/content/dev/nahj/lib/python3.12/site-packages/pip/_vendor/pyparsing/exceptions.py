{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:pyparsing:exceptions.py","body":"# exceptions.py\n\nimport re\nimport sys\nimport typing\n\nfrom .util import (\n    col,\n    line,\n    lineno,\n    _collapse_string_to_ranges,\n    replaced_by_pep8,\n)\nfrom .unicode import pyparsing_unicode as ppu\n\n\nclass ExceptionWordUnicode(ppu.Latin1, ppu.LatinA, ppu.LatinB, ppu.Greek, ppu.Cyrillic):\n    pass\n\n\n_extract_alphanums = _collapse_string_to_ranges(ExceptionWordUnicode.alphanums)\n_exception_word_extractor = re.compile(\"([\" + _extract_alphanums + \"]{1,16})|.\")\n\n\nclass ParseBaseException(Exception):\n    \"\"\"base exception class for all parsing runtime exceptions\"\"\"\n\n    loc: int\n    msg: str\n    pstr: str\n    parser_element: typing.Any  # \"ParserElement\"\n    args: typing.Tuple[str, int, typing.Optional[str]]\n\n    __slots__ = (\n        \"loc\",\n        \"msg\",\n        \"pstr\",\n        \"parser_element\",\n        \"args\",\n    )\n\n    # Performance tuning: we construct a *lot* of these, so keep this\n    # constructor as small and fast as possible\n    def __init__(\n        self,\n        pstr: str,\n        loc: int = 0,\n        msg: typing.Optional[str] = None,\n        elem=None,\n    ):\n        self.loc = loc\n        if msg is None:\n            self.msg = pstr\n            self.pstr = \"\"\n        else:\n            self.msg = msg\n            self.pstr = pstr\n        self.parser_element = elem\n        self.args = (pstr, loc, msg)\n\n    @staticmethod\n    def explain_exception(exc, depth=16):\n        \"\"\"\n        Method to take an exception and translate the Python internal traceback into a list\n        of the pyparsing expressions that caused the exception to be raised.\n\n        Parameters:\n\n        - exc - exception raised during parsing (need not be a ParseException, in support\n          of Python exceptions that might be raised in a parse action)\n        - depth (default=16) - number of levels back in the stack trace to list expression\n          and function names; if None, the full stack trace names will be listed; if 0, only\n          the failing input line, marker, and exception string will be shown\n\n        Returns a multi-line string listing the ParserElements and/or function names in the\n        exception's stack trace.\n        \"\"\"\n        import inspect\n        from .core import ParserElement\n\n        if depth is None:\n            depth = sys.getrecursionlimit()\n        ret = []\n        if isinstance(exc, ParseBaseException):\n            ret.append(exc.line)\n            ret.append(\" \" * (exc.column - 1) + \"^\")\n        ret.append(f\"{type(exc).__name__}: {exc}\")\n\n        if depth > 0:\n            callers = inspect.getinnerframes(exc.__traceback__, context=depth)\n            seen = set()\n            for i, ff in enumerate(callers[-depth:]):\n                frm = ff[0]\n\n                f_self = frm.f_locals.get(\"self\", None)\n                if isinstance(f_self, ParserElement):\n                    if not frm.f_code.co_name.startswith(\n                        (\"parseImpl\", \"_parseNoCache\")\n                    ):\n                        continue\n                    if id(f_self) in seen:\n                        continue\n                    seen.add(id(f_self))\n\n                    self_type = type(f_self)\n                    ret.append(\n                        f\"{self_type.__module__}.{self_type.__name__} - {f_self}\"\n                    )\n\n                elif f_self is not None:\n                    self_type = type(f_self)\n                    ret.append(f\"{self_type.__module__}.{self_type.__name__}\")\n\n                else:\n                    code = frm.f_code\n                    if code.co_name in (\"wrapper\", \"<module>\"):\n                        continue\n\n                    ret.append(code.co_name)\n\n                depth -= 1\n                if not depth:\n                    break\n\n        return \"\\n\".join(ret)\n\n    @classmethod\n    def _from_exception(cls, pe):\n        \"\"\"\n        internal factory method to simplify creating one type of ParseException\n        from another - avoids having __init__ signature conflicts among subclasses\n        \"\"\"\n        return cls(pe.pstr, pe.loc, pe.msg, pe.parser_element)\n\n    @property\n    def line(self) -> str:\n        \"\"\"\n        Return the line of text where the exception occurred.\n        \"\"\"\n        return line(self.loc, self.pstr)\n\n    @property\n    def lineno(self) -> int:\n        \"\"\"\n        Return the 1-based line number of text where the exception occurred.\n        \"\"\"\n        return lineno(self.loc, self.pstr)\n\n    @property\n    def col(self) -> int:\n        \"\"\"\n        Return the 1-based column on the line of text where the exception occurred.\n        \"\"\"\n        return col(self.loc, self.pstr)\n\n    @property\n    def column(self) -> int:\n        \"\"\"\n        Return the 1-based column on the line of text where the exception occurred.\n        \"\"\"\n        return col(self.loc, self.pstr)\n\n    # pre-PEP8 compatibility\n    @property\n    def parserElement(self):\n        return self.parser_element\n\n    @parserElement.setter\n    def parserElement(self, elem):\n        self.parser_element = elem\n\n    def __str__(self) -> str:\n        if self.pstr:\n            if self.loc >= len(self.pstr):\n                foundstr = \", found end of text\"\n            else:\n                # pull out next word at error location\n                found_match = _exception_word_extractor.match(self.pstr, self.loc)\n                if found_match is not None:\n                    found = found_match.group(0)\n                else:\n                    found = self.pstr[self.loc : self.loc + 1]\n                foundstr = (\", found %r\" % found).replace(r\"\\\\\", \"\\\\\")\n        else:\n            foundstr = \"\"\n        return f\"{self.msg}{foundstr}  (at char {self.loc}), (line:{self.lineno}, col:{self.column})\"\n\n    def __repr__(self):\n        return str(self)\n\n    def mark_input_line(\n        self, marker_string: typing.Optional[str] = None, *, markerString: str = \">!<\"\n    ) -> str:\n        \"\"\"\n        Extracts the exception line from the input string, and marks\n        the location of the exception with a special symbol.\n        \"\"\"\n        markerString = marker_string if marker_string is not None else markerString\n        line_str = self.line\n        line_column = self.column - 1\n        if markerString:\n            line_str = \"\".join(\n                (line_str[:line_column], markerString, line_str[line_column:])\n            )\n        return line_str.strip()\n\n    def explain(self, depth=16) -> str:\n        \"\"\"\n        Method to translate the Python internal traceback into a list\n        of the pyparsing expressions that caused the exception to be raised.\n\n        Parameters:\n\n        - depth (default=16) - number of levels back in the stack trace to list expression\n          and function names; if None, the full stack trace names will be listed; if 0, only\n          the failing input line, marker, and exception string will be shown\n\n        Returns a multi-line string listing the ParserElements and/or function names in the\n        exception's stack trace.\n\n        Example::\n\n            expr = pp.Word(pp.nums) * 3\n            try:\n                expr.parse_string(\"123 456 A789\")\n            except pp.ParseException as pe:\n                print(pe.explain(depth=0))\n\n        prints::\n\n            123 456 A789\n                    ^\n            ParseException: Expected W:(0-9), found 'A'  (at char 8), (line:1, col:9)\n\n        Note: the diagnostic output will include string representations of the expressions\n        that failed to parse. These representations will be more helpful if you use `set_name` to\n        give identifiable names to your expressions. Otherwise they will use the default string\n        forms, which may be cryptic to read.\n\n        Note: pyparsing's default truncation of exception tracebacks may also truncate the\n        stack of expressions that are displayed in the ``explain`` output. To get the full listing\n        of parser expressions, you may have to set ``ParserElement.verbose_stacktrace = True``\n        \"\"\"\n        return self.explain_exception(self, depth)\n\n    # fmt: off\n    @replaced_by_pep8(mark_input_line)\n    def markInputline(self): ...\n    # fmt: on\n\n\nclass ParseException(ParseBaseException):\n    \"\"\"\n    Exception thrown when a parse expression doesn't match the input string\n\n    Example::\n\n        try:\n            Word(nums).set_name(\"integer\").parse_string(\"ABC\")\n        except ParseException as pe:\n            print(pe)\n            print(\"column: {}\".format(pe.column))\n\n    prints::\n\n       Expected integer (at char 0), (line:1, col:1)\n        column: 1\n\n    \"\"\"\n\n\nclass ParseFatalException(ParseBaseException):\n    \"\"\"\n    User-throwable exception thrown when inconsistent parse content\n    is found; stops all parsing immediately\n    \"\"\"\n\n\nclass ParseSyntaxException(ParseFatalException):\n    \"\"\"\n    Just like :class:`ParseFatalException`, but thrown internally\n    when an :class:`ErrorStop<And._ErrorStop>` ('-' operator) indicates\n    that parsing is to stop immediately because an unbacktrackable\n    syntax error has been found.\n    \"\"\"\n\n\nclass RecursiveGrammarException(Exception):\n    \"\"\"\n    Exception thrown by :class:`ParserElement.validate` if the\n    grammar could be left-recursive; parser may need to enable\n    left recursion using :class:`ParserElement.enable_left_recursion<ParserElement.enable_left_recursion>`\n    \"\"\"\n\n    def __init__(self, parseElementList):\n        self.parseElementTrace = parseElementList\n\n    def __str__(self) -> str:\n        return f\"RecursiveGrammarException: {self.parseElementTrace}\"\n"},"hash":"IbvRkpbRLJ"}