{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:utils:compatibility_tags.py","body":"\"\"\"Generate and work with PEP 425 Compatibility Tags.\n\"\"\"\n\nimport re\nfrom typing import List, Optional, Tuple\n\nfrom pip._vendor.packaging.tags import (\n    PythonVersion,\n    Tag,\n    compatible_tags,\n    cpython_tags,\n    generic_tags,\n    interpreter_name,\n    interpreter_version,\n    mac_platforms,\n)\n\n_osx_arch_pat = re.compile(r\"(.+)_(\\d+)_(\\d+)_(.+)\")\n\n\ndef version_info_to_nodot(version_info: Tuple[int, ...]) -> str:\n    # Only use up to the first two numbers.\n    return \"\".join(map(str, version_info[:2]))\n\n\ndef _mac_platforms(arch: str) -> List[str]:\n    match = _osx_arch_pat.match(arch)\n    if match:\n        name, major, minor, actual_arch = match.groups()\n        mac_version = (int(major), int(minor))\n        arches = [\n            # Since we have always only checked that the platform starts\n            # with \"macosx\", for backwards-compatibility we extract the\n            # actual prefix provided by the user in case they provided\n            # something like \"macosxcustom_\". It may be good to remove\n            # this as undocumented or deprecate it in the future.\n            \"{}_{}\".format(name, arch[len(\"macosx_\") :])\n            for arch in mac_platforms(mac_version, actual_arch)\n        ]\n    else:\n        # arch pattern didn't match (?!)\n        arches = [arch]\n    return arches\n\n\ndef _custom_manylinux_platforms(arch: str) -> List[str]:\n    arches = [arch]\n    arch_prefix, arch_sep, arch_suffix = arch.partition(\"_\")\n    if arch_prefix == \"manylinux2014\":\n        # manylinux1/manylinux2010 wheels run on most manylinux2014 systems\n        # with the exception of wheels depending on ncurses. PEP 599 states\n        # manylinux1/manylinux2010 wheels should be considered\n        # manylinux2014 wheels:\n        # https://www.python.org/dev/peps/pep-0599/#backwards-compatibility-with-manylinux2010-wheels\n        if arch_suffix in {\"i686\", \"x86_64\"}:\n            arches.append(\"manylinux2010\" + arch_sep + arch_suffix)\n            arches.append(\"manylinux1\" + arch_sep + arch_suffix)\n    elif arch_prefix == \"manylinux2010\":\n        # manylinux1 wheels run on most manylinux2010 systems with the\n        # exception of wheels depending on ncurses. PEP 571 states\n        # manylinux1 wheels should be considered manylinux2010 wheels:\n        # https://www.python.org/dev/peps/pep-0571/#backwards-compatibility-with-manylinux1-wheels\n        arches.append(\"manylinux1\" + arch_sep + arch_suffix)\n    return arches\n\n\ndef _get_custom_platforms(arch: str) -> List[str]:\n    arch_prefix, arch_sep, arch_suffix = arch.partition(\"_\")\n    if arch.startswith(\"macosx\"):\n        arches = _mac_platforms(arch)\n    elif arch_prefix in [\"manylinux2014\", \"manylinux2010\"]:\n        arches = _custom_manylinux_platforms(arch)\n    else:\n        arches = [arch]\n    return arches\n\n\ndef _expand_allowed_platforms(platforms: Optional[List[str]]) -> Optional[List[str]]:\n    if not platforms:\n        return None\n\n    seen = set()\n    result = []\n\n    for p in platforms:\n        if p in seen:\n            continue\n        additions = [c for c in _get_custom_platforms(p) if c not in seen]\n        seen.update(additions)\n        result.extend(additions)\n\n    return result\n\n\ndef _get_python_version(version: str) -> PythonVersion:\n    if len(version) > 1:\n        return int(version[0]), int(version[1:])\n    else:\n        return (int(version[0]),)\n\n\ndef _get_custom_interpreter(\n    implementation: Optional[str] = None, version: Optional[str] = None\n) -> str:\n    if implementation is None:\n        implementation = interpreter_name()\n    if version is None:\n        version = interpreter_version()\n    return f\"{implementation}{version}\"\n\n\ndef get_supported(\n    version: Optional[str] = None,\n    platforms: Optional[List[str]] = None,\n    impl: Optional[str] = None,\n    abis: Optional[List[str]] = None,\n) -> List[Tag]:\n    \"\"\"Return a list of supported tags for each version specified in\n    `versions`.\n\n    :param version: a string version, of the form \"33\" or \"32\",\n        or None. The version will be assumed to support our ABI.\n    :param platform: specify a list of platforms you want valid\n        tags for, or None. If None, use the local system platform.\n    :param impl: specify the exact implementation you want valid\n        tags for, or None. If None, use the local interpreter impl.\n    :param abis: specify a list of abis you want valid\n        tags for, or None. If None, use the local interpreter abi.\n    \"\"\"\n    supported: List[Tag] = []\n\n    python_version: Optional[PythonVersion] = None\n    if version is not None:\n        python_version = _get_python_version(version)\n\n    interpreter = _get_custom_interpreter(impl, version)\n\n    platforms = _expand_allowed_platforms(platforms)\n\n    is_cpython = (impl or interpreter_name()) == \"cp\"\n    if is_cpython:\n        supported.extend(\n            cpython_tags(\n                python_version=python_version,\n                abis=abis,\n                platforms=platforms,\n            )\n        )\n    else:\n        supported.extend(\n            generic_tags(\n                interpreter=interpreter,\n                abis=abis,\n                platforms=platforms,\n            )\n        )\n    supported.extend(\n        compatible_tags(\n            python_version=python_version,\n            interpreter=interpreter,\n            platforms=platforms,\n        )\n    )\n\n    return supported\n"},"hash":"OBFUJC9gY8"}