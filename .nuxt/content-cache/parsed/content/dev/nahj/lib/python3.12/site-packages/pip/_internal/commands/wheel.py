{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:commands:wheel.py","body":"import logging\nimport os\nimport shutil\nfrom optparse import Values\nfrom typing import List\n\nfrom pip._internal.cache import WheelCache\nfrom pip._internal.cli import cmdoptions\nfrom pip._internal.cli.req_command import RequirementCommand, with_cleanup\nfrom pip._internal.cli.status_codes import SUCCESS\nfrom pip._internal.exceptions import CommandError\nfrom pip._internal.operations.build.build_tracker import get_build_tracker\nfrom pip._internal.req.req_install import (\n    InstallRequirement,\n    check_legacy_setup_py_options,\n)\nfrom pip._internal.utils.misc import ensure_dir, normalize_path\nfrom pip._internal.utils.temp_dir import TempDirectory\nfrom pip._internal.wheel_builder import build, should_build_for_wheel_command\n\nlogger = logging.getLogger(__name__)\n\n\nclass WheelCommand(RequirementCommand):\n    \"\"\"\n    Build Wheel archives for your requirements and dependencies.\n\n    Wheel is a built-package format, and offers the advantage of not\n    recompiling your software during every install. For more details, see the\n    wheel docs: https://wheel.readthedocs.io/en/latest/\n\n    'pip wheel' uses the build system interface as described here:\n    https://pip.pypa.io/en/stable/reference/build-system/\n\n    \"\"\"\n\n    usage = \"\"\"\n      %prog [options] <requirement specifier> ...\n      %prog [options] -r <requirements file> ...\n      %prog [options] [-e] <vcs project url> ...\n      %prog [options] [-e] <local project path> ...\n      %prog [options] <archive url/path> ...\"\"\"\n\n    def add_options(self) -> None:\n        self.cmd_opts.add_option(\n            \"-w\",\n            \"--wheel-dir\",\n            dest=\"wheel_dir\",\n            metavar=\"dir\",\n            default=os.curdir,\n            help=(\n                \"Build wheels into <dir>, where the default is the \"\n                \"current working directory.\"\n            ),\n        )\n        self.cmd_opts.add_option(cmdoptions.no_binary())\n        self.cmd_opts.add_option(cmdoptions.only_binary())\n        self.cmd_opts.add_option(cmdoptions.prefer_binary())\n        self.cmd_opts.add_option(cmdoptions.no_build_isolation())\n        self.cmd_opts.add_option(cmdoptions.use_pep517())\n        self.cmd_opts.add_option(cmdoptions.no_use_pep517())\n        self.cmd_opts.add_option(cmdoptions.check_build_deps())\n        self.cmd_opts.add_option(cmdoptions.constraints())\n        self.cmd_opts.add_option(cmdoptions.editable())\n        self.cmd_opts.add_option(cmdoptions.requirements())\n        self.cmd_opts.add_option(cmdoptions.src())\n        self.cmd_opts.add_option(cmdoptions.ignore_requires_python())\n        self.cmd_opts.add_option(cmdoptions.no_deps())\n        self.cmd_opts.add_option(cmdoptions.progress_bar())\n\n        self.cmd_opts.add_option(\n            \"--no-verify\",\n            dest=\"no_verify\",\n            action=\"store_true\",\n            default=False,\n            help=\"Don't verify if built wheel is valid.\",\n        )\n\n        self.cmd_opts.add_option(cmdoptions.config_settings())\n        self.cmd_opts.add_option(cmdoptions.build_options())\n        self.cmd_opts.add_option(cmdoptions.global_options())\n\n        self.cmd_opts.add_option(\n            \"--pre\",\n            action=\"store_true\",\n            default=False,\n            help=(\n                \"Include pre-release and development versions. By default, \"\n                \"pip only finds stable versions.\"\n            ),\n        )\n\n        self.cmd_opts.add_option(cmdoptions.require_hashes())\n\n        index_opts = cmdoptions.make_option_group(\n            cmdoptions.index_group,\n            self.parser,\n        )\n\n        self.parser.insert_option_group(0, index_opts)\n        self.parser.insert_option_group(0, self.cmd_opts)\n\n    @with_cleanup\n    def run(self, options: Values, args: List[str]) -> int:\n        session = self.get_default_session(options)\n\n        finder = self._build_package_finder(options, session)\n\n        options.wheel_dir = normalize_path(options.wheel_dir)\n        ensure_dir(options.wheel_dir)\n\n        build_tracker = self.enter_context(get_build_tracker())\n\n        directory = TempDirectory(\n            delete=not options.no_clean,\n            kind=\"wheel\",\n            globally_managed=True,\n        )\n\n        reqs = self.get_requirements(args, options, finder, session)\n        check_legacy_setup_py_options(options, reqs)\n\n        wheel_cache = WheelCache(options.cache_dir)\n\n        preparer = self.make_requirement_preparer(\n            temp_build_dir=directory,\n            options=options,\n            build_tracker=build_tracker,\n            session=session,\n            finder=finder,\n            download_dir=options.wheel_dir,\n            use_user_site=False,\n            verbosity=self.verbosity,\n        )\n\n        resolver = self.make_resolver(\n            preparer=preparer,\n            finder=finder,\n            options=options,\n            wheel_cache=wheel_cache,\n            ignore_requires_python=options.ignore_requires_python,\n            use_pep517=options.use_pep517,\n        )\n\n        self.trace_basic_info(finder)\n\n        requirement_set = resolver.resolve(reqs, check_supported_wheels=True)\n\n        reqs_to_build: List[InstallRequirement] = []\n        for req in requirement_set.requirements.values():\n            if req.is_wheel:\n                preparer.save_linked_requirement(req)\n            elif should_build_for_wheel_command(req):\n                reqs_to_build.append(req)\n\n        preparer.prepare_linked_requirements_more(requirement_set.requirements.values())\n        requirement_set.warn_legacy_versions_and_specifiers()\n\n        # build wheels\n        build_successes, build_failures = build(\n            reqs_to_build,\n            wheel_cache=wheel_cache,\n            verify=(not options.no_verify),\n            build_options=options.build_options or [],\n            global_options=options.global_options or [],\n        )\n        for req in build_successes:\n            assert req.link and req.link.is_wheel\n            assert req.local_file_path\n            # copy from cache to target directory\n            try:\n                shutil.copy(req.local_file_path, options.wheel_dir)\n            except OSError as e:\n                logger.warning(\n                    \"Building wheel for %s failed: %s\",\n                    req.name,\n                    e,\n                )\n                build_failures.append(req)\n        if len(build_failures) != 0:\n            raise CommandError(\"Failed to build one or more wheels\")\n\n        return SUCCESS\n"},"hash":"wPLEKTu7se"}