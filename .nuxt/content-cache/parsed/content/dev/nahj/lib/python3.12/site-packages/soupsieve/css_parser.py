{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:soupsieve:css_parser.py","body":"\"\"\"CSS selector parser.\"\"\"\nfrom __future__ import annotations\nimport re\nfrom functools import lru_cache\nfrom . import util\nfrom . import css_match as cm\nfrom . import css_types as ct\nfrom .util import SelectorSyntaxError\nimport warnings\nfrom typing import Match, Any, Iterator, cast\n\nUNICODE_REPLACEMENT_CHAR = 0xFFFD\n\n# Simple pseudo classes that take no parameters\nPSEUDO_SIMPLE = {\n    \":any-link\",\n    \":empty\",\n    \":first-child\",\n    \":first-of-type\",\n    \":in-range\",\n    \":out-of-range\",\n    \":last-child\",\n    \":last-of-type\",\n    \":link\",\n    \":only-child\",\n    \":only-of-type\",\n    \":root\",\n    ':checked',\n    ':default',\n    ':disabled',\n    ':enabled',\n    ':indeterminate',\n    ':optional',\n    ':placeholder-shown',\n    ':read-only',\n    ':read-write',\n    ':required',\n    ':scope',\n    ':defined'\n}\n\n# Supported, simple pseudo classes that match nothing in the Soup Sieve environment\nPSEUDO_SIMPLE_NO_MATCH = {\n    ':active',\n    ':current',\n    ':focus',\n    ':focus-visible',\n    ':focus-within',\n    ':future',\n    ':host',\n    ':hover',\n    ':local-link',\n    ':past',\n    ':paused',\n    ':playing',\n    ':target',\n    ':target-within',\n    ':user-invalid',\n    ':visited'\n}\n\n# Complex pseudo classes that take selector lists\nPSEUDO_COMPLEX = {\n    ':contains',\n    ':-soup-contains',\n    ':-soup-contains-own',\n    ':has',\n    ':is',\n    ':matches',\n    ':not',\n    ':where'\n}\n\nPSEUDO_COMPLEX_NO_MATCH = {\n    ':current',\n    ':host',\n    ':host-context'\n}\n\n# Complex pseudo classes that take very specific parameters and are handled special\nPSEUDO_SPECIAL = {\n    ':dir',\n    ':lang',\n    ':nth-child',\n    ':nth-last-child',\n    ':nth-last-of-type',\n    ':nth-of-type'\n}\n\nPSEUDO_SUPPORTED = PSEUDO_SIMPLE | PSEUDO_SIMPLE_NO_MATCH | PSEUDO_COMPLEX | PSEUDO_COMPLEX_NO_MATCH | PSEUDO_SPECIAL\n\n# Sub-patterns parts\n# Whitespace\nNEWLINE = r'(?:\\r\\n|(?!\\r\\n)[\\n\\f\\r])'\nWS = fr'(?:[ \\t]|{NEWLINE})'\n# Comments\nCOMMENTS = r'(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/)'\n# Whitespace with comments included\nWSC = fr'(?:{WS}|{COMMENTS})'\n# CSS escapes\nCSS_ESCAPES = fr'(?:\\\\(?:[a-f0-9]{{1,6}}{WS}?|[^\\r\\n\\f]|$))'\nCSS_STRING_ESCAPES = fr'(?:\\\\(?:[a-f0-9]{{1,6}}{WS}?|[^\\r\\n\\f]|$|{NEWLINE}))'\n# CSS Identifier\nIDENTIFIER = fr'''\n(?:(?:-?(?:[^\\x00-\\x2f\\x30-\\x40\\x5B-\\x5E\\x60\\x7B-\\x9f]|{CSS_ESCAPES})+|--)\n(?:[^\\x00-\\x2c\\x2e\\x2f\\x3A-\\x40\\x5B-\\x5E\\x60\\x7B-\\x9f]|{CSS_ESCAPES})*)\n'''\n# `nth` content\nNTH = fr'(?:[-+])?(?:[0-9]+n?|n)(?:(?<=n){WSC}*(?:[-+]){WSC}*(?:[0-9]+))?'\n# Value: quoted string or identifier\nVALUE = fr'''(?:\"(?:\\\\(?:.|{NEWLINE})|[^\\\\\"\\r\\n\\f]+)*?\"|'(?:\\\\(?:.|{NEWLINE})|[^\\\\'\\r\\n\\f]+)*?'|{IDENTIFIER}+)'''\n# Attribute value comparison. `!=` is handled special as it is non-standard.\nATTR = fr'(?:{WSC}*(?P<cmp>[!~^|*$]?=){WSC}*(?P<value>{VALUE})(?:{WSC}*(?P<case>[is]))?)?{WSC}*\\]'\n\n# Selector patterns\n# IDs (`#id`)\nPAT_ID = fr'\\#{IDENTIFIER}'\n# Classes (`.class`)\nPAT_CLASS = fr'\\.{IDENTIFIER}'\n# Prefix:Tag (`prefix|tag`)\nPAT_TAG = fr'(?P<tag_ns>(?:{IDENTIFIER}|\\*)?\\|)?(?P<tag_name>{IDENTIFIER}|\\*)'\n# Attributes (`[attr]`, `[attr=value]`, etc.)\nPAT_ATTR = fr'\\[{WSC}*(?P<attr_ns>(?:{IDENTIFIER}|\\*)?\\|)?(?P<attr_name>{IDENTIFIER}){ATTR}'\n# Pseudo class (`:pseudo-class`, `:pseudo-class(`)\nPAT_PSEUDO_CLASS = fr'(?P<name>:{IDENTIFIER})(?P<open>\\({WSC}*)?'\n# Pseudo class special patterns. Matches `:pseudo-class(` for special case pseudo classes.\nPAT_PSEUDO_CLASS_SPECIAL = fr'(?P<name>:{IDENTIFIER})(?P<open>\\({WSC}*)'\n# Custom pseudo class (`:--custom-pseudo`)\nPAT_PSEUDO_CLASS_CUSTOM = fr'(?P<name>:(?=--){IDENTIFIER})'\n# Closing pseudo group (`)`)\nPAT_PSEUDO_CLOSE = fr'{WSC}*\\)'\n# Pseudo element (`::pseudo-element`)\nPAT_PSEUDO_ELEMENT = fr':{PAT_PSEUDO_CLASS}'\n# At rule (`@page`, etc.) (not supported)\nPAT_AT_RULE = fr'@P{IDENTIFIER}'\n# Pseudo class `nth-child` (`:nth-child(an+b [of S]?)`, `:first-child`, etc.)\nPAT_PSEUDO_NTH_CHILD = fr'''\n(?P<pseudo_nth_child>{PAT_PSEUDO_CLASS_SPECIAL}\n(?P<nth_child>{NTH}|even|odd))(?:{WSC}*\\)|(?P<of>{COMMENTS}*{WS}{WSC}*of{COMMENTS}*{WS}{WSC}*))\n'''\n# Pseudo class `nth-of-type` (`:nth-of-type(an+b)`, `:first-of-type`, etc.)\nPAT_PSEUDO_NTH_TYPE = fr'''\n(?P<pseudo_nth_type>{PAT_PSEUDO_CLASS_SPECIAL}\n(?P<nth_type>{NTH}|even|odd)){WSC}*\\)\n'''\n# Pseudo class language (`:lang(\"*-de\", en)`)\nPAT_PSEUDO_LANG = fr'{PAT_PSEUDO_CLASS_SPECIAL}(?P<values>{VALUE}(?:{WSC}*,{WSC}*{VALUE})*){WSC}*\\)'\n# Pseudo class direction (`:dir(ltr)`)\nPAT_PSEUDO_DIR = fr'{PAT_PSEUDO_CLASS_SPECIAL}(?P<dir>ltr|rtl){WSC}*\\)'\n# Combining characters (`>`, `~`, ` `, `+`, `,`)\nPAT_COMBINE = fr'{WSC}*?(?P<relation>[,+>~]|{WS}(?![,+>~])){WSC}*'\n# Extra: Contains (`:contains(text)`)\nPAT_PSEUDO_CONTAINS = fr'{PAT_PSEUDO_CLASS_SPECIAL}(?P<values>{VALUE}(?:{WSC}*,{WSC}*{VALUE})*){WSC}*\\)'\n\n# Regular expressions\n# CSS escape pattern\nRE_CSS_ESC = re.compile(fr'(?:(\\\\[a-f0-9]{{1,6}}{WSC}?)|(\\\\[^\\r\\n\\f])|(\\\\$))', re.I)\nRE_CSS_STR_ESC = re.compile(fr'(?:(\\\\[a-f0-9]{{1,6}}{WS}?)|(\\\\[^\\r\\n\\f])|(\\\\$)|(\\\\{NEWLINE}))', re.I)\n# Pattern to break up `nth` specifiers\nRE_NTH = re.compile(fr'(?P<s1>[-+])?(?P<a>[0-9]+n?|n)(?:(?<=n){WSC}*(?P<s2>[-+]){WSC}*(?P<b>[0-9]+))?', re.I)\n# Pattern to iterate multiple values.\nRE_VALUES = re.compile(fr'(?:(?P<value>{VALUE})|(?P<split>{WSC}*,{WSC}*))', re.X)\n# Whitespace checks\nRE_WS = re.compile(WS)\nRE_WS_BEGIN = re.compile(fr'^{WSC}*')\nRE_WS_END = re.compile(fr'{WSC}*$')\nRE_CUSTOM = re.compile(fr'^{PAT_PSEUDO_CLASS_CUSTOM}$', re.X)\n\n# Constants\n# List split token\nCOMMA_COMBINATOR = ','\n# Relation token for descendant\nWS_COMBINATOR = \" \"\n\n# Parse flags\nFLG_PSEUDO = 0x01\nFLG_NOT = 0x02\nFLG_RELATIVE = 0x04\nFLG_DEFAULT = 0x08\nFLG_HTML = 0x10\nFLG_INDETERMINATE = 0x20\nFLG_OPEN = 0x40\nFLG_IN_RANGE = 0x80\nFLG_OUT_OF_RANGE = 0x100\nFLG_PLACEHOLDER_SHOWN = 0x200\nFLG_FORGIVE = 0x400\n\n# Maximum cached patterns to store\n_MAXCACHE = 500\n\n\n@lru_cache(maxsize=_MAXCACHE)\ndef _cached_css_compile(\n    pattern: str,\n    namespaces: ct.Namespaces | None,\n    custom: ct.CustomSelectors | None,\n    flags: int\n) -> cm.SoupSieve:\n    \"\"\"Cached CSS compile.\"\"\"\n\n    custom_selectors = process_custom(custom)\n    return cm.SoupSieve(\n        pattern,\n        CSSParser(\n            pattern,\n            custom=custom_selectors,\n            flags=flags\n        ).process_selectors(),\n        namespaces,\n        custom,\n        flags\n    )\n\n\ndef _purge_cache() -> None:\n    \"\"\"Purge the cache.\"\"\"\n\n    _cached_css_compile.cache_clear()\n\n\ndef process_custom(custom: ct.CustomSelectors | None) -> dict[str, str | ct.SelectorList]:\n    \"\"\"Process custom.\"\"\"\n\n    custom_selectors = {}\n    if custom is not None:\n        for key, value in custom.items():\n            name = util.lower(key)\n            if RE_CUSTOM.match(name) is None:\n                raise SelectorSyntaxError(f\"The name '{name}' is not a valid custom pseudo-class name\")\n            if name in custom_selectors:\n                raise KeyError(f\"The custom selector '{name}' has already been registered\")\n            custom_selectors[css_unescape(name)] = value\n    return custom_selectors\n\n\ndef css_unescape(content: str, string: bool = False) -> str:\n    \"\"\"\n    Unescape CSS value.\n\n    Strings allow for spanning the value on multiple strings by escaping a new line.\n    \"\"\"\n\n    def replace(m: Match[str]) -> str:\n        \"\"\"Replace with the appropriate substitute.\"\"\"\n\n        if m.group(1):\n            codepoint = int(m.group(1)[1:], 16)\n            if codepoint == 0:\n                codepoint = UNICODE_REPLACEMENT_CHAR\n            value = chr(codepoint)\n        elif m.group(2):\n            value = m.group(2)[1:]\n        elif m.group(3):\n            value = '\\ufffd'\n        else:\n            value = ''\n\n        return value\n\n    return (RE_CSS_ESC if not string else RE_CSS_STR_ESC).sub(replace, content)\n\n\ndef escape(ident: str) -> str:\n    \"\"\"Escape identifier.\"\"\"\n\n    string = []\n    length = len(ident)\n    start_dash = length > 0 and ident[0] == '-'\n    if length == 1 and start_dash:\n        # Need to escape identifier that is a single `-` with no other characters\n        string.append(f'\\\\{ident}')\n    else:\n        for index, c in enumerate(ident):\n            codepoint = ord(c)\n            if codepoint == 0x00:\n                string.append('\\ufffd')\n            elif (0x01 <= codepoint <= 0x1F) or codepoint == 0x7F:\n                string.append(f'\\\\{codepoint:x} ')\n            elif (index == 0 or (start_dash and index == 1)) and (0x30 <= codepoint <= 0x39):\n                string.append(f'\\\\{codepoint:x} ')\n            elif (\n                codepoint in (0x2D, 0x5F) or codepoint >= 0x80 or (0x30 <= codepoint <= 0x39) or\n                (0x30 <= codepoint <= 0x39) or (0x41 <= codepoint <= 0x5A) or (0x61 <= codepoint <= 0x7A)\n            ):\n                string.append(c)\n            else:\n                string.append(f'\\\\{c}')\n    return ''.join(string)\n\n\nclass SelectorPattern:\n    \"\"\"Selector pattern.\"\"\"\n\n    def __init__(self, name: str, pattern: str) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self.name = name\n        self.re_pattern = re.compile(pattern, re.I | re.X | re.U)\n\n    def get_name(self) -> str:\n        \"\"\"Get name.\"\"\"\n\n        return self.name\n\n    def match(self, selector: str, index: int, flags: int) -> Match[str] | None:\n        \"\"\"Match the selector.\"\"\"\n\n        return self.re_pattern.match(selector, index)\n\n\nclass SpecialPseudoPattern(SelectorPattern):\n    \"\"\"Selector pattern.\"\"\"\n\n    def __init__(self, patterns: tuple[tuple[str, tuple[str, ...], str, type[SelectorPattern]], ...]) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self.patterns = {}\n        for p in patterns:\n            name = p[0]\n            pattern = p[3](name, p[2])\n            for pseudo in p[1]:\n                self.patterns[pseudo] = pattern\n\n        self.matched_name = None  # type: SelectorPattern | None\n        self.re_pseudo_name = re.compile(PAT_PSEUDO_CLASS_SPECIAL, re.I | re.X | re.U)\n\n    def get_name(self) -> str:\n        \"\"\"Get name.\"\"\"\n\n        return '' if self.matched_name is None else self.matched_name.get_name()\n\n    def match(self, selector: str, index: int, flags: int) -> Match[str] | None:\n        \"\"\"Match the selector.\"\"\"\n\n        pseudo = None\n        m = self.re_pseudo_name.match(selector, index)\n        if m:\n            name = util.lower(css_unescape(m.group('name')))\n            pattern = self.patterns.get(name)\n            if pattern:\n                pseudo = pattern.match(selector, index, flags)\n                if pseudo:\n                    self.matched_name = pattern\n\n        return pseudo\n\n\nclass _Selector:\n    \"\"\"\n    Intermediate selector class.\n\n    This stores selector data for a compound selector as we are acquiring them.\n    Once we are done collecting the data for a compound selector, we freeze\n    the data in an object that can be pickled and hashed.\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self.tag = kwargs.get('tag', None)  # type: ct.SelectorTag | None\n        self.ids = kwargs.get('ids', [])  # type: list[str]\n        self.classes = kwargs.get('classes', [])  # type: list[str]\n        self.attributes = kwargs.get('attributes', [])  # type: list[ct.SelectorAttribute]\n        self.nth = kwargs.get('nth', [])  # type: list[ct.SelectorNth]\n        self.selectors = kwargs.get('selectors', [])  # type: list[ct.SelectorList]\n        self.relations = kwargs.get('relations', [])  # type: list[_Selector]\n        self.rel_type = kwargs.get('rel_type', None)  # type: str | None\n        self.contains = kwargs.get('contains', [])  # type: list[ct.SelectorContains]\n        self.lang = kwargs.get('lang', [])  # type: list[ct.SelectorLang]\n        self.flags = kwargs.get('flags', 0)  # type: int\n        self.no_match = kwargs.get('no_match', False)  # type: bool\n\n    def _freeze_relations(self, relations: list[_Selector]) -> ct.SelectorList:\n        \"\"\"Freeze relation.\"\"\"\n\n        if relations:\n            sel = relations[0]\n            sel.relations.extend(relations[1:])\n            return ct.SelectorList([sel.freeze()])\n        else:\n            return ct.SelectorList()\n\n    def freeze(self) -> ct.Selector | ct.SelectorNull:\n        \"\"\"Freeze self.\"\"\"\n\n        if self.no_match:\n            return ct.SelectorNull()\n        else:\n            return ct.Selector(\n                self.tag,\n                tuple(self.ids),\n                tuple(self.classes),\n                tuple(self.attributes),\n                tuple(self.nth),\n                tuple(self.selectors),\n                self._freeze_relations(self.relations),\n                self.rel_type,\n                tuple(self.contains),\n                tuple(self.lang),\n                self.flags\n            )\n\n    def __str__(self) -> str:  # pragma: no cover\n        \"\"\"String representation.\"\"\"\n\n        return (\n            f'_Selector(tag={self.tag!r}, ids={self.ids!r}, classes={self.classes!r}, attributes={self.attributes!r}, '\n            f'nth={self.nth!r}, selectors={self.selectors!r}, relations={self.relations!r}, '\n            f'rel_type={self.rel_type!r}, contains={self.contains!r}, lang={self.lang!r}, flags={self.flags!r}, '\n            f'no_match={self.no_match!r})'\n        )\n\n    __repr__ = __str__\n\n\nclass CSSParser:\n    \"\"\"Parse CSS selectors.\"\"\"\n\n    css_tokens = (\n        SelectorPattern(\"pseudo_close\", PAT_PSEUDO_CLOSE),\n        SpecialPseudoPattern(\n            (\n                (\n                    \"pseudo_contains\",\n                    (':contains', ':-soup-contains', ':-soup-contains-own'),\n                    PAT_PSEUDO_CONTAINS,\n                    SelectorPattern\n                ),\n                (\"pseudo_nth_child\", (':nth-child', ':nth-last-child'), PAT_PSEUDO_NTH_CHILD, SelectorPattern),\n                (\"pseudo_nth_type\", (':nth-of-type', ':nth-last-of-type'), PAT_PSEUDO_NTH_TYPE, SelectorPattern),\n                (\"pseudo_lang\", (':lang',), PAT_PSEUDO_LANG, SelectorPattern),\n                (\"pseudo_dir\", (':dir',), PAT_PSEUDO_DIR, SelectorPattern)\n            )\n        ),\n        SelectorPattern(\"pseudo_class_custom\", PAT_PSEUDO_CLASS_CUSTOM),\n        SelectorPattern(\"pseudo_class\", PAT_PSEUDO_CLASS),\n        SelectorPattern(\"pseudo_element\", PAT_PSEUDO_ELEMENT),\n        SelectorPattern(\"at_rule\", PAT_AT_RULE),\n        SelectorPattern(\"id\", PAT_ID),\n        SelectorPattern(\"class\", PAT_CLASS),\n        SelectorPattern(\"tag\", PAT_TAG),\n        SelectorPattern(\"attribute\", PAT_ATTR),\n        SelectorPattern(\"combine\", PAT_COMBINE)\n    )\n\n    def __init__(\n        self,\n        selector: str,\n        custom: dict[str, str | ct.SelectorList] | None = None,\n        flags: int = 0\n    ) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self.pattern = selector.replace('\\x00', '\\ufffd')\n        self.flags = flags\n        self.debug = self.flags & util.DEBUG\n        self.custom = {} if custom is None else custom\n\n    def parse_attribute_selector(self, sel: _Selector, m: Match[str], has_selector: bool) -> bool:\n        \"\"\"Create attribute selector from the returned regex match.\"\"\"\n\n        inverse = False\n        op = m.group('cmp')\n        case = util.lower(m.group('case')) if m.group('case') else None\n        ns = css_unescape(m.group('attr_ns')[:-1]) if m.group('attr_ns') else ''\n        attr = css_unescape(m.group('attr_name'))\n        is_type = False\n        pattern2 = None\n        value = ''\n\n        if case:\n            flags = (re.I if case == 'i' else 0) | re.DOTALL\n        elif util.lower(attr) == 'type':\n            flags = re.I | re.DOTALL\n            is_type = True\n        else:\n            flags = re.DOTALL\n\n        if op:\n            if m.group('value').startswith(('\"', \"'\")):\n                value = css_unescape(m.group('value')[1:-1], True)\n            else:\n                value = css_unescape(m.group('value'))\n\n        if not op:\n            # Attribute name\n            pattern = None\n        elif op.startswith('^'):\n            # Value start with\n            pattern = re.compile(r'^%s.*' % re.escape(value), flags)\n        elif op.startswith('$'):\n            # Value ends with\n            pattern = re.compile(r'.*?%s$' % re.escape(value), flags)\n        elif op.startswith('*'):\n            # Value contains\n            pattern = re.compile(r'.*?%s.*' % re.escape(value), flags)\n        elif op.startswith('~'):\n            # Value contains word within space separated list\n            # `~=` should match nothing if it is empty or contains whitespace,\n            # so if either of these cases is present, use `[^\\s\\S]` which cannot be matched.\n            value = r'[^\\s\\S]' if not value or RE_WS.search(value) else re.escape(value)\n            pattern = re.compile(r'.*?(?:(?<=^)|(?<=[ \\t\\r\\n\\f]))%s(?=(?:[ \\t\\r\\n\\f]|$)).*' % value, flags)\n        elif op.startswith('|'):\n            # Value starts with word in dash separated list\n            pattern = re.compile(r'^%s(?:-.*)?$' % re.escape(value), flags)\n        else:\n            # Value matches\n            pattern = re.compile(r'^%s$' % re.escape(value), flags)\n            if op.startswith('!'):\n                # Equivalent to `:not([attr=value])`\n                inverse = True\n        if is_type and pattern:\n            pattern2 = re.compile(pattern.pattern)\n\n        # Append the attribute selector\n        sel_attr = ct.SelectorAttribute(attr, ns, pattern, pattern2)\n        if inverse:\n            # If we are using `!=`, we need to nest the pattern under a `:not()`.\n            sub_sel = _Selector()\n            sub_sel.attributes.append(sel_attr)\n            not_list = ct.SelectorList([sub_sel.freeze()], True, False)\n            sel.selectors.append(not_list)\n        else:\n            sel.attributes.append(sel_attr)\n\n        has_selector = True\n        return has_selector\n\n    def parse_tag_pattern(self, sel: _Selector, m: Match[str], has_selector: bool) -> bool:\n        \"\"\"Parse tag pattern from regex match.\"\"\"\n\n        prefix = css_unescape(m.group('tag_ns')[:-1]) if m.group('tag_ns') else None\n        tag = css_unescape(m.group('tag_name'))\n        sel.tag = ct.SelectorTag(tag, prefix)\n        has_selector = True\n        return has_selector\n\n    def parse_pseudo_class_custom(self, sel: _Selector, m: Match[str], has_selector: bool) -> bool:\n        \"\"\"\n        Parse custom pseudo class alias.\n\n        Compile custom selectors as we need them. When compiling a custom selector,\n        set it to `None` in the dictionary so we can avoid an infinite loop.\n        \"\"\"\n\n        pseudo = util.lower(css_unescape(m.group('name')))\n        selector = self.custom.get(pseudo)\n        if selector is None:\n            raise SelectorSyntaxError(\n                f\"Undefined custom selector '{pseudo}' found at position {m.end(0)}\",\n                self.pattern,\n                m.end(0)\n            )\n\n        if not isinstance(selector, ct.SelectorList):\n            del self.custom[pseudo]\n            selector = CSSParser(\n                selector, custom=self.custom, flags=self.flags\n            ).process_selectors(flags=FLG_PSEUDO)\n            self.custom[pseudo] = selector\n\n        sel.selectors.append(selector)\n        has_selector = True\n        return has_selector\n\n    def parse_pseudo_class(\n        self,\n        sel: _Selector,\n        m: Match[str],\n        has_selector: bool,\n        iselector: Iterator[tuple[str, Match[str]]],\n        is_html: bool\n    ) -> tuple[bool, bool]:\n        \"\"\"Parse pseudo class.\"\"\"\n\n        complex_pseudo = False\n        pseudo = util.lower(css_unescape(m.group('name')))\n        if m.group('open'):\n            complex_pseudo = True\n        if complex_pseudo and pseudo in PSEUDO_COMPLEX:\n            has_selector = self.parse_pseudo_open(sel, pseudo, has_selector, iselector, m.end(0))\n        elif not complex_pseudo and pseudo in PSEUDO_SIMPLE:\n            if pseudo == ':root':\n                sel.flags |= ct.SEL_ROOT\n            elif pseudo == ':defined':\n                sel.flags |= ct.SEL_DEFINED\n                is_html = True\n            elif pseudo == ':scope':\n                sel.flags |= ct.SEL_SCOPE\n            elif pseudo == ':empty':\n                sel.flags |= ct.SEL_EMPTY\n            elif pseudo in (':link', ':any-link'):\n                sel.selectors.append(CSS_LINK)\n            elif pseudo == ':checked':\n                sel.selectors.append(CSS_CHECKED)\n            elif pseudo == ':default':\n                sel.selectors.append(CSS_DEFAULT)\n            elif pseudo == ':indeterminate':\n                sel.selectors.append(CSS_INDETERMINATE)\n            elif pseudo == \":disabled\":\n                sel.selectors.append(CSS_DISABLED)\n            elif pseudo == \":enabled\":\n                sel.selectors.append(CSS_ENABLED)\n            elif pseudo == \":required\":\n                sel.selectors.append(CSS_REQUIRED)\n            elif pseudo == \":optional\":\n                sel.selectors.append(CSS_OPTIONAL)\n            elif pseudo == \":read-only\":\n                sel.selectors.append(CSS_READ_ONLY)\n            elif pseudo == \":read-write\":\n                sel.selectors.append(CSS_READ_WRITE)\n            elif pseudo == \":in-range\":\n                sel.selectors.append(CSS_IN_RANGE)\n            elif pseudo == \":out-of-range\":\n                sel.selectors.append(CSS_OUT_OF_RANGE)\n            elif pseudo == \":placeholder-shown\":\n                sel.selectors.append(CSS_PLACEHOLDER_SHOWN)\n            elif pseudo == ':first-child':\n                sel.nth.append(ct.SelectorNth(1, False, 0, False, False, ct.SelectorList()))\n            elif pseudo == ':last-child':\n                sel.nth.append(ct.SelectorNth(1, False, 0, False, True, ct.SelectorList()))\n            elif pseudo == ':first-of-type':\n                sel.nth.append(ct.SelectorNth(1, False, 0, True, False, ct.SelectorList()))\n            elif pseudo == ':last-of-type':\n                sel.nth.append(ct.SelectorNth(1, False, 0, True, True, ct.SelectorList()))\n            elif pseudo == ':only-child':\n                sel.nth.extend(\n                    [\n                        ct.SelectorNth(1, False, 0, False, False, ct.SelectorList()),\n                        ct.SelectorNth(1, False, 0, False, True, ct.SelectorList())\n                    ]\n                )\n            elif pseudo == ':only-of-type':\n                sel.nth.extend(\n                    [\n                        ct.SelectorNth(1, False, 0, True, False, ct.SelectorList()),\n                        ct.SelectorNth(1, False, 0, True, True, ct.SelectorList())\n                    ]\n                )\n            has_selector = True\n        elif complex_pseudo and pseudo in PSEUDO_COMPLEX_NO_MATCH:\n            self.parse_selectors(iselector, m.end(0), FLG_PSEUDO | FLG_OPEN)\n            sel.no_match = True\n            has_selector = True\n        elif not complex_pseudo and pseudo in PSEUDO_SIMPLE_NO_MATCH:\n            sel.no_match = True\n            has_selector = True\n        elif pseudo in PSEUDO_SUPPORTED:\n            raise SelectorSyntaxError(\n                f\"Invalid syntax for pseudo class '{pseudo}'\",\n                self.pattern,\n                m.start(0)\n            )\n        else:\n            raise NotImplementedError(\n                f\"'{pseudo}' pseudo-class is not implemented at this time\"\n            )\n\n        return has_selector, is_html\n\n    def parse_pseudo_nth(\n        self,\n        sel: _Selector,\n        m: Match[str],\n        has_selector: bool,\n        iselector: Iterator[tuple[str, Match[str]]]\n    ) -> bool:\n        \"\"\"Parse `nth` pseudo.\"\"\"\n\n        mdict = m.groupdict()\n        if mdict.get('pseudo_nth_child'):\n            postfix = '_child'\n        else:\n            postfix = '_type'\n        mdict['name'] = util.lower(css_unescape(mdict['name']))\n        content = util.lower(mdict.get('nth' + postfix))\n        if content == 'even':\n            # 2n\n            s1 = 2\n            s2 = 0\n            var = True\n        elif content == 'odd':\n            # 2n+1\n            s1 = 2\n            s2 = 1\n            var = True\n        else:\n            nth_parts = cast(Match[str], RE_NTH.match(content))\n            _s1 = '-' if nth_parts.group('s1') and nth_parts.group('s1') == '-' else ''\n            a = nth_parts.group('a')\n            var = a.endswith('n')\n            if a.startswith('n'):\n                _s1 += '1'\n            elif var:\n                _s1 += a[:-1]\n            else:\n                _s1 += a\n            _s2 = '-' if nth_parts.group('s2') and nth_parts.group('s2') == '-' else ''\n            if nth_parts.group('b'):\n                _s2 += nth_parts.group('b')\n            else:\n                _s2 = '0'\n            s1 = int(_s1, 10)\n            s2 = int(_s2, 10)\n\n        pseudo_sel = mdict['name']\n        if postfix == '_child':\n            if m.group('of'):\n                # Parse the rest of `of S`.\n                nth_sel = self.parse_selectors(iselector, m.end(0), FLG_PSEUDO | FLG_OPEN)\n            else:\n                # Use default `*|*` for `of S`.\n                nth_sel = CSS_NTH_OF_S_DEFAULT\n            if pseudo_sel == ':nth-child':\n                sel.nth.append(ct.SelectorNth(s1, var, s2, False, False, nth_sel))\n            elif pseudo_sel == ':nth-last-child':\n                sel.nth.append(ct.SelectorNth(s1, var, s2, False, True, nth_sel))\n        else:\n            if pseudo_sel == ':nth-of-type':\n                sel.nth.append(ct.SelectorNth(s1, var, s2, True, False, ct.SelectorList()))\n            elif pseudo_sel == ':nth-last-of-type':\n                sel.nth.append(ct.SelectorNth(s1, var, s2, True, True, ct.SelectorList()))\n        has_selector = True\n        return has_selector\n\n    def parse_pseudo_open(\n        self,\n        sel: _Selector,\n        name: str,\n        has_selector: bool,\n        iselector: Iterator[tuple[str, Match[str]]],\n        index: int\n    ) -> bool:\n        \"\"\"Parse pseudo with opening bracket.\"\"\"\n\n        flags = FLG_PSEUDO | FLG_OPEN\n        if name == ':not':\n            flags |= FLG_NOT\n        elif name == ':has':\n            flags |= FLG_RELATIVE\n        elif name in (':where', ':is'):\n            flags |= FLG_FORGIVE\n\n        sel.selectors.append(self.parse_selectors(iselector, index, flags))\n        has_selector = True\n\n        return has_selector\n\n    def parse_has_combinator(\n        self,\n        sel: _Selector,\n        m: Match[str],\n        has_selector: bool,\n        selectors: list[_Selector],\n        rel_type: str,\n        index: int\n    ) -> tuple[bool, _Selector, str]:\n        \"\"\"Parse combinator tokens.\"\"\"\n\n        combinator = m.group('relation').strip()\n        if not combinator:\n            combinator = WS_COMBINATOR\n        if combinator == COMMA_COMBINATOR:\n            sel.rel_type = rel_type\n            selectors[-1].relations.append(sel)\n            rel_type = \":\" + WS_COMBINATOR\n            selectors.append(_Selector())\n        else:\n            if has_selector:\n                # End the current selector and associate the leading combinator with this selector.\n                sel.rel_type = rel_type\n                selectors[-1].relations.append(sel)\n            elif rel_type[1:] != WS_COMBINATOR:\n                # It's impossible to have two whitespace combinators after each other as the patterns\n                # will gobble up trailing whitespace. It is also impossible to have a whitespace\n                # combinator after any other kind for the same reason. But we could have\n                # multiple non-whitespace combinators. So if the current combinator is not a whitespace,\n                # then we've hit the multiple combinator case, so we should fail.\n                raise SelectorSyntaxError(\n                    f'The multiple combinators at position {index}',\n                    self.pattern,\n                    index\n                )\n\n            # Set the leading combinator for the next selector.\n            rel_type = ':' + combinator\n\n        sel = _Selector()\n        has_selector = False\n        return has_selector, sel, rel_type\n\n    def parse_combinator(\n        self,\n        sel: _Selector,\n        m: Match[str],\n        has_selector: bool,\n        selectors: list[_Selector],\n        relations: list[_Selector],\n        is_pseudo: bool,\n        is_forgive: bool,\n        index: int\n    ) -> tuple[bool, _Selector]:\n        \"\"\"Parse combinator tokens.\"\"\"\n\n        combinator = m.group('relation').strip()\n        if not combinator:\n            combinator = WS_COMBINATOR\n        if not has_selector:\n            if not is_forgive or combinator != COMMA_COMBINATOR:\n                raise SelectorSyntaxError(\n                    f\"The combinator '{combinator}' at position {index}, must have a selector before it\",\n                    self.pattern,\n                    index\n                )\n\n            # If we are in a forgiving pseudo class, just make the selector a \"no match\"\n            if combinator == COMMA_COMBINATOR:\n                sel.no_match = True\n                del relations[:]\n                selectors.append(sel)\n        else:\n            if combinator == COMMA_COMBINATOR:\n                if not sel.tag and not is_pseudo:\n                    # Implied `*`\n                    sel.tag = ct.SelectorTag('*', None)\n                sel.relations.extend(relations)\n                selectors.append(sel)\n                del relations[:]\n            else:\n                sel.relations.extend(relations)\n                sel.rel_type = combinator\n                del relations[:]\n                relations.append(sel)\n\n        sel = _Selector()\n        has_selector = False\n\n        return has_selector, sel\n\n    def parse_class_id(self, sel: _Selector, m: Match[str], has_selector: bool) -> bool:\n        \"\"\"Parse HTML classes and ids.\"\"\"\n\n        selector = m.group(0)\n        if selector.startswith('.'):\n            sel.classes.append(css_unescape(selector[1:]))\n        else:\n            sel.ids.append(css_unescape(selector[1:]))\n        has_selector = True\n        return has_selector\n\n    def parse_pseudo_contains(self, sel: _Selector, m: Match[str], has_selector: bool) -> bool:\n        \"\"\"Parse contains.\"\"\"\n\n        pseudo = util.lower(css_unescape(m.group('name')))\n        if pseudo == \":contains\":\n            warnings.warn(  # noqa: B028\n                \"The pseudo class ':contains' is deprecated, ':-soup-contains' should be used moving forward.\",\n                FutureWarning\n            )\n        contains_own = pseudo == \":-soup-contains-own\"\n        values = css_unescape(m.group('values'))\n        patterns = []\n        for token in RE_VALUES.finditer(values):\n            if token.group('split'):\n                continue\n            value = token.group('value')\n            if value.startswith((\"'\", '\"')):\n                value = css_unescape(value[1:-1], True)\n            else:\n                value = css_unescape(value)\n            patterns.append(value)\n        sel.contains.append(ct.SelectorContains(patterns, contains_own))\n        has_selector = True\n        return has_selector\n\n    def parse_pseudo_lang(self, sel: _Selector, m: Match[str], has_selector: bool) -> bool:\n        \"\"\"Parse pseudo language.\"\"\"\n\n        values = m.group('values')\n        patterns = []\n        for token in RE_VALUES.finditer(values):\n            if token.group('split'):\n                continue\n            value = token.group('value')\n            if value.startswith(('\"', \"'\")):\n                value = css_unescape(value[1:-1], True)\n            else:\n                value = css_unescape(value)\n\n            patterns.append(value)\n\n        sel.lang.append(ct.SelectorLang(patterns))\n        has_selector = True\n\n        return has_selector\n\n    def parse_pseudo_dir(self, sel: _Selector, m: Match[str], has_selector: bool) -> bool:\n        \"\"\"Parse pseudo direction.\"\"\"\n\n        value = ct.SEL_DIR_LTR if util.lower(m.group('dir')) == 'ltr' else ct.SEL_DIR_RTL\n        sel.flags |= value\n        has_selector = True\n        return has_selector\n\n    def parse_selectors(\n        self,\n        iselector: Iterator[tuple[str, Match[str]]],\n        index: int = 0,\n        flags: int = 0\n    ) -> ct.SelectorList:\n        \"\"\"Parse selectors.\"\"\"\n\n        # Initialize important variables\n        sel = _Selector()\n        selectors = []\n        has_selector = False\n        closed = False\n        relations = []  # type: list[_Selector]\n        rel_type = \":\" + WS_COMBINATOR\n\n        # Setup various flags\n        is_open = bool(flags & FLG_OPEN)\n        is_pseudo = bool(flags & FLG_PSEUDO)\n        is_relative = bool(flags & FLG_RELATIVE)\n        is_not = bool(flags & FLG_NOT)\n        is_html = bool(flags & FLG_HTML)\n        is_default = bool(flags & FLG_DEFAULT)\n        is_indeterminate = bool(flags & FLG_INDETERMINATE)\n        is_in_range = bool(flags & FLG_IN_RANGE)\n        is_out_of_range = bool(flags & FLG_OUT_OF_RANGE)\n        is_placeholder_shown = bool(flags & FLG_PLACEHOLDER_SHOWN)\n        is_forgive = bool(flags & FLG_FORGIVE)\n\n        # Print out useful debug stuff\n        if self.debug:  # pragma: no cover\n            if is_pseudo:\n                print('    is_pseudo: True')\n            if is_open:\n                print('    is_open: True')\n            if is_relative:\n                print('    is_relative: True')\n            if is_not:\n                print('    is_not: True')\n            if is_html:\n                print('    is_html: True')\n            if is_default:\n                print('    is_default: True')\n            if is_indeterminate:\n                print('    is_indeterminate: True')\n            if is_in_range:\n                print('    is_in_range: True')\n            if is_out_of_range:\n                print('    is_out_of_range: True')\n            if is_placeholder_shown:\n                print('    is_placeholder_shown: True')\n            if is_forgive:\n                print('    is_forgive: True')\n\n        # The algorithm for relative selectors require an initial selector in the selector list\n        if is_relative:\n            selectors.append(_Selector())\n\n        try:\n            while True:\n                key, m = next(iselector)\n\n                # Handle parts\n                if key == \"at_rule\":\n                    raise NotImplementedError(f\"At-rules found at position {m.start(0)}\")\n                elif key == 'pseudo_class_custom':\n                    has_selector = self.parse_pseudo_class_custom(sel, m, has_selector)\n                elif key == 'pseudo_class':\n                    has_selector, is_html = self.parse_pseudo_class(sel, m, has_selector, iselector, is_html)\n                elif key == 'pseudo_element':\n                    raise NotImplementedError(f\"Pseudo-element found at position {m.start(0)}\")\n                elif key == 'pseudo_contains':\n                    has_selector = self.parse_pseudo_contains(sel, m, has_selector)\n                elif key in ('pseudo_nth_type', 'pseudo_nth_child'):\n                    has_selector = self.parse_pseudo_nth(sel, m, has_selector, iselector)\n                elif key == 'pseudo_lang':\n                    has_selector = self.parse_pseudo_lang(sel, m, has_selector)\n                elif key == 'pseudo_dir':\n                    has_selector = self.parse_pseudo_dir(sel, m, has_selector)\n                    # Currently only supports HTML\n                    is_html = True\n                elif key == 'pseudo_close':\n                    if not has_selector:\n                        if not is_forgive:\n                            raise SelectorSyntaxError(\n                                f\"Expected a selector at position {m.start(0)}\",\n                                self.pattern,\n                                m.start(0)\n                            )\n                        sel.no_match = True\n                    if is_open:\n                        closed = True\n                        break\n                    else:\n                        raise SelectorSyntaxError(\n                            f\"Unmatched pseudo-class close at position {m.start(0)}\",\n                            self.pattern,\n                            m.start(0)\n                        )\n                elif key == 'combine':\n                    if is_relative:\n                        has_selector, sel, rel_type = self.parse_has_combinator(\n                            sel, m, has_selector, selectors, rel_type, index\n                        )\n                    else:\n                        has_selector, sel = self.parse_combinator(\n                            sel, m, has_selector, selectors, relations, is_pseudo, is_forgive, index\n                        )\n                elif key == 'attribute':\n                    has_selector = self.parse_attribute_selector(sel, m, has_selector)\n                elif key == 'tag':\n                    if has_selector:\n                        raise SelectorSyntaxError(\n                            f\"Tag name found at position {m.start(0)} instead of at the start\",\n                            self.pattern,\n                            m.start(0)\n                        )\n                    has_selector = self.parse_tag_pattern(sel, m, has_selector)\n                elif key in ('class', 'id'):\n                    has_selector = self.parse_class_id(sel, m, has_selector)\n\n                index = m.end(0)\n        except StopIteration:\n            pass\n\n        # Handle selectors that are not closed\n        if is_open and not closed:\n            raise SelectorSyntaxError(\n                f\"Unclosed pseudo-class at position {index}\",\n                self.pattern,\n                index\n            )\n\n        # Cleanup completed selector piece\n        if has_selector:\n            if not sel.tag and not is_pseudo:\n                # Implied `*`\n                sel.tag = ct.SelectorTag('*', None)\n            if is_relative:\n                sel.rel_type = rel_type\n                selectors[-1].relations.append(sel)\n            else:\n                sel.relations.extend(relations)\n                del relations[:]\n                selectors.append(sel)\n\n        # Forgive empty slots in pseudo-classes that have lists (and are forgiving)\n        elif is_forgive and (not selectors or not relations):\n            # Handle normal pseudo-classes with empty slots like `:is()` etc.\n            sel.no_match = True\n            del relations[:]\n            selectors.append(sel)\n            has_selector = True\n\n        if not has_selector:\n            # We will always need to finish a selector when `:has()` is used as it leads with combining.\n            # May apply to others as well.\n            raise SelectorSyntaxError(\n                f'Expected a selector at position {index}',\n                self.pattern,\n                index\n            )\n\n        # Some patterns require additional logic, such as default. We try to make these the\n        # last pattern, and append the appropriate flag to that selector which communicates\n        # to the matcher what additional logic is required.\n        if is_default:\n            selectors[-1].flags = ct.SEL_DEFAULT\n        if is_indeterminate:\n            selectors[-1].flags = ct.SEL_INDETERMINATE\n        if is_in_range:\n            selectors[-1].flags = ct.SEL_IN_RANGE\n        if is_out_of_range:\n            selectors[-1].flags = ct.SEL_OUT_OF_RANGE\n        if is_placeholder_shown:\n            selectors[-1].flags = ct.SEL_PLACEHOLDER_SHOWN\n\n        # Return selector list\n        return ct.SelectorList([s.freeze() for s in selectors], is_not, is_html)\n\n    def selector_iter(self, pattern: str) -> Iterator[tuple[str, Match[str]]]:\n        \"\"\"Iterate selector tokens.\"\"\"\n\n        # Ignore whitespace and comments at start and end of pattern\n        m = RE_WS_BEGIN.search(pattern)\n        index = m.end(0) if m else 0\n        m = RE_WS_END.search(pattern)\n        end = (m.start(0) - 1) if m else (len(pattern) - 1)\n\n        if self.debug:  # pragma: no cover\n            print(f'## PARSING: {pattern!r}')\n        while index <= end:\n            m = None\n            for v in self.css_tokens:\n                m = v.match(pattern, index, self.flags)\n                if m:\n                    name = v.get_name()\n                    if self.debug:  # pragma: no cover\n                        print(f\"TOKEN: '{name}' --> {m.group(0)!r} at position {m.start(0)}\")\n                    index = m.end(0)\n                    yield name, m\n                    break\n            if m is None:\n                c = pattern[index]\n                # If the character represents the start of one of the known selector types,\n                # throw an exception mentioning that the known selector type is in error;\n                # otherwise, report the invalid character.\n                if c == '[':\n                    msg = f\"Malformed attribute selector at position {index}\"\n                elif c == '.':\n                    msg = f\"Malformed class selector at position {index}\"\n                elif c == '#':\n                    msg = f\"Malformed id selector at position {index}\"\n                elif c == ':':\n                    msg = f\"Malformed pseudo-class selector at position {index}\"\n                else:\n                    msg = f\"Invalid character {c!r} position {index}\"\n                raise SelectorSyntaxError(msg, self.pattern, index)\n        if self.debug:  # pragma: no cover\n            print('## END PARSING')\n\n    def process_selectors(self, index: int = 0, flags: int = 0) -> ct.SelectorList:\n        \"\"\"Process selectors.\"\"\"\n\n        return self.parse_selectors(self.selector_iter(self.pattern), index, flags)\n\n\n# Precompile CSS selector lists for pseudo-classes (additional logic may be required beyond the pattern)\n# A few patterns are order dependent as they use patterns previous compiled.\n\n# CSS pattern for `:link` and `:any-link`\nCSS_LINK = CSSParser(\n    'html|*:is(a, area)[href]'\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:checked`\nCSS_CHECKED = CSSParser(\n    '''\n    html|*:is(input[type=checkbox], input[type=radio])[checked], html|option[selected]\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:default` (must compile CSS_CHECKED first)\nCSS_DEFAULT = CSSParser(\n    '''\n    :checked,\n\n    /*\n    This pattern must be at the end.\n    Special logic is applied to the last selector.\n    */\n    html|form html|*:is(button, input)[type=\"submit\"]\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML | FLG_DEFAULT)\n# CSS pattern for `:indeterminate`\nCSS_INDETERMINATE = CSSParser(\n    '''\n    html|input[type=\"checkbox\"][indeterminate],\n    html|input[type=\"radio\"]:is(:not([name]), [name=\"\"]):not([checked]),\n    html|progress:not([value]),\n\n    /*\n    This pattern must be at the end.\n    Special logic is applied to the last selector.\n    */\n    html|input[type=\"radio\"][name]:not([name='']):not([checked])\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML | FLG_INDETERMINATE)\n# CSS pattern for `:disabled`\nCSS_DISABLED = CSSParser(\n    '''\n    html|*:is(input:not([type=hidden]), button, select, textarea, fieldset, optgroup, option, fieldset)[disabled],\n    html|optgroup[disabled] > html|option,\n    html|fieldset[disabled] > html|*:is(input:not([type=hidden]), button, select, textarea, fieldset),\n    html|fieldset[disabled] >\n        html|*:not(legend:nth-of-type(1)) html|*:is(input:not([type=hidden]), button, select, textarea, fieldset)\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:enabled`\nCSS_ENABLED = CSSParser(\n    '''\n    html|*:is(input:not([type=hidden]), button, select, textarea, fieldset, optgroup, option, fieldset):not(:disabled)\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:required`\nCSS_REQUIRED = CSSParser(\n    'html|*:is(input, textarea, select)[required]'\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:optional`\nCSS_OPTIONAL = CSSParser(\n    'html|*:is(input, textarea, select):not([required])'\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:placeholder-shown`\nCSS_PLACEHOLDER_SHOWN = CSSParser(\n    '''\n    html|input:is(\n        :not([type]),\n        [type=\"\"],\n        [type=text],\n        [type=search],\n        [type=url],\n        [type=tel],\n        [type=email],\n        [type=password],\n        [type=number]\n    )[placeholder]:not([placeholder='']):is(:not([value]), [value=\"\"]),\n    html|textarea[placeholder]:not([placeholder=''])\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML | FLG_PLACEHOLDER_SHOWN)\n# CSS pattern default for `:nth-child` \"of S\" feature\nCSS_NTH_OF_S_DEFAULT = CSSParser(\n    '*|*'\n).process_selectors(flags=FLG_PSEUDO)\n# CSS pattern for `:read-write` (CSS_DISABLED must be compiled first)\nCSS_READ_WRITE = CSSParser(\n    '''\n    html|*:is(\n        textarea,\n        input:is(\n            :not([type]),\n            [type=\"\"],\n            [type=text],\n            [type=search],\n            [type=url],\n            [type=tel],\n            [type=email],\n            [type=number],\n            [type=password],\n            [type=date],\n            [type=datetime-local],\n            [type=month],\n            [type=time],\n            [type=week]\n        )\n    ):not([readonly], :disabled),\n    html|*:is([contenteditable=\"\"], [contenteditable=\"true\" i])\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:read-only`\nCSS_READ_ONLY = CSSParser(\n    '''\n    html|*:not(:read-write)\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_HTML)\n# CSS pattern for `:in-range`\nCSS_IN_RANGE = CSSParser(\n    '''\n    html|input:is(\n        [type=\"date\"],\n        [type=\"month\"],\n        [type=\"week\"],\n        [type=\"time\"],\n        [type=\"datetime-local\"],\n        [type=\"number\"],\n        [type=\"range\"]\n    ):is(\n        [min],\n        [max]\n    )\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_IN_RANGE | FLG_HTML)\n# CSS pattern for `:out-of-range`\nCSS_OUT_OF_RANGE = CSSParser(\n    '''\n    html|input:is(\n        [type=\"date\"],\n        [type=\"month\"],\n        [type=\"week\"],\n        [type=\"time\"],\n        [type=\"datetime-local\"],\n        [type=\"number\"],\n        [type=\"range\"]\n    ):is(\n        [min],\n        [max]\n    )\n    '''\n).process_selectors(flags=FLG_PSEUDO | FLG_OUT_OF_RANGE | FLG_HTML)\n"},"hash":"FrrhyOfmxP"}