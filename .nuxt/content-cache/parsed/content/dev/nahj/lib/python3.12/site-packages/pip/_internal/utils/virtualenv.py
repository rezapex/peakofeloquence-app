{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:utils:virtualenv.py","body":"import logging\nimport os\nimport re\nimport site\nimport sys\nfrom typing import List, Optional\n\nlogger = logging.getLogger(__name__)\n_INCLUDE_SYSTEM_SITE_PACKAGES_REGEX = re.compile(\n    r\"include-system-site-packages\\s*=\\s*(?P<value>true|false)\"\n)\n\n\ndef _running_under_venv() -> bool:\n    \"\"\"Checks if sys.base_prefix and sys.prefix match.\n\n    This handles PEP 405 compliant virtual environments.\n    \"\"\"\n    return sys.prefix != getattr(sys, \"base_prefix\", sys.prefix)\n\n\ndef _running_under_legacy_virtualenv() -> bool:\n    \"\"\"Checks if sys.real_prefix is set.\n\n    This handles virtual environments created with pypa's virtualenv.\n    \"\"\"\n    # pypa/virtualenv case\n    return hasattr(sys, \"real_prefix\")\n\n\ndef running_under_virtualenv() -> bool:\n    \"\"\"True if we're running inside a virtual environment, False otherwise.\"\"\"\n    return _running_under_venv() or _running_under_legacy_virtualenv()\n\n\ndef _get_pyvenv_cfg_lines() -> Optional[List[str]]:\n    \"\"\"Reads {sys.prefix}/pyvenv.cfg and returns its contents as list of lines\n\n    Returns None, if it could not read/access the file.\n    \"\"\"\n    pyvenv_cfg_file = os.path.join(sys.prefix, \"pyvenv.cfg\")\n    try:\n        # Although PEP 405 does not specify, the built-in venv module always\n        # writes with UTF-8. (pypa/pip#8717)\n        with open(pyvenv_cfg_file, encoding=\"utf-8\") as f:\n            return f.read().splitlines()  # avoids trailing newlines\n    except OSError:\n        return None\n\n\ndef _no_global_under_venv() -> bool:\n    \"\"\"Check `{sys.prefix}/pyvenv.cfg` for system site-packages inclusion\n\n    PEP 405 specifies that when system site-packages are not supposed to be\n    visible from a virtual environment, `pyvenv.cfg` must contain the following\n    line:\n\n        include-system-site-packages = false\n\n    Additionally, log a warning if accessing the file fails.\n    \"\"\"\n    cfg_lines = _get_pyvenv_cfg_lines()\n    if cfg_lines is None:\n        # We're not in a \"sane\" venv, so assume there is no system\n        # site-packages access (since that's PEP 405's default state).\n        logger.warning(\n            \"Could not access 'pyvenv.cfg' despite a virtual environment \"\n            \"being active. Assuming global site-packages is not accessible \"\n            \"in this environment.\"\n        )\n        return True\n\n    for line in cfg_lines:\n        match = _INCLUDE_SYSTEM_SITE_PACKAGES_REGEX.match(line)\n        if match is not None and match.group(\"value\") == \"false\":\n            return True\n    return False\n\n\ndef _no_global_under_legacy_virtualenv() -> bool:\n    \"\"\"Check if \"no-global-site-packages.txt\" exists beside site.py\n\n    This mirrors logic in pypa/virtualenv for determining whether system\n    site-packages are visible in the virtual environment.\n    \"\"\"\n    site_mod_dir = os.path.dirname(os.path.abspath(site.__file__))\n    no_global_site_packages_file = os.path.join(\n        site_mod_dir,\n        \"no-global-site-packages.txt\",\n    )\n    return os.path.exists(no_global_site_packages_file)\n\n\ndef virtualenv_no_global() -> bool:\n    \"\"\"Returns a boolean, whether running in venv with no system site-packages.\"\"\"\n    # PEP 405 compliance needs to be checked first since virtualenv >=20 would\n    # return True for both checks, but is only able to use the PEP 405 config.\n    if _running_under_venv():\n        return _no_global_under_venv()\n\n    if _running_under_legacy_virtualenv():\n        return _no_global_under_legacy_virtualenv()\n\n    return False\n"},"hash":"oMqg9ho3Pb"}