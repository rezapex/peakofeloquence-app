{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:rich:segment.py","body":"from enum import IntEnum\nfrom functools import lru_cache\nfrom itertools import filterfalse\nfrom logging import getLogger\nfrom operator import attrgetter\nfrom typing import (\n    TYPE_CHECKING,\n    Dict,\n    Iterable,\n    List,\n    NamedTuple,\n    Optional,\n    Sequence,\n    Tuple,\n    Type,\n    Union,\n)\n\nfrom .cells import (\n    _is_single_cell_widths,\n    cached_cell_len,\n    cell_len,\n    get_character_cell_size,\n    set_cell_size,\n)\nfrom .repr import Result, rich_repr\nfrom .style import Style\n\nif TYPE_CHECKING:\n    from .console import Console, ConsoleOptions, RenderResult\n\nlog = getLogger(\"rich\")\n\n\nclass ControlType(IntEnum):\n    \"\"\"Non-printable control codes which typically translate to ANSI codes.\"\"\"\n\n    BELL = 1\n    CARRIAGE_RETURN = 2\n    HOME = 3\n    CLEAR = 4\n    SHOW_CURSOR = 5\n    HIDE_CURSOR = 6\n    ENABLE_ALT_SCREEN = 7\n    DISABLE_ALT_SCREEN = 8\n    CURSOR_UP = 9\n    CURSOR_DOWN = 10\n    CURSOR_FORWARD = 11\n    CURSOR_BACKWARD = 12\n    CURSOR_MOVE_TO_COLUMN = 13\n    CURSOR_MOVE_TO = 14\n    ERASE_IN_LINE = 15\n    SET_WINDOW_TITLE = 16\n\n\nControlCode = Union[\n    Tuple[ControlType],\n    Tuple[ControlType, Union[int, str]],\n    Tuple[ControlType, int, int],\n]\n\n\n@rich_repr()\nclass Segment(NamedTuple):\n    \"\"\"A piece of text with associated style. Segments are produced by the Console render process and\n    are ultimately converted in to strings to be written to the terminal.\n\n    Args:\n        text (str): A piece of text.\n        style (:class:`~rich.style.Style`, optional): An optional style to apply to the text.\n        control (Tuple[ControlCode], optional): Optional sequence of control codes.\n\n    Attributes:\n        cell_length (int): The cell length of this Segment.\n    \"\"\"\n\n    text: str\n    style: Optional[Style] = None\n    control: Optional[Sequence[ControlCode]] = None\n\n    @property\n    def cell_length(self) -> int:\n        \"\"\"The number of terminal cells required to display self.text.\n\n        Returns:\n            int: A number of cells.\n        \"\"\"\n        text, _style, control = self\n        return 0 if control else cell_len(text)\n\n    def __rich_repr__(self) -> Result:\n        yield self.text\n        if self.control is None:\n            if self.style is not None:\n                yield self.style\n        else:\n            yield self.style\n            yield self.control\n\n    def __bool__(self) -> bool:\n        \"\"\"Check if the segment contains text.\"\"\"\n        return bool(self.text)\n\n    @property\n    def is_control(self) -> bool:\n        \"\"\"Check if the segment contains control codes.\"\"\"\n        return self.control is not None\n\n    @classmethod\n    @lru_cache(1024 * 16)\n    def _split_cells(cls, segment: \"Segment\", cut: int) -> Tuple[\"Segment\", \"Segment\"]:\n\n        text, style, control = segment\n        _Segment = Segment\n\n        cell_length = segment.cell_length\n        if cut >= cell_length:\n            return segment, _Segment(\"\", style, control)\n\n        cell_size = get_character_cell_size\n\n        pos = int((cut / cell_length) * (len(text) - 1))\n\n        before = text[:pos]\n        cell_pos = cell_len(before)\n        if cell_pos == cut:\n            return (\n                _Segment(before, style, control),\n                _Segment(text[pos:], style, control),\n            )\n        while pos < len(text):\n            char = text[pos]\n            pos += 1\n            cell_pos += cell_size(char)\n            before = text[:pos]\n            if cell_pos == cut:\n                return (\n                    _Segment(before, style, control),\n                    _Segment(text[pos:], style, control),\n                )\n            if cell_pos > cut:\n                return (\n                    _Segment(before[: pos - 1] + \" \", style, control),\n                    _Segment(\" \" + text[pos:], style, control),\n                )\n\n        raise AssertionError(\"Will never reach here\")\n\n    def split_cells(self, cut: int) -> Tuple[\"Segment\", \"Segment\"]:\n        \"\"\"Split segment in to two segments at the specified column.\n\n        If the cut point falls in the middle of a 2-cell wide character then it is replaced\n        by two spaces, to preserve the display width of the parent segment.\n\n        Returns:\n            Tuple[Segment, Segment]: Two segments.\n        \"\"\"\n        text, style, control = self\n\n        if _is_single_cell_widths(text):\n            # Fast path with all 1 cell characters\n            if cut >= len(text):\n                return self, Segment(\"\", style, control)\n            return (\n                Segment(text[:cut], style, control),\n                Segment(text[cut:], style, control),\n            )\n\n        return self._split_cells(self, cut)\n\n    @classmethod\n    def line(cls) -> \"Segment\":\n        \"\"\"Make a new line segment.\"\"\"\n        return cls(\"\\n\")\n\n    @classmethod\n    def apply_style(\n        cls,\n        segments: Iterable[\"Segment\"],\n        style: Optional[Style] = None,\n        post_style: Optional[Style] = None,\n    ) -> Iterable[\"Segment\"]:\n        \"\"\"Apply style(s) to an iterable of segments.\n\n        Returns an iterable of segments where the style is replaced by ``style + segment.style + post_style``.\n\n        Args:\n            segments (Iterable[Segment]): Segments to process.\n            style (Style, optional): Base style. Defaults to None.\n            post_style (Style, optional): Style to apply on top of segment style. Defaults to None.\n\n        Returns:\n            Iterable[Segments]: A new iterable of segments (possibly the same iterable).\n        \"\"\"\n        result_segments = segments\n        if style:\n            apply = style.__add__\n            result_segments = (\n                cls(text, None if control else apply(_style), control)\n                for text, _style, control in result_segments\n            )\n        if post_style:\n            result_segments = (\n                cls(\n                    text,\n                    (\n                        None\n                        if control\n                        else (_style + post_style if _style else post_style)\n                    ),\n                    control,\n                )\n                for text, _style, control in result_segments\n            )\n        return result_segments\n\n    @classmethod\n    def filter_control(\n        cls, segments: Iterable[\"Segment\"], is_control: bool = False\n    ) -> Iterable[\"Segment\"]:\n        \"\"\"Filter segments by ``is_control`` attribute.\n\n        Args:\n            segments (Iterable[Segment]): An iterable of Segment instances.\n            is_control (bool, optional): is_control flag to match in search.\n\n        Returns:\n            Iterable[Segment]: And iterable of Segment instances.\n\n        \"\"\"\n        if is_control:\n            return filter(attrgetter(\"control\"), segments)\n        else:\n            return filterfalse(attrgetter(\"control\"), segments)\n\n    @classmethod\n    def split_lines(cls, segments: Iterable[\"Segment\"]) -> Iterable[List[\"Segment\"]]:\n        \"\"\"Split a sequence of segments in to a list of lines.\n\n        Args:\n            segments (Iterable[Segment]): Segments potentially containing line feeds.\n\n        Yields:\n            Iterable[List[Segment]]: Iterable of segment lists, one per line.\n        \"\"\"\n        line: List[Segment] = []\n        append = line.append\n\n        for segment in segments:\n            if \"\\n\" in segment.text and not segment.control:\n                text, style, _ = segment\n                while text:\n                    _text, new_line, text = text.partition(\"\\n\")\n                    if _text:\n                        append(cls(_text, style))\n                    if new_line:\n                        yield line\n                        line = []\n                        append = line.append\n            else:\n                append(segment)\n        if line:\n            yield line\n\n    @classmethod\n    def split_and_crop_lines(\n        cls,\n        segments: Iterable[\"Segment\"],\n        length: int,\n        style: Optional[Style] = None,\n        pad: bool = True,\n        include_new_lines: bool = True,\n    ) -> Iterable[List[\"Segment\"]]:\n        \"\"\"Split segments in to lines, and crop lines greater than a given length.\n\n        Args:\n            segments (Iterable[Segment]): An iterable of segments, probably\n                generated from console.render.\n            length (int): Desired line length.\n            style (Style, optional): Style to use for any padding.\n            pad (bool): Enable padding of lines that are less than `length`.\n\n        Returns:\n            Iterable[List[Segment]]: An iterable of lines of segments.\n        \"\"\"\n        line: List[Segment] = []\n        append = line.append\n\n        adjust_line_length = cls.adjust_line_length\n        new_line_segment = cls(\"\\n\")\n\n        for segment in segments:\n            if \"\\n\" in segment.text and not segment.control:\n                text, segment_style, _ = segment\n                while text:\n                    _text, new_line, text = text.partition(\"\\n\")\n                    if _text:\n                        append(cls(_text, segment_style))\n                    if new_line:\n                        cropped_line = adjust_line_length(\n                            line, length, style=style, pad=pad\n                        )\n                        if include_new_lines:\n                            cropped_line.append(new_line_segment)\n                        yield cropped_line\n                        line.clear()\n            else:\n                append(segment)\n        if line:\n            yield adjust_line_length(line, length, style=style, pad=pad)\n\n    @classmethod\n    def adjust_line_length(\n        cls,\n        line: List[\"Segment\"],\n        length: int,\n        style: Optional[Style] = None,\n        pad: bool = True,\n    ) -> List[\"Segment\"]:\n        \"\"\"Adjust a line to a given width (cropping or padding as required).\n\n        Args:\n            segments (Iterable[Segment]): A list of segments in a single line.\n            length (int): The desired width of the line.\n            style (Style, optional): The style of padding if used (space on the end). Defaults to None.\n            pad (bool, optional): Pad lines with spaces if they are shorter than `length`. Defaults to True.\n\n        Returns:\n            List[Segment]: A line of segments with the desired length.\n        \"\"\"\n        line_length = sum(segment.cell_length for segment in line)\n        new_line: List[Segment]\n\n        if line_length < length:\n            if pad:\n                new_line = line + [cls(\" \" * (length - line_length), style)]\n            else:\n                new_line = line[:]\n        elif line_length > length:\n            new_line = []\n            append = new_line.append\n            line_length = 0\n            for segment in line:\n                segment_length = segment.cell_length\n                if line_length + segment_length < length or segment.control:\n                    append(segment)\n                    line_length += segment_length\n                else:\n                    text, segment_style, _ = segment\n                    text = set_cell_size(text, length - line_length)\n                    append(cls(text, segment_style))\n                    break\n        else:\n            new_line = line[:]\n        return new_line\n\n    @classmethod\n    def get_line_length(cls, line: List[\"Segment\"]) -> int:\n        \"\"\"Get the length of list of segments.\n\n        Args:\n            line (List[Segment]): A line encoded as a list of Segments (assumes no '\\\\\\\\n' characters),\n\n        Returns:\n            int: The length of the line.\n        \"\"\"\n        _cell_len = cell_len\n        return sum(_cell_len(text) for text, style, control in line if not control)\n\n    @classmethod\n    def get_shape(cls, lines: List[List[\"Segment\"]]) -> Tuple[int, int]:\n        \"\"\"Get the shape (enclosing rectangle) of a list of lines.\n\n        Args:\n            lines (List[List[Segment]]): A list of lines (no '\\\\\\\\n' characters).\n\n        Returns:\n            Tuple[int, int]: Width and height in characters.\n        \"\"\"\n        get_line_length = cls.get_line_length\n        max_width = max(get_line_length(line) for line in lines) if lines else 0\n        return (max_width, len(lines))\n\n    @classmethod\n    def set_shape(\n        cls,\n        lines: List[List[\"Segment\"]],\n        width: int,\n        height: Optional[int] = None,\n        style: Optional[Style] = None,\n        new_lines: bool = False,\n    ) -> List[List[\"Segment\"]]:\n        \"\"\"Set the shape of a list of lines (enclosing rectangle).\n\n        Args:\n            lines (List[List[Segment]]): A list of lines.\n            width (int): Desired width.\n            height (int, optional): Desired height or None for no change.\n            style (Style, optional): Style of any padding added.\n            new_lines (bool, optional): Padded lines should include \"\\n\". Defaults to False.\n\n        Returns:\n            List[List[Segment]]: New list of lines.\n        \"\"\"\n        _height = height or len(lines)\n\n        blank = (\n            [cls(\" \" * width + \"\\n\", style)] if new_lines else [cls(\" \" * width, style)]\n        )\n\n        adjust_line_length = cls.adjust_line_length\n        shaped_lines = lines[:_height]\n        shaped_lines[:] = [\n            adjust_line_length(line, width, style=style) for line in lines\n        ]\n        if len(shaped_lines) < _height:\n            shaped_lines.extend([blank] * (_height - len(shaped_lines)))\n        return shaped_lines\n\n    @classmethod\n    def align_top(\n        cls: Type[\"Segment\"],\n        lines: List[List[\"Segment\"]],\n        width: int,\n        height: int,\n        style: Style,\n        new_lines: bool = False,\n    ) -> List[List[\"Segment\"]]:\n        \"\"\"Aligns lines to top (adds extra lines to bottom as required).\n\n        Args:\n            lines (List[List[Segment]]): A list of lines.\n            width (int): Desired width.\n            height (int, optional): Desired height or None for no change.\n            style (Style): Style of any padding added.\n            new_lines (bool, optional): Padded lines should include \"\\n\". Defaults to False.\n\n        Returns:\n            List[List[Segment]]: New list of lines.\n        \"\"\"\n        extra_lines = height - len(lines)\n        if not extra_lines:\n            return lines[:]\n        lines = lines[:height]\n        blank = cls(\" \" * width + \"\\n\", style) if new_lines else cls(\" \" * width, style)\n        lines = lines + [[blank]] * extra_lines\n        return lines\n\n    @classmethod\n    def align_bottom(\n        cls: Type[\"Segment\"],\n        lines: List[List[\"Segment\"]],\n        width: int,\n        height: int,\n        style: Style,\n        new_lines: bool = False,\n    ) -> List[List[\"Segment\"]]:\n        \"\"\"Aligns render to bottom (adds extra lines above as required).\n\n        Args:\n            lines (List[List[Segment]]): A list of lines.\n            width (int): Desired width.\n            height (int, optional): Desired height or None for no change.\n            style (Style): Style of any padding added. Defaults to None.\n            new_lines (bool, optional): Padded lines should include \"\\n\". Defaults to False.\n\n        Returns:\n            List[List[Segment]]: New list of lines.\n        \"\"\"\n        extra_lines = height - len(lines)\n        if not extra_lines:\n            return lines[:]\n        lines = lines[:height]\n        blank = cls(\" \" * width + \"\\n\", style) if new_lines else cls(\" \" * width, style)\n        lines = [[blank]] * extra_lines + lines\n        return lines\n\n    @classmethod\n    def align_middle(\n        cls: Type[\"Segment\"],\n        lines: List[List[\"Segment\"]],\n        width: int,\n        height: int,\n        style: Style,\n        new_lines: bool = False,\n    ) -> List[List[\"Segment\"]]:\n        \"\"\"Aligns lines to middle (adds extra lines to above and below as required).\n\n        Args:\n            lines (List[List[Segment]]): A list of lines.\n            width (int): Desired width.\n            height (int, optional): Desired height or None for no change.\n            style (Style): Style of any padding added.\n            new_lines (bool, optional): Padded lines should include \"\\n\". Defaults to False.\n\n        Returns:\n            List[List[Segment]]: New list of lines.\n        \"\"\"\n        extra_lines = height - len(lines)\n        if not extra_lines:\n            return lines[:]\n        lines = lines[:height]\n        blank = cls(\" \" * width + \"\\n\", style) if new_lines else cls(\" \" * width, style)\n        top_lines = extra_lines // 2\n        bottom_lines = extra_lines - top_lines\n        lines = [[blank]] * top_lines + lines + [[blank]] * bottom_lines\n        return lines\n\n    @classmethod\n    def simplify(cls, segments: Iterable[\"Segment\"]) -> Iterable[\"Segment\"]:\n        \"\"\"Simplify an iterable of segments by combining contiguous segments with the same style.\n\n        Args:\n            segments (Iterable[Segment]): An iterable of segments.\n\n        Returns:\n            Iterable[Segment]: A possibly smaller iterable of segments that will render the same way.\n        \"\"\"\n        iter_segments = iter(segments)\n        try:\n            last_segment = next(iter_segments)\n        except StopIteration:\n            return\n\n        _Segment = Segment\n        for segment in iter_segments:\n            if last_segment.style == segment.style and not segment.control:\n                last_segment = _Segment(\n                    last_segment.text + segment.text, last_segment.style\n                )\n            else:\n                yield last_segment\n                last_segment = segment\n        yield last_segment\n\n    @classmethod\n    def strip_links(cls, segments: Iterable[\"Segment\"]) -> Iterable[\"Segment\"]:\n        \"\"\"Remove all links from an iterable of styles.\n\n        Args:\n            segments (Iterable[Segment]): An iterable segments.\n\n        Yields:\n            Segment: Segments with link removed.\n        \"\"\"\n        for segment in segments:\n            if segment.control or segment.style is None:\n                yield segment\n            else:\n                text, style, _control = segment\n                yield cls(text, style.update_link(None) if style else None)\n\n    @classmethod\n    def strip_styles(cls, segments: Iterable[\"Segment\"]) -> Iterable[\"Segment\"]:\n        \"\"\"Remove all styles from an iterable of segments.\n\n        Args:\n            segments (Iterable[Segment]): An iterable segments.\n\n        Yields:\n            Segment: Segments with styles replace with None\n        \"\"\"\n        for text, _style, control in segments:\n            yield cls(text, None, control)\n\n    @classmethod\n    def remove_color(cls, segments: Iterable[\"Segment\"]) -> Iterable[\"Segment\"]:\n        \"\"\"Remove all color from an iterable of segments.\n\n        Args:\n            segments (Iterable[Segment]): An iterable segments.\n\n        Yields:\n            Segment: Segments with colorless style.\n        \"\"\"\n\n        cache: Dict[Style, Style] = {}\n        for text, style, control in segments:\n            if style:\n                colorless_style = cache.get(style)\n                if colorless_style is None:\n                    colorless_style = style.without_color\n                    cache[style] = colorless_style\n                yield cls(text, colorless_style, control)\n            else:\n                yield cls(text, None, control)\n\n    @classmethod\n    def divide(\n        cls, segments: Iterable[\"Segment\"], cuts: Iterable[int]\n    ) -> Iterable[List[\"Segment\"]]:\n        \"\"\"Divides an iterable of segments in to portions.\n\n        Args:\n            cuts (Iterable[int]): Cell positions where to divide.\n\n        Yields:\n            [Iterable[List[Segment]]]: An iterable of Segments in List.\n        \"\"\"\n        split_segments: List[\"Segment\"] = []\n        add_segment = split_segments.append\n\n        iter_cuts = iter(cuts)\n\n        while True:\n            cut = next(iter_cuts, -1)\n            if cut == -1:\n                return []\n            if cut != 0:\n                break\n            yield []\n        pos = 0\n\n        segments_clear = split_segments.clear\n        segments_copy = split_segments.copy\n\n        _cell_len = cached_cell_len\n        for segment in segments:\n            text, _style, control = segment\n            while text:\n                end_pos = pos if control else pos + _cell_len(text)\n                if end_pos < cut:\n                    add_segment(segment)\n                    pos = end_pos\n                    break\n\n                if end_pos == cut:\n                    add_segment(segment)\n                    yield segments_copy()\n                    segments_clear()\n                    pos = end_pos\n\n                    cut = next(iter_cuts, -1)\n                    if cut == -1:\n                        if split_segments:\n                            yield segments_copy()\n                        return\n\n                    break\n\n                else:\n                    before, segment = segment.split_cells(cut - pos)\n                    text, _style, control = segment\n                    add_segment(before)\n                    yield segments_copy()\n                    segments_clear()\n                    pos = cut\n\n                cut = next(iter_cuts, -1)\n                if cut == -1:\n                    if split_segments:\n                        yield segments_copy()\n                    return\n\n        yield segments_copy()\n\n\nclass Segments:\n    \"\"\"A simple renderable to render an iterable of segments. This class may be useful if\n    you want to print segments outside of a __rich_console__ method.\n\n    Args:\n        segments (Iterable[Segment]): An iterable of segments.\n        new_lines (bool, optional): Add new lines between segments. Defaults to False.\n    \"\"\"\n\n    def __init__(self, segments: Iterable[Segment], new_lines: bool = False) -> None:\n        self.segments = list(segments)\n        self.new_lines = new_lines\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        if self.new_lines:\n            line = Segment.line()\n            for segment in self.segments:\n                yield segment\n                yield line\n        else:\n            yield from self.segments\n\n\nclass SegmentLines:\n    def __init__(self, lines: Iterable[List[Segment]], new_lines: bool = False) -> None:\n        \"\"\"A simple renderable containing a number of lines of segments. May be used as an intermediate\n        in rendering process.\n\n        Args:\n            lines (Iterable[List[Segment]]): Lists of segments forming lines.\n            new_lines (bool, optional): Insert new lines after each line. Defaults to False.\n        \"\"\"\n        self.lines = list(lines)\n        self.new_lines = new_lines\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        if self.new_lines:\n            new_line = Segment.line()\n            for line in self.lines:\n                yield from line\n                yield new_line\n        else:\n            for line in self.lines:\n                yield from line\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    from pip._vendor.rich.console import Console\n    from pip._vendor.rich.syntax import Syntax\n    from pip._vendor.rich.text import Text\n\n    code = \"\"\"from rich.console import Console\nconsole = Console()\ntext = Text.from_markup(\"Hello, [bold magenta]World[/]!\")\nconsole.print(text)\"\"\"\n\n    text = Text.from_markup(\"Hello, [bold magenta]World[/]!\")\n\n    console = Console()\n\n    console.rule(\"rich.Segment\")\n    console.print(\n        \"A Segment is the last step in the Rich render process before generating text with ANSI codes.\"\n    )\n    console.print(\"\\nConsider the following code:\\n\")\n    console.print(Syntax(code, \"python\", line_numbers=True))\n    console.print()\n    console.print(\n        \"When you call [b]print()[/b], Rich [i]renders[/i] the object in to the following:\\n\"\n    )\n    fragments = list(console.render(text))\n    console.print(fragments)\n    console.print()\n    console.print(\"The Segments are then processed to produce the following output:\\n\")\n    console.print(text)\n    console.print(\n        \"\\nYou will only need to know this if you are implementing your own Rich renderables.\"\n    )\n"},"hash":"U0ZbRjvMAi"}