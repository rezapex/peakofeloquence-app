{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:resolution:resolvelib:base.py","body":"from typing import FrozenSet, Iterable, Optional, Tuple, Union\n\nfrom pip._vendor.packaging.specifiers import SpecifierSet\nfrom pip._vendor.packaging.utils import NormalizedName\nfrom pip._vendor.packaging.version import LegacyVersion, Version\n\nfrom pip._internal.models.link import Link, links_equivalent\nfrom pip._internal.req.req_install import InstallRequirement\nfrom pip._internal.utils.hashes import Hashes\n\nCandidateLookup = Tuple[Optional[\"Candidate\"], Optional[InstallRequirement]]\nCandidateVersion = Union[LegacyVersion, Version]\n\n\ndef format_name(project: NormalizedName, extras: FrozenSet[NormalizedName]) -> str:\n    if not extras:\n        return project\n    extras_expr = \",\".join(sorted(extras))\n    return f\"{project}[{extras_expr}]\"\n\n\nclass Constraint:\n    def __init__(\n        self, specifier: SpecifierSet, hashes: Hashes, links: FrozenSet[Link]\n    ) -> None:\n        self.specifier = specifier\n        self.hashes = hashes\n        self.links = links\n\n    @classmethod\n    def empty(cls) -> \"Constraint\":\n        return Constraint(SpecifierSet(), Hashes(), frozenset())\n\n    @classmethod\n    def from_ireq(cls, ireq: InstallRequirement) -> \"Constraint\":\n        links = frozenset([ireq.link]) if ireq.link else frozenset()\n        return Constraint(ireq.specifier, ireq.hashes(trust_internet=False), links)\n\n    def __bool__(self) -> bool:\n        return bool(self.specifier) or bool(self.hashes) or bool(self.links)\n\n    def __and__(self, other: InstallRequirement) -> \"Constraint\":\n        if not isinstance(other, InstallRequirement):\n            return NotImplemented\n        specifier = self.specifier & other.specifier\n        hashes = self.hashes & other.hashes(trust_internet=False)\n        links = self.links\n        if other.link:\n            links = links.union([other.link])\n        return Constraint(specifier, hashes, links)\n\n    def is_satisfied_by(self, candidate: \"Candidate\") -> bool:\n        # Reject if there are any mismatched URL constraints on this package.\n        if self.links and not all(_match_link(link, candidate) for link in self.links):\n            return False\n        # We can safely always allow prereleases here since PackageFinder\n        # already implements the prerelease logic, and would have filtered out\n        # prerelease candidates if the user does not expect them.\n        return self.specifier.contains(candidate.version, prereleases=True)\n\n\nclass Requirement:\n    @property\n    def project_name(self) -> NormalizedName:\n        \"\"\"The \"project name\" of a requirement.\n\n        This is different from ``name`` if this requirement contains extras,\n        in which case ``name`` would contain the ``[...]`` part, while this\n        refers to the name of the project.\n        \"\"\"\n        raise NotImplementedError(\"Subclass should override\")\n\n    @property\n    def name(self) -> str:\n        \"\"\"The name identifying this requirement in the resolver.\n\n        This is different from ``project_name`` if this requirement contains\n        extras, where ``project_name`` would not contain the ``[...]`` part.\n        \"\"\"\n        raise NotImplementedError(\"Subclass should override\")\n\n    def is_satisfied_by(self, candidate: \"Candidate\") -> bool:\n        return False\n\n    def get_candidate_lookup(self) -> CandidateLookup:\n        raise NotImplementedError(\"Subclass should override\")\n\n    def format_for_error(self) -> str:\n        raise NotImplementedError(\"Subclass should override\")\n\n\ndef _match_link(link: Link, candidate: \"Candidate\") -> bool:\n    if candidate.source_link:\n        return links_equivalent(link, candidate.source_link)\n    return False\n\n\nclass Candidate:\n    @property\n    def project_name(self) -> NormalizedName:\n        \"\"\"The \"project name\" of the candidate.\n\n        This is different from ``name`` if this candidate contains extras,\n        in which case ``name`` would contain the ``[...]`` part, while this\n        refers to the name of the project.\n        \"\"\"\n        raise NotImplementedError(\"Override in subclass\")\n\n    @property\n    def name(self) -> str:\n        \"\"\"The name identifying this candidate in the resolver.\n\n        This is different from ``project_name`` if this candidate contains\n        extras, where ``project_name`` would not contain the ``[...]`` part.\n        \"\"\"\n        raise NotImplementedError(\"Override in subclass\")\n\n    @property\n    def version(self) -> CandidateVersion:\n        raise NotImplementedError(\"Override in subclass\")\n\n    @property\n    def is_installed(self) -> bool:\n        raise NotImplementedError(\"Override in subclass\")\n\n    @property\n    def is_editable(self) -> bool:\n        raise NotImplementedError(\"Override in subclass\")\n\n    @property\n    def source_link(self) -> Optional[Link]:\n        raise NotImplementedError(\"Override in subclass\")\n\n    def iter_dependencies(self, with_requires: bool) -> Iterable[Optional[Requirement]]:\n        raise NotImplementedError(\"Override in subclass\")\n\n    def get_install_requirement(self) -> Optional[InstallRequirement]:\n        raise NotImplementedError(\"Override in subclass\")\n\n    def format_for_error(self) -> str:\n        raise NotImplementedError(\"Subclass should override\")\n"},"hash":"XiEDL6fkgE"}