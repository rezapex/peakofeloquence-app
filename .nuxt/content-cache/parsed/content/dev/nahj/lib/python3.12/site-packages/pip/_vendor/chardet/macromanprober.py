{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:chardet:macromanprober.py","body":"######################## BEGIN LICENSE BLOCK ########################\n# This code was modified from latin1prober.py by Rob Speer <rob@lumino.so>.\n# The Original Code is Mozilla Universal charset detector code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 2001\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Rob Speer - adapt to MacRoman encoding\n#   Mark Pilgrim - port to Python\n#   Shy Shalom - original C code\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nfrom typing import List, Union\n\nfrom .charsetprober import CharSetProber\nfrom .enums import ProbingState\n\nFREQ_CAT_NUM = 4\n\nUDF = 0  # undefined\nOTH = 1  # other\nASC = 2  # ascii capital letter\nASS = 3  # ascii small letter\nACV = 4  # accent capital vowel\nACO = 5  # accent capital other\nASV = 6  # accent small vowel\nASO = 7  # accent small other\nODD = 8  # character that is unlikely to appear\nCLASS_NUM = 9  # total classes\n\n# The change from Latin1 is that we explicitly look for extended characters\n# that are infrequently-occurring symbols, and consider them to always be\n# improbable. This should let MacRoman get out of the way of more likely\n# encodings in most situations.\n\n# fmt: off\nMacRoman_CharToClass = (\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,  # 00 - 07\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,  # 08 - 0F\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,  # 10 - 17\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,  # 18 - 1F\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,  # 20 - 27\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,  # 28 - 2F\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,  # 30 - 37\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,  # 38 - 3F\n    OTH, ASC, ASC, ASC, ASC, ASC, ASC, ASC,  # 40 - 47\n    ASC, ASC, ASC, ASC, ASC, ASC, ASC, ASC,  # 48 - 4F\n    ASC, ASC, ASC, ASC, ASC, ASC, ASC, ASC,  # 50 - 57\n    ASC, ASC, ASC, OTH, OTH, OTH, OTH, OTH,  # 58 - 5F\n    OTH, ASS, ASS, ASS, ASS, ASS, ASS, ASS,  # 60 - 67\n    ASS, ASS, ASS, ASS, ASS, ASS, ASS, ASS,  # 68 - 6F\n    ASS, ASS, ASS, ASS, ASS, ASS, ASS, ASS,  # 70 - 77\n    ASS, ASS, ASS, OTH, OTH, OTH, OTH, OTH,  # 78 - 7F\n    ACV, ACV, ACO, ACV, ACO, ACV, ACV, ASV,  # 80 - 87\n    ASV, ASV, ASV, ASV, ASV, ASO, ASV, ASV,  # 88 - 8F\n    ASV, ASV, ASV, ASV, ASV, ASV, ASO, ASV,  # 90 - 97\n    ASV, ASV, ASV, ASV, ASV, ASV, ASV, ASV,  # 98 - 9F\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, ASO,  # A0 - A7\n    OTH, OTH, ODD, ODD, OTH, OTH, ACV, ACV,  # A8 - AF\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,  # B0 - B7\n    OTH, OTH, OTH, OTH, OTH, OTH, ASV, ASV,  # B8 - BF\n    OTH, OTH, ODD, OTH, ODD, OTH, OTH, OTH,  # C0 - C7\n    OTH, OTH, OTH, ACV, ACV, ACV, ACV, ASV,  # C8 - CF\n    OTH, OTH, OTH, OTH, OTH, OTH, OTH, ODD,  # D0 - D7\n    ASV, ACV, ODD, OTH, OTH, OTH, OTH, OTH,  # D8 - DF\n    OTH, OTH, OTH, OTH, OTH, ACV, ACV, ACV,  # E0 - E7\n    ACV, ACV, ACV, ACV, ACV, ACV, ACV, ACV,  # E8 - EF\n    ODD, ACV, ACV, ACV, ACV, ASV, ODD, ODD,  # F0 - F7\n    ODD, ODD, ODD, ODD, ODD, ODD, ODD, ODD,  # F8 - FF\n)\n\n# 0 : illegal\n# 1 : very unlikely\n# 2 : normal\n# 3 : very likely\nMacRomanClassModel = (\n# UDF OTH ASC ASS ACV ACO ASV ASO ODD\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  # UDF\n    0,  3,  3,  3,  3,  3,  3,  3,  1,  # OTH\n    0,  3,  3,  3,  3,  3,  3,  3,  1,  # ASC\n    0,  3,  3,  3,  1,  1,  3,  3,  1,  # ASS\n    0,  3,  3,  3,  1,  2,  1,  2,  1,  # ACV\n    0,  3,  3,  3,  3,  3,  3,  3,  1,  # ACO\n    0,  3,  1,  3,  1,  1,  1,  3,  1,  # ASV\n    0,  3,  1,  3,  1,  1,  3,  3,  1,  # ASO\n    0,  1,  1,  1,  1,  1,  1,  1,  1,  # ODD\n)\n# fmt: on\n\n\nclass MacRomanProber(CharSetProber):\n    def __init__(self) -> None:\n        super().__init__()\n        self._last_char_class = OTH\n        self._freq_counter: List[int] = []\n        self.reset()\n\n    def reset(self) -> None:\n        self._last_char_class = OTH\n        self._freq_counter = [0] * FREQ_CAT_NUM\n\n        # express the prior that MacRoman is a somewhat rare encoding;\n        # this can be done by starting out in a slightly improbable state\n        # that must be overcome\n        self._freq_counter[2] = 10\n\n        super().reset()\n\n    @property\n    def charset_name(self) -> str:\n        return \"MacRoman\"\n\n    @property\n    def language(self) -> str:\n        return \"\"\n\n    def feed(self, byte_str: Union[bytes, bytearray]) -> ProbingState:\n        byte_str = self.remove_xml_tags(byte_str)\n        for c in byte_str:\n            char_class = MacRoman_CharToClass[c]\n            freq = MacRomanClassModel[(self._last_char_class * CLASS_NUM) + char_class]\n            if freq == 0:\n                self._state = ProbingState.NOT_ME\n                break\n            self._freq_counter[freq] += 1\n            self._last_char_class = char_class\n\n        return self.state\n\n    def get_confidence(self) -> float:\n        if self.state == ProbingState.NOT_ME:\n            return 0.01\n\n        total = sum(self._freq_counter)\n        confidence = (\n            0.0\n            if total < 0.01\n            else (self._freq_counter[3] - self._freq_counter[1] * 20.0) / total\n        )\n        confidence = max(confidence, 0.0)\n        # lower the confidence of MacRoman so that other more accurate\n        # detector can take priority.\n        confidence *= 0.73\n        return confidence\n"},"hash":"R7CE1aWKVD"}