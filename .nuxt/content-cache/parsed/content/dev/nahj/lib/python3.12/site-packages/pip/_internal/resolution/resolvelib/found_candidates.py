{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:resolution:resolvelib:found_candidates.py","body":"\"\"\"Utilities to lazily create and visit candidates found.\n\nCreating and visiting a candidate is a *very* costly operation. It involves\nfetching, extracting, potentially building modules from source, and verifying\ndistribution metadata. It is therefore crucial for performance to keep\neverything here lazy all the way down, so we only touch candidates that we\nabsolutely need, and not \"download the world\" when we only need one version of\nsomething.\n\"\"\"\n\nimport functools\nfrom collections.abc import Sequence\nfrom typing import TYPE_CHECKING, Any, Callable, Iterator, Optional, Set, Tuple\n\nfrom pip._vendor.packaging.version import _BaseVersion\n\nfrom .base import Candidate\n\nIndexCandidateInfo = Tuple[_BaseVersion, Callable[[], Optional[Candidate]]]\n\nif TYPE_CHECKING:\n    SequenceCandidate = Sequence[Candidate]\nelse:\n    # For compatibility: Python before 3.9 does not support using [] on the\n    # Sequence class.\n    #\n    # >>> from collections.abc import Sequence\n    # >>> Sequence[str]\n    # Traceback (most recent call last):\n    #   File \"<stdin>\", line 1, in <module>\n    # TypeError: 'ABCMeta' object is not subscriptable\n    #\n    # TODO: Remove this block after dropping Python 3.8 support.\n    SequenceCandidate = Sequence\n\n\ndef _iter_built(infos: Iterator[IndexCandidateInfo]) -> Iterator[Candidate]:\n    \"\"\"Iterator for ``FoundCandidates``.\n\n    This iterator is used when the package is not already installed. Candidates\n    from index come later in their normal ordering.\n    \"\"\"\n    versions_found: Set[_BaseVersion] = set()\n    for version, func in infos:\n        if version in versions_found:\n            continue\n        candidate = func()\n        if candidate is None:\n            continue\n        yield candidate\n        versions_found.add(version)\n\n\ndef _iter_built_with_prepended(\n    installed: Candidate, infos: Iterator[IndexCandidateInfo]\n) -> Iterator[Candidate]:\n    \"\"\"Iterator for ``FoundCandidates``.\n\n    This iterator is used when the resolver prefers the already-installed\n    candidate and NOT to upgrade. The installed candidate is therefore\n    always yielded first, and candidates from index come later in their\n    normal ordering, except skipped when the version is already installed.\n    \"\"\"\n    yield installed\n    versions_found: Set[_BaseVersion] = {installed.version}\n    for version, func in infos:\n        if version in versions_found:\n            continue\n        candidate = func()\n        if candidate is None:\n            continue\n        yield candidate\n        versions_found.add(version)\n\n\ndef _iter_built_with_inserted(\n    installed: Candidate, infos: Iterator[IndexCandidateInfo]\n) -> Iterator[Candidate]:\n    \"\"\"Iterator for ``FoundCandidates``.\n\n    This iterator is used when the resolver prefers to upgrade an\n    already-installed package. Candidates from index are returned in their\n    normal ordering, except replaced when the version is already installed.\n\n    The implementation iterates through and yields other candidates, inserting\n    the installed candidate exactly once before we start yielding older or\n    equivalent candidates, or after all other candidates if they are all newer.\n    \"\"\"\n    versions_found: Set[_BaseVersion] = set()\n    for version, func in infos:\n        if version in versions_found:\n            continue\n        # If the installed candidate is better, yield it first.\n        if installed.version >= version:\n            yield installed\n            versions_found.add(installed.version)\n        candidate = func()\n        if candidate is None:\n            continue\n        yield candidate\n        versions_found.add(version)\n\n    # If the installed candidate is older than all other candidates.\n    if installed.version not in versions_found:\n        yield installed\n\n\nclass FoundCandidates(SequenceCandidate):\n    \"\"\"A lazy sequence to provide candidates to the resolver.\n\n    The intended usage is to return this from `find_matches()` so the resolver\n    can iterate through the sequence multiple times, but only access the index\n    page when remote packages are actually needed. This improve performances\n    when suitable candidates are already installed on disk.\n    \"\"\"\n\n    def __init__(\n        self,\n        get_infos: Callable[[], Iterator[IndexCandidateInfo]],\n        installed: Optional[Candidate],\n        prefers_installed: bool,\n        incompatible_ids: Set[int],\n    ):\n        self._get_infos = get_infos\n        self._installed = installed\n        self._prefers_installed = prefers_installed\n        self._incompatible_ids = incompatible_ids\n\n    def __getitem__(self, index: Any) -> Any:\n        # Implemented to satisfy the ABC check. This is not needed by the\n        # resolver, and should not be used by the provider either (for\n        # performance reasons).\n        raise NotImplementedError(\"don't do this\")\n\n    def __iter__(self) -> Iterator[Candidate]:\n        infos = self._get_infos()\n        if not self._installed:\n            iterator = _iter_built(infos)\n        elif self._prefers_installed:\n            iterator = _iter_built_with_prepended(self._installed, infos)\n        else:\n            iterator = _iter_built_with_inserted(self._installed, infos)\n        return (c for c in iterator if id(c) not in self._incompatible_ids)\n\n    def __len__(self) -> int:\n        # Implemented to satisfy the ABC check. This is not needed by the\n        # resolver, and should not be used by the provider either (for\n        # performance reasons).\n        raise NotImplementedError(\"don't do this\")\n\n    @functools.lru_cache(maxsize=1)\n    def __bool__(self) -> bool:\n        if self._prefers_installed and self._installed:\n            return True\n        return any(self)\n"},"hash":"XVMt8Qhy8u"}