{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:pygments:util.py","body":"\"\"\"\n    pygments.util\n    ~~~~~~~~~~~~~\n\n    Utility functions.\n\n    :copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.\n    :license: BSD, see LICENSE for details.\n\"\"\"\n\nimport re\nfrom io import TextIOWrapper\n\n\nsplit_path_re = re.compile(r'[/\\\\ ]')\ndoctype_lookup_re = re.compile(r'''\n    <!DOCTYPE\\s+(\n     [a-zA-Z_][a-zA-Z0-9]*\n     (?: \\s+      # optional in HTML5\n     [a-zA-Z_][a-zA-Z0-9]*\\s+\n     \"[^\"]*\")?\n     )\n     [^>]*>\n''', re.DOTALL | re.MULTILINE | re.VERBOSE)\ntag_re = re.compile(r'<(.+?)(\\s.*?)?>.*?</.+?>',\n                    re.IGNORECASE | re.DOTALL | re.MULTILINE)\nxml_decl_re = re.compile(r'\\s*<\\?xml[^>]*\\?>', re.I)\n\n\nclass ClassNotFound(ValueError):\n    \"\"\"Raised if one of the lookup functions didn't find a matching class.\"\"\"\n\n\nclass OptionError(Exception):\n    \"\"\"\n    This exception will be raised by all option processing functions if\n    the type or value of the argument is not correct.\n    \"\"\"\n\ndef get_choice_opt(options, optname, allowed, default=None, normcase=False):\n    \"\"\"\n    If the key `optname` from the dictionary is not in the sequence\n    `allowed`, raise an error, otherwise return it.\n    \"\"\"\n    string = options.get(optname, default)\n    if normcase:\n        string = string.lower()\n    if string not in allowed:\n        raise OptionError('Value for option %s must be one of %s' %\n                          (optname, ', '.join(map(str, allowed))))\n    return string\n\n\ndef get_bool_opt(options, optname, default=None):\n    \"\"\"\n    Intuitively, this is `options.get(optname, default)`, but restricted to\n    Boolean value. The Booleans can be represented as string, in order to accept\n    Boolean value from the command line arguments. If the key `optname` is\n    present in the dictionary `options` and is not associated with a Boolean,\n    raise an `OptionError`. If it is absent, `default` is returned instead.\n\n    The valid string values for ``True`` are ``1``, ``yes``, ``true`` and\n    ``on``, the ones for ``False`` are ``0``, ``no``, ``false`` and ``off``\n    (matched case-insensitively).\n    \"\"\"\n    string = options.get(optname, default)\n    if isinstance(string, bool):\n        return string\n    elif isinstance(string, int):\n        return bool(string)\n    elif not isinstance(string, str):\n        raise OptionError('Invalid type %r for option %s; use '\n                          '1/0, yes/no, true/false, on/off' % (\n                              string, optname))\n    elif string.lower() in ('1', 'yes', 'true', 'on'):\n        return True\n    elif string.lower() in ('0', 'no', 'false', 'off'):\n        return False\n    else:\n        raise OptionError('Invalid value %r for option %s; use '\n                          '1/0, yes/no, true/false, on/off' % (\n                              string, optname))\n\n\ndef get_int_opt(options, optname, default=None):\n    \"\"\"As :func:`get_bool_opt`, but interpret the value as an integer.\"\"\"\n    string = options.get(optname, default)\n    try:\n        return int(string)\n    except TypeError:\n        raise OptionError('Invalid type %r for option %s; you '\n                          'must give an integer value' % (\n                              string, optname))\n    except ValueError:\n        raise OptionError('Invalid value %r for option %s; you '\n                          'must give an integer value' % (\n                              string, optname))\n\ndef get_list_opt(options, optname, default=None):\n    \"\"\"\n    If the key `optname` from the dictionary `options` is a string,\n    split it at whitespace and return it. If it is already a list\n    or a tuple, it is returned as a list.\n    \"\"\"\n    val = options.get(optname, default)\n    if isinstance(val, str):\n        return val.split()\n    elif isinstance(val, (list, tuple)):\n        return list(val)\n    else:\n        raise OptionError('Invalid type %r for option %s; you '\n                          'must give a list value' % (\n                              val, optname))\n\n\ndef docstring_headline(obj):\n    if not obj.__doc__:\n        return ''\n    res = []\n    for line in obj.__doc__.strip().splitlines():\n        if line.strip():\n            res.append(\" \" + line.strip())\n        else:\n            break\n    return ''.join(res).lstrip()\n\n\ndef make_analysator(f):\n    \"\"\"Return a static text analyser function that returns float values.\"\"\"\n    def text_analyse(text):\n        try:\n            rv = f(text)\n        except Exception:\n            return 0.0\n        if not rv:\n            return 0.0\n        try:\n            return min(1.0, max(0.0, float(rv)))\n        except (ValueError, TypeError):\n            return 0.0\n    text_analyse.__doc__ = f.__doc__\n    return staticmethod(text_analyse)\n\n\ndef shebang_matches(text, regex):\n    r\"\"\"Check if the given regular expression matches the last part of the\n    shebang if one exists.\n\n        >>> from pygments.util import shebang_matches\n        >>> shebang_matches('#!/usr/bin/env python', r'python(2\\.\\d)?')\n        True\n        >>> shebang_matches('#!/usr/bin/python2.4', r'python(2\\.\\d)?')\n        True\n        >>> shebang_matches('#!/usr/bin/python-ruby', r'python(2\\.\\d)?')\n        False\n        >>> shebang_matches('#!/usr/bin/python/ruby', r'python(2\\.\\d)?')\n        False\n        >>> shebang_matches('#!/usr/bin/startsomethingwith python',\n        ...                 r'python(2\\.\\d)?')\n        True\n\n    It also checks for common windows executable file extensions::\n\n        >>> shebang_matches('#!C:\\\\Python2.4\\\\Python.exe', r'python(2\\.\\d)?')\n        True\n\n    Parameters (``'-f'`` or ``'--foo'`` are ignored so ``'perl'`` does\n    the same as ``'perl -e'``)\n\n    Note that this method automatically searches the whole string (eg:\n    the regular expression is wrapped in ``'^$'``)\n    \"\"\"\n    index = text.find('\\n')\n    if index >= 0:\n        first_line = text[:index].lower()\n    else:\n        first_line = text.lower()\n    if first_line.startswith('#!'):\n        try:\n            found = [x for x in split_path_re.split(first_line[2:].strip())\n                     if x and not x.startswith('-')][-1]\n        except IndexError:\n            return False\n        regex = re.compile(r'^%s(\\.(exe|cmd|bat|bin))?$' % regex, re.IGNORECASE)\n        if regex.search(found) is not None:\n            return True\n    return False\n\n\ndef doctype_matches(text, regex):\n    \"\"\"Check if the doctype matches a regular expression (if present).\n\n    Note that this method only checks the first part of a DOCTYPE.\n    eg: 'html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"'\n    \"\"\"\n    m = doctype_lookup_re.search(text)\n    if m is None:\n        return False\n    doctype = m.group(1)\n    return re.compile(regex, re.I).match(doctype.strip()) is not None\n\n\ndef html_doctype_matches(text):\n    \"\"\"Check if the file looks like it has a html doctype.\"\"\"\n    return doctype_matches(text, r'html')\n\n\n_looks_like_xml_cache = {}\n\n\ndef looks_like_xml(text):\n    \"\"\"Check if a doctype exists or if we have some tags.\"\"\"\n    if xml_decl_re.match(text):\n        return True\n    key = hash(text)\n    try:\n        return _looks_like_xml_cache[key]\n    except KeyError:\n        m = doctype_lookup_re.search(text)\n        if m is not None:\n            return True\n        rv = tag_re.search(text[:1000]) is not None\n        _looks_like_xml_cache[key] = rv\n        return rv\n\n\ndef surrogatepair(c):\n    \"\"\"Given a unicode character code with length greater than 16 bits,\n    return the two 16 bit surrogate pair.\n    \"\"\"\n    # From example D28 of:\n    # http://www.unicode.org/book/ch03.pdf\n    return (0xd7c0 + (c >> 10), (0xdc00 + (c & 0x3ff)))\n\n\ndef format_lines(var_name, seq, raw=False, indent_level=0):\n    \"\"\"Formats a sequence of strings for output.\"\"\"\n    lines = []\n    base_indent = ' ' * indent_level * 4\n    inner_indent = ' ' * (indent_level + 1) * 4\n    lines.append(base_indent + var_name + ' = (')\n    if raw:\n        # These should be preformatted reprs of, say, tuples.\n        for i in seq:\n            lines.append(inner_indent + i + ',')\n    else:\n        for i in seq:\n            # Force use of single quotes\n            r = repr(i + '\"')\n            lines.append(inner_indent + r[:-2] + r[-1] + ',')\n    lines.append(base_indent + ')')\n    return '\\n'.join(lines)\n\n\ndef duplicates_removed(it, already_seen=()):\n    \"\"\"\n    Returns a list with duplicates removed from the iterable `it`.\n\n    Order is preserved.\n    \"\"\"\n    lst = []\n    seen = set()\n    for i in it:\n        if i in seen or i in already_seen:\n            continue\n        lst.append(i)\n        seen.add(i)\n    return lst\n\n\nclass Future:\n    \"\"\"Generic class to defer some work.\n\n    Handled specially in RegexLexerMeta, to support regex string construction at\n    first use.\n    \"\"\"\n    def get(self):\n        raise NotImplementedError\n\n\ndef guess_decode(text):\n    \"\"\"Decode *text* with guessed encoding.\n\n    First try UTF-8; this should fail for non-UTF-8 encodings.\n    Then try the preferred locale encoding.\n    Fall back to latin-1, which always works.\n    \"\"\"\n    try:\n        text = text.decode('utf-8')\n        return text, 'utf-8'\n    except UnicodeDecodeError:\n        try:\n            import locale\n            prefencoding = locale.getpreferredencoding()\n            text = text.decode()\n            return text, prefencoding\n        except (UnicodeDecodeError, LookupError):\n            text = text.decode('latin1')\n            return text, 'latin1'\n\n\ndef guess_decode_from_terminal(text, term):\n    \"\"\"Decode *text* coming from terminal *term*.\n\n    First try the terminal encoding, if given.\n    Then try UTF-8.  Then try the preferred locale encoding.\n    Fall back to latin-1, which always works.\n    \"\"\"\n    if getattr(term, 'encoding', None):\n        try:\n            text = text.decode(term.encoding)\n        except UnicodeDecodeError:\n            pass\n        else:\n            return text, term.encoding\n    return guess_decode(text)\n\n\ndef terminal_encoding(term):\n    \"\"\"Return our best guess of encoding for the given *term*.\"\"\"\n    if getattr(term, 'encoding', None):\n        return term.encoding\n    import locale\n    return locale.getpreferredencoding()\n\n\nclass UnclosingTextIOWrapper(TextIOWrapper):\n    # Don't close underlying buffer on destruction.\n    def close(self):\n        self.flush()\n"},"hash":"Zvw9wt4BCi"}