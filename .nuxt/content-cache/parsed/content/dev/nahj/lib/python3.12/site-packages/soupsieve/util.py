{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:soupsieve:util.py","body":"\"\"\"Utility.\"\"\"\nfrom __future__ import annotations\nfrom functools import wraps, lru_cache\nimport warnings\nimport re\nfrom typing import Callable, Any\n\nDEBUG = 0x00001\n\nRE_PATTERN_LINE_SPLIT = re.compile(r'(?:\\r\\n|(?!\\r\\n)[\\n\\r])|$')\n\nUC_A = ord('A')\nUC_Z = ord('Z')\n\n\n@lru_cache(maxsize=512)\ndef lower(string: str) -> str:\n    \"\"\"Lower.\"\"\"\n\n    new_string = []\n    for c in string:\n        o = ord(c)\n        new_string.append(chr(o + 32) if UC_A <= o <= UC_Z else c)\n    return ''.join(new_string)\n\n\nclass SelectorSyntaxError(Exception):\n    \"\"\"Syntax error in a CSS selector.\"\"\"\n\n    def __init__(self, msg: str, pattern: str | None = None, index: int | None = None) -> None:\n        \"\"\"Initialize.\"\"\"\n\n        self.line = None\n        self.col = None\n        self.context = None\n\n        if pattern is not None and index is not None:\n            # Format pattern to show line and column position\n            self.context, self.line, self.col = get_pattern_context(pattern, index)\n            msg = f'{msg}\\n  line {self.line}:\\n{self.context}'\n\n        super().__init__(msg)\n\n\ndef deprecated(message: str, stacklevel: int = 2) -> Callable[..., Any]:  # pragma: no cover\n    \"\"\"\n    Raise a `DeprecationWarning` when wrapped function/method is called.\n\n    Usage:\n\n        @deprecated(\"This method will be removed in version X; use Y instead.\")\n        def some_method()\"\n            pass\n    \"\"\"\n\n    def _wrapper(func: Callable[..., Any]) -> Callable[..., Any]:\n        @wraps(func)\n        def _deprecated_func(*args: Any, **kwargs: Any) -> Any:\n            warnings.warn(\n                f\"'{func.__name__}' is deprecated. {message}\",\n                category=DeprecationWarning,\n                stacklevel=stacklevel\n            )\n            return func(*args, **kwargs)\n        return _deprecated_func\n    return _wrapper\n\n\ndef warn_deprecated(message: str, stacklevel: int = 2) -> None:  # pragma: no cover\n    \"\"\"Warn deprecated.\"\"\"\n\n    warnings.warn(\n        message,\n        category=DeprecationWarning,\n        stacklevel=stacklevel\n    )\n\n\ndef get_pattern_context(pattern: str, index: int) -> tuple[str, int, int]:\n    \"\"\"Get the pattern context.\"\"\"\n\n    last = 0\n    current_line = 1\n    col = 1\n    text = []  # type: list[str]\n    line = 1\n    offset = None  # type: int | None\n\n    # Split pattern by newline and handle the text before the newline\n    for m in RE_PATTERN_LINE_SPLIT.finditer(pattern):\n        linetext = pattern[last:m.start(0)]\n        if not len(m.group(0)) and not len(text):\n            indent = ''\n            offset = -1\n            col = index - last + 1\n        elif last <= index < m.end(0):\n            indent = '--> '\n            offset = (-1 if index > m.start(0) else 0) + 3\n            col = index - last + 1\n        else:\n            indent = '    '\n            offset = None\n        if len(text):\n            # Regardless of whether we are presented with `\\r\\n`, `\\r`, or `\\n`,\n            # we will render the output with just `\\n`. We will still log the column\n            # correctly though.\n            text.append('\\n')\n        text.append(f'{indent}{linetext}')\n        if offset is not None:\n            text.append('\\n')\n            text.append(' ' * (col + offset) + '^')\n            line = current_line\n\n        current_line += 1\n        last = m.end(0)\n\n    return ''.join(text), line, col\n"},"hash":"xyi0rino5T"}