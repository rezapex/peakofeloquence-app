{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:pygments:formatters:rtf.py","body":"\"\"\"\n    pygments.formatters.rtf\n    ~~~~~~~~~~~~~~~~~~~~~~~\n\n    A formatter that generates RTF files.\n\n    :copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.\n    :license: BSD, see LICENSE for details.\n\"\"\"\n\nfrom pip._vendor.pygments.formatter import Formatter\nfrom pip._vendor.pygments.util import get_int_opt, surrogatepair\n\n\n__all__ = ['RtfFormatter']\n\n\nclass RtfFormatter(Formatter):\n    \"\"\"\n    Format tokens as RTF markup. This formatter automatically outputs full RTF\n    documents with color information and other useful stuff. Perfect for Copy and\n    Paste into Microsoft(R) Word(R) documents.\n\n    Please note that ``encoding`` and ``outencoding`` options are ignored.\n    The RTF format is ASCII natively, but handles unicode characters correctly\n    thanks to escape sequences.\n\n    .. versionadded:: 0.6\n\n    Additional options accepted:\n\n    `style`\n        The style to use, can be a string or a Style subclass (default:\n        ``'default'``).\n\n    `fontface`\n        The used font family, for example ``Bitstream Vera Sans``. Defaults to\n        some generic font which is supposed to have fixed width.\n\n    `fontsize`\n        Size of the font used. Size is specified in half points. The\n        default is 24 half-points, giving a size 12 font.\n\n        .. versionadded:: 2.0\n    \"\"\"\n    name = 'RTF'\n    aliases = ['rtf']\n    filenames = ['*.rtf']\n\n    def __init__(self, **options):\n        r\"\"\"\n        Additional options accepted:\n\n        ``fontface``\n            Name of the font used. Could for example be ``'Courier New'``\n            to further specify the default which is ``'\\fmodern'``. The RTF\n            specification claims that ``\\fmodern`` are \"Fixed-pitch serif\n            and sans serif fonts\". Hope every RTF implementation thinks\n            the same about modern...\n\n        \"\"\"\n        Formatter.__init__(self, **options)\n        self.fontface = options.get('fontface') or ''\n        self.fontsize = get_int_opt(options, 'fontsize', 0)\n\n    def _escape(self, text):\n        return text.replace('\\\\', '\\\\\\\\') \\\n                   .replace('{', '\\\\{') \\\n                   .replace('}', '\\\\}')\n\n    def _escape_text(self, text):\n        # empty strings, should give a small performance improvement\n        if not text:\n            return ''\n\n        # escape text\n        text = self._escape(text)\n\n        buf = []\n        for c in text:\n            cn = ord(c)\n            if cn < (2**7):\n                # ASCII character\n                buf.append(str(c))\n            elif (2**7) <= cn < (2**16):\n                # single unicode escape sequence\n                buf.append('{\\\\u%d}' % cn)\n            elif (2**16) <= cn:\n                # RTF limits unicode to 16 bits.\n                # Force surrogate pairs\n                buf.append('{\\\\u%d}{\\\\u%d}' % surrogatepair(cn))\n\n        return ''.join(buf).replace('\\n', '\\\\par\\n')\n\n    def format_unencoded(self, tokensource, outfile):\n        # rtf 1.8 header\n        outfile.write('{\\\\rtf1\\\\ansi\\\\uc0\\\\deff0'\n                      '{\\\\fonttbl{\\\\f0\\\\fmodern\\\\fprq1\\\\fcharset0%s;}}'\n                      '{\\\\colortbl;' % (self.fontface and\n                                        ' ' + self._escape(self.fontface) or\n                                        ''))\n\n        # convert colors and save them in a mapping to access them later.\n        color_mapping = {}\n        offset = 1\n        for _, style in self.style:\n            for color in style['color'], style['bgcolor'], style['border']:\n                if color and color not in color_mapping:\n                    color_mapping[color] = offset\n                    outfile.write('\\\\red%d\\\\green%d\\\\blue%d;' % (\n                        int(color[0:2], 16),\n                        int(color[2:4], 16),\n                        int(color[4:6], 16)\n                    ))\n                    offset += 1\n        outfile.write('}\\\\f0 ')\n        if self.fontsize:\n            outfile.write('\\\\fs%d' % self.fontsize)\n\n        # highlight stream\n        for ttype, value in tokensource:\n            while not self.style.styles_token(ttype) and ttype.parent:\n                ttype = ttype.parent\n            style = self.style.style_for_token(ttype)\n            buf = []\n            if style['bgcolor']:\n                buf.append('\\\\cb%d' % color_mapping[style['bgcolor']])\n            if style['color']:\n                buf.append('\\\\cf%d' % color_mapping[style['color']])\n            if style['bold']:\n                buf.append('\\\\b')\n            if style['italic']:\n                buf.append('\\\\i')\n            if style['underline']:\n                buf.append('\\\\ul')\n            if style['border']:\n                buf.append('\\\\chbrdr\\\\chcfpat%d' %\n                           color_mapping[style['border']])\n            start = ''.join(buf)\n            if start:\n                outfile.write('{%s ' % start)\n            outfile.write(self._escape_text(value))\n            if start:\n                outfile.write('}')\n\n        outfile.write('}')\n"},"hash":"6ynFQlBQHH"}