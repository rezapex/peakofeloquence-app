{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:cachecontrol:filewrapper.py","body":"# SPDX-FileCopyrightText: 2015 Eric Larson\n#\n# SPDX-License-Identifier: Apache-2.0\nfrom __future__ import annotations\n\nimport mmap\nfrom tempfile import NamedTemporaryFile\nfrom typing import TYPE_CHECKING, Any, Callable\n\nif TYPE_CHECKING:\n    from http.client import HTTPResponse\n\n\nclass CallbackFileWrapper:\n    \"\"\"\n    Small wrapper around a fp object which will tee everything read into a\n    buffer, and when that file is closed it will execute a callback with the\n    contents of that buffer.\n\n    All attributes are proxied to the underlying file object.\n\n    This class uses members with a double underscore (__) leading prefix so as\n    not to accidentally shadow an attribute.\n\n    The data is stored in a temporary file until it is all available.  As long\n    as the temporary files directory is disk-based (sometimes it's a\n    memory-backed-``tmpfs`` on Linux), data will be unloaded to disk if memory\n    pressure is high.  For small files the disk usually won't be used at all,\n    it'll all be in the filesystem memory cache, so there should be no\n    performance impact.\n    \"\"\"\n\n    def __init__(\n        self, fp: HTTPResponse, callback: Callable[[bytes], None] | None\n    ) -> None:\n        self.__buf = NamedTemporaryFile(\"rb+\", delete=True)\n        self.__fp = fp\n        self.__callback = callback\n\n    def __getattr__(self, name: str) -> Any:\n        # The vaguaries of garbage collection means that self.__fp is\n        # not always set.  By using __getattribute__ and the private\n        # name[0] allows looking up the attribute value and raising an\n        # AttributeError when it doesn't exist. This stop thigns from\n        # infinitely recursing calls to getattr in the case where\n        # self.__fp hasn't been set.\n        #\n        # [0] https://docs.python.org/2/reference/expressions.html#atom-identifiers\n        fp = self.__getattribute__(\"_CallbackFileWrapper__fp\")\n        return getattr(fp, name)\n\n    def __is_fp_closed(self) -> bool:\n        try:\n            return self.__fp.fp is None\n\n        except AttributeError:\n            pass\n\n        try:\n            closed: bool = self.__fp.closed\n            return closed\n\n        except AttributeError:\n            pass\n\n        # We just don't cache it then.\n        # TODO: Add some logging here...\n        return False\n\n    def _close(self) -> None:\n        if self.__callback:\n            if self.__buf.tell() == 0:\n                # Empty file:\n                result = b\"\"\n            else:\n                # Return the data without actually loading it into memory,\n                # relying on Python's buffer API and mmap(). mmap() just gives\n                # a view directly into the filesystem's memory cache, so it\n                # doesn't result in duplicate memory use.\n                self.__buf.seek(0, 0)\n                result = memoryview(\n                    mmap.mmap(self.__buf.fileno(), 0, access=mmap.ACCESS_READ)\n                )\n            self.__callback(result)\n\n        # We assign this to None here, because otherwise we can get into\n        # really tricky problems where the CPython interpreter dead locks\n        # because the callback is holding a reference to something which\n        # has a __del__ method. Setting this to None breaks the cycle\n        # and allows the garbage collector to do it's thing normally.\n        self.__callback = None\n\n        # Closing the temporary file releases memory and frees disk space.\n        # Important when caching big files.\n        self.__buf.close()\n\n    def read(self, amt: int | None = None) -> bytes:\n        data: bytes = self.__fp.read(amt)\n        if data:\n            # We may be dealing with b'', a sign that things are over:\n            # it's passed e.g. after we've already closed self.__buf.\n            self.__buf.write(data)\n        if self.__is_fp_closed():\n            self._close()\n\n        return data\n\n    def _safe_read(self, amt: int) -> bytes:\n        data: bytes = self.__fp._safe_read(amt)  # type: ignore[attr-defined]\n        if amt == 2 and data == b\"\\r\\n\":\n            # urllib executes this read to toss the CRLF at the end\n            # of the chunk.\n            return data\n\n        self.__buf.write(data)\n        if self.__is_fp_closed():\n            self._close()\n\n        return data\n"},"hash":"a23anZLdE6"}