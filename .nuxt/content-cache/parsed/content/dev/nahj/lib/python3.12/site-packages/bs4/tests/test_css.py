{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:bs4:tests:test_css.py","body":"import pytest\nimport types\nfrom unittest.mock import MagicMock\n\nfrom bs4 import (\n    CSS,\n    BeautifulSoup,\n    ResultSet,\n)\n\nfrom . import (\n    SoupTest,\n    SOUP_SIEVE_PRESENT,\n)\n\nif SOUP_SIEVE_PRESENT:\n    from soupsieve import SelectorSyntaxError\n\n\n@pytest.mark.skipif(not SOUP_SIEVE_PRESENT, reason=\"Soup Sieve not installed\")\nclass TestCSSSelectors(SoupTest):\n    \"\"\"Test basic CSS selector functionality.\n\n    This functionality is implemented in soupsieve, which has a much\n    more comprehensive test suite, so this is basically an extra check\n    that soupsieve works as expected.\n    \"\"\"\n\n    HTML = \"\"\"\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"\n\"http://www.w3.org/TR/html4/strict.dtd\">\n<html>\n<head>\n<title>The title</title>\n<link rel=\"stylesheet\" href=\"blah.css\" type=\"text/css\" id=\"l1\">\n</head>\n<body>\n<custom-dashed-tag class=\"dashed\" id=\"dash1\">Hello there.</custom-dashed-tag>\n<div id=\"main\" class=\"fancy\">\n<div id=\"inner\">\n<h1 id=\"header1\">An H1</h1>\n<p>Some text</p>\n<p class=\"onep\" id=\"p1\">Some more text</p>\n<h2 id=\"header2\">An H2</h2>\n<p class=\"class1 class2 class3\" id=\"pmulti\">Another</p>\n<a href=\"http://bob.example.org/\" rel=\"friend met\" id=\"bob\">Bob</a>\n<h2 id=\"header3\">Another H2</h2>\n<a id=\"me\" href=\"http://simonwillison.net/\" rel=\"me\">me</a>\n<span class=\"s1\">\n<a href=\"#\" id=\"s1a1\">span1a1</a>\n<a href=\"#\" id=\"s1a2\">span1a2 <span id=\"s1a2s1\">test</span></a>\n<span class=\"span2\">\n<a href=\"#\" id=\"s2a1\">span2a1</a>\n</span>\n<span class=\"span3\"></span>\n<custom-dashed-tag class=\"dashed\" id=\"dash2\"/>\n<div data-tag=\"dashedvalue\" id=\"data1\"/>\n</span>\n</div>\n<x id=\"xid\">\n<z id=\"zida\"/>\n<z id=\"zidab\"/>\n<z id=\"zidac\"/>\n</x>\n<y id=\"yid\">\n<z id=\"zidb\"/>\n</y>\n<p lang=\"en\" id=\"lang-en\">English</p>\n<p lang=\"en-gb\" id=\"lang-en-gb\">English UK</p>\n<p lang=\"en-us\" id=\"lang-en-us\">English US</p>\n<p lang=\"fr\" id=\"lang-fr\">French</p>\n</div>\n\n<div id=\"footer\">\n</div>\n\"\"\"\n\n    def setup_method(self):\n        self.soup = BeautifulSoup(self.HTML, 'html.parser')\n\n    def assert_selects(self, selector, expected_ids, **kwargs):\n        results = self.soup.select(selector, **kwargs)\n        assert isinstance(results, ResultSet)\n        el_ids = [el['id'] for el in results]\n        el_ids.sort()\n        expected_ids.sort()\n        assert expected_ids == el_ids, \"Selector %s, expected [%s], got [%s]\" % (\n                selector, ', '.join(expected_ids), ', '.join(el_ids)\n        )\n\n    assertSelect = assert_selects\n\n    def assert_select_multiple(self, *tests):\n        for selector, expected_ids in tests:\n            self.assert_selects(selector, expected_ids)\n\n    def test_precompiled(self):\n        sel = self.soup.css.compile('div')\n\n        els = self.soup.select(sel)\n        assert len(els) == 4\n        for div in els:\n            assert div.name == 'div'\n\n        el = self.soup.select_one(sel)\n        assert 'main' == el['id']\n\n    def test_one_tag_one(self):\n        els = self.soup.select('title')\n        assert len(els) == 1\n        assert els[0].name == 'title'\n        assert els[0].contents == ['The title']\n\n    def test_one_tag_many(self):\n        els = self.soup.select('div')\n        assert len(els) == 4\n        for div in els:\n            assert div.name == 'div'\n\n        el = self.soup.select_one('div')\n        assert 'main' == el['id']\n\n    def test_select_one_returns_none_if_no_match(self):\n        match = self.soup.select_one('nonexistenttag')\n        assert None == match\n\n\n    def test_tag_in_tag_one(self):\n        els = self.soup.select('div div')\n        self.assert_selects('div div', ['inner', 'data1'])\n\n    def test_tag_in_tag_many(self):\n        for selector in ('html div', 'html body div', 'body div'):\n            self.assert_selects(selector, ['data1', 'main', 'inner', 'footer'])\n\n\n    def test_limit(self):\n        self.assert_selects('html div', ['main'], limit=1)\n        self.assert_selects('html body div', ['inner', 'main'], limit=2)\n        self.assert_selects('body div', ['data1', 'main', 'inner', 'footer'],\n                           limit=10)\n\n    def test_tag_no_match(self):\n        assert len(self.soup.select('del')) == 0\n\n    def test_invalid_tag(self):\n        with pytest.raises(SelectorSyntaxError):\n            self.soup.select('tag%t')\n\n    def test_select_dashed_tag_ids(self):\n        self.assert_selects('custom-dashed-tag', ['dash1', 'dash2'])\n\n    def test_select_dashed_by_id(self):\n        dashed = self.soup.select('custom-dashed-tag[id=\\\"dash2\\\"]')\n        assert dashed[0].name == 'custom-dashed-tag'\n        assert dashed[0]['id'] == 'dash2'\n\n    def test_dashed_tag_text(self):\n        assert self.soup.select('body > custom-dashed-tag')[0].text == 'Hello there.'\n\n    def test_select_dashed_matches_find_all(self):\n        assert self.soup.select('custom-dashed-tag') == self.soup.find_all('custom-dashed-tag')\n\n    def test_header_tags(self):\n        self.assert_select_multiple(\n            ('h1', ['header1']),\n            ('h2', ['header2', 'header3']),\n        )\n\n    def test_class_one(self):\n        for selector in ('.onep', 'p.onep', 'html p.onep'):\n            els = self.soup.select(selector)\n            assert len(els) == 1\n            assert els[0].name == 'p'\n            assert els[0]['class'] == ['onep']\n\n    def test_class_mismatched_tag(self):\n        els = self.soup.select('div.onep')\n        assert len(els) == 0\n\n    def test_one_id(self):\n        for selector in ('div#inner', '#inner', 'div div#inner'):\n            self.assert_selects(selector, ['inner'])\n\n    def test_bad_id(self):\n        els = self.soup.select('#doesnotexist')\n        assert len(els) == 0\n\n    def test_items_in_id(self):\n        els = self.soup.select('div#inner p')\n        assert len(els) == 3\n        for el in els:\n            assert el.name == 'p'\n        assert els[1]['class'] == ['onep']\n        assert not els[0].has_attr('class')\n\n    def test_a_bunch_of_emptys(self):\n        for selector in ('div#main del', 'div#main div.oops', 'div div#main'):\n            assert len(self.soup.select(selector)) == 0\n\n    def test_multi_class_support(self):\n        for selector in ('.class1', 'p.class1', '.class2', 'p.class2',\n            '.class3', 'p.class3', 'html p.class2', 'div#inner .class2'):\n            self.assert_selects(selector, ['pmulti'])\n\n    def test_multi_class_selection(self):\n        for selector in ('.class1.class3', '.class3.class2',\n                         '.class1.class2.class3'):\n            self.assert_selects(selector, ['pmulti'])\n\n    def test_child_selector(self):\n        self.assert_selects('.s1 > a', ['s1a1', 's1a2'])\n        self.assert_selects('.s1 > a span', ['s1a2s1'])\n\n    def test_child_selector_id(self):\n        self.assert_selects('.s1 > a#s1a2 span', ['s1a2s1'])\n\n    def test_attribute_equals(self):\n        self.assert_select_multiple(\n            ('p[class=\"onep\"]', ['p1']),\n            ('p[id=\"p1\"]', ['p1']),\n            ('[class=\"onep\"]', ['p1']),\n            ('[id=\"p1\"]', ['p1']),\n            ('link[rel=\"stylesheet\"]', ['l1']),\n            ('link[type=\"text/css\"]', ['l1']),\n            ('link[href=\"blah.css\"]', ['l1']),\n            ('link[href=\"no-blah.css\"]', []),\n            ('[rel=\"stylesheet\"]', ['l1']),\n            ('[type=\"text/css\"]', ['l1']),\n            ('[href=\"blah.css\"]', ['l1']),\n            ('[href=\"no-blah.css\"]', []),\n            ('p[href=\"no-blah.css\"]', []),\n            ('[href=\"no-blah.css\"]', []),\n        )\n\n    def test_attribute_tilde(self):\n        self.assert_select_multiple(\n            ('p[class~=\"class1\"]', ['pmulti']),\n            ('p[class~=\"class2\"]', ['pmulti']),\n            ('p[class~=\"class3\"]', ['pmulti']),\n            ('[class~=\"class1\"]', ['pmulti']),\n            ('[class~=\"class2\"]', ['pmulti']),\n            ('[class~=\"class3\"]', ['pmulti']),\n            ('a[rel~=\"friend\"]', ['bob']),\n            ('a[rel~=\"met\"]', ['bob']),\n            ('[rel~=\"friend\"]', ['bob']),\n            ('[rel~=\"met\"]', ['bob']),\n        )\n\n    def test_attribute_startswith(self):\n        self.assert_select_multiple(\n            ('[rel^=\"style\"]', ['l1']),\n            ('link[rel^=\"style\"]', ['l1']),\n            ('notlink[rel^=\"notstyle\"]', []),\n            ('[rel^=\"notstyle\"]', []),\n            ('link[rel^=\"notstyle\"]', []),\n            ('link[href^=\"bla\"]', ['l1']),\n            ('a[href^=\"http://\"]', ['bob', 'me']),\n            ('[href^=\"http://\"]', ['bob', 'me']),\n            ('[id^=\"p\"]', ['pmulti', 'p1']),\n            ('[id^=\"m\"]', ['me', 'main']),\n            ('div[id^=\"m\"]', ['main']),\n            ('a[id^=\"m\"]', ['me']),\n            ('div[data-tag^=\"dashed\"]', ['data1'])\n        )\n\n    def test_attribute_endswith(self):\n        self.assert_select_multiple(\n            ('[href$=\".css\"]', ['l1']),\n            ('link[href$=\".css\"]', ['l1']),\n            ('link[id$=\"1\"]', ['l1']),\n            ('[id$=\"1\"]', ['data1', 'l1', 'p1', 'header1', 's1a1', 's2a1', 's1a2s1', 'dash1']),\n            ('div[id$=\"1\"]', ['data1']),\n            ('[id$=\"noending\"]', []),\n        )\n\n    def test_attribute_contains(self):\n        self.assert_select_multiple(\n            # From test_attribute_startswith\n            ('[rel*=\"style\"]', ['l1']),\n            ('link[rel*=\"style\"]', ['l1']),\n            ('notlink[rel*=\"notstyle\"]', []),\n            ('[rel*=\"notstyle\"]', []),\n            ('link[rel*=\"notstyle\"]', []),\n            ('link[href*=\"bla\"]', ['l1']),\n            ('[href*=\"http://\"]', ['bob', 'me']),\n            ('[id*=\"p\"]', ['pmulti', 'p1']),\n            ('div[id*=\"m\"]', ['main']),\n            ('a[id*=\"m\"]', ['me']),\n            # From test_attribute_endswith\n            ('[href*=\".css\"]', ['l1']),\n            ('link[href*=\".css\"]', ['l1']),\n            ('link[id*=\"1\"]', ['l1']),\n            ('[id*=\"1\"]', ['data1', 'l1', 'p1', 'header1', 's1a1', 's1a2', 's2a1', 's1a2s1', 'dash1']),\n            ('div[id*=\"1\"]', ['data1']),\n            ('[id*=\"noending\"]', []),\n            # New for this test\n            ('[href*=\".\"]', ['bob', 'me', 'l1']),\n            ('a[href*=\".\"]', ['bob', 'me']),\n            ('link[href*=\".\"]', ['l1']),\n            ('div[id*=\"n\"]', ['main', 'inner']),\n            ('div[id*=\"nn\"]', ['inner']),\n            ('div[data-tag*=\"edval\"]', ['data1'])\n        )\n\n    def test_attribute_exact_or_hypen(self):\n        self.assert_select_multiple(\n            ('p[lang|=\"en\"]', ['lang-en', 'lang-en-gb', 'lang-en-us']),\n            ('[lang|=\"en\"]', ['lang-en', 'lang-en-gb', 'lang-en-us']),\n            ('p[lang|=\"fr\"]', ['lang-fr']),\n            ('p[lang|=\"gb\"]', []),\n        )\n\n    def test_attribute_exists(self):\n        self.assert_select_multiple(\n            ('[rel]', ['l1', 'bob', 'me']),\n            ('link[rel]', ['l1']),\n            ('a[rel]', ['bob', 'me']),\n            ('[lang]', ['lang-en', 'lang-en-gb', 'lang-en-us', 'lang-fr']),\n            ('p[class]', ['p1', 'pmulti']),\n            ('[blah]', []),\n            ('p[blah]', []),\n            ('div[data-tag]', ['data1'])\n        )\n\n    def test_quoted_space_in_selector_name(self):\n        html = \"\"\"<div style=\"display: wrong\">nope</div>\n        <div style=\"display: right\">yes</div>\n        \"\"\"\n        soup = BeautifulSoup(html, 'html.parser')\n        [chosen] = soup.select('div[style=\"display: right\"]')\n        assert \"yes\" == chosen.string\n\n    def test_unsupported_pseudoclass(self):\n        with pytest.raises(NotImplementedError):\n            self.soup.select(\"a:no-such-pseudoclass\")\n\n        with pytest.raises(SelectorSyntaxError):\n            self.soup.select(\"a:nth-of-type(a)\")\n\n    def test_nth_of_type(self):\n        # Try to select first paragraph\n        els = self.soup.select('div#inner p:nth-of-type(1)')\n        assert len(els) == 1\n        assert els[0].string == 'Some text'\n\n        # Try to select third paragraph\n        els = self.soup.select('div#inner p:nth-of-type(3)')\n        assert len(els) == 1\n        assert els[0].string == 'Another'\n\n        # Try to select (non-existent!) fourth paragraph\n        els = self.soup.select('div#inner p:nth-of-type(4)')\n        assert len(els) == 0\n\n        # Zero will select no tags.\n        els = self.soup.select('div p:nth-of-type(0)')\n        assert len(els) == 0\n\n    def test_nth_of_type_direct_descendant(self):\n        els = self.soup.select('div#inner > p:nth-of-type(1)')\n        assert len(els) == 1\n        assert els[0].string == 'Some text'\n\n    def test_id_child_selector_nth_of_type(self):\n        self.assert_selects('#inner > p:nth-of-type(2)', ['p1'])\n\n    def test_select_on_element(self):\n        # Other tests operate on the tree; this operates on an element\n        # within the tree.\n        inner = self.soup.find(\"div\", id=\"main\")\n        selected = inner.select(\"div\")\n        # The <div id=\"inner\"> tag was selected. The <div id=\"footer\">\n        # tag was not.\n        self.assert_selects_ids(selected, ['inner', 'data1'])\n\n    def test_overspecified_child_id(self):\n        self.assert_selects(\".fancy #inner\", ['inner'])\n        self.assert_selects(\".normal #inner\", [])\n\n    def test_adjacent_sibling_selector(self):\n        self.assert_selects('#p1 + h2', ['header2'])\n        self.assert_selects('#p1 + h2 + p', ['pmulti'])\n        self.assert_selects('#p1 + #header2 + .class1', ['pmulti'])\n        assert [] == self.soup.select('#p1 + p')\n\n    def test_general_sibling_selector(self):\n        self.assert_selects('#p1 ~ h2', ['header2', 'header3'])\n        self.assert_selects('#p1 ~ #header2', ['header2'])\n        self.assert_selects('#p1 ~ h2 + a', ['me'])\n        self.assert_selects('#p1 ~ h2 + [rel=\"me\"]', ['me'])\n        assert [] == self.soup.select('#inner ~ h2')\n\n    def test_dangling_combinator(self):\n        with pytest.raises(SelectorSyntaxError):\n            self.soup.select('h1 >')\n\n    def test_sibling_combinator_wont_select_same_tag_twice(self):\n        self.assert_selects('p[lang] ~ p', ['lang-en-gb', 'lang-en-us', 'lang-fr'])\n\n    # Test the selector grouping operator (the comma)\n    def test_multiple_select(self):\n        self.assert_selects('x, y', ['xid', 'yid'])\n\n    def test_multiple_select_with_no_space(self):\n        self.assert_selects('x,y', ['xid', 'yid'])\n\n    def test_multiple_select_with_more_space(self):\n        self.assert_selects('x,    y', ['xid', 'yid'])\n\n    def test_multiple_select_duplicated(self):\n        self.assert_selects('x, x', ['xid'])\n\n    def test_multiple_select_sibling(self):\n        self.assert_selects('x, y ~ p[lang=fr]', ['xid', 'lang-fr'])\n\n    def test_multiple_select_tag_and_direct_descendant(self):\n        self.assert_selects('x, y > z', ['xid', 'zidb'])\n\n    def test_multiple_select_direct_descendant_and_tags(self):\n        self.assert_selects('div > x, y, z', ['xid', 'yid', 'zida', 'zidb', 'zidab', 'zidac'])\n\n    def test_multiple_select_indirect_descendant(self):\n        self.assert_selects('div x,y,  z', ['xid', 'yid', 'zida', 'zidb', 'zidab', 'zidac'])\n\n    def test_invalid_multiple_select(self):\n        with pytest.raises(SelectorSyntaxError):\n            self.soup.select(',x, y')\n        with pytest.raises(SelectorSyntaxError):\n            self.soup.select('x,,y')\n\n    def test_multiple_select_attrs(self):\n        self.assert_selects('p[lang=en], p[lang=en-gb]', ['lang-en', 'lang-en-gb'])\n\n    def test_multiple_select_ids(self):\n        self.assert_selects('x, y > z[id=zida], z[id=zidab], z[id=zidb]', ['xid', 'zidb', 'zidab'])\n\n    def test_multiple_select_nested(self):\n        self.assert_selects('body > div > x, y > z', ['xid', 'zidb'])\n\n    def test_select_duplicate_elements(self):\n        # When markup contains duplicate elements, a multiple select\n        # will find all of them.\n        markup = '<div class=\"c1\"/><div class=\"c2\"/><div class=\"c1\"/>'\n        soup = BeautifulSoup(markup, 'html.parser')\n        selected = soup.select(\".c1, .c2\")\n        assert 3 == len(selected)\n\n        # Verify that find_all finds the same elements, though because\n        # of an implementation detail it finds them in a different\n        # order.\n        for element in soup.find_all(class_=['c1', 'c2']):\n            assert element in selected\n\n    def test_closest(self):\n        inner = self.soup.find(\"div\", id=\"inner\")\n        closest = inner.css.closest(\"div[id=main]\")\n        assert closest == self.soup.find(\"div\", id=\"main\")\n\n    def test_match(self):\n        inner = self.soup.find(\"div\", id=\"inner\")\n        main = self.soup.find(\"div\", id=\"main\")\n        assert inner.css.match(\"div[id=main]\") == False\n        assert main.css.match(\"div[id=main]\") == True\n\n    def test_iselect(self):\n        gen = self.soup.css.iselect(\"h2\")\n        assert isinstance(gen, types.GeneratorType)\n        [header2, header3] = gen\n        assert header2['id'] == 'header2'\n        assert header3['id'] == 'header3'\n\n    def test_filter(self):\n        inner = self.soup.find(\"div\", id=\"inner\")\n        results = inner.css.filter(\"h2\")\n        assert len(inner.css.filter(\"h2\")) == 2\n\n        results = inner.css.filter(\"h2[id=header3]\")\n        assert isinstance(results, ResultSet)\n        [result] = results\n        assert result['id'] == 'header3'\n\n    def test_escape(self):\n        m = self.soup.css.escape\n        assert m(\".foo#bar\") == '\\\\.foo\\\\#bar'\n        assert m(\"()[]{}\") == '\\\\(\\\\)\\\\[\\\\]\\\\{\\\\}'\n        assert m(\".foo\") == self.soup.css.escape(\".foo\")\n"},"hash":"zxmnGKFDl9"}