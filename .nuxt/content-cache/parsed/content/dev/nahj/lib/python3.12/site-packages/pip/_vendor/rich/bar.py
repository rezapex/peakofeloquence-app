{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:rich:bar.py","body":"from typing import Optional, Union\n\nfrom .color import Color\nfrom .console import Console, ConsoleOptions, RenderResult\nfrom .jupyter import JupyterMixin\nfrom .measure import Measurement\nfrom .segment import Segment\nfrom .style import Style\n\n# There are left-aligned characters for 1/8 to 7/8, but\n# the right-aligned characters exist only for 1/8 and 4/8.\nBEGIN_BLOCK_ELEMENTS = [\"█\", \"█\", \"█\", \"▐\", \"▐\", \"▐\", \"▕\", \"▕\"]\nEND_BLOCK_ELEMENTS = [\" \", \"▏\", \"▎\", \"▍\", \"▌\", \"▋\", \"▊\", \"▉\"]\nFULL_BLOCK = \"█\"\n\n\nclass Bar(JupyterMixin):\n    \"\"\"Renders a solid block bar.\n\n    Args:\n        size (float): Value for the end of the bar.\n        begin (float): Begin point (between 0 and size, inclusive).\n        end (float): End point (between 0 and size, inclusive).\n        width (int, optional): Width of the bar, or ``None`` for maximum width. Defaults to None.\n        color (Union[Color, str], optional): Color of the bar. Defaults to \"default\".\n        bgcolor (Union[Color, str], optional): Color of bar background. Defaults to \"default\".\n    \"\"\"\n\n    def __init__(\n        self,\n        size: float,\n        begin: float,\n        end: float,\n        *,\n        width: Optional[int] = None,\n        color: Union[Color, str] = \"default\",\n        bgcolor: Union[Color, str] = \"default\",\n    ):\n        self.size = size\n        self.begin = max(begin, 0)\n        self.end = min(end, size)\n        self.width = width\n        self.style = Style(color=color, bgcolor=bgcolor)\n\n    def __repr__(self) -> str:\n        return f\"Bar({self.size}, {self.begin}, {self.end})\"\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n\n        width = min(\n            self.width if self.width is not None else options.max_width,\n            options.max_width,\n        )\n\n        if self.begin >= self.end:\n            yield Segment(\" \" * width, self.style)\n            yield Segment.line()\n            return\n\n        prefix_complete_eights = int(width * 8 * self.begin / self.size)\n        prefix_bar_count = prefix_complete_eights // 8\n        prefix_eights_count = prefix_complete_eights % 8\n\n        body_complete_eights = int(width * 8 * self.end / self.size)\n        body_bar_count = body_complete_eights // 8\n        body_eights_count = body_complete_eights % 8\n\n        # When start and end fall into the same cell, we ideally should render\n        # a symbol that's \"center-aligned\", but there is no good symbol in Unicode.\n        # In this case, we fall back to right-aligned block symbol for simplicity.\n\n        prefix = \" \" * prefix_bar_count\n        if prefix_eights_count:\n            prefix += BEGIN_BLOCK_ELEMENTS[prefix_eights_count]\n\n        body = FULL_BLOCK * body_bar_count\n        if body_eights_count:\n            body += END_BLOCK_ELEMENTS[body_eights_count]\n\n        suffix = \" \" * (width - len(body))\n\n        yield Segment(prefix + body[len(prefix) :] + suffix, self.style)\n        yield Segment.line()\n\n    def __rich_measure__(\n        self, console: Console, options: ConsoleOptions\n    ) -> Measurement:\n        return (\n            Measurement(self.width, self.width)\n            if self.width is not None\n            else Measurement(4, options.max_width)\n        )\n"},"hash":"IeIkNQkC92"}