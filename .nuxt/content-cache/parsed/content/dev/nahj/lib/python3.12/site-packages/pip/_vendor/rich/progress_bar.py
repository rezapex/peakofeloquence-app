{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:rich:progress_bar.py","body":"import math\nfrom functools import lru_cache\nfrom time import monotonic\nfrom typing import Iterable, List, Optional\n\nfrom .color import Color, blend_rgb\nfrom .color_triplet import ColorTriplet\nfrom .console import Console, ConsoleOptions, RenderResult\nfrom .jupyter import JupyterMixin\nfrom .measure import Measurement\nfrom .segment import Segment\nfrom .style import Style, StyleType\n\n# Number of characters before 'pulse' animation repeats\nPULSE_SIZE = 20\n\n\nclass ProgressBar(JupyterMixin):\n    \"\"\"Renders a (progress) bar. Used by rich.progress.\n\n    Args:\n        total (float, optional): Number of steps in the bar. Defaults to 100. Set to None to render a pulsing animation.\n        completed (float, optional): Number of steps completed. Defaults to 0.\n        width (int, optional): Width of the bar, or ``None`` for maximum width. Defaults to None.\n        pulse (bool, optional): Enable pulse effect. Defaults to False. Will pulse if a None total was passed.\n        style (StyleType, optional): Style for the bar background. Defaults to \"bar.back\".\n        complete_style (StyleType, optional): Style for the completed bar. Defaults to \"bar.complete\".\n        finished_style (StyleType, optional): Style for a finished bar. Defaults to \"bar.finished\".\n        pulse_style (StyleType, optional): Style for pulsing bars. Defaults to \"bar.pulse\".\n        animation_time (Optional[float], optional): Time in seconds to use for animation, or None to use system time.\n    \"\"\"\n\n    def __init__(\n        self,\n        total: Optional[float] = 100.0,\n        completed: float = 0,\n        width: Optional[int] = None,\n        pulse: bool = False,\n        style: StyleType = \"bar.back\",\n        complete_style: StyleType = \"bar.complete\",\n        finished_style: StyleType = \"bar.finished\",\n        pulse_style: StyleType = \"bar.pulse\",\n        animation_time: Optional[float] = None,\n    ):\n        self.total = total\n        self.completed = completed\n        self.width = width\n        self.pulse = pulse\n        self.style = style\n        self.complete_style = complete_style\n        self.finished_style = finished_style\n        self.pulse_style = pulse_style\n        self.animation_time = animation_time\n\n        self._pulse_segments: Optional[List[Segment]] = None\n\n    def __repr__(self) -> str:\n        return f\"<Bar {self.completed!r} of {self.total!r}>\"\n\n    @property\n    def percentage_completed(self) -> Optional[float]:\n        \"\"\"Calculate percentage complete.\"\"\"\n        if self.total is None:\n            return None\n        completed = (self.completed / self.total) * 100.0\n        completed = min(100, max(0.0, completed))\n        return completed\n\n    @lru_cache(maxsize=16)\n    def _get_pulse_segments(\n        self,\n        fore_style: Style,\n        back_style: Style,\n        color_system: str,\n        no_color: bool,\n        ascii: bool = False,\n    ) -> List[Segment]:\n        \"\"\"Get a list of segments to render a pulse animation.\n\n        Returns:\n            List[Segment]: A list of segments, one segment per character.\n        \"\"\"\n        bar = \"-\" if ascii else \"━\"\n        segments: List[Segment] = []\n        if color_system not in (\"standard\", \"eight_bit\", \"truecolor\") or no_color:\n            segments += [Segment(bar, fore_style)] * (PULSE_SIZE // 2)\n            segments += [Segment(\" \" if no_color else bar, back_style)] * (\n                PULSE_SIZE - (PULSE_SIZE // 2)\n            )\n            return segments\n\n        append = segments.append\n        fore_color = (\n            fore_style.color.get_truecolor()\n            if fore_style.color\n            else ColorTriplet(255, 0, 255)\n        )\n        back_color = (\n            back_style.color.get_truecolor()\n            if back_style.color\n            else ColorTriplet(0, 0, 0)\n        )\n        cos = math.cos\n        pi = math.pi\n        _Segment = Segment\n        _Style = Style\n        from_triplet = Color.from_triplet\n\n        for index in range(PULSE_SIZE):\n            position = index / PULSE_SIZE\n            fade = 0.5 + cos((position * pi * 2)) / 2.0\n            color = blend_rgb(fore_color, back_color, cross_fade=fade)\n            append(_Segment(bar, _Style(color=from_triplet(color))))\n        return segments\n\n    def update(self, completed: float, total: Optional[float] = None) -> None:\n        \"\"\"Update progress with new values.\n\n        Args:\n            completed (float): Number of steps completed.\n            total (float, optional): Total number of steps, or ``None`` to not change. Defaults to None.\n        \"\"\"\n        self.completed = completed\n        self.total = total if total is not None else self.total\n\n    def _render_pulse(\n        self, console: Console, width: int, ascii: bool = False\n    ) -> Iterable[Segment]:\n        \"\"\"Renders the pulse animation.\n\n        Args:\n            console (Console): Console instance.\n            width (int): Width in characters of pulse animation.\n\n        Returns:\n            RenderResult: [description]\n\n        Yields:\n            Iterator[Segment]: Segments to render pulse\n        \"\"\"\n        fore_style = console.get_style(self.pulse_style, default=\"white\")\n        back_style = console.get_style(self.style, default=\"black\")\n\n        pulse_segments = self._get_pulse_segments(\n            fore_style, back_style, console.color_system, console.no_color, ascii=ascii\n        )\n        segment_count = len(pulse_segments)\n        current_time = (\n            monotonic() if self.animation_time is None else self.animation_time\n        )\n        segments = pulse_segments * (int(width / segment_count) + 2)\n        offset = int(-current_time * 15) % segment_count\n        segments = segments[offset : offset + width]\n        yield from segments\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n\n        width = min(self.width or options.max_width, options.max_width)\n        ascii = options.legacy_windows or options.ascii_only\n        should_pulse = self.pulse or self.total is None\n        if should_pulse:\n            yield from self._render_pulse(console, width, ascii=ascii)\n            return\n\n        completed: Optional[float] = (\n            min(self.total, max(0, self.completed)) if self.total is not None else None\n        )\n\n        bar = \"-\" if ascii else \"━\"\n        half_bar_right = \" \" if ascii else \"╸\"\n        half_bar_left = \" \" if ascii else \"╺\"\n        complete_halves = (\n            int(width * 2 * completed / self.total)\n            if self.total and completed is not None\n            else width * 2\n        )\n        bar_count = complete_halves // 2\n        half_bar_count = complete_halves % 2\n        style = console.get_style(self.style)\n        is_finished = self.total is None or self.completed >= self.total\n        complete_style = console.get_style(\n            self.finished_style if is_finished else self.complete_style\n        )\n        _Segment = Segment\n        if bar_count:\n            yield _Segment(bar * bar_count, complete_style)\n        if half_bar_count:\n            yield _Segment(half_bar_right * half_bar_count, complete_style)\n\n        if not console.no_color:\n            remaining_bars = width - bar_count - half_bar_count\n            if remaining_bars and console.color_system is not None:\n                if not half_bar_count and bar_count:\n                    yield _Segment(half_bar_left, style)\n                    remaining_bars -= 1\n                if remaining_bars:\n                    yield _Segment(bar * remaining_bars, style)\n\n    def __rich_measure__(\n        self, console: Console, options: ConsoleOptions\n    ) -> Measurement:\n        return (\n            Measurement(self.width, self.width)\n            if self.width is not None\n            else Measurement(4, options.max_width)\n        )\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    console = Console()\n    bar = ProgressBar(width=50, total=100)\n\n    import time\n\n    console.show_cursor(False)\n    for n in range(0, 101, 1):\n        bar.update(n)\n        console.print(bar)\n        console.file.write(\"\\r\")\n        time.sleep(0.05)\n    console.show_cursor(True)\n    console.print()\n"},"hash":"LX0wudlIze"}