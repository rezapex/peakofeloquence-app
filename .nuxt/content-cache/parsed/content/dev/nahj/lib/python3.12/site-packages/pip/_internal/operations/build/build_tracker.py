{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:operations:build:build_tracker.py","body":"import contextlib\nimport hashlib\nimport logging\nimport os\nfrom types import TracebackType\nfrom typing import Dict, Generator, Optional, Set, Type, Union\n\nfrom pip._internal.models.link import Link\nfrom pip._internal.req.req_install import InstallRequirement\nfrom pip._internal.utils.temp_dir import TempDirectory\n\nlogger = logging.getLogger(__name__)\n\n\n@contextlib.contextmanager\ndef update_env_context_manager(**changes: str) -> Generator[None, None, None]:\n    target = os.environ\n\n    # Save values from the target and change them.\n    non_existent_marker = object()\n    saved_values: Dict[str, Union[object, str]] = {}\n    for name, new_value in changes.items():\n        try:\n            saved_values[name] = target[name]\n        except KeyError:\n            saved_values[name] = non_existent_marker\n        target[name] = new_value\n\n    try:\n        yield\n    finally:\n        # Restore original values in the target.\n        for name, original_value in saved_values.items():\n            if original_value is non_existent_marker:\n                del target[name]\n            else:\n                assert isinstance(original_value, str)  # for mypy\n                target[name] = original_value\n\n\n@contextlib.contextmanager\ndef get_build_tracker() -> Generator[\"BuildTracker\", None, None]:\n    root = os.environ.get(\"PIP_BUILD_TRACKER\")\n    with contextlib.ExitStack() as ctx:\n        if root is None:\n            root = ctx.enter_context(TempDirectory(kind=\"build-tracker\")).path\n            ctx.enter_context(update_env_context_manager(PIP_BUILD_TRACKER=root))\n            logger.debug(\"Initialized build tracking at %s\", root)\n\n        with BuildTracker(root) as tracker:\n            yield tracker\n\n\nclass TrackerId(str):\n    \"\"\"Uniquely identifying string provided to the build tracker.\"\"\"\n\n\nclass BuildTracker:\n    \"\"\"Ensure that an sdist cannot request itself as a setup requirement.\n\n    When an sdist is prepared, it identifies its setup requirements in the\n    context of ``BuildTracker.track()``. If a requirement shows up recursively, this\n    raises an exception.\n\n    This stops fork bombs embedded in malicious packages.\"\"\"\n\n    def __init__(self, root: str) -> None:\n        self._root = root\n        self._entries: Dict[TrackerId, InstallRequirement] = {}\n        logger.debug(\"Created build tracker: %s\", self._root)\n\n    def __enter__(self) -> \"BuildTracker\":\n        logger.debug(\"Entered build tracker: %s\", self._root)\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        self.cleanup()\n\n    def _entry_path(self, key: TrackerId) -> str:\n        hashed = hashlib.sha224(key.encode()).hexdigest()\n        return os.path.join(self._root, hashed)\n\n    def add(self, req: InstallRequirement, key: TrackerId) -> None:\n        \"\"\"Add an InstallRequirement to build tracking.\"\"\"\n\n        # Get the file to write information about this requirement.\n        entry_path = self._entry_path(key)\n\n        # Try reading from the file. If it exists and can be read from, a build\n        # is already in progress, so a LookupError is raised.\n        try:\n            with open(entry_path) as fp:\n                contents = fp.read()\n        except FileNotFoundError:\n            pass\n        else:\n            message = \"{} is already being built: {}\".format(req.link, contents)\n            raise LookupError(message)\n\n        # If we're here, req should really not be building already.\n        assert key not in self._entries\n\n        # Start tracking this requirement.\n        with open(entry_path, \"w\", encoding=\"utf-8\") as fp:\n            fp.write(str(req))\n        self._entries[key] = req\n\n        logger.debug(\"Added %s to build tracker %r\", req, self._root)\n\n    def remove(self, req: InstallRequirement, key: TrackerId) -> None:\n        \"\"\"Remove an InstallRequirement from build tracking.\"\"\"\n\n        # Delete the created file and the corresponding entry.\n        os.unlink(self._entry_path(key))\n        del self._entries[key]\n\n        logger.debug(\"Removed %s from build tracker %r\", req, self._root)\n\n    def cleanup(self) -> None:\n        for key, req in list(self._entries.items()):\n            self.remove(req, key)\n\n        logger.debug(\"Removed build tracker: %r\", self._root)\n\n    @contextlib.contextmanager\n    def track(self, req: InstallRequirement, key: str) -> Generator[None, None, None]:\n        \"\"\"Ensure that `key` cannot install itself as a setup requirement.\n\n        :raises LookupError: If `key` was already provided in a parent invocation of\n                             the context introduced by this method.\"\"\"\n        tracker_id = TrackerId(key)\n        self.add(req, tracker_id)\n        yield\n        self.remove(req, tracker_id)\n"},"hash":"I4qXEfDysA"}