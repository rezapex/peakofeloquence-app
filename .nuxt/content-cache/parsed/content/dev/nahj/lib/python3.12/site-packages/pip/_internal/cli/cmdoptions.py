{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:cli:cmdoptions.py","body":"\"\"\"\nshared options and groups\n\nThe principle here is to define options once, but *not* instantiate them\nglobally. One reason being that options with action='append' can carry state\nbetween parses. pip parses general options twice internally, and shouldn't\npass on state. To be consistent, all options will follow this design.\n\"\"\"\n\n# The following comment should be removed at some point in the future.\n# mypy: strict-optional=False\n\nimport importlib.util\nimport logging\nimport os\nimport textwrap\nfrom functools import partial\nfrom optparse import SUPPRESS_HELP, Option, OptionGroup, OptionParser, Values\nfrom textwrap import dedent\nfrom typing import Any, Callable, Dict, Optional, Tuple\n\nfrom pip._vendor.packaging.utils import canonicalize_name\n\nfrom pip._internal.cli.parser import ConfigOptionParser\nfrom pip._internal.exceptions import CommandError\nfrom pip._internal.locations import USER_CACHE_DIR, get_src_prefix\nfrom pip._internal.models.format_control import FormatControl\nfrom pip._internal.models.index import PyPI\nfrom pip._internal.models.target_python import TargetPython\nfrom pip._internal.utils.hashes import STRONG_HASHES\nfrom pip._internal.utils.misc import strtobool\n\nlogger = logging.getLogger(__name__)\n\n\ndef raise_option_error(parser: OptionParser, option: Option, msg: str) -> None:\n    \"\"\"\n    Raise an option parsing error using parser.error().\n\n    Args:\n      parser: an OptionParser instance.\n      option: an Option instance.\n      msg: the error text.\n    \"\"\"\n    msg = f\"{option} error: {msg}\"\n    msg = textwrap.fill(\" \".join(msg.split()))\n    parser.error(msg)\n\n\ndef make_option_group(group: Dict[str, Any], parser: ConfigOptionParser) -> OptionGroup:\n    \"\"\"\n    Return an OptionGroup object\n    group  -- assumed to be dict with 'name' and 'options' keys\n    parser -- an optparse Parser\n    \"\"\"\n    option_group = OptionGroup(parser, group[\"name\"])\n    for option in group[\"options\"]:\n        option_group.add_option(option())\n    return option_group\n\n\ndef check_dist_restriction(options: Values, check_target: bool = False) -> None:\n    \"\"\"Function for determining if custom platform options are allowed.\n\n    :param options: The OptionParser options.\n    :param check_target: Whether or not to check if --target is being used.\n    \"\"\"\n    dist_restriction_set = any(\n        [\n            options.python_version,\n            options.platforms,\n            options.abis,\n            options.implementation,\n        ]\n    )\n\n    binary_only = FormatControl(set(), {\":all:\"})\n    sdist_dependencies_allowed = (\n        options.format_control != binary_only and not options.ignore_dependencies\n    )\n\n    # Installations or downloads using dist restrictions must not combine\n    # source distributions and dist-specific wheels, as they are not\n    # guaranteed to be locally compatible.\n    if dist_restriction_set and sdist_dependencies_allowed:\n        raise CommandError(\n            \"When restricting platform and interpreter constraints using \"\n            \"--python-version, --platform, --abi, or --implementation, \"\n            \"either --no-deps must be set, or --only-binary=:all: must be \"\n            \"set and --no-binary must not be set (or must be set to \"\n            \":none:).\"\n        )\n\n    if check_target:\n        if not options.dry_run and dist_restriction_set and not options.target_dir:\n            raise CommandError(\n                \"Can not use any platform or abi specific options unless \"\n                \"installing via '--target' or using '--dry-run'\"\n            )\n\n\ndef _path_option_check(option: Option, opt: str, value: str) -> str:\n    return os.path.expanduser(value)\n\n\ndef _package_name_option_check(option: Option, opt: str, value: str) -> str:\n    return canonicalize_name(value)\n\n\nclass PipOption(Option):\n    TYPES = Option.TYPES + (\"path\", \"package_name\")\n    TYPE_CHECKER = Option.TYPE_CHECKER.copy()\n    TYPE_CHECKER[\"package_name\"] = _package_name_option_check\n    TYPE_CHECKER[\"path\"] = _path_option_check\n\n\n###########\n# options #\n###########\n\nhelp_: Callable[..., Option] = partial(\n    Option,\n    \"-h\",\n    \"--help\",\n    dest=\"help\",\n    action=\"help\",\n    help=\"Show help.\",\n)\n\ndebug_mode: Callable[..., Option] = partial(\n    Option,\n    \"--debug\",\n    dest=\"debug_mode\",\n    action=\"store_true\",\n    default=False,\n    help=(\n        \"Let unhandled exceptions propagate outside the main subroutine, \"\n        \"instead of logging them to stderr.\"\n    ),\n)\n\nisolated_mode: Callable[..., Option] = partial(\n    Option,\n    \"--isolated\",\n    dest=\"isolated_mode\",\n    action=\"store_true\",\n    default=False,\n    help=(\n        \"Run pip in an isolated mode, ignoring environment variables and user \"\n        \"configuration.\"\n    ),\n)\n\nrequire_virtualenv: Callable[..., Option] = partial(\n    Option,\n    \"--require-virtualenv\",\n    \"--require-venv\",\n    dest=\"require_venv\",\n    action=\"store_true\",\n    default=False,\n    help=(\n        \"Allow pip to only run in a virtual environment; \"\n        \"exit with an error otherwise.\"\n    ),\n)\n\noverride_externally_managed: Callable[..., Option] = partial(\n    Option,\n    \"--break-system-packages\",\n    dest=\"override_externally_managed\",\n    action=\"store_true\",\n    help=\"Allow pip to modify an EXTERNALLY-MANAGED Python installation\",\n)\n\npython: Callable[..., Option] = partial(\n    Option,\n    \"--python\",\n    dest=\"python\",\n    help=\"Run pip with the specified Python interpreter.\",\n)\n\nverbose: Callable[..., Option] = partial(\n    Option,\n    \"-v\",\n    \"--verbose\",\n    dest=\"verbose\",\n    action=\"count\",\n    default=0,\n    help=\"Give more output. Option is additive, and can be used up to 3 times.\",\n)\n\nno_color: Callable[..., Option] = partial(\n    Option,\n    \"--no-color\",\n    dest=\"no_color\",\n    action=\"store_true\",\n    default=False,\n    help=\"Suppress colored output.\",\n)\n\nversion: Callable[..., Option] = partial(\n    Option,\n    \"-V\",\n    \"--version\",\n    dest=\"version\",\n    action=\"store_true\",\n    help=\"Show version and exit.\",\n)\n\nquiet: Callable[..., Option] = partial(\n    Option,\n    \"-q\",\n    \"--quiet\",\n    dest=\"quiet\",\n    action=\"count\",\n    default=0,\n    help=(\n        \"Give less output. Option is additive, and can be used up to 3\"\n        \" times (corresponding to WARNING, ERROR, and CRITICAL logging\"\n        \" levels).\"\n    ),\n)\n\nprogress_bar: Callable[..., Option] = partial(\n    Option,\n    \"--progress-bar\",\n    dest=\"progress_bar\",\n    type=\"choice\",\n    choices=[\"on\", \"off\"],\n    default=\"on\",\n    help=\"Specify whether the progress bar should be used [on, off] (default: on)\",\n)\n\nlog: Callable[..., Option] = partial(\n    PipOption,\n    \"--log\",\n    \"--log-file\",\n    \"--local-log\",\n    dest=\"log\",\n    metavar=\"path\",\n    type=\"path\",\n    help=\"Path to a verbose appending log.\",\n)\n\nno_input: Callable[..., Option] = partial(\n    Option,\n    # Don't ask for input\n    \"--no-input\",\n    dest=\"no_input\",\n    action=\"store_true\",\n    default=False,\n    help=\"Disable prompting for input.\",\n)\n\nkeyring_provider: Callable[..., Option] = partial(\n    Option,\n    \"--keyring-provider\",\n    dest=\"keyring_provider\",\n    choices=[\"auto\", \"disabled\", \"import\", \"subprocess\"],\n    default=\"auto\",\n    help=(\n        \"Enable the credential lookup via the keyring library if user input is allowed.\"\n        \" Specify which mechanism to use [disabled, import, subprocess].\"\n        \" (default: disabled)\"\n    ),\n)\n\nproxy: Callable[..., Option] = partial(\n    Option,\n    \"--proxy\",\n    dest=\"proxy\",\n    type=\"str\",\n    default=\"\",\n    help=\"Specify a proxy in the form scheme://[user:passwd@]proxy.server:port.\",\n)\n\nretries: Callable[..., Option] = partial(\n    Option,\n    \"--retries\",\n    dest=\"retries\",\n    type=\"int\",\n    default=5,\n    help=\"Maximum number of retries each connection should attempt \"\n    \"(default %default times).\",\n)\n\ntimeout: Callable[..., Option] = partial(\n    Option,\n    \"--timeout\",\n    \"--default-timeout\",\n    metavar=\"sec\",\n    dest=\"timeout\",\n    type=\"float\",\n    default=15,\n    help=\"Set the socket timeout (default %default seconds).\",\n)\n\n\ndef exists_action() -> Option:\n    return Option(\n        # Option when path already exist\n        \"--exists-action\",\n        dest=\"exists_action\",\n        type=\"choice\",\n        choices=[\"s\", \"i\", \"w\", \"b\", \"a\"],\n        default=[],\n        action=\"append\",\n        metavar=\"action\",\n        help=\"Default action when a path already exists: \"\n        \"(s)witch, (i)gnore, (w)ipe, (b)ackup, (a)bort.\",\n    )\n\n\ncert: Callable[..., Option] = partial(\n    PipOption,\n    \"--cert\",\n    dest=\"cert\",\n    type=\"path\",\n    metavar=\"path\",\n    help=(\n        \"Path to PEM-encoded CA certificate bundle. \"\n        \"If provided, overrides the default. \"\n        \"See 'SSL Certificate Verification' in pip documentation \"\n        \"for more information.\"\n    ),\n)\n\nclient_cert: Callable[..., Option] = partial(\n    PipOption,\n    \"--client-cert\",\n    dest=\"client_cert\",\n    type=\"path\",\n    default=None,\n    metavar=\"path\",\n    help=\"Path to SSL client certificate, a single file containing the \"\n    \"private key and the certificate in PEM format.\",\n)\n\nindex_url: Callable[..., Option] = partial(\n    Option,\n    \"-i\",\n    \"--index-url\",\n    \"--pypi-url\",\n    dest=\"index_url\",\n    metavar=\"URL\",\n    default=PyPI.simple_url,\n    help=\"Base URL of the Python Package Index (default %default). \"\n    \"This should point to a repository compliant with PEP 503 \"\n    \"(the simple repository API) or a local directory laid out \"\n    \"in the same format.\",\n)\n\n\ndef extra_index_url() -> Option:\n    return Option(\n        \"--extra-index-url\",\n        dest=\"extra_index_urls\",\n        metavar=\"URL\",\n        action=\"append\",\n        default=[],\n        help=\"Extra URLs of package indexes to use in addition to \"\n        \"--index-url. Should follow the same rules as \"\n        \"--index-url.\",\n    )\n\n\nno_index: Callable[..., Option] = partial(\n    Option,\n    \"--no-index\",\n    dest=\"no_index\",\n    action=\"store_true\",\n    default=False,\n    help=\"Ignore package index (only looking at --find-links URLs instead).\",\n)\n\n\ndef find_links() -> Option:\n    return Option(\n        \"-f\",\n        \"--find-links\",\n        dest=\"find_links\",\n        action=\"append\",\n        default=[],\n        metavar=\"url\",\n        help=\"If a URL or path to an html file, then parse for links to \"\n        \"archives such as sdist (.tar.gz) or wheel (.whl) files. \"\n        \"If a local path or file:// URL that's a directory, \"\n        \"then look for archives in the directory listing. \"\n        \"Links to VCS project URLs are not supported.\",\n    )\n\n\ndef trusted_host() -> Option:\n    return Option(\n        \"--trusted-host\",\n        dest=\"trusted_hosts\",\n        action=\"append\",\n        metavar=\"HOSTNAME\",\n        default=[],\n        help=\"Mark this host or host:port pair as trusted, even though it \"\n        \"does not have valid or any HTTPS.\",\n    )\n\n\ndef constraints() -> Option:\n    return Option(\n        \"-c\",\n        \"--constraint\",\n        dest=\"constraints\",\n        action=\"append\",\n        default=[],\n        metavar=\"file\",\n        help=\"Constrain versions using the given constraints file. \"\n        \"This option can be used multiple times.\",\n    )\n\n\ndef requirements() -> Option:\n    return Option(\n        \"-r\",\n        \"--requirement\",\n        dest=\"requirements\",\n        action=\"append\",\n        default=[],\n        metavar=\"file\",\n        help=\"Install from the given requirements file. \"\n        \"This option can be used multiple times.\",\n    )\n\n\ndef editable() -> Option:\n    return Option(\n        \"-e\",\n        \"--editable\",\n        dest=\"editables\",\n        action=\"append\",\n        default=[],\n        metavar=\"path/url\",\n        help=(\n            \"Install a project in editable mode (i.e. setuptools \"\n            '\"develop mode\") from a local project path or a VCS url.'\n        ),\n    )\n\n\ndef _handle_src(option: Option, opt_str: str, value: str, parser: OptionParser) -> None:\n    value = os.path.abspath(value)\n    setattr(parser.values, option.dest, value)\n\n\nsrc: Callable[..., Option] = partial(\n    PipOption,\n    \"--src\",\n    \"--source\",\n    \"--source-dir\",\n    \"--source-directory\",\n    dest=\"src_dir\",\n    type=\"path\",\n    metavar=\"dir\",\n    default=get_src_prefix(),\n    action=\"callback\",\n    callback=_handle_src,\n    help=\"Directory to check out editable projects into. \"\n    'The default in a virtualenv is \"<venv path>/src\". '\n    'The default for global installs is \"<current dir>/src\".',\n)\n\n\ndef _get_format_control(values: Values, option: Option) -> Any:\n    \"\"\"Get a format_control object.\"\"\"\n    return getattr(values, option.dest)\n\n\ndef _handle_no_binary(\n    option: Option, opt_str: str, value: str, parser: OptionParser\n) -> None:\n    existing = _get_format_control(parser.values, option)\n    FormatControl.handle_mutual_excludes(\n        value,\n        existing.no_binary,\n        existing.only_binary,\n    )\n\n\ndef _handle_only_binary(\n    option: Option, opt_str: str, value: str, parser: OptionParser\n) -> None:\n    existing = _get_format_control(parser.values, option)\n    FormatControl.handle_mutual_excludes(\n        value,\n        existing.only_binary,\n        existing.no_binary,\n    )\n\n\ndef no_binary() -> Option:\n    format_control = FormatControl(set(), set())\n    return Option(\n        \"--no-binary\",\n        dest=\"format_control\",\n        action=\"callback\",\n        callback=_handle_no_binary,\n        type=\"str\",\n        default=format_control,\n        help=\"Do not use binary packages. Can be supplied multiple times, and \"\n        'each time adds to the existing value. Accepts either \":all:\" to '\n        'disable all binary packages, \":none:\" to empty the set (notice '\n        \"the colons), or one or more package names with commas between \"\n        \"them (no colons). Note that some packages are tricky to compile \"\n        \"and may fail to install when this option is used on them.\",\n    )\n\n\ndef only_binary() -> Option:\n    format_control = FormatControl(set(), set())\n    return Option(\n        \"--only-binary\",\n        dest=\"format_control\",\n        action=\"callback\",\n        callback=_handle_only_binary,\n        type=\"str\",\n        default=format_control,\n        help=\"Do not use source packages. Can be supplied multiple times, and \"\n        'each time adds to the existing value. Accepts either \":all:\" to '\n        'disable all source packages, \":none:\" to empty the set, or one '\n        \"or more package names with commas between them. Packages \"\n        \"without binary distributions will fail to install when this \"\n        \"option is used on them.\",\n    )\n\n\nplatforms: Callable[..., Option] = partial(\n    Option,\n    \"--platform\",\n    dest=\"platforms\",\n    metavar=\"platform\",\n    action=\"append\",\n    default=None,\n    help=(\n        \"Only use wheels compatible with <platform>. Defaults to the \"\n        \"platform of the running system. Use this option multiple times to \"\n        \"specify multiple platforms supported by the target interpreter.\"\n    ),\n)\n\n\n# This was made a separate function for unit-testing purposes.\ndef _convert_python_version(value: str) -> Tuple[Tuple[int, ...], Optional[str]]:\n    \"\"\"\n    Convert a version string like \"3\", \"37\", or \"3.7.3\" into a tuple of ints.\n\n    :return: A 2-tuple (version_info, error_msg), where `error_msg` is\n        non-None if and only if there was a parsing error.\n    \"\"\"\n    if not value:\n        # The empty string is the same as not providing a value.\n        return (None, None)\n\n    parts = value.split(\".\")\n    if len(parts) > 3:\n        return ((), \"at most three version parts are allowed\")\n\n    if len(parts) == 1:\n        # Then we are in the case of \"3\" or \"37\".\n        value = parts[0]\n        if len(value) > 1:\n            parts = [value[0], value[1:]]\n\n    try:\n        version_info = tuple(int(part) for part in parts)\n    except ValueError:\n        return ((), \"each version part must be an integer\")\n\n    return (version_info, None)\n\n\ndef _handle_python_version(\n    option: Option, opt_str: str, value: str, parser: OptionParser\n) -> None:\n    \"\"\"\n    Handle a provided --python-version value.\n    \"\"\"\n    version_info, error_msg = _convert_python_version(value)\n    if error_msg is not None:\n        msg = f\"invalid --python-version value: {value!r}: {error_msg}\"\n        raise_option_error(parser, option=option, msg=msg)\n\n    parser.values.python_version = version_info\n\n\npython_version: Callable[..., Option] = partial(\n    Option,\n    \"--python-version\",\n    dest=\"python_version\",\n    metavar=\"python_version\",\n    action=\"callback\",\n    callback=_handle_python_version,\n    type=\"str\",\n    default=None,\n    help=dedent(\n        \"\"\"\\\n    The Python interpreter version to use for wheel and \"Requires-Python\"\n    compatibility checks. Defaults to a version derived from the running\n    interpreter. The version can be specified using up to three dot-separated\n    integers (e.g. \"3\" for 3.0.0, \"3.7\" for 3.7.0, or \"3.7.3\"). A major-minor\n    version can also be given as a string without dots (e.g. \"37\" for 3.7.0).\n    \"\"\"\n    ),\n)\n\n\nimplementation: Callable[..., Option] = partial(\n    Option,\n    \"--implementation\",\n    dest=\"implementation\",\n    metavar=\"implementation\",\n    default=None,\n    help=(\n        \"Only use wheels compatible with Python \"\n        \"implementation <implementation>, e.g. 'pp', 'jy', 'cp', \"\n        \" or 'ip'. If not specified, then the current \"\n        \"interpreter implementation is used.  Use 'py' to force \"\n        \"implementation-agnostic wheels.\"\n    ),\n)\n\n\nabis: Callable[..., Option] = partial(\n    Option,\n    \"--abi\",\n    dest=\"abis\",\n    metavar=\"abi\",\n    action=\"append\",\n    default=None,\n    help=(\n        \"Only use wheels compatible with Python abi <abi>, e.g. 'pypy_41'. \"\n        \"If not specified, then the current interpreter abi tag is used. \"\n        \"Use this option multiple times to specify multiple abis supported \"\n        \"by the target interpreter. Generally you will need to specify \"\n        \"--implementation, --platform, and --python-version when using this \"\n        \"option.\"\n    ),\n)\n\n\ndef add_target_python_options(cmd_opts: OptionGroup) -> None:\n    cmd_opts.add_option(platforms())\n    cmd_opts.add_option(python_version())\n    cmd_opts.add_option(implementation())\n    cmd_opts.add_option(abis())\n\n\ndef make_target_python(options: Values) -> TargetPython:\n    target_python = TargetPython(\n        platforms=options.platforms,\n        py_version_info=options.python_version,\n        abis=options.abis,\n        implementation=options.implementation,\n    )\n\n    return target_python\n\n\ndef prefer_binary() -> Option:\n    return Option(\n        \"--prefer-binary\",\n        dest=\"prefer_binary\",\n        action=\"store_true\",\n        default=False,\n        help=(\n            \"Prefer binary packages over source packages, even if the \"\n            \"source packages are newer.\"\n        ),\n    )\n\n\ncache_dir: Callable[..., Option] = partial(\n    PipOption,\n    \"--cache-dir\",\n    dest=\"cache_dir\",\n    default=USER_CACHE_DIR,\n    metavar=\"dir\",\n    type=\"path\",\n    help=\"Store the cache data in <dir>.\",\n)\n\n\ndef _handle_no_cache_dir(\n    option: Option, opt: str, value: str, parser: OptionParser\n) -> None:\n    \"\"\"\n    Process a value provided for the --no-cache-dir option.\n\n    This is an optparse.Option callback for the --no-cache-dir option.\n    \"\"\"\n    # The value argument will be None if --no-cache-dir is passed via the\n    # command-line, since the option doesn't accept arguments.  However,\n    # the value can be non-None if the option is triggered e.g. by an\n    # environment variable, like PIP_NO_CACHE_DIR=true.\n    if value is not None:\n        # Then parse the string value to get argument error-checking.\n        try:\n            strtobool(value)\n        except ValueError as exc:\n            raise_option_error(parser, option=option, msg=str(exc))\n\n    # Originally, setting PIP_NO_CACHE_DIR to a value that strtobool()\n    # converted to 0 (like \"false\" or \"no\") caused cache_dir to be disabled\n    # rather than enabled (logic would say the latter).  Thus, we disable\n    # the cache directory not just on values that parse to True, but (for\n    # backwards compatibility reasons) also on values that parse to False.\n    # In other words, always set it to False if the option is provided in\n    # some (valid) form.\n    parser.values.cache_dir = False\n\n\nno_cache: Callable[..., Option] = partial(\n    Option,\n    \"--no-cache-dir\",\n    dest=\"cache_dir\",\n    action=\"callback\",\n    callback=_handle_no_cache_dir,\n    help=\"Disable the cache.\",\n)\n\nno_deps: Callable[..., Option] = partial(\n    Option,\n    \"--no-deps\",\n    \"--no-dependencies\",\n    dest=\"ignore_dependencies\",\n    action=\"store_true\",\n    default=False,\n    help=\"Don't install package dependencies.\",\n)\n\nignore_requires_python: Callable[..., Option] = partial(\n    Option,\n    \"--ignore-requires-python\",\n    dest=\"ignore_requires_python\",\n    action=\"store_true\",\n    help=\"Ignore the Requires-Python information.\",\n)\n\nno_build_isolation: Callable[..., Option] = partial(\n    Option,\n    \"--no-build-isolation\",\n    dest=\"build_isolation\",\n    action=\"store_false\",\n    default=True,\n    help=\"Disable isolation when building a modern source distribution. \"\n    \"Build dependencies specified by PEP 518 must be already installed \"\n    \"if this option is used.\",\n)\n\ncheck_build_deps: Callable[..., Option] = partial(\n    Option,\n    \"--check-build-dependencies\",\n    dest=\"check_build_deps\",\n    action=\"store_true\",\n    default=False,\n    help=\"Check the build dependencies when PEP517 is used.\",\n)\n\n\ndef _handle_no_use_pep517(\n    option: Option, opt: str, value: str, parser: OptionParser\n) -> None:\n    \"\"\"\n    Process a value provided for the --no-use-pep517 option.\n\n    This is an optparse.Option callback for the no_use_pep517 option.\n    \"\"\"\n    # Since --no-use-pep517 doesn't accept arguments, the value argument\n    # will be None if --no-use-pep517 is passed via the command-line.\n    # However, the value can be non-None if the option is triggered e.g.\n    # by an environment variable, for example \"PIP_NO_USE_PEP517=true\".\n    if value is not None:\n        msg = \"\"\"A value was passed for --no-use-pep517,\n        probably using either the PIP_NO_USE_PEP517 environment variable\n        or the \"no-use-pep517\" config file option. Use an appropriate value\n        of the PIP_USE_PEP517 environment variable or the \"use-pep517\"\n        config file option instead.\n        \"\"\"\n        raise_option_error(parser, option=option, msg=msg)\n\n    # If user doesn't wish to use pep517, we check if setuptools and wheel are installed\n    # and raise error if it is not.\n    packages = (\"setuptools\", \"wheel\")\n    if not all(importlib.util.find_spec(package) for package in packages):\n        msg = (\n            f\"It is not possible to use --no-use-pep517 \"\n            f\"without {' and '.join(packages)} installed.\"\n        )\n        raise_option_error(parser, option=option, msg=msg)\n\n    # Otherwise, --no-use-pep517 was passed via the command-line.\n    parser.values.use_pep517 = False\n\n\nuse_pep517: Any = partial(\n    Option,\n    \"--use-pep517\",\n    dest=\"use_pep517\",\n    action=\"store_true\",\n    default=None,\n    help=\"Use PEP 517 for building source distributions \"\n    \"(use --no-use-pep517 to force legacy behaviour).\",\n)\n\nno_use_pep517: Any = partial(\n    Option,\n    \"--no-use-pep517\",\n    dest=\"use_pep517\",\n    action=\"callback\",\n    callback=_handle_no_use_pep517,\n    default=None,\n    help=SUPPRESS_HELP,\n)\n\n\ndef _handle_config_settings(\n    option: Option, opt_str: str, value: str, parser: OptionParser\n) -> None:\n    key, sep, val = value.partition(\"=\")\n    if sep != \"=\":\n        parser.error(f\"Arguments to {opt_str} must be of the form KEY=VAL\")\n    dest = getattr(parser.values, option.dest)\n    if dest is None:\n        dest = {}\n        setattr(parser.values, option.dest, dest)\n    if key in dest:\n        if isinstance(dest[key], list):\n            dest[key].append(val)\n        else:\n            dest[key] = [dest[key], val]\n    else:\n        dest[key] = val\n\n\nconfig_settings: Callable[..., Option] = partial(\n    Option,\n    \"-C\",\n    \"--config-settings\",\n    dest=\"config_settings\",\n    type=str,\n    action=\"callback\",\n    callback=_handle_config_settings,\n    metavar=\"settings\",\n    help=\"Configuration settings to be passed to the PEP 517 build backend. \"\n    \"Settings take the form KEY=VALUE. Use multiple --config-settings options \"\n    \"to pass multiple keys to the backend.\",\n)\n\nbuild_options: Callable[..., Option] = partial(\n    Option,\n    \"--build-option\",\n    dest=\"build_options\",\n    metavar=\"options\",\n    action=\"append\",\n    help=\"Extra arguments to be supplied to 'setup.py bdist_wheel'.\",\n)\n\nglobal_options: Callable[..., Option] = partial(\n    Option,\n    \"--global-option\",\n    dest=\"global_options\",\n    action=\"append\",\n    metavar=\"options\",\n    help=\"Extra global options to be supplied to the setup.py \"\n    \"call before the install or bdist_wheel command.\",\n)\n\nno_clean: Callable[..., Option] = partial(\n    Option,\n    \"--no-clean\",\n    action=\"store_true\",\n    default=False,\n    help=\"Don't clean up build directories.\",\n)\n\npre: Callable[..., Option] = partial(\n    Option,\n    \"--pre\",\n    action=\"store_true\",\n    default=False,\n    help=\"Include pre-release and development versions. By default, \"\n    \"pip only finds stable versions.\",\n)\n\ndisable_pip_version_check: Callable[..., Option] = partial(\n    Option,\n    \"--disable-pip-version-check\",\n    dest=\"disable_pip_version_check\",\n    action=\"store_true\",\n    default=False,\n    help=\"Don't periodically check PyPI to determine whether a new version \"\n    \"of pip is available for download. Implied with --no-index.\",\n)\n\nroot_user_action: Callable[..., Option] = partial(\n    Option,\n    \"--root-user-action\",\n    dest=\"root_user_action\",\n    default=\"warn\",\n    choices=[\"warn\", \"ignore\"],\n    help=\"Action if pip is run as a root user. By default, a warning message is shown.\",\n)\n\n\ndef _handle_merge_hash(\n    option: Option, opt_str: str, value: str, parser: OptionParser\n) -> None:\n    \"\"\"Given a value spelled \"algo:digest\", append the digest to a list\n    pointed to in a dict by the algo name.\"\"\"\n    if not parser.values.hashes:\n        parser.values.hashes = {}\n    try:\n        algo, digest = value.split(\":\", 1)\n    except ValueError:\n        parser.error(\n            f\"Arguments to {opt_str} must be a hash name \"\n            \"followed by a value, like --hash=sha256:\"\n            \"abcde...\"\n        )\n    if algo not in STRONG_HASHES:\n        parser.error(\n            \"Allowed hash algorithms for {} are {}.\".format(\n                opt_str, \", \".join(STRONG_HASHES)\n            )\n        )\n    parser.values.hashes.setdefault(algo, []).append(digest)\n\n\nhash: Callable[..., Option] = partial(\n    Option,\n    \"--hash\",\n    # Hash values eventually end up in InstallRequirement.hashes due to\n    # __dict__ copying in process_line().\n    dest=\"hashes\",\n    action=\"callback\",\n    callback=_handle_merge_hash,\n    type=\"string\",\n    help=\"Verify that the package's archive matches this \"\n    \"hash before installing. Example: --hash=sha256:abcdef...\",\n)\n\n\nrequire_hashes: Callable[..., Option] = partial(\n    Option,\n    \"--require-hashes\",\n    dest=\"require_hashes\",\n    action=\"store_true\",\n    default=False,\n    help=\"Require a hash to check each requirement against, for \"\n    \"repeatable installs. This option is implied when any package in a \"\n    \"requirements file has a --hash option.\",\n)\n\n\nlist_path: Callable[..., Option] = partial(\n    PipOption,\n    \"--path\",\n    dest=\"path\",\n    type=\"path\",\n    action=\"append\",\n    help=\"Restrict to the specified installation path for listing \"\n    \"packages (can be used multiple times).\",\n)\n\n\ndef check_list_path_option(options: Values) -> None:\n    if options.path and (options.user or options.local):\n        raise CommandError(\"Cannot combine '--path' with '--user' or '--local'\")\n\n\nlist_exclude: Callable[..., Option] = partial(\n    PipOption,\n    \"--exclude\",\n    dest=\"excludes\",\n    action=\"append\",\n    metavar=\"package\",\n    type=\"package_name\",\n    help=\"Exclude specified package from the output\",\n)\n\n\nno_python_version_warning: Callable[..., Option] = partial(\n    Option,\n    \"--no-python-version-warning\",\n    dest=\"no_python_version_warning\",\n    action=\"store_true\",\n    default=False,\n    help=\"Silence deprecation warnings for upcoming unsupported Pythons.\",\n)\n\n\n# Features that are now always on. A warning is printed if they are used.\nALWAYS_ENABLED_FEATURES = [\n    \"no-binary-enable-wheel-cache\",  # always on since 23.1\n]\n\nuse_new_feature: Callable[..., Option] = partial(\n    Option,\n    \"--use-feature\",\n    dest=\"features_enabled\",\n    metavar=\"feature\",\n    action=\"append\",\n    default=[],\n    choices=[\n        \"fast-deps\",\n        \"truststore\",\n    ]\n    + ALWAYS_ENABLED_FEATURES,\n    help=\"Enable new functionality, that may be backward incompatible.\",\n)\n\nuse_deprecated_feature: Callable[..., Option] = partial(\n    Option,\n    \"--use-deprecated\",\n    dest=\"deprecated_features_enabled\",\n    metavar=\"feature\",\n    action=\"append\",\n    default=[],\n    choices=[\n        \"legacy-resolver\",\n    ],\n    help=(\"Enable deprecated functionality, that will be removed in the future.\"),\n)\n\n\n##########\n# groups #\n##########\n\ngeneral_group: Dict[str, Any] = {\n    \"name\": \"General Options\",\n    \"options\": [\n        help_,\n        debug_mode,\n        isolated_mode,\n        require_virtualenv,\n        python,\n        verbose,\n        version,\n        quiet,\n        log,\n        no_input,\n        keyring_provider,\n        proxy,\n        retries,\n        timeout,\n        exists_action,\n        trusted_host,\n        cert,\n        client_cert,\n        cache_dir,\n        no_cache,\n        disable_pip_version_check,\n        no_color,\n        no_python_version_warning,\n        use_new_feature,\n        use_deprecated_feature,\n    ],\n}\n\nindex_group: Dict[str, Any] = {\n    \"name\": \"Package Index Options\",\n    \"options\": [\n        index_url,\n        extra_index_url,\n        no_index,\n        find_links,\n    ],\n}\n"},"hash":"QS2GCWd1f7"}