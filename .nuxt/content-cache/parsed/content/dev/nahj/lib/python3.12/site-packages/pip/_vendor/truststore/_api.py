{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:truststore:_api.py","body":"import os\nimport platform\nimport socket\nimport ssl\nimport typing\n\nimport _ssl  # type: ignore[import]\n\nfrom ._ssl_constants import (\n    _original_SSLContext,\n    _original_super_SSLContext,\n    _truststore_SSLContext_dunder_class,\n    _truststore_SSLContext_super_class,\n)\n\nif platform.system() == \"Windows\":\n    from ._windows import _configure_context, _verify_peercerts_impl\nelif platform.system() == \"Darwin\":\n    from ._macos import _configure_context, _verify_peercerts_impl\nelse:\n    from ._openssl import _configure_context, _verify_peercerts_impl\n\nif typing.TYPE_CHECKING:\n    from pip._vendor.typing_extensions import Buffer\n\n# From typeshed/stdlib/ssl.pyi\n_StrOrBytesPath: typing.TypeAlias = str | bytes | os.PathLike[str] | os.PathLike[bytes]\n_PasswordType: typing.TypeAlias = str | bytes | typing.Callable[[], str | bytes]\n\n\ndef inject_into_ssl() -> None:\n    \"\"\"Injects the :class:`truststore.SSLContext` into the ``ssl``\n    module by replacing :class:`ssl.SSLContext`.\n    \"\"\"\n    setattr(ssl, \"SSLContext\", SSLContext)\n    # urllib3 holds on to its own reference of ssl.SSLContext\n    # so we need to replace that reference too.\n    try:\n        import pip._vendor.urllib3.util.ssl_ as urllib3_ssl\n\n        setattr(urllib3_ssl, \"SSLContext\", SSLContext)\n    except ImportError:\n        pass\n\n\ndef extract_from_ssl() -> None:\n    \"\"\"Restores the :class:`ssl.SSLContext` class to its original state\"\"\"\n    setattr(ssl, \"SSLContext\", _original_SSLContext)\n    try:\n        import pip._vendor.urllib3.util.ssl_ as urllib3_ssl\n\n        urllib3_ssl.SSLContext = _original_SSLContext\n    except ImportError:\n        pass\n\n\nclass SSLContext(_truststore_SSLContext_super_class):  # type: ignore[misc]\n    \"\"\"SSLContext API that uses system certificates on all platforms\"\"\"\n\n    @property  # type: ignore[misc]\n    def __class__(self) -> type:\n        # Dirty hack to get around isinstance() checks\n        # for ssl.SSLContext instances in aiohttp/trustme\n        # when using non-CPython implementations.\n        return _truststore_SSLContext_dunder_class or SSLContext\n\n    def __init__(self, protocol: int = None) -> None:  # type: ignore[assignment]\n        self._ctx = _original_SSLContext(protocol)\n\n        class TruststoreSSLObject(ssl.SSLObject):\n            # This object exists because wrap_bio() doesn't\n            # immediately do the handshake so we need to do\n            # certificate verifications after SSLObject.do_handshake()\n\n            def do_handshake(self) -> None:\n                ret = super().do_handshake()\n                _verify_peercerts(self, server_hostname=self.server_hostname)\n                return ret\n\n        self._ctx.sslobject_class = TruststoreSSLObject\n\n    def wrap_socket(\n        self,\n        sock: socket.socket,\n        server_side: bool = False,\n        do_handshake_on_connect: bool = True,\n        suppress_ragged_eofs: bool = True,\n        server_hostname: str | None = None,\n        session: ssl.SSLSession | None = None,\n    ) -> ssl.SSLSocket:\n        # Use a context manager here because the\n        # inner SSLContext holds on to our state\n        # but also does the actual handshake.\n        with _configure_context(self._ctx):\n            ssl_sock = self._ctx.wrap_socket(\n                sock,\n                server_side=server_side,\n                server_hostname=server_hostname,\n                do_handshake_on_connect=do_handshake_on_connect,\n                suppress_ragged_eofs=suppress_ragged_eofs,\n                session=session,\n            )\n        try:\n            _verify_peercerts(ssl_sock, server_hostname=server_hostname)\n        except Exception:\n            ssl_sock.close()\n            raise\n        return ssl_sock\n\n    def wrap_bio(\n        self,\n        incoming: ssl.MemoryBIO,\n        outgoing: ssl.MemoryBIO,\n        server_side: bool = False,\n        server_hostname: str | None = None,\n        session: ssl.SSLSession | None = None,\n    ) -> ssl.SSLObject:\n        with _configure_context(self._ctx):\n            ssl_obj = self._ctx.wrap_bio(\n                incoming,\n                outgoing,\n                server_hostname=server_hostname,\n                server_side=server_side,\n                session=session,\n            )\n        return ssl_obj\n\n    def load_verify_locations(\n        self,\n        cafile: str | bytes | os.PathLike[str] | os.PathLike[bytes] | None = None,\n        capath: str | bytes | os.PathLike[str] | os.PathLike[bytes] | None = None,\n        cadata: typing.Union[str, \"Buffer\", None] = None,\n    ) -> None:\n        return self._ctx.load_verify_locations(\n            cafile=cafile, capath=capath, cadata=cadata\n        )\n\n    def load_cert_chain(\n        self,\n        certfile: _StrOrBytesPath,\n        keyfile: _StrOrBytesPath | None = None,\n        password: _PasswordType | None = None,\n    ) -> None:\n        return self._ctx.load_cert_chain(\n            certfile=certfile, keyfile=keyfile, password=password\n        )\n\n    def load_default_certs(\n        self, purpose: ssl.Purpose = ssl.Purpose.SERVER_AUTH\n    ) -> None:\n        return self._ctx.load_default_certs(purpose)\n\n    def set_alpn_protocols(self, alpn_protocols: typing.Iterable[str]) -> None:\n        return self._ctx.set_alpn_protocols(alpn_protocols)\n\n    def set_npn_protocols(self, npn_protocols: typing.Iterable[str]) -> None:\n        return self._ctx.set_npn_protocols(npn_protocols)\n\n    def set_ciphers(self, __cipherlist: str) -> None:\n        return self._ctx.set_ciphers(__cipherlist)\n\n    def get_ciphers(self) -> typing.Any:\n        return self._ctx.get_ciphers()\n\n    def session_stats(self) -> dict[str, int]:\n        return self._ctx.session_stats()\n\n    def cert_store_stats(self) -> dict[str, int]:\n        raise NotImplementedError()\n\n    @typing.overload\n    def get_ca_certs(\n        self, binary_form: typing.Literal[False] = ...\n    ) -> list[typing.Any]:\n        ...\n\n    @typing.overload\n    def get_ca_certs(self, binary_form: typing.Literal[True] = ...) -> list[bytes]:\n        ...\n\n    @typing.overload\n    def get_ca_certs(self, binary_form: bool = ...) -> typing.Any:\n        ...\n\n    def get_ca_certs(self, binary_form: bool = False) -> list[typing.Any] | list[bytes]:\n        raise NotImplementedError()\n\n    @property\n    def check_hostname(self) -> bool:\n        return self._ctx.check_hostname\n\n    @check_hostname.setter\n    def check_hostname(self, value: bool) -> None:\n        self._ctx.check_hostname = value\n\n    @property\n    def hostname_checks_common_name(self) -> bool:\n        return self._ctx.hostname_checks_common_name\n\n    @hostname_checks_common_name.setter\n    def hostname_checks_common_name(self, value: bool) -> None:\n        self._ctx.hostname_checks_common_name = value\n\n    @property\n    def keylog_filename(self) -> str:\n        return self._ctx.keylog_filename\n\n    @keylog_filename.setter\n    def keylog_filename(self, value: str) -> None:\n        self._ctx.keylog_filename = value\n\n    @property\n    def maximum_version(self) -> ssl.TLSVersion:\n        return self._ctx.maximum_version\n\n    @maximum_version.setter\n    def maximum_version(self, value: ssl.TLSVersion) -> None:\n        _original_super_SSLContext.maximum_version.__set__(  # type: ignore[attr-defined]\n            self._ctx, value\n        )\n\n    @property\n    def minimum_version(self) -> ssl.TLSVersion:\n        return self._ctx.minimum_version\n\n    @minimum_version.setter\n    def minimum_version(self, value: ssl.TLSVersion) -> None:\n        _original_super_SSLContext.minimum_version.__set__(  # type: ignore[attr-defined]\n            self._ctx, value\n        )\n\n    @property\n    def options(self) -> ssl.Options:\n        return self._ctx.options\n\n    @options.setter\n    def options(self, value: ssl.Options) -> None:\n        _original_super_SSLContext.options.__set__(  # type: ignore[attr-defined]\n            self._ctx, value\n        )\n\n    @property\n    def post_handshake_auth(self) -> bool:\n        return self._ctx.post_handshake_auth\n\n    @post_handshake_auth.setter\n    def post_handshake_auth(self, value: bool) -> None:\n        self._ctx.post_handshake_auth = value\n\n    @property\n    def protocol(self) -> ssl._SSLMethod:\n        return self._ctx.protocol\n\n    @property\n    def security_level(self) -> int:\n        return self._ctx.security_level\n\n    @property\n    def verify_flags(self) -> ssl.VerifyFlags:\n        return self._ctx.verify_flags\n\n    @verify_flags.setter\n    def verify_flags(self, value: ssl.VerifyFlags) -> None:\n        _original_super_SSLContext.verify_flags.__set__(  # type: ignore[attr-defined]\n            self._ctx, value\n        )\n\n    @property\n    def verify_mode(self) -> ssl.VerifyMode:\n        return self._ctx.verify_mode\n\n    @verify_mode.setter\n    def verify_mode(self, value: ssl.VerifyMode) -> None:\n        _original_super_SSLContext.verify_mode.__set__(  # type: ignore[attr-defined]\n            self._ctx, value\n        )\n\n\ndef _verify_peercerts(\n    sock_or_sslobj: ssl.SSLSocket | ssl.SSLObject, server_hostname: str | None\n) -> None:\n    \"\"\"\n    Verifies the peer certificates from an SSLSocket or SSLObject\n    against the certificates in the OS trust store.\n    \"\"\"\n    sslobj: ssl.SSLObject = sock_or_sslobj  # type: ignore[assignment]\n    try:\n        while not hasattr(sslobj, \"get_unverified_chain\"):\n            sslobj = sslobj._sslobj  # type: ignore[attr-defined]\n    except AttributeError:\n        pass\n\n    # SSLObject.get_unverified_chain() returns 'None'\n    # if the peer sends no certificates. This is common\n    # for the server-side scenario.\n    unverified_chain: typing.Sequence[_ssl.Certificate] = (\n        sslobj.get_unverified_chain() or ()  # type: ignore[attr-defined]\n    )\n    cert_bytes = [cert.public_bytes(_ssl.ENCODING_DER) for cert in unverified_chain]\n    _verify_peercerts_impl(\n        sock_or_sslobj.context, cert_bytes, server_hostname=server_hostname\n    )\n"},"hash":"wG4wxhTjqA"}