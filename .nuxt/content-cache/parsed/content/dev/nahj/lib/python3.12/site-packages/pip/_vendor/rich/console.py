{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:rich:console.py","body":"import inspect\nimport os\nimport platform\nimport sys\nimport threading\nimport zlib\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom functools import wraps\nfrom getpass import getpass\nfrom html import escape\nfrom inspect import isclass\nfrom itertools import islice\nfrom math import ceil\nfrom time import monotonic\nfrom types import FrameType, ModuleType, TracebackType\nfrom typing import (\n    IO,\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    Dict,\n    Iterable,\n    List,\n    Mapping,\n    NamedTuple,\n    Optional,\n    TextIO,\n    Tuple,\n    Type,\n    Union,\n    cast,\n)\n\nfrom pip._vendor.rich._null_file import NULL_FILE\n\nif sys.version_info >= (3, 8):\n    from typing import Literal, Protocol, runtime_checkable\nelse:\n    from pip._vendor.typing_extensions import (\n        Literal,\n        Protocol,\n        runtime_checkable,\n    )  # pragma: no cover\n\nfrom . import errors, themes\nfrom ._emoji_replace import _emoji_replace\nfrom ._export_format import CONSOLE_HTML_FORMAT, CONSOLE_SVG_FORMAT\nfrom ._fileno import get_fileno\nfrom ._log_render import FormatTimeCallable, LogRender\nfrom .align import Align, AlignMethod\nfrom .color import ColorSystem, blend_rgb\nfrom .control import Control\nfrom .emoji import EmojiVariant\nfrom .highlighter import NullHighlighter, ReprHighlighter\nfrom .markup import render as render_markup\nfrom .measure import Measurement, measure_renderables\nfrom .pager import Pager, SystemPager\nfrom .pretty import Pretty, is_expandable\nfrom .protocol import rich_cast\nfrom .region import Region\nfrom .scope import render_scope\nfrom .screen import Screen\nfrom .segment import Segment\nfrom .style import Style, StyleType\nfrom .styled import Styled\nfrom .terminal_theme import DEFAULT_TERMINAL_THEME, SVG_EXPORT_THEME, TerminalTheme\nfrom .text import Text, TextType\nfrom .theme import Theme, ThemeStack\n\nif TYPE_CHECKING:\n    from ._windows import WindowsConsoleFeatures\n    from .live import Live\n    from .status import Status\n\nJUPYTER_DEFAULT_COLUMNS = 115\nJUPYTER_DEFAULT_LINES = 100\nWINDOWS = platform.system() == \"Windows\"\n\nHighlighterType = Callable[[Union[str, \"Text\"]], \"Text\"]\nJustifyMethod = Literal[\"default\", \"left\", \"center\", \"right\", \"full\"]\nOverflowMethod = Literal[\"fold\", \"crop\", \"ellipsis\", \"ignore\"]\n\n\nclass NoChange:\n    pass\n\n\nNO_CHANGE = NoChange()\n\ntry:\n    _STDIN_FILENO = sys.__stdin__.fileno()\nexcept Exception:\n    _STDIN_FILENO = 0\ntry:\n    _STDOUT_FILENO = sys.__stdout__.fileno()\nexcept Exception:\n    _STDOUT_FILENO = 1\ntry:\n    _STDERR_FILENO = sys.__stderr__.fileno()\nexcept Exception:\n    _STDERR_FILENO = 2\n\n_STD_STREAMS = (_STDIN_FILENO, _STDOUT_FILENO, _STDERR_FILENO)\n_STD_STREAMS_OUTPUT = (_STDOUT_FILENO, _STDERR_FILENO)\n\n\n_TERM_COLORS = {\n    \"kitty\": ColorSystem.EIGHT_BIT,\n    \"256color\": ColorSystem.EIGHT_BIT,\n    \"16color\": ColorSystem.STANDARD,\n}\n\n\nclass ConsoleDimensions(NamedTuple):\n    \"\"\"Size of the terminal.\"\"\"\n\n    width: int\n    \"\"\"The width of the console in 'cells'.\"\"\"\n    height: int\n    \"\"\"The height of the console in lines.\"\"\"\n\n\n@dataclass\nclass ConsoleOptions:\n    \"\"\"Options for __rich_console__ method.\"\"\"\n\n    size: ConsoleDimensions\n    \"\"\"Size of console.\"\"\"\n    legacy_windows: bool\n    \"\"\"legacy_windows: flag for legacy windows.\"\"\"\n    min_width: int\n    \"\"\"Minimum width of renderable.\"\"\"\n    max_width: int\n    \"\"\"Maximum width of renderable.\"\"\"\n    is_terminal: bool\n    \"\"\"True if the target is a terminal, otherwise False.\"\"\"\n    encoding: str\n    \"\"\"Encoding of terminal.\"\"\"\n    max_height: int\n    \"\"\"Height of container (starts as terminal)\"\"\"\n    justify: Optional[JustifyMethod] = None\n    \"\"\"Justify value override for renderable.\"\"\"\n    overflow: Optional[OverflowMethod] = None\n    \"\"\"Overflow value override for renderable.\"\"\"\n    no_wrap: Optional[bool] = False\n    \"\"\"Disable wrapping for text.\"\"\"\n    highlight: Optional[bool] = None\n    \"\"\"Highlight override for render_str.\"\"\"\n    markup: Optional[bool] = None\n    \"\"\"Enable markup when rendering strings.\"\"\"\n    height: Optional[int] = None\n\n    @property\n    def ascii_only(self) -> bool:\n        \"\"\"Check if renderables should use ascii only.\"\"\"\n        return not self.encoding.startswith(\"utf\")\n\n    def copy(self) -> \"ConsoleOptions\":\n        \"\"\"Return a copy of the options.\n\n        Returns:\n            ConsoleOptions: a copy of self.\n        \"\"\"\n        options: ConsoleOptions = ConsoleOptions.__new__(ConsoleOptions)\n        options.__dict__ = self.__dict__.copy()\n        return options\n\n    def update(\n        self,\n        *,\n        width: Union[int, NoChange] = NO_CHANGE,\n        min_width: Union[int, NoChange] = NO_CHANGE,\n        max_width: Union[int, NoChange] = NO_CHANGE,\n        justify: Union[Optional[JustifyMethod], NoChange] = NO_CHANGE,\n        overflow: Union[Optional[OverflowMethod], NoChange] = NO_CHANGE,\n        no_wrap: Union[Optional[bool], NoChange] = NO_CHANGE,\n        highlight: Union[Optional[bool], NoChange] = NO_CHANGE,\n        markup: Union[Optional[bool], NoChange] = NO_CHANGE,\n        height: Union[Optional[int], NoChange] = NO_CHANGE,\n    ) -> \"ConsoleOptions\":\n        \"\"\"Update values, return a copy.\"\"\"\n        options = self.copy()\n        if not isinstance(width, NoChange):\n            options.min_width = options.max_width = max(0, width)\n        if not isinstance(min_width, NoChange):\n            options.min_width = min_width\n        if not isinstance(max_width, NoChange):\n            options.max_width = max_width\n        if not isinstance(justify, NoChange):\n            options.justify = justify\n        if not isinstance(overflow, NoChange):\n            options.overflow = overflow\n        if not isinstance(no_wrap, NoChange):\n            options.no_wrap = no_wrap\n        if not isinstance(highlight, NoChange):\n            options.highlight = highlight\n        if not isinstance(markup, NoChange):\n            options.markup = markup\n        if not isinstance(height, NoChange):\n            if height is not None:\n                options.max_height = height\n            options.height = None if height is None else max(0, height)\n        return options\n\n    def update_width(self, width: int) -> \"ConsoleOptions\":\n        \"\"\"Update just the width, return a copy.\n\n        Args:\n            width (int): New width (sets both min_width and max_width)\n\n        Returns:\n            ~ConsoleOptions: New console options instance.\n        \"\"\"\n        options = self.copy()\n        options.min_width = options.max_width = max(0, width)\n        return options\n\n    def update_height(self, height: int) -> \"ConsoleOptions\":\n        \"\"\"Update the height, and return a copy.\n\n        Args:\n            height (int): New height\n\n        Returns:\n            ~ConsoleOptions: New Console options instance.\n        \"\"\"\n        options = self.copy()\n        options.max_height = options.height = height\n        return options\n\n    def reset_height(self) -> \"ConsoleOptions\":\n        \"\"\"Return a copy of the options with height set to ``None``.\n\n        Returns:\n            ~ConsoleOptions: New console options instance.\n        \"\"\"\n        options = self.copy()\n        options.height = None\n        return options\n\n    def update_dimensions(self, width: int, height: int) -> \"ConsoleOptions\":\n        \"\"\"Update the width and height, and return a copy.\n\n        Args:\n            width (int): New width (sets both min_width and max_width).\n            height (int): New height.\n\n        Returns:\n            ~ConsoleOptions: New console options instance.\n        \"\"\"\n        options = self.copy()\n        options.min_width = options.max_width = max(0, width)\n        options.height = options.max_height = height\n        return options\n\n\n@runtime_checkable\nclass RichCast(Protocol):\n    \"\"\"An object that may be 'cast' to a console renderable.\"\"\"\n\n    def __rich__(\n        self,\n    ) -> Union[\"ConsoleRenderable\", \"RichCast\", str]:  # pragma: no cover\n        ...\n\n\n@runtime_checkable\nclass ConsoleRenderable(Protocol):\n    \"\"\"An object that supports the console protocol.\"\"\"\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":  # pragma: no cover\n        ...\n\n\n# A type that may be rendered by Console.\nRenderableType = Union[ConsoleRenderable, RichCast, str]\n\n# The result of calling a __rich_console__ method.\nRenderResult = Iterable[Union[RenderableType, Segment]]\n\n_null_highlighter = NullHighlighter()\n\n\nclass CaptureError(Exception):\n    \"\"\"An error in the Capture context manager.\"\"\"\n\n\nclass NewLine:\n    \"\"\"A renderable to generate new line(s)\"\"\"\n\n    def __init__(self, count: int = 1) -> None:\n        self.count = count\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> Iterable[Segment]:\n        yield Segment(\"\\n\" * self.count)\n\n\nclass ScreenUpdate:\n    \"\"\"Render a list of lines at a given offset.\"\"\"\n\n    def __init__(self, lines: List[List[Segment]], x: int, y: int) -> None:\n        self._lines = lines\n        self.x = x\n        self.y = y\n\n    def __rich_console__(\n        self, console: \"Console\", options: ConsoleOptions\n    ) -> RenderResult:\n        x = self.x\n        move_to = Control.move_to\n        for offset, line in enumerate(self._lines, self.y):\n            yield move_to(x, offset)\n            yield from line\n\n\nclass Capture:\n    \"\"\"Context manager to capture the result of printing to the console.\n    See :meth:`~rich.console.Console.capture` for how to use.\n\n    Args:\n        console (Console): A console instance to capture output.\n    \"\"\"\n\n    def __init__(self, console: \"Console\") -> None:\n        self._console = console\n        self._result: Optional[str] = None\n\n    def __enter__(self) -> \"Capture\":\n        self._console.begin_capture()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        self._result = self._console.end_capture()\n\n    def get(self) -> str:\n        \"\"\"Get the result of the capture.\"\"\"\n        if self._result is None:\n            raise CaptureError(\n                \"Capture result is not available until context manager exits.\"\n            )\n        return self._result\n\n\nclass ThemeContext:\n    \"\"\"A context manager to use a temporary theme. See :meth:`~rich.console.Console.use_theme` for usage.\"\"\"\n\n    def __init__(self, console: \"Console\", theme: Theme, inherit: bool = True) -> None:\n        self.console = console\n        self.theme = theme\n        self.inherit = inherit\n\n    def __enter__(self) -> \"ThemeContext\":\n        self.console.push_theme(self.theme)\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        self.console.pop_theme()\n\n\nclass PagerContext:\n    \"\"\"A context manager that 'pages' content. See :meth:`~rich.console.Console.pager` for usage.\"\"\"\n\n    def __init__(\n        self,\n        console: \"Console\",\n        pager: Optional[Pager] = None,\n        styles: bool = False,\n        links: bool = False,\n    ) -> None:\n        self._console = console\n        self.pager = SystemPager() if pager is None else pager\n        self.styles = styles\n        self.links = links\n\n    def __enter__(self) -> \"PagerContext\":\n        self._console._enter_buffer()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        if exc_type is None:\n            with self._console._lock:\n                buffer: List[Segment] = self._console._buffer[:]\n                del self._console._buffer[:]\n                segments: Iterable[Segment] = buffer\n                if not self.styles:\n                    segments = Segment.strip_styles(segments)\n                elif not self.links:\n                    segments = Segment.strip_links(segments)\n                content = self._console._render_buffer(segments)\n            self.pager.show(content)\n        self._console._exit_buffer()\n\n\nclass ScreenContext:\n    \"\"\"A context manager that enables an alternative screen. See :meth:`~rich.console.Console.screen` for usage.\"\"\"\n\n    def __init__(\n        self, console: \"Console\", hide_cursor: bool, style: StyleType = \"\"\n    ) -> None:\n        self.console = console\n        self.hide_cursor = hide_cursor\n        self.screen = Screen(style=style)\n        self._changed = False\n\n    def update(\n        self, *renderables: RenderableType, style: Optional[StyleType] = None\n    ) -> None:\n        \"\"\"Update the screen.\n\n        Args:\n            renderable (RenderableType, optional): Optional renderable to replace current renderable,\n                or None for no change. Defaults to None.\n            style: (Style, optional): Replacement style, or None for no change. Defaults to None.\n        \"\"\"\n        if renderables:\n            self.screen.renderable = (\n                Group(*renderables) if len(renderables) > 1 else renderables[0]\n            )\n        if style is not None:\n            self.screen.style = style\n        self.console.print(self.screen, end=\"\")\n\n    def __enter__(self) -> \"ScreenContext\":\n        self._changed = self.console.set_alt_screen(True)\n        if self._changed and self.hide_cursor:\n            self.console.show_cursor(False)\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        if self._changed:\n            self.console.set_alt_screen(False)\n            if self.hide_cursor:\n                self.console.show_cursor(True)\n\n\nclass Group:\n    \"\"\"Takes a group of renderables and returns a renderable object that renders the group.\n\n    Args:\n        renderables (Iterable[RenderableType]): An iterable of renderable objects.\n        fit (bool, optional): Fit dimension of group to contents, or fill available space. Defaults to True.\n    \"\"\"\n\n    def __init__(self, *renderables: \"RenderableType\", fit: bool = True) -> None:\n        self._renderables = renderables\n        self.fit = fit\n        self._render: Optional[List[RenderableType]] = None\n\n    @property\n    def renderables(self) -> List[\"RenderableType\"]:\n        if self._render is None:\n            self._render = list(self._renderables)\n        return self._render\n\n    def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"Measurement\":\n        if self.fit:\n            return measure_renderables(console, options, self.renderables)\n        else:\n            return Measurement(options.max_width, options.max_width)\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> RenderResult:\n        yield from self.renderables\n\n\ndef group(fit: bool = True) -> Callable[..., Callable[..., Group]]:\n    \"\"\"A decorator that turns an iterable of renderables in to a group.\n\n    Args:\n        fit (bool, optional): Fit dimension of group to contents, or fill available space. Defaults to True.\n    \"\"\"\n\n    def decorator(\n        method: Callable[..., Iterable[RenderableType]]\n    ) -> Callable[..., Group]:\n        \"\"\"Convert a method that returns an iterable of renderables in to a Group.\"\"\"\n\n        @wraps(method)\n        def _replace(*args: Any, **kwargs: Any) -> Group:\n            renderables = method(*args, **kwargs)\n            return Group(*renderables, fit=fit)\n\n        return _replace\n\n    return decorator\n\n\ndef _is_jupyter() -> bool:  # pragma: no cover\n    \"\"\"Check if we're running in a Jupyter notebook.\"\"\"\n    try:\n        get_ipython  # type: ignore[name-defined]\n    except NameError:\n        return False\n    ipython = get_ipython()  # type: ignore[name-defined]\n    shell = ipython.__class__.__name__\n    if (\n        \"google.colab\" in str(ipython.__class__)\n        or os.getenv(\"DATABRICKS_RUNTIME_VERSION\")\n        or shell == \"ZMQInteractiveShell\"\n    ):\n        return True  # Jupyter notebook or qtconsole\n    elif shell == \"TerminalInteractiveShell\":\n        return False  # Terminal running IPython\n    else:\n        return False  # Other type (?)\n\n\nCOLOR_SYSTEMS = {\n    \"standard\": ColorSystem.STANDARD,\n    \"256\": ColorSystem.EIGHT_BIT,\n    \"truecolor\": ColorSystem.TRUECOLOR,\n    \"windows\": ColorSystem.WINDOWS,\n}\n\n_COLOR_SYSTEMS_NAMES = {system: name for name, system in COLOR_SYSTEMS.items()}\n\n\n@dataclass\nclass ConsoleThreadLocals(threading.local):\n    \"\"\"Thread local values for Console context.\"\"\"\n\n    theme_stack: ThemeStack\n    buffer: List[Segment] = field(default_factory=list)\n    buffer_index: int = 0\n\n\nclass RenderHook(ABC):\n    \"\"\"Provides hooks in to the render process.\"\"\"\n\n    @abstractmethod\n    def process_renderables(\n        self, renderables: List[ConsoleRenderable]\n    ) -> List[ConsoleRenderable]:\n        \"\"\"Called with a list of objects to render.\n\n        This method can return a new list of renderables, or modify and return the same list.\n\n        Args:\n            renderables (List[ConsoleRenderable]): A number of renderable objects.\n\n        Returns:\n            List[ConsoleRenderable]: A replacement list of renderables.\n        \"\"\"\n\n\n_windows_console_features: Optional[\"WindowsConsoleFeatures\"] = None\n\n\ndef get_windows_console_features() -> \"WindowsConsoleFeatures\":  # pragma: no cover\n    global _windows_console_features\n    if _windows_console_features is not None:\n        return _windows_console_features\n    from ._windows import get_windows_console_features\n\n    _windows_console_features = get_windows_console_features()\n    return _windows_console_features\n\n\ndef detect_legacy_windows() -> bool:\n    \"\"\"Detect legacy Windows.\"\"\"\n    return WINDOWS and not get_windows_console_features().vt\n\n\nclass Console:\n    \"\"\"A high level console interface.\n\n    Args:\n        color_system (str, optional): The color system supported by your terminal,\n            either ``\"standard\"``, ``\"256\"`` or ``\"truecolor\"``. Leave as ``\"auto\"`` to autodetect.\n        force_terminal (Optional[bool], optional): Enable/disable terminal control codes, or None to auto-detect terminal. Defaults to None.\n        force_jupyter (Optional[bool], optional): Enable/disable Jupyter rendering, or None to auto-detect Jupyter. Defaults to None.\n        force_interactive (Optional[bool], optional): Enable/disable interactive mode, or None to auto detect. Defaults to None.\n        soft_wrap (Optional[bool], optional): Set soft wrap default on print method. Defaults to False.\n        theme (Theme, optional): An optional style theme object, or ``None`` for default theme.\n        stderr (bool, optional): Use stderr rather than stdout if ``file`` is not specified. Defaults to False.\n        file (IO, optional): A file object where the console should write to. Defaults to stdout.\n        quiet (bool, Optional): Boolean to suppress all output. Defaults to False.\n        width (int, optional): The width of the terminal. Leave as default to auto-detect width.\n        height (int, optional): The height of the terminal. Leave as default to auto-detect height.\n        style (StyleType, optional): Style to apply to all output, or None for no style. Defaults to None.\n        no_color (Optional[bool], optional): Enabled no color mode, or None to auto detect. Defaults to None.\n        tab_size (int, optional): Number of spaces used to replace a tab character. Defaults to 8.\n        record (bool, optional): Boolean to enable recording of terminal output,\n            required to call :meth:`export_html`, :meth:`export_svg`, and :meth:`export_text`. Defaults to False.\n        markup (bool, optional): Boolean to enable :ref:`console_markup`. Defaults to True.\n        emoji (bool, optional): Enable emoji code. Defaults to True.\n        emoji_variant (str, optional): Optional emoji variant, either \"text\" or \"emoji\". Defaults to None.\n        highlight (bool, optional): Enable automatic highlighting. Defaults to True.\n        log_time (bool, optional): Boolean to enable logging of time by :meth:`log` methods. Defaults to True.\n        log_path (bool, optional): Boolean to enable the logging of the caller by :meth:`log`. Defaults to True.\n        log_time_format (Union[str, TimeFormatterCallable], optional): If ``log_time`` is enabled, either string for strftime or callable that formats the time. Defaults to \"[%X] \".\n        highlighter (HighlighterType, optional): Default highlighter.\n        legacy_windows (bool, optional): Enable legacy Windows mode, or ``None`` to auto detect. Defaults to ``None``.\n        safe_box (bool, optional): Restrict box options that don't render on legacy Windows.\n        get_datetime (Callable[[], datetime], optional): Callable that gets the current time as a datetime.datetime object (used by Console.log),\n            or None for datetime.now.\n        get_time (Callable[[], time], optional): Callable that gets the current time in seconds, default uses time.monotonic.\n    \"\"\"\n\n    _environ: Mapping[str, str] = os.environ\n\n    def __init__(\n        self,\n        *,\n        color_system: Optional[\n            Literal[\"auto\", \"standard\", \"256\", \"truecolor\", \"windows\"]\n        ] = \"auto\",\n        force_terminal: Optional[bool] = None,\n        force_jupyter: Optional[bool] = None,\n        force_interactive: Optional[bool] = None,\n        soft_wrap: bool = False,\n        theme: Optional[Theme] = None,\n        stderr: bool = False,\n        file: Optional[IO[str]] = None,\n        quiet: bool = False,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        style: Optional[StyleType] = None,\n        no_color: Optional[bool] = None,\n        tab_size: int = 8,\n        record: bool = False,\n        markup: bool = True,\n        emoji: bool = True,\n        emoji_variant: Optional[EmojiVariant] = None,\n        highlight: bool = True,\n        log_time: bool = True,\n        log_path: bool = True,\n        log_time_format: Union[str, FormatTimeCallable] = \"[%X]\",\n        highlighter: Optional[\"HighlighterType\"] = ReprHighlighter(),\n        legacy_windows: Optional[bool] = None,\n        safe_box: bool = True,\n        get_datetime: Optional[Callable[[], datetime]] = None,\n        get_time: Optional[Callable[[], float]] = None,\n        _environ: Optional[Mapping[str, str]] = None,\n    ):\n        # Copy of os.environ allows us to replace it for testing\n        if _environ is not None:\n            self._environ = _environ\n\n        self.is_jupyter = _is_jupyter() if force_jupyter is None else force_jupyter\n        if self.is_jupyter:\n            if width is None:\n                jupyter_columns = self._environ.get(\"JUPYTER_COLUMNS\")\n                if jupyter_columns is not None and jupyter_columns.isdigit():\n                    width = int(jupyter_columns)\n                else:\n                    width = JUPYTER_DEFAULT_COLUMNS\n            if height is None:\n                jupyter_lines = self._environ.get(\"JUPYTER_LINES\")\n                if jupyter_lines is not None and jupyter_lines.isdigit():\n                    height = int(jupyter_lines)\n                else:\n                    height = JUPYTER_DEFAULT_LINES\n\n        self.tab_size = tab_size\n        self.record = record\n        self._markup = markup\n        self._emoji = emoji\n        self._emoji_variant: Optional[EmojiVariant] = emoji_variant\n        self._highlight = highlight\n        self.legacy_windows: bool = (\n            (detect_legacy_windows() and not self.is_jupyter)\n            if legacy_windows is None\n            else legacy_windows\n        )\n\n        if width is None:\n            columns = self._environ.get(\"COLUMNS\")\n            if columns is not None and columns.isdigit():\n                width = int(columns) - self.legacy_windows\n        if height is None:\n            lines = self._environ.get(\"LINES\")\n            if lines is not None and lines.isdigit():\n                height = int(lines)\n\n        self.soft_wrap = soft_wrap\n        self._width = width\n        self._height = height\n\n        self._color_system: Optional[ColorSystem]\n\n        self._force_terminal = None\n        if force_terminal is not None:\n            self._force_terminal = force_terminal\n\n        self._file = file\n        self.quiet = quiet\n        self.stderr = stderr\n\n        if color_system is None:\n            self._color_system = None\n        elif color_system == \"auto\":\n            self._color_system = self._detect_color_system()\n        else:\n            self._color_system = COLOR_SYSTEMS[color_system]\n\n        self._lock = threading.RLock()\n        self._log_render = LogRender(\n            show_time=log_time,\n            show_path=log_path,\n            time_format=log_time_format,\n        )\n        self.highlighter: HighlighterType = highlighter or _null_highlighter\n        self.safe_box = safe_box\n        self.get_datetime = get_datetime or datetime.now\n        self.get_time = get_time or monotonic\n        self.style = style\n        self.no_color = (\n            no_color if no_color is not None else \"NO_COLOR\" in self._environ\n        )\n        self.is_interactive = (\n            (self.is_terminal and not self.is_dumb_terminal)\n            if force_interactive is None\n            else force_interactive\n        )\n\n        self._record_buffer_lock = threading.RLock()\n        self._thread_locals = ConsoleThreadLocals(\n            theme_stack=ThemeStack(themes.DEFAULT if theme is None else theme)\n        )\n        self._record_buffer: List[Segment] = []\n        self._render_hooks: List[RenderHook] = []\n        self._live: Optional[\"Live\"] = None\n        self._is_alt_screen = False\n\n    def __repr__(self) -> str:\n        return f\"<console width={self.width} {self._color_system!s}>\"\n\n    @property\n    def file(self) -> IO[str]:\n        \"\"\"Get the file object to write to.\"\"\"\n        file = self._file or (sys.stderr if self.stderr else sys.stdout)\n        file = getattr(file, \"rich_proxied_file\", file)\n        if file is None:\n            file = NULL_FILE\n        return file\n\n    @file.setter\n    def file(self, new_file: IO[str]) -> None:\n        \"\"\"Set a new file object.\"\"\"\n        self._file = new_file\n\n    @property\n    def _buffer(self) -> List[Segment]:\n        \"\"\"Get a thread local buffer.\"\"\"\n        return self._thread_locals.buffer\n\n    @property\n    def _buffer_index(self) -> int:\n        \"\"\"Get a thread local buffer.\"\"\"\n        return self._thread_locals.buffer_index\n\n    @_buffer_index.setter\n    def _buffer_index(self, value: int) -> None:\n        self._thread_locals.buffer_index = value\n\n    @property\n    def _theme_stack(self) -> ThemeStack:\n        \"\"\"Get the thread local theme stack.\"\"\"\n        return self._thread_locals.theme_stack\n\n    def _detect_color_system(self) -> Optional[ColorSystem]:\n        \"\"\"Detect color system from env vars.\"\"\"\n        if self.is_jupyter:\n            return ColorSystem.TRUECOLOR\n        if not self.is_terminal or self.is_dumb_terminal:\n            return None\n        if WINDOWS:  # pragma: no cover\n            if self.legacy_windows:  # pragma: no cover\n                return ColorSystem.WINDOWS\n            windows_console_features = get_windows_console_features()\n            return (\n                ColorSystem.TRUECOLOR\n                if windows_console_features.truecolor\n                else ColorSystem.EIGHT_BIT\n            )\n        else:\n            color_term = self._environ.get(\"COLORTERM\", \"\").strip().lower()\n            if color_term in (\"truecolor\", \"24bit\"):\n                return ColorSystem.TRUECOLOR\n            term = self._environ.get(\"TERM\", \"\").strip().lower()\n            _term_name, _hyphen, colors = term.rpartition(\"-\")\n            color_system = _TERM_COLORS.get(colors, ColorSystem.STANDARD)\n            return color_system\n\n    def _enter_buffer(self) -> None:\n        \"\"\"Enter in to a buffer context, and buffer all output.\"\"\"\n        self._buffer_index += 1\n\n    def _exit_buffer(self) -> None:\n        \"\"\"Leave buffer context, and render content if required.\"\"\"\n        self._buffer_index -= 1\n        self._check_buffer()\n\n    def set_live(self, live: \"Live\") -> None:\n        \"\"\"Set Live instance. Used by Live context manager.\n\n        Args:\n            live (Live): Live instance using this Console.\n\n        Raises:\n            errors.LiveError: If this Console has a Live context currently active.\n        \"\"\"\n        with self._lock:\n            if self._live is not None:\n                raise errors.LiveError(\"Only one live display may be active at once\")\n            self._live = live\n\n    def clear_live(self) -> None:\n        \"\"\"Clear the Live instance.\"\"\"\n        with self._lock:\n            self._live = None\n\n    def push_render_hook(self, hook: RenderHook) -> None:\n        \"\"\"Add a new render hook to the stack.\n\n        Args:\n            hook (RenderHook): Render hook instance.\n        \"\"\"\n        with self._lock:\n            self._render_hooks.append(hook)\n\n    def pop_render_hook(self) -> None:\n        \"\"\"Pop the last renderhook from the stack.\"\"\"\n        with self._lock:\n            self._render_hooks.pop()\n\n    def __enter__(self) -> \"Console\":\n        \"\"\"Own context manager to enter buffer context.\"\"\"\n        self._enter_buffer()\n        return self\n\n    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> None:\n        \"\"\"Exit buffer context.\"\"\"\n        self._exit_buffer()\n\n    def begin_capture(self) -> None:\n        \"\"\"Begin capturing console output. Call :meth:`end_capture` to exit capture mode and return output.\"\"\"\n        self._enter_buffer()\n\n    def end_capture(self) -> str:\n        \"\"\"End capture mode and return captured string.\n\n        Returns:\n            str: Console output.\n        \"\"\"\n        render_result = self._render_buffer(self._buffer)\n        del self._buffer[:]\n        self._exit_buffer()\n        return render_result\n\n    def push_theme(self, theme: Theme, *, inherit: bool = True) -> None:\n        \"\"\"Push a new theme on to the top of the stack, replacing the styles from the previous theme.\n        Generally speaking, you should call :meth:`~rich.console.Console.use_theme` to get a context manager, rather\n        than calling this method directly.\n\n        Args:\n            theme (Theme): A theme instance.\n            inherit (bool, optional): Inherit existing styles. Defaults to True.\n        \"\"\"\n        self._theme_stack.push_theme(theme, inherit=inherit)\n\n    def pop_theme(self) -> None:\n        \"\"\"Remove theme from top of stack, restoring previous theme.\"\"\"\n        self._theme_stack.pop_theme()\n\n    def use_theme(self, theme: Theme, *, inherit: bool = True) -> ThemeContext:\n        \"\"\"Use a different theme for the duration of the context manager.\n\n        Args:\n            theme (Theme): Theme instance to user.\n            inherit (bool, optional): Inherit existing console styles. Defaults to True.\n\n        Returns:\n            ThemeContext: [description]\n        \"\"\"\n        return ThemeContext(self, theme, inherit)\n\n    @property\n    def color_system(self) -> Optional[str]:\n        \"\"\"Get color system string.\n\n        Returns:\n            Optional[str]: \"standard\", \"256\" or \"truecolor\".\n        \"\"\"\n\n        if self._color_system is not None:\n            return _COLOR_SYSTEMS_NAMES[self._color_system]\n        else:\n            return None\n\n    @property\n    def encoding(self) -> str:\n        \"\"\"Get the encoding of the console file, e.g. ``\"utf-8\"``.\n\n        Returns:\n            str: A standard encoding string.\n        \"\"\"\n        return (getattr(self.file, \"encoding\", \"utf-8\") or \"utf-8\").lower()\n\n    @property\n    def is_terminal(self) -> bool:\n        \"\"\"Check if the console is writing to a terminal.\n\n        Returns:\n            bool: True if the console writing to a device capable of\n            understanding terminal codes, otherwise False.\n        \"\"\"\n        if self._force_terminal is not None:\n            return self._force_terminal\n\n        if hasattr(sys.stdin, \"__module__\") and sys.stdin.__module__.startswith(\n            \"idlelib\"\n        ):\n            # Return False for Idle which claims to be a tty but can't handle ansi codes\n            return False\n\n        if self.is_jupyter:\n            # return False for Jupyter, which may have FORCE_COLOR set\n            return False\n\n        # If FORCE_COLOR env var has any value at all, we assume a terminal.\n        force_color = self._environ.get(\"FORCE_COLOR\")\n        if force_color is not None:\n            self._force_terminal = True\n            return True\n\n        isatty: Optional[Callable[[], bool]] = getattr(self.file, \"isatty\", None)\n        try:\n            return False if isatty is None else isatty()\n        except ValueError:\n            # in some situation (at the end of a pytest run for example) isatty() can raise\n            # ValueError: I/O operation on closed file\n            # return False because we aren't in a terminal anymore\n            return False\n\n    @property\n    def is_dumb_terminal(self) -> bool:\n        \"\"\"Detect dumb terminal.\n\n        Returns:\n            bool: True if writing to a dumb terminal, otherwise False.\n\n        \"\"\"\n        _term = self._environ.get(\"TERM\", \"\")\n        is_dumb = _term.lower() in (\"dumb\", \"unknown\")\n        return self.is_terminal and is_dumb\n\n    @property\n    def options(self) -> ConsoleOptions:\n        \"\"\"Get default console options.\"\"\"\n        return ConsoleOptions(\n            max_height=self.size.height,\n            size=self.size,\n            legacy_windows=self.legacy_windows,\n            min_width=1,\n            max_width=self.width,\n            encoding=self.encoding,\n            is_terminal=self.is_terminal,\n        )\n\n    @property\n    def size(self) -> ConsoleDimensions:\n        \"\"\"Get the size of the console.\n\n        Returns:\n            ConsoleDimensions: A named tuple containing the dimensions.\n        \"\"\"\n\n        if self._width is not None and self._height is not None:\n            return ConsoleDimensions(self._width - self.legacy_windows, self._height)\n\n        if self.is_dumb_terminal:\n            return ConsoleDimensions(80, 25)\n\n        width: Optional[int] = None\n        height: Optional[int] = None\n\n        if WINDOWS:  # pragma: no cover\n            try:\n                width, height = os.get_terminal_size()\n            except (AttributeError, ValueError, OSError):  # Probably not a terminal\n                pass\n        else:\n            for file_descriptor in _STD_STREAMS:\n                try:\n                    width, height = os.get_terminal_size(file_descriptor)\n                except (AttributeError, ValueError, OSError):\n                    pass\n                else:\n                    break\n\n        columns = self._environ.get(\"COLUMNS\")\n        if columns is not None and columns.isdigit():\n            width = int(columns)\n        lines = self._environ.get(\"LINES\")\n        if lines is not None and lines.isdigit():\n            height = int(lines)\n\n        # get_terminal_size can report 0, 0 if run from pseudo-terminal\n        width = width or 80\n        height = height or 25\n        return ConsoleDimensions(\n            width - self.legacy_windows if self._width is None else self._width,\n            height if self._height is None else self._height,\n        )\n\n    @size.setter\n    def size(self, new_size: Tuple[int, int]) -> None:\n        \"\"\"Set a new size for the terminal.\n\n        Args:\n            new_size (Tuple[int, int]): New width and height.\n        \"\"\"\n        width, height = new_size\n        self._width = width\n        self._height = height\n\n    @property\n    def width(self) -> int:\n        \"\"\"Get the width of the console.\n\n        Returns:\n            int: The width (in characters) of the console.\n        \"\"\"\n        return self.size.width\n\n    @width.setter\n    def width(self, width: int) -> None:\n        \"\"\"Set width.\n\n        Args:\n            width (int): New width.\n        \"\"\"\n        self._width = width\n\n    @property\n    def height(self) -> int:\n        \"\"\"Get the height of the console.\n\n        Returns:\n            int: The height (in lines) of the console.\n        \"\"\"\n        return self.size.height\n\n    @height.setter\n    def height(self, height: int) -> None:\n        \"\"\"Set height.\n\n        Args:\n            height (int): new height.\n        \"\"\"\n        self._height = height\n\n    def bell(self) -> None:\n        \"\"\"Play a 'bell' sound (if supported by the terminal).\"\"\"\n        self.control(Control.bell())\n\n    def capture(self) -> Capture:\n        \"\"\"A context manager to *capture* the result of print() or log() in a string,\n        rather than writing it to the console.\n\n        Example:\n            >>> from rich.console import Console\n            >>> console = Console()\n            >>> with console.capture() as capture:\n            ...     console.print(\"[bold magenta]Hello World[/]\")\n            >>> print(capture.get())\n\n        Returns:\n            Capture: Context manager with disables writing to the terminal.\n        \"\"\"\n        capture = Capture(self)\n        return capture\n\n    def pager(\n        self, pager: Optional[Pager] = None, styles: bool = False, links: bool = False\n    ) -> PagerContext:\n        \"\"\"A context manager to display anything printed within a \"pager\". The pager application\n        is defined by the system and will typically support at least pressing a key to scroll.\n\n        Args:\n            pager (Pager, optional): A pager object, or None to use :class:`~rich.pager.SystemPager`. Defaults to None.\n            styles (bool, optional): Show styles in pager. Defaults to False.\n            links (bool, optional): Show links in pager. Defaults to False.\n\n        Example:\n            >>> from rich.console import Console\n            >>> from rich.__main__ import make_test_card\n            >>> console = Console()\n            >>> with console.pager():\n                    console.print(make_test_card())\n\n        Returns:\n            PagerContext: A context manager.\n        \"\"\"\n        return PagerContext(self, pager=pager, styles=styles, links=links)\n\n    def line(self, count: int = 1) -> None:\n        \"\"\"Write new line(s).\n\n        Args:\n            count (int, optional): Number of new lines. Defaults to 1.\n        \"\"\"\n\n        assert count >= 0, \"count must be >= 0\"\n        self.print(NewLine(count))\n\n    def clear(self, home: bool = True) -> None:\n        \"\"\"Clear the screen.\n\n        Args:\n            home (bool, optional): Also move the cursor to 'home' position. Defaults to True.\n        \"\"\"\n        if home:\n            self.control(Control.clear(), Control.home())\n        else:\n            self.control(Control.clear())\n\n    def status(\n        self,\n        status: RenderableType,\n        *,\n        spinner: str = \"dots\",\n        spinner_style: StyleType = \"status.spinner\",\n        speed: float = 1.0,\n        refresh_per_second: float = 12.5,\n    ) -> \"Status\":\n        \"\"\"Display a status and spinner.\n\n        Args:\n            status (RenderableType): A status renderable (str or Text typically).\n            spinner (str, optional): Name of spinner animation (see python -m rich.spinner). Defaults to \"dots\".\n            spinner_style (StyleType, optional): Style of spinner. Defaults to \"status.spinner\".\n            speed (float, optional): Speed factor for spinner animation. Defaults to 1.0.\n            refresh_per_second (float, optional): Number of refreshes per second. Defaults to 12.5.\n\n        Returns:\n            Status: A Status object that may be used as a context manager.\n        \"\"\"\n        from .status import Status\n\n        status_renderable = Status(\n            status,\n            console=self,\n            spinner=spinner,\n            spinner_style=spinner_style,\n            speed=speed,\n            refresh_per_second=refresh_per_second,\n        )\n        return status_renderable\n\n    def show_cursor(self, show: bool = True) -> bool:\n        \"\"\"Show or hide the cursor.\n\n        Args:\n            show (bool, optional): Set visibility of the cursor.\n        \"\"\"\n        if self.is_terminal:\n            self.control(Control.show_cursor(show))\n            return True\n        return False\n\n    def set_alt_screen(self, enable: bool = True) -> bool:\n        \"\"\"Enables alternative screen mode.\n\n        Note, if you enable this mode, you should ensure that is disabled before\n        the application exits. See :meth:`~rich.Console.screen` for a context manager\n        that handles this for you.\n\n        Args:\n            enable (bool, optional): Enable (True) or disable (False) alternate screen. Defaults to True.\n\n        Returns:\n            bool: True if the control codes were written.\n\n        \"\"\"\n        changed = False\n        if self.is_terminal and not self.legacy_windows:\n            self.control(Control.alt_screen(enable))\n            changed = True\n            self._is_alt_screen = enable\n        return changed\n\n    @property\n    def is_alt_screen(self) -> bool:\n        \"\"\"Check if the alt screen was enabled.\n\n        Returns:\n            bool: True if the alt screen was enabled, otherwise False.\n        \"\"\"\n        return self._is_alt_screen\n\n    def set_window_title(self, title: str) -> bool:\n        \"\"\"Set the title of the console terminal window.\n\n        Warning: There is no means within Rich of \"resetting\" the window title to its\n        previous value, meaning the title you set will persist even after your application\n        exits.\n\n        ``fish`` shell resets the window title before and after each command by default,\n        negating this issue. Windows Terminal and command prompt will also reset the title for you.\n        Most other shells and terminals, however, do not do this.\n\n        Some terminals may require configuration changes before you can set the title.\n        Some terminals may not support setting the title at all.\n\n        Other software (including the terminal itself, the shell, custom prompts, plugins, etc.)\n        may also set the terminal window title. This could result in whatever value you write\n        using this method being overwritten.\n\n        Args:\n            title (str): The new title of the terminal window.\n\n        Returns:\n            bool: True if the control code to change the terminal title was\n                written, otherwise False. Note that a return value of True\n                does not guarantee that the window title has actually changed,\n                since the feature may be unsupported/disabled in some terminals.\n        \"\"\"\n        if self.is_terminal:\n            self.control(Control.title(title))\n            return True\n        return False\n\n    def screen(\n        self, hide_cursor: bool = True, style: Optional[StyleType] = None\n    ) -> \"ScreenContext\":\n        \"\"\"Context manager to enable and disable 'alternative screen' mode.\n\n        Args:\n            hide_cursor (bool, optional): Also hide the cursor. Defaults to False.\n            style (Style, optional): Optional style for screen. Defaults to None.\n\n        Returns:\n            ~ScreenContext: Context which enables alternate screen on enter, and disables it on exit.\n        \"\"\"\n        return ScreenContext(self, hide_cursor=hide_cursor, style=style or \"\")\n\n    def measure(\n        self, renderable: RenderableType, *, options: Optional[ConsoleOptions] = None\n    ) -> Measurement:\n        \"\"\"Measure a renderable. Returns a :class:`~rich.measure.Measurement` object which contains\n        information regarding the number of characters required to print the renderable.\n\n        Args:\n            renderable (RenderableType): Any renderable or string.\n            options (Optional[ConsoleOptions], optional): Options to use when measuring, or None\n                to use default options. Defaults to None.\n\n        Returns:\n            Measurement: A measurement of the renderable.\n        \"\"\"\n        measurement = Measurement.get(self, options or self.options, renderable)\n        return measurement\n\n    def render(\n        self, renderable: RenderableType, options: Optional[ConsoleOptions] = None\n    ) -> Iterable[Segment]:\n        \"\"\"Render an object in to an iterable of `Segment` instances.\n\n        This method contains the logic for rendering objects with the console protocol.\n        You are unlikely to need to use it directly, unless you are extending the library.\n\n        Args:\n            renderable (RenderableType): An object supporting the console protocol, or\n                an object that may be converted to a string.\n            options (ConsoleOptions, optional): An options object, or None to use self.options. Defaults to None.\n\n        Returns:\n            Iterable[Segment]: An iterable of segments that may be rendered.\n        \"\"\"\n\n        _options = options or self.options\n        if _options.max_width < 1:\n            # No space to render anything. This prevents potential recursion errors.\n            return\n        render_iterable: RenderResult\n\n        renderable = rich_cast(renderable)\n        if hasattr(renderable, \"__rich_console__\") and not isclass(renderable):\n            render_iterable = renderable.__rich_console__(self, _options)  # type: ignore[union-attr]\n        elif isinstance(renderable, str):\n            text_renderable = self.render_str(\n                renderable, highlight=_options.highlight, markup=_options.markup\n            )\n            render_iterable = text_renderable.__rich_console__(self, _options)\n        else:\n            raise errors.NotRenderableError(\n                f\"Unable to render {renderable!r}; \"\n                \"A str, Segment or object with __rich_console__ method is required\"\n            )\n\n        try:\n            iter_render = iter(render_iterable)\n        except TypeError:\n            raise errors.NotRenderableError(\n                f\"object {render_iterable!r} is not renderable\"\n            )\n        _Segment = Segment\n        _options = _options.reset_height()\n        for render_output in iter_render:\n            if isinstance(render_output, _Segment):\n                yield render_output\n            else:\n                yield from self.render(render_output, _options)\n\n    def render_lines(\n        self,\n        renderable: RenderableType,\n        options: Optional[ConsoleOptions] = None,\n        *,\n        style: Optional[Style] = None,\n        pad: bool = True,\n        new_lines: bool = False,\n    ) -> List[List[Segment]]:\n        \"\"\"Render objects in to a list of lines.\n\n        The output of render_lines is useful when further formatting of rendered console text\n        is required, such as the Panel class which draws a border around any renderable object.\n\n        Args:\n            renderable (RenderableType): Any object renderable in the console.\n            options (Optional[ConsoleOptions], optional): Console options, or None to use self.options. Default to ``None``.\n            style (Style, optional): Optional style to apply to renderables. Defaults to ``None``.\n            pad (bool, optional): Pad lines shorter than render width. Defaults to ``True``.\n            new_lines (bool, optional): Include \"\\n\" characters at end of lines.\n\n        Returns:\n            List[List[Segment]]: A list of lines, where a line is a list of Segment objects.\n        \"\"\"\n        with self._lock:\n            render_options = options or self.options\n            _rendered = self.render(renderable, render_options)\n            if style:\n                _rendered = Segment.apply_style(_rendered, style)\n\n            render_height = render_options.height\n            if render_height is not None:\n                render_height = max(0, render_height)\n\n            lines = list(\n                islice(\n                    Segment.split_and_crop_lines(\n                        _rendered,\n                        render_options.max_width,\n                        include_new_lines=new_lines,\n                        pad=pad,\n                        style=style,\n                    ),\n                    None,\n                    render_height,\n                )\n            )\n            if render_options.height is not None:\n                extra_lines = render_options.height - len(lines)\n                if extra_lines > 0:\n                    pad_line = [\n                        [Segment(\" \" * render_options.max_width, style), Segment(\"\\n\")]\n                        if new_lines\n                        else [Segment(\" \" * render_options.max_width, style)]\n                    ]\n                    lines.extend(pad_line * extra_lines)\n\n            return lines\n\n    def render_str(\n        self,\n        text: str,\n        *,\n        style: Union[str, Style] = \"\",\n        justify: Optional[JustifyMethod] = None,\n        overflow: Optional[OverflowMethod] = None,\n        emoji: Optional[bool] = None,\n        markup: Optional[bool] = None,\n        highlight: Optional[bool] = None,\n        highlighter: Optional[HighlighterType] = None,\n    ) -> \"Text\":\n        \"\"\"Convert a string to a Text instance. This is called automatically if\n        you print or log a string.\n\n        Args:\n            text (str): Text to render.\n            style (Union[str, Style], optional): Style to apply to rendered text.\n            justify (str, optional): Justify method: \"default\", \"left\", \"center\", \"full\", or \"right\". Defaults to ``None``.\n            overflow (str, optional): Overflow method: \"crop\", \"fold\", or \"ellipsis\". Defaults to ``None``.\n            emoji (Optional[bool], optional): Enable emoji, or ``None`` to use Console default.\n            markup (Optional[bool], optional): Enable markup, or ``None`` to use Console default.\n            highlight (Optional[bool], optional): Enable highlighting, or ``None`` to use Console default.\n            highlighter (HighlighterType, optional): Optional highlighter to apply.\n        Returns:\n            ConsoleRenderable: Renderable object.\n\n        \"\"\"\n        emoji_enabled = emoji or (emoji is None and self._emoji)\n        markup_enabled = markup or (markup is None and self._markup)\n        highlight_enabled = highlight or (highlight is None and self._highlight)\n\n        if markup_enabled:\n            rich_text = render_markup(\n                text,\n                style=style,\n                emoji=emoji_enabled,\n                emoji_variant=self._emoji_variant,\n            )\n            rich_text.justify = justify\n            rich_text.overflow = overflow\n        else:\n            rich_text = Text(\n                _emoji_replace(text, default_variant=self._emoji_variant)\n                if emoji_enabled\n                else text,\n                justify=justify,\n                overflow=overflow,\n                style=style,\n            )\n\n        _highlighter = (highlighter or self.highlighter) if highlight_enabled else None\n        if _highlighter is not None:\n            highlight_text = _highlighter(str(rich_text))\n            highlight_text.copy_styles(rich_text)\n            return highlight_text\n\n        return rich_text\n\n    def get_style(\n        self, name: Union[str, Style], *, default: Optional[Union[Style, str]] = None\n    ) -> Style:\n        \"\"\"Get a Style instance by its theme name or parse a definition.\n\n        Args:\n            name (str): The name of a style or a style definition.\n\n        Returns:\n            Style: A Style object.\n\n        Raises:\n            MissingStyle: If no style could be parsed from name.\n\n        \"\"\"\n        if isinstance(name, Style):\n            return name\n\n        try:\n            style = self._theme_stack.get(name)\n            if style is None:\n                style = Style.parse(name)\n            return style.copy() if style.link else style\n        except errors.StyleSyntaxError as error:\n            if default is not None:\n                return self.get_style(default)\n            raise errors.MissingStyle(\n                f\"Failed to get style {name!r}; {error}\"\n            ) from None\n\n    def _collect_renderables(\n        self,\n        objects: Iterable[Any],\n        sep: str,\n        end: str,\n        *,\n        justify: Optional[JustifyMethod] = None,\n        emoji: Optional[bool] = None,\n        markup: Optional[bool] = None,\n        highlight: Optional[bool] = None,\n    ) -> List[ConsoleRenderable]:\n        \"\"\"Combine a number of renderables and text into one renderable.\n\n        Args:\n            objects (Iterable[Any]): Anything that Rich can render.\n            sep (str): String to write between print data.\n            end (str): String to write at end of print data.\n            justify (str, optional): One of \"left\", \"right\", \"center\", or \"full\". Defaults to ``None``.\n            emoji (Optional[bool], optional): Enable emoji code, or ``None`` to use console default.\n            markup (Optional[bool], optional): Enable markup, or ``None`` to use console default.\n            highlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use console default.\n\n        Returns:\n            List[ConsoleRenderable]: A list of things to render.\n        \"\"\"\n        renderables: List[ConsoleRenderable] = []\n        _append = renderables.append\n        text: List[Text] = []\n        append_text = text.append\n\n        append = _append\n        if justify in (\"left\", \"center\", \"right\"):\n\n            def align_append(renderable: RenderableType) -> None:\n                _append(Align(renderable, cast(AlignMethod, justify)))\n\n            append = align_append\n\n        _highlighter: HighlighterType = _null_highlighter\n        if highlight or (highlight is None and self._highlight):\n            _highlighter = self.highlighter\n\n        def check_text() -> None:\n            if text:\n                sep_text = Text(sep, justify=justify, end=end)\n                append(sep_text.join(text))\n                text.clear()\n\n        for renderable in objects:\n            renderable = rich_cast(renderable)\n            if isinstance(renderable, str):\n                append_text(\n                    self.render_str(\n                        renderable, emoji=emoji, markup=markup, highlighter=_highlighter\n                    )\n                )\n            elif isinstance(renderable, Text):\n                append_text(renderable)\n            elif isinstance(renderable, ConsoleRenderable):\n                check_text()\n                append(renderable)\n            elif is_expandable(renderable):\n                check_text()\n                append(Pretty(renderable, highlighter=_highlighter))\n            else:\n                append_text(_highlighter(str(renderable)))\n\n        check_text()\n\n        if self.style is not None:\n            style = self.get_style(self.style)\n            renderables = [Styled(renderable, style) for renderable in renderables]\n\n        return renderables\n\n    def rule(\n        self,\n        title: TextType = \"\",\n        *,\n        characters: str = \"─\",\n        style: Union[str, Style] = \"rule.line\",\n        align: AlignMethod = \"center\",\n    ) -> None:\n        \"\"\"Draw a line with optional centered title.\n\n        Args:\n            title (str, optional): Text to render over the rule. Defaults to \"\".\n            characters (str, optional): Character(s) to form the line. Defaults to \"─\".\n            style (str, optional): Style of line. Defaults to \"rule.line\".\n            align (str, optional): How to align the title, one of \"left\", \"center\", or \"right\". Defaults to \"center\".\n        \"\"\"\n        from .rule import Rule\n\n        rule = Rule(title=title, characters=characters, style=style, align=align)\n        self.print(rule)\n\n    def control(self, *control: Control) -> None:\n        \"\"\"Insert non-printing control codes.\n\n        Args:\n            control_codes (str): Control codes, such as those that may move the cursor.\n        \"\"\"\n        if not self.is_dumb_terminal:\n            with self:\n                self._buffer.extend(_control.segment for _control in control)\n\n    def out(\n        self,\n        *objects: Any,\n        sep: str = \" \",\n        end: str = \"\\n\",\n        style: Optional[Union[str, Style]] = None,\n        highlight: Optional[bool] = None,\n    ) -> None:\n        \"\"\"Output to the terminal. This is a low-level way of writing to the terminal which unlike\n        :meth:`~rich.console.Console.print` won't pretty print, wrap text, or apply markup, but will\n        optionally apply highlighting and a basic style.\n\n        Args:\n            sep (str, optional): String to write between print data. Defaults to \" \".\n            end (str, optional): String to write at end of print data. Defaults to \"\\\\\\\\n\".\n            style (Union[str, Style], optional): A style to apply to output. Defaults to None.\n            highlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use\n                console default. Defaults to ``None``.\n        \"\"\"\n        raw_output: str = sep.join(str(_object) for _object in objects)\n        self.print(\n            raw_output,\n            style=style,\n            highlight=highlight,\n            emoji=False,\n            markup=False,\n            no_wrap=True,\n            overflow=\"ignore\",\n            crop=False,\n            end=end,\n        )\n\n    def print(\n        self,\n        *objects: Any,\n        sep: str = \" \",\n        end: str = \"\\n\",\n        style: Optional[Union[str, Style]] = None,\n        justify: Optional[JustifyMethod] = None,\n        overflow: Optional[OverflowMethod] = None,\n        no_wrap: Optional[bool] = None,\n        emoji: Optional[bool] = None,\n        markup: Optional[bool] = None,\n        highlight: Optional[bool] = None,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        crop: bool = True,\n        soft_wrap: Optional[bool] = None,\n        new_line_start: bool = False,\n    ) -> None:\n        \"\"\"Print to the console.\n\n        Args:\n            objects (positional args): Objects to log to the terminal.\n            sep (str, optional): String to write between print data. Defaults to \" \".\n            end (str, optional): String to write at end of print data. Defaults to \"\\\\\\\\n\".\n            style (Union[str, Style], optional): A style to apply to output. Defaults to None.\n            justify (str, optional): Justify method: \"default\", \"left\", \"right\", \"center\", or \"full\". Defaults to ``None``.\n            overflow (str, optional): Overflow method: \"ignore\", \"crop\", \"fold\", or \"ellipsis\". Defaults to None.\n            no_wrap (Optional[bool], optional): Disable word wrapping. Defaults to None.\n            emoji (Optional[bool], optional): Enable emoji code, or ``None`` to use console default. Defaults to ``None``.\n            markup (Optional[bool], optional): Enable markup, or ``None`` to use console default. Defaults to ``None``.\n            highlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use console default. Defaults to ``None``.\n            width (Optional[int], optional): Width of output, or ``None`` to auto-detect. Defaults to ``None``.\n            crop (Optional[bool], optional): Crop output to width of terminal. Defaults to True.\n            soft_wrap (bool, optional): Enable soft wrap mode which disables word wrapping and cropping of text or ``None`` for\n                Console default. Defaults to ``None``.\n            new_line_start (bool, False): Insert a new line at the start if the output contains more than one line. Defaults to ``False``.\n        \"\"\"\n        if not objects:\n            objects = (NewLine(),)\n\n        if soft_wrap is None:\n            soft_wrap = self.soft_wrap\n        if soft_wrap:\n            if no_wrap is None:\n                no_wrap = True\n            if overflow is None:\n                overflow = \"ignore\"\n            crop = False\n        render_hooks = self._render_hooks[:]\n        with self:\n            renderables = self._collect_renderables(\n                objects,\n                sep,\n                end,\n                justify=justify,\n                emoji=emoji,\n                markup=markup,\n                highlight=highlight,\n            )\n            for hook in render_hooks:\n                renderables = hook.process_renderables(renderables)\n            render_options = self.options.update(\n                justify=justify,\n                overflow=overflow,\n                width=min(width, self.width) if width is not None else NO_CHANGE,\n                height=height,\n                no_wrap=no_wrap,\n                markup=markup,\n                highlight=highlight,\n            )\n\n            new_segments: List[Segment] = []\n            extend = new_segments.extend\n            render = self.render\n            if style is None:\n                for renderable in renderables:\n                    extend(render(renderable, render_options))\n            else:\n                for renderable in renderables:\n                    extend(\n                        Segment.apply_style(\n                            render(renderable, render_options), self.get_style(style)\n                        )\n                    )\n            if new_line_start:\n                if (\n                    len(\"\".join(segment.text for segment in new_segments).splitlines())\n                    > 1\n                ):\n                    new_segments.insert(0, Segment.line())\n            if crop:\n                buffer_extend = self._buffer.extend\n                for line in Segment.split_and_crop_lines(\n                    new_segments, self.width, pad=False\n                ):\n                    buffer_extend(line)\n            else:\n                self._buffer.extend(new_segments)\n\n    def print_json(\n        self,\n        json: Optional[str] = None,\n        *,\n        data: Any = None,\n        indent: Union[None, int, str] = 2,\n        highlight: bool = True,\n        skip_keys: bool = False,\n        ensure_ascii: bool = False,\n        check_circular: bool = True,\n        allow_nan: bool = True,\n        default: Optional[Callable[[Any], Any]] = None,\n        sort_keys: bool = False,\n    ) -> None:\n        \"\"\"Pretty prints JSON. Output will be valid JSON.\n\n        Args:\n            json (Optional[str]): A string containing JSON.\n            data (Any): If json is not supplied, then encode this data.\n            indent (Union[None, int, str], optional): Number of spaces to indent. Defaults to 2.\n            highlight (bool, optional): Enable highlighting of output: Defaults to True.\n            skip_keys (bool, optional): Skip keys not of a basic type. Defaults to False.\n            ensure_ascii (bool, optional): Escape all non-ascii characters. Defaults to False.\n            check_circular (bool, optional): Check for circular references. Defaults to True.\n            allow_nan (bool, optional): Allow NaN and Infinity values. Defaults to True.\n            default (Callable, optional): A callable that converts values that can not be encoded\n                in to something that can be JSON encoded. Defaults to None.\n            sort_keys (bool, optional): Sort dictionary keys. Defaults to False.\n        \"\"\"\n        from pip._vendor.rich.json import JSON\n\n        if json is None:\n            json_renderable = JSON.from_data(\n                data,\n                indent=indent,\n                highlight=highlight,\n                skip_keys=skip_keys,\n                ensure_ascii=ensure_ascii,\n                check_circular=check_circular,\n                allow_nan=allow_nan,\n                default=default,\n                sort_keys=sort_keys,\n            )\n        else:\n            if not isinstance(json, str):\n                raise TypeError(\n                    f\"json must be str. Did you mean print_json(data={json!r}) ?\"\n                )\n            json_renderable = JSON(\n                json,\n                indent=indent,\n                highlight=highlight,\n                skip_keys=skip_keys,\n                ensure_ascii=ensure_ascii,\n                check_circular=check_circular,\n                allow_nan=allow_nan,\n                default=default,\n                sort_keys=sort_keys,\n            )\n        self.print(json_renderable, soft_wrap=True)\n\n    def update_screen(\n        self,\n        renderable: RenderableType,\n        *,\n        region: Optional[Region] = None,\n        options: Optional[ConsoleOptions] = None,\n    ) -> None:\n        \"\"\"Update the screen at a given offset.\n\n        Args:\n            renderable (RenderableType): A Rich renderable.\n            region (Region, optional): Region of screen to update, or None for entire screen. Defaults to None.\n            x (int, optional): x offset. Defaults to 0.\n            y (int, optional): y offset. Defaults to 0.\n\n        Raises:\n            errors.NoAltScreen: If the Console isn't in alt screen mode.\n\n        \"\"\"\n        if not self.is_alt_screen:\n            raise errors.NoAltScreen(\"Alt screen must be enabled to call update_screen\")\n        render_options = options or self.options\n        if region is None:\n            x = y = 0\n            render_options = render_options.update_dimensions(\n                render_options.max_width, render_options.height or self.height\n            )\n        else:\n            x, y, width, height = region\n            render_options = render_options.update_dimensions(width, height)\n\n        lines = self.render_lines(renderable, options=render_options)\n        self.update_screen_lines(lines, x, y)\n\n    def update_screen_lines(\n        self, lines: List[List[Segment]], x: int = 0, y: int = 0\n    ) -> None:\n        \"\"\"Update lines of the screen at a given offset.\n\n        Args:\n            lines (List[List[Segment]]): Rendered lines (as produced by :meth:`~rich.Console.render_lines`).\n            x (int, optional): x offset (column no). Defaults to 0.\n            y (int, optional): y offset (column no). Defaults to 0.\n\n        Raises:\n            errors.NoAltScreen: If the Console isn't in alt screen mode.\n        \"\"\"\n        if not self.is_alt_screen:\n            raise errors.NoAltScreen(\"Alt screen must be enabled to call update_screen\")\n        screen_update = ScreenUpdate(lines, x, y)\n        segments = self.render(screen_update)\n        self._buffer.extend(segments)\n        self._check_buffer()\n\n    def print_exception(\n        self,\n        *,\n        width: Optional[int] = 100,\n        extra_lines: int = 3,\n        theme: Optional[str] = None,\n        word_wrap: bool = False,\n        show_locals: bool = False,\n        suppress: Iterable[Union[str, ModuleType]] = (),\n        max_frames: int = 100,\n    ) -> None:\n        \"\"\"Prints a rich render of the last exception and traceback.\n\n        Args:\n            width (Optional[int], optional): Number of characters used to render code. Defaults to 100.\n            extra_lines (int, optional): Additional lines of code to render. Defaults to 3.\n            theme (str, optional): Override pygments theme used in traceback\n            word_wrap (bool, optional): Enable word wrapping of long lines. Defaults to False.\n            show_locals (bool, optional): Enable display of local variables. Defaults to False.\n            suppress (Iterable[Union[str, ModuleType]]): Optional sequence of modules or paths to exclude from traceback.\n            max_frames (int): Maximum number of frames to show in a traceback, 0 for no maximum. Defaults to 100.\n        \"\"\"\n        from .traceback import Traceback\n\n        traceback = Traceback(\n            width=width,\n            extra_lines=extra_lines,\n            theme=theme,\n            word_wrap=word_wrap,\n            show_locals=show_locals,\n            suppress=suppress,\n            max_frames=max_frames,\n        )\n        self.print(traceback)\n\n    @staticmethod\n    def _caller_frame_info(\n        offset: int,\n        currentframe: Callable[[], Optional[FrameType]] = inspect.currentframe,\n    ) -> Tuple[str, int, Dict[str, Any]]:\n        \"\"\"Get caller frame information.\n\n        Args:\n            offset (int): the caller offset within the current frame stack.\n            currentframe (Callable[[], Optional[FrameType]], optional): the callable to use to\n                retrieve the current frame. Defaults to ``inspect.currentframe``.\n\n        Returns:\n            Tuple[str, int, Dict[str, Any]]: A tuple containing the filename, the line number and\n                the dictionary of local variables associated with the caller frame.\n\n        Raises:\n            RuntimeError: If the stack offset is invalid.\n        \"\"\"\n        # Ignore the frame of this local helper\n        offset += 1\n\n        frame = currentframe()\n        if frame is not None:\n            # Use the faster currentframe where implemented\n            while offset and frame is not None:\n                frame = frame.f_back\n                offset -= 1\n            assert frame is not None\n            return frame.f_code.co_filename, frame.f_lineno, frame.f_locals\n        else:\n            # Fallback to the slower stack\n            frame_info = inspect.stack()[offset]\n            return frame_info.filename, frame_info.lineno, frame_info.frame.f_locals\n\n    def log(\n        self,\n        *objects: Any,\n        sep: str = \" \",\n        end: str = \"\\n\",\n        style: Optional[Union[str, Style]] = None,\n        justify: Optional[JustifyMethod] = None,\n        emoji: Optional[bool] = None,\n        markup: Optional[bool] = None,\n        highlight: Optional[bool] = None,\n        log_locals: bool = False,\n        _stack_offset: int = 1,\n    ) -> None:\n        \"\"\"Log rich content to the terminal.\n\n        Args:\n            objects (positional args): Objects to log to the terminal.\n            sep (str, optional): String to write between print data. Defaults to \" \".\n            end (str, optional): String to write at end of print data. Defaults to \"\\\\\\\\n\".\n            style (Union[str, Style], optional): A style to apply to output. Defaults to None.\n            justify (str, optional): One of \"left\", \"right\", \"center\", or \"full\". Defaults to ``None``.\n            overflow (str, optional): Overflow method: \"crop\", \"fold\", or \"ellipsis\". Defaults to None.\n            emoji (Optional[bool], optional): Enable emoji code, or ``None`` to use console default. Defaults to None.\n            markup (Optional[bool], optional): Enable markup, or ``None`` to use console default. Defaults to None.\n            highlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use console default. Defaults to None.\n            log_locals (bool, optional): Boolean to enable logging of locals where ``log()``\n                was called. Defaults to False.\n            _stack_offset (int, optional): Offset of caller from end of call stack. Defaults to 1.\n        \"\"\"\n        if not objects:\n            objects = (NewLine(),)\n\n        render_hooks = self._render_hooks[:]\n\n        with self:\n            renderables = self._collect_renderables(\n                objects,\n                sep,\n                end,\n                justify=justify,\n                emoji=emoji,\n                markup=markup,\n                highlight=highlight,\n            )\n            if style is not None:\n                renderables = [Styled(renderable, style) for renderable in renderables]\n\n            filename, line_no, locals = self._caller_frame_info(_stack_offset)\n            link_path = None if filename.startswith(\"<\") else os.path.abspath(filename)\n            path = filename.rpartition(os.sep)[-1]\n            if log_locals:\n                locals_map = {\n                    key: value\n                    for key, value in locals.items()\n                    if not key.startswith(\"__\")\n                }\n                renderables.append(render_scope(locals_map, title=\"[i]locals\"))\n\n            renderables = [\n                self._log_render(\n                    self,\n                    renderables,\n                    log_time=self.get_datetime(),\n                    path=path,\n                    line_no=line_no,\n                    link_path=link_path,\n                )\n            ]\n            for hook in render_hooks:\n                renderables = hook.process_renderables(renderables)\n            new_segments: List[Segment] = []\n            extend = new_segments.extend\n            render = self.render\n            render_options = self.options\n            for renderable in renderables:\n                extend(render(renderable, render_options))\n            buffer_extend = self._buffer.extend\n            for line in Segment.split_and_crop_lines(\n                new_segments, self.width, pad=False\n            ):\n                buffer_extend(line)\n\n    def _check_buffer(self) -> None:\n        \"\"\"Check if the buffer may be rendered. Render it if it can (e.g. Console.quiet is False)\n        Rendering is supported on Windows, Unix and Jupyter environments. For\n        legacy Windows consoles, the win32 API is called directly.\n        This method will also record what it renders if recording is enabled via Console.record.\n        \"\"\"\n        if self.quiet:\n            del self._buffer[:]\n            return\n        with self._lock:\n            if self.record:\n                with self._record_buffer_lock:\n                    self._record_buffer.extend(self._buffer[:])\n\n            if self._buffer_index == 0:\n                if self.is_jupyter:  # pragma: no cover\n                    from .jupyter import display\n\n                    display(self._buffer, self._render_buffer(self._buffer[:]))\n                    del self._buffer[:]\n                else:\n                    if WINDOWS:\n                        use_legacy_windows_render = False\n                        if self.legacy_windows:\n                            fileno = get_fileno(self.file)\n                            if fileno is not None:\n                                use_legacy_windows_render = (\n                                    fileno in _STD_STREAMS_OUTPUT\n                                )\n\n                        if use_legacy_windows_render:\n                            from pip._vendor.rich._win32_console import LegacyWindowsTerm\n                            from pip._vendor.rich._windows_renderer import legacy_windows_render\n\n                            buffer = self._buffer[:]\n                            if self.no_color and self._color_system:\n                                buffer = list(Segment.remove_color(buffer))\n\n                            legacy_windows_render(buffer, LegacyWindowsTerm(self.file))\n                        else:\n                            # Either a non-std stream on legacy Windows, or modern Windows.\n                            text = self._render_buffer(self._buffer[:])\n                            # https://bugs.python.org/issue37871\n                            # https://github.com/python/cpython/issues/82052\n                            # We need to avoid writing more than 32Kb in a single write, due to the above bug\n                            write = self.file.write\n                            # Worse case scenario, every character is 4 bytes of utf-8\n                            MAX_WRITE = 32 * 1024 // 4\n                            try:\n                                if len(text) <= MAX_WRITE:\n                                    write(text)\n                                else:\n                                    batch: List[str] = []\n                                    batch_append = batch.append\n                                    size = 0\n                                    for line in text.splitlines(True):\n                                        if size + len(line) > MAX_WRITE and batch:\n                                            write(\"\".join(batch))\n                                            batch.clear()\n                                            size = 0\n                                        batch_append(line)\n                                        size += len(line)\n                                    if batch:\n                                        write(\"\".join(batch))\n                                        batch.clear()\n                            except UnicodeEncodeError as error:\n                                error.reason = f\"{error.reason}\\n*** You may need to add PYTHONIOENCODING=utf-8 to your environment ***\"\n                                raise\n                    else:\n                        text = self._render_buffer(self._buffer[:])\n                        try:\n                            self.file.write(text)\n                        except UnicodeEncodeError as error:\n                            error.reason = f\"{error.reason}\\n*** You may need to add PYTHONIOENCODING=utf-8 to your environment ***\"\n                            raise\n\n                    self.file.flush()\n                    del self._buffer[:]\n\n    def _render_buffer(self, buffer: Iterable[Segment]) -> str:\n        \"\"\"Render buffered output, and clear buffer.\"\"\"\n        output: List[str] = []\n        append = output.append\n        color_system = self._color_system\n        legacy_windows = self.legacy_windows\n        not_terminal = not self.is_terminal\n        if self.no_color and color_system:\n            buffer = Segment.remove_color(buffer)\n        for text, style, control in buffer:\n            if style:\n                append(\n                    style.render(\n                        text,\n                        color_system=color_system,\n                        legacy_windows=legacy_windows,\n                    )\n                )\n            elif not (not_terminal and control):\n                append(text)\n\n        rendered = \"\".join(output)\n        return rendered\n\n    def input(\n        self,\n        prompt: TextType = \"\",\n        *,\n        markup: bool = True,\n        emoji: bool = True,\n        password: bool = False,\n        stream: Optional[TextIO] = None,\n    ) -> str:\n        \"\"\"Displays a prompt and waits for input from the user. The prompt may contain color / style.\n\n        It works in the same way as Python's builtin :func:`input` function and provides elaborate line editing and history features if Python's builtin :mod:`readline` module is previously loaded.\n\n        Args:\n            prompt (Union[str, Text]): Text to render in the prompt.\n            markup (bool, optional): Enable console markup (requires a str prompt). Defaults to True.\n            emoji (bool, optional): Enable emoji (requires a str prompt). Defaults to True.\n            password: (bool, optional): Hide typed text. Defaults to False.\n            stream: (TextIO, optional): Optional file to read input from (rather than stdin). Defaults to None.\n\n        Returns:\n            str: Text read from stdin.\n        \"\"\"\n        if prompt:\n            self.print(prompt, markup=markup, emoji=emoji, end=\"\")\n        if password:\n            result = getpass(\"\", stream=stream)\n        else:\n            if stream:\n                result = stream.readline()\n            else:\n                result = input()\n        return result\n\n    def export_text(self, *, clear: bool = True, styles: bool = False) -> str:\n        \"\"\"Generate text from console contents (requires record=True argument in constructor).\n\n        Args:\n            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``.\n            styles (bool, optional): If ``True``, ansi escape codes will be included. ``False`` for plain text.\n                Defaults to ``False``.\n\n        Returns:\n            str: String containing console contents.\n\n        \"\"\"\n        assert (\n            self.record\n        ), \"To export console contents set record=True in the constructor or instance\"\n\n        with self._record_buffer_lock:\n            if styles:\n                text = \"\".join(\n                    (style.render(text) if style else text)\n                    for text, style, _ in self._record_buffer\n                )\n            else:\n                text = \"\".join(\n                    segment.text\n                    for segment in self._record_buffer\n                    if not segment.control\n                )\n            if clear:\n                del self._record_buffer[:]\n        return text\n\n    def save_text(self, path: str, *, clear: bool = True, styles: bool = False) -> None:\n        \"\"\"Generate text from console and save to a given location (requires record=True argument in constructor).\n\n        Args:\n            path (str): Path to write text files.\n            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``.\n            styles (bool, optional): If ``True``, ansi style codes will be included. ``False`` for plain text.\n                Defaults to ``False``.\n\n        \"\"\"\n        text = self.export_text(clear=clear, styles=styles)\n        with open(path, \"wt\", encoding=\"utf-8\") as write_file:\n            write_file.write(text)\n\n    def export_html(\n        self,\n        *,\n        theme: Optional[TerminalTheme] = None,\n        clear: bool = True,\n        code_format: Optional[str] = None,\n        inline_styles: bool = False,\n    ) -> str:\n        \"\"\"Generate HTML from console contents (requires record=True argument in constructor).\n\n        Args:\n            theme (TerminalTheme, optional): TerminalTheme object containing console colors.\n            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``.\n            code_format (str, optional): Format string to render HTML. In addition to '{foreground}',\n                '{background}', and '{code}', should contain '{stylesheet}' if inline_styles is ``False``.\n            inline_styles (bool, optional): If ``True`` styles will be inlined in to spans, which makes files\n                larger but easier to cut and paste markup. If ``False``, styles will be embedded in a style tag.\n                Defaults to False.\n\n        Returns:\n            str: String containing console contents as HTML.\n        \"\"\"\n        assert (\n            self.record\n        ), \"To export console contents set record=True in the constructor or instance\"\n        fragments: List[str] = []\n        append = fragments.append\n        _theme = theme or DEFAULT_TERMINAL_THEME\n        stylesheet = \"\"\n\n        render_code_format = CONSOLE_HTML_FORMAT if code_format is None else code_format\n\n        with self._record_buffer_lock:\n            if inline_styles:\n                for text, style, _ in Segment.filter_control(\n                    Segment.simplify(self._record_buffer)\n                ):\n                    text = escape(text)\n                    if style:\n                        rule = style.get_html_style(_theme)\n                        if style.link:\n                            text = f'<a href=\"{style.link}\">{text}</a>'\n                        text = f'<span style=\"{rule}\">{text}</span>' if rule else text\n                    append(text)\n            else:\n                styles: Dict[str, int] = {}\n                for text, style, _ in Segment.filter_control(\n                    Segment.simplify(self._record_buffer)\n                ):\n                    text = escape(text)\n                    if style:\n                        rule = style.get_html_style(_theme)\n                        style_number = styles.setdefault(rule, len(styles) + 1)\n                        if style.link:\n                            text = f'<a class=\"r{style_number}\" href=\"{style.link}\">{text}</a>'\n                        else:\n                            text = f'<span class=\"r{style_number}\">{text}</span>'\n                    append(text)\n                stylesheet_rules: List[str] = []\n                stylesheet_append = stylesheet_rules.append\n                for style_rule, style_number in styles.items():\n                    if style_rule:\n                        stylesheet_append(f\".r{style_number} {{{style_rule}}}\")\n                stylesheet = \"\\n\".join(stylesheet_rules)\n\n            rendered_code = render_code_format.format(\n                code=\"\".join(fragments),\n                stylesheet=stylesheet,\n                foreground=_theme.foreground_color.hex,\n                background=_theme.background_color.hex,\n            )\n            if clear:\n                del self._record_buffer[:]\n        return rendered_code\n\n    def save_html(\n        self,\n        path: str,\n        *,\n        theme: Optional[TerminalTheme] = None,\n        clear: bool = True,\n        code_format: str = CONSOLE_HTML_FORMAT,\n        inline_styles: bool = False,\n    ) -> None:\n        \"\"\"Generate HTML from console contents and write to a file (requires record=True argument in constructor).\n\n        Args:\n            path (str): Path to write html file.\n            theme (TerminalTheme, optional): TerminalTheme object containing console colors.\n            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``.\n            code_format (str, optional): Format string to render HTML. In addition to '{foreground}',\n                '{background}', and '{code}', should contain '{stylesheet}' if inline_styles is ``False``.\n            inline_styles (bool, optional): If ``True`` styles will be inlined in to spans, which makes files\n                larger but easier to cut and paste markup. If ``False``, styles will be embedded in a style tag.\n                Defaults to False.\n\n        \"\"\"\n        html = self.export_html(\n            theme=theme,\n            clear=clear,\n            code_format=code_format,\n            inline_styles=inline_styles,\n        )\n        with open(path, \"wt\", encoding=\"utf-8\") as write_file:\n            write_file.write(html)\n\n    def export_svg(\n        self,\n        *,\n        title: str = \"Rich\",\n        theme: Optional[TerminalTheme] = None,\n        clear: bool = True,\n        code_format: str = CONSOLE_SVG_FORMAT,\n        font_aspect_ratio: float = 0.61,\n        unique_id: Optional[str] = None,\n    ) -> str:\n        \"\"\"\n        Generate an SVG from the console contents (requires record=True in Console constructor).\n\n        Args:\n            title (str, optional): The title of the tab in the output image\n            theme (TerminalTheme, optional): The ``TerminalTheme`` object to use to style the terminal\n            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``\n            code_format (str, optional): Format string used to generate the SVG. Rich will inject a number of variables\n                into the string in order to form the final SVG output. The default template used and the variables\n                injected by Rich can be found by inspecting the ``console.CONSOLE_SVG_FORMAT`` variable.\n            font_aspect_ratio (float, optional): The width to height ratio of the font used in the ``code_format``\n                string. Defaults to 0.61, which is the width to height ratio of Fira Code (the default font).\n                If you aren't specifying a different font inside ``code_format``, you probably don't need this.\n            unique_id (str, optional): unique id that is used as the prefix for various elements (CSS styles, node\n                ids). If not set, this defaults to a computed value based on the recorded content.\n        \"\"\"\n\n        from pip._vendor.rich.cells import cell_len\n\n        style_cache: Dict[Style, str] = {}\n\n        def get_svg_style(style: Style) -> str:\n            \"\"\"Convert a Style to CSS rules for SVG.\"\"\"\n            if style in style_cache:\n                return style_cache[style]\n            css_rules = []\n            color = (\n                _theme.foreground_color\n                if (style.color is None or style.color.is_default)\n                else style.color.get_truecolor(_theme)\n            )\n            bgcolor = (\n                _theme.background_color\n                if (style.bgcolor is None or style.bgcolor.is_default)\n                else style.bgcolor.get_truecolor(_theme)\n            )\n            if style.reverse:\n                color, bgcolor = bgcolor, color\n            if style.dim:\n                color = blend_rgb(color, bgcolor, 0.4)\n            css_rules.append(f\"fill: {color.hex}\")\n            if style.bold:\n                css_rules.append(\"font-weight: bold\")\n            if style.italic:\n                css_rules.append(\"font-style: italic;\")\n            if style.underline:\n                css_rules.append(\"text-decoration: underline;\")\n            if style.strike:\n                css_rules.append(\"text-decoration: line-through;\")\n\n            css = \";\".join(css_rules)\n            style_cache[style] = css\n            return css\n\n        _theme = theme or SVG_EXPORT_THEME\n\n        width = self.width\n        char_height = 20\n        char_width = char_height * font_aspect_ratio\n        line_height = char_height * 1.22\n\n        margin_top = 1\n        margin_right = 1\n        margin_bottom = 1\n        margin_left = 1\n\n        padding_top = 40\n        padding_right = 8\n        padding_bottom = 8\n        padding_left = 8\n\n        padding_width = padding_left + padding_right\n        padding_height = padding_top + padding_bottom\n        margin_width = margin_left + margin_right\n        margin_height = margin_top + margin_bottom\n\n        text_backgrounds: List[str] = []\n        text_group: List[str] = []\n        classes: Dict[str, int] = {}\n        style_no = 1\n\n        def escape_text(text: str) -> str:\n            \"\"\"HTML escape text and replace spaces with nbsp.\"\"\"\n            return escape(text).replace(\" \", \"&#160;\")\n\n        def make_tag(\n            name: str, content: Optional[str] = None, **attribs: object\n        ) -> str:\n            \"\"\"Make a tag from name, content, and attributes.\"\"\"\n\n            def stringify(value: object) -> str:\n                if isinstance(value, (float)):\n                    return format(value, \"g\")\n                return str(value)\n\n            tag_attribs = \" \".join(\n                f'{k.lstrip(\"_\").replace(\"_\", \"-\")}=\"{stringify(v)}\"'\n                for k, v in attribs.items()\n            )\n            return (\n                f\"<{name} {tag_attribs}>{content}</{name}>\"\n                if content\n                else f\"<{name} {tag_attribs}/>\"\n            )\n\n        with self._record_buffer_lock:\n            segments = list(Segment.filter_control(self._record_buffer))\n            if clear:\n                self._record_buffer.clear()\n\n        if unique_id is None:\n            unique_id = \"terminal-\" + str(\n                zlib.adler32(\n                    (\"\".join(repr(segment) for segment in segments)).encode(\n                        \"utf-8\",\n                        \"ignore\",\n                    )\n                    + title.encode(\"utf-8\", \"ignore\")\n                )\n            )\n        y = 0\n        for y, line in enumerate(Segment.split_and_crop_lines(segments, length=width)):\n            x = 0\n            for text, style, _control in line:\n                style = style or Style()\n                rules = get_svg_style(style)\n                if rules not in classes:\n                    classes[rules] = style_no\n                    style_no += 1\n                class_name = f\"r{classes[rules]}\"\n\n                if style.reverse:\n                    has_background = True\n                    background = (\n                        _theme.foreground_color.hex\n                        if style.color is None\n                        else style.color.get_truecolor(_theme).hex\n                    )\n                else:\n                    bgcolor = style.bgcolor\n                    has_background = bgcolor is not None and not bgcolor.is_default\n                    background = (\n                        _theme.background_color.hex\n                        if style.bgcolor is None\n                        else style.bgcolor.get_truecolor(_theme).hex\n                    )\n\n                text_length = cell_len(text)\n                if has_background:\n                    text_backgrounds.append(\n                        make_tag(\n                            \"rect\",\n                            fill=background,\n                            x=x * char_width,\n                            y=y * line_height + 1.5,\n                            width=char_width * text_length,\n                            height=line_height + 0.25,\n                            shape_rendering=\"crispEdges\",\n                        )\n                    )\n\n                if text != \" \" * len(text):\n                    text_group.append(\n                        make_tag(\n                            \"text\",\n                            escape_text(text),\n                            _class=f\"{unique_id}-{class_name}\",\n                            x=x * char_width,\n                            y=y * line_height + char_height,\n                            textLength=char_width * len(text),\n                            clip_path=f\"url(#{unique_id}-line-{y})\",\n                        )\n                    )\n                x += cell_len(text)\n\n        line_offsets = [line_no * line_height + 1.5 for line_no in range(y)]\n        lines = \"\\n\".join(\n            f\"\"\"<clipPath id=\"{unique_id}-line-{line_no}\">\n    {make_tag(\"rect\", x=0, y=offset, width=char_width * width, height=line_height + 0.25)}\n            </clipPath>\"\"\"\n            for line_no, offset in enumerate(line_offsets)\n        )\n\n        styles = \"\\n\".join(\n            f\".{unique_id}-r{rule_no} {{ {css} }}\" for css, rule_no in classes.items()\n        )\n        backgrounds = \"\".join(text_backgrounds)\n        matrix = \"\".join(text_group)\n\n        terminal_width = ceil(width * char_width + padding_width)\n        terminal_height = (y + 1) * line_height + padding_height\n        chrome = make_tag(\n            \"rect\",\n            fill=_theme.background_color.hex,\n            stroke=\"rgba(255,255,255,0.35)\",\n            stroke_width=\"1\",\n            x=margin_left,\n            y=margin_top,\n            width=terminal_width,\n            height=terminal_height,\n            rx=8,\n        )\n\n        title_color = _theme.foreground_color.hex\n        if title:\n            chrome += make_tag(\n                \"text\",\n                escape_text(title),\n                _class=f\"{unique_id}-title\",\n                fill=title_color,\n                text_anchor=\"middle\",\n                x=terminal_width // 2,\n                y=margin_top + char_height + 6,\n            )\n        chrome += f\"\"\"\n            <g transform=\"translate(26,22)\">\n            <circle cx=\"0\" cy=\"0\" r=\"7\" fill=\"#ff5f57\"/>\n            <circle cx=\"22\" cy=\"0\" r=\"7\" fill=\"#febc2e\"/>\n            <circle cx=\"44\" cy=\"0\" r=\"7\" fill=\"#28c840\"/>\n            </g>\n        \"\"\"\n\n        svg = code_format.format(\n            unique_id=unique_id,\n            char_width=char_width,\n            char_height=char_height,\n            line_height=line_height,\n            terminal_width=char_width * width - 1,\n            terminal_height=(y + 1) * line_height - 1,\n            width=terminal_width + margin_width,\n            height=terminal_height + margin_height,\n            terminal_x=margin_left + padding_left,\n            terminal_y=margin_top + padding_top,\n            styles=styles,\n            chrome=chrome,\n            backgrounds=backgrounds,\n            matrix=matrix,\n            lines=lines,\n        )\n        return svg\n\n    def save_svg(\n        self,\n        path: str,\n        *,\n        title: str = \"Rich\",\n        theme: Optional[TerminalTheme] = None,\n        clear: bool = True,\n        code_format: str = CONSOLE_SVG_FORMAT,\n        font_aspect_ratio: float = 0.61,\n        unique_id: Optional[str] = None,\n    ) -> None:\n        \"\"\"Generate an SVG file from the console contents (requires record=True in Console constructor).\n\n        Args:\n            path (str): The path to write the SVG to.\n            title (str, optional): The title of the tab in the output image\n            theme (TerminalTheme, optional): The ``TerminalTheme`` object to use to style the terminal\n            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``\n            code_format (str, optional): Format string used to generate the SVG. Rich will inject a number of variables\n                into the string in order to form the final SVG output. The default template used and the variables\n                injected by Rich can be found by inspecting the ``console.CONSOLE_SVG_FORMAT`` variable.\n            font_aspect_ratio (float, optional): The width to height ratio of the font used in the ``code_format``\n                string. Defaults to 0.61, which is the width to height ratio of Fira Code (the default font).\n                If you aren't specifying a different font inside ``code_format``, you probably don't need this.\n            unique_id (str, optional): unique id that is used as the prefix for various elements (CSS styles, node\n                ids). If not set, this defaults to a computed value based on the recorded content.\n        \"\"\"\n        svg = self.export_svg(\n            title=title,\n            theme=theme,\n            clear=clear,\n            code_format=code_format,\n            font_aspect_ratio=font_aspect_ratio,\n            unique_id=unique_id,\n        )\n        with open(path, \"wt\", encoding=\"utf-8\") as write_file:\n            write_file.write(svg)\n\n\ndef _svg_hash(svg_main_code: str) -> str:\n    \"\"\"Returns a unique hash for the given SVG main code.\n\n    Args:\n        svg_main_code (str): The content we're going to inject in the SVG envelope.\n\n    Returns:\n        str: a hash of the given content\n    \"\"\"\n    return str(zlib.adler32(svg_main_code.encode()))\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    console = Console(record=True)\n\n    console.log(\n        \"JSONRPC [i]request[/i]\",\n        5,\n        1.3,\n        True,\n        False,\n        None,\n        {\n            \"jsonrpc\": \"2.0\",\n            \"method\": \"subtract\",\n            \"params\": {\"minuend\": 42, \"subtrahend\": 23},\n            \"id\": 3,\n        },\n    )\n\n    console.log(\"Hello, World!\", \"{'a': 1}\", repr(console))\n\n    console.print(\n        {\n            \"name\": None,\n            \"empty\": [],\n            \"quiz\": {\n                \"sport\": {\n                    \"answered\": True,\n                    \"q1\": {\n                        \"question\": \"Which one is correct team name in NBA?\",\n                        \"options\": [\n                            \"New York Bulls\",\n                            \"Los Angeles Kings\",\n                            \"Golden State Warriors\",\n                            \"Huston Rocket\",\n                        ],\n                        \"answer\": \"Huston Rocket\",\n                    },\n                },\n                \"maths\": {\n                    \"answered\": False,\n                    \"q1\": {\n                        \"question\": \"5 + 7 = ?\",\n                        \"options\": [10, 11, 12, 13],\n                        \"answer\": 12,\n                    },\n                    \"q2\": {\n                        \"question\": \"12 - 8 = ?\",\n                        \"options\": [1, 2, 3, 4],\n                        \"answer\": 4,\n                    },\n                },\n            },\n        }\n    )\n"},"hash":"9vRVN4eoAP"}