{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:req:constructors.py","body":"\"\"\"Backing implementation for InstallRequirement's various constructors\n\nThe idea here is that these formed a major chunk of InstallRequirement's size\nso, moving them and support code dedicated to them outside of that class\nhelps creates for better understandability for the rest of the code.\n\nThese are meant to be used elsewhere within pip to create instances of\nInstallRequirement.\n\"\"\"\n\nimport copy\nimport logging\nimport os\nimport re\nfrom typing import Collection, Dict, List, Optional, Set, Tuple, Union\n\nfrom pip._vendor.packaging.markers import Marker\nfrom pip._vendor.packaging.requirements import InvalidRequirement, Requirement\nfrom pip._vendor.packaging.specifiers import Specifier\n\nfrom pip._internal.exceptions import InstallationError\nfrom pip._internal.models.index import PyPI, TestPyPI\nfrom pip._internal.models.link import Link\nfrom pip._internal.models.wheel import Wheel\nfrom pip._internal.req.req_file import ParsedRequirement\nfrom pip._internal.req.req_install import InstallRequirement\nfrom pip._internal.utils.filetypes import is_archive_file\nfrom pip._internal.utils.misc import is_installable_dir\nfrom pip._internal.utils.packaging import get_requirement\nfrom pip._internal.utils.urls import path_to_url\nfrom pip._internal.vcs import is_url, vcs\n\n__all__ = [\n    \"install_req_from_editable\",\n    \"install_req_from_line\",\n    \"parse_editable\",\n]\n\nlogger = logging.getLogger(__name__)\noperators = Specifier._operators.keys()\n\n\ndef _strip_extras(path: str) -> Tuple[str, Optional[str]]:\n    m = re.match(r\"^(.+)(\\[[^\\]]+\\])$\", path)\n    extras = None\n    if m:\n        path_no_extras = m.group(1)\n        extras = m.group(2)\n    else:\n        path_no_extras = path\n\n    return path_no_extras, extras\n\n\ndef convert_extras(extras: Optional[str]) -> Set[str]:\n    if not extras:\n        return set()\n    return get_requirement(\"placeholder\" + extras.lower()).extras\n\n\ndef _set_requirement_extras(req: Requirement, new_extras: Set[str]) -> Requirement:\n    \"\"\"\n    Returns a new requirement based on the given one, with the supplied extras. If the\n    given requirement already has extras those are replaced (or dropped if no new extras\n    are given).\n    \"\"\"\n    match: Optional[re.Match[str]] = re.fullmatch(\n        # see https://peps.python.org/pep-0508/#complete-grammar\n        r\"([\\w\\t .-]+)(\\[[^\\]]*\\])?(.*)\",\n        str(req),\n        flags=re.ASCII,\n    )\n    # ireq.req is a valid requirement so the regex should always match\n    assert (\n        match is not None\n    ), f\"regex match on requirement {req} failed, this should never happen\"\n    pre: Optional[str] = match.group(1)\n    post: Optional[str] = match.group(3)\n    assert (\n        pre is not None and post is not None\n    ), f\"regex group selection for requirement {req} failed, this should never happen\"\n    extras: str = \"[%s]\" % \",\".join(sorted(new_extras)) if new_extras else \"\"\n    return Requirement(f\"{pre}{extras}{post}\")\n\n\ndef parse_editable(editable_req: str) -> Tuple[Optional[str], str, Set[str]]:\n    \"\"\"Parses an editable requirement into:\n        - a requirement name\n        - an URL\n        - extras\n        - editable options\n    Accepted requirements:\n        svn+http://blahblah@rev#egg=Foobar[baz]&subdirectory=version_subdir\n        .[some_extra]\n    \"\"\"\n\n    url = editable_req\n\n    # If a file path is specified with extras, strip off the extras.\n    url_no_extras, extras = _strip_extras(url)\n\n    if os.path.isdir(url_no_extras):\n        # Treating it as code that has already been checked out\n        url_no_extras = path_to_url(url_no_extras)\n\n    if url_no_extras.lower().startswith(\"file:\"):\n        package_name = Link(url_no_extras).egg_fragment\n        if extras:\n            return (\n                package_name,\n                url_no_extras,\n                get_requirement(\"placeholder\" + extras.lower()).extras,\n            )\n        else:\n            return package_name, url_no_extras, set()\n\n    for version_control in vcs:\n        if url.lower().startswith(f\"{version_control}:\"):\n            url = f\"{version_control}+{url}\"\n            break\n\n    link = Link(url)\n\n    if not link.is_vcs:\n        backends = \", \".join(vcs.all_schemes)\n        raise InstallationError(\n            f\"{editable_req} is not a valid editable requirement. \"\n            f\"It should either be a path to a local project or a VCS URL \"\n            f\"(beginning with {backends}).\"\n        )\n\n    package_name = link.egg_fragment\n    if not package_name:\n        raise InstallationError(\n            \"Could not detect requirement name for '{}', please specify one \"\n            \"with #egg=your_package_name\".format(editable_req)\n        )\n    return package_name, url, set()\n\n\ndef check_first_requirement_in_file(filename: str) -> None:\n    \"\"\"Check if file is parsable as a requirements file.\n\n    This is heavily based on ``pkg_resources.parse_requirements``, but\n    simplified to just check the first meaningful line.\n\n    :raises InvalidRequirement: If the first meaningful line cannot be parsed\n        as an requirement.\n    \"\"\"\n    with open(filename, encoding=\"utf-8\", errors=\"ignore\") as f:\n        # Create a steppable iterator, so we can handle \\-continuations.\n        lines = (\n            line\n            for line in (line.strip() for line in f)\n            if line and not line.startswith(\"#\")  # Skip blank lines/comments.\n        )\n\n        for line in lines:\n            # Drop comments -- a hash without a space may be in a URL.\n            if \" #\" in line:\n                line = line[: line.find(\" #\")]\n            # If there is a line continuation, drop it, and append the next line.\n            if line.endswith(\"\\\\\"):\n                line = line[:-2].strip() + next(lines, \"\")\n            Requirement(line)\n            return\n\n\ndef deduce_helpful_msg(req: str) -> str:\n    \"\"\"Returns helpful msg in case requirements file does not exist,\n    or cannot be parsed.\n\n    :params req: Requirements file path\n    \"\"\"\n    if not os.path.exists(req):\n        return f\" File '{req}' does not exist.\"\n    msg = \" The path does exist. \"\n    # Try to parse and check if it is a requirements file.\n    try:\n        check_first_requirement_in_file(req)\n    except InvalidRequirement:\n        logger.debug(\"Cannot parse '%s' as requirements file\", req)\n    else:\n        msg += (\n            f\"The argument you provided \"\n            f\"({req}) appears to be a\"\n            f\" requirements file. If that is the\"\n            f\" case, use the '-r' flag to install\"\n            f\" the packages specified within it.\"\n        )\n    return msg\n\n\nclass RequirementParts:\n    def __init__(\n        self,\n        requirement: Optional[Requirement],\n        link: Optional[Link],\n        markers: Optional[Marker],\n        extras: Set[str],\n    ):\n        self.requirement = requirement\n        self.link = link\n        self.markers = markers\n        self.extras = extras\n\n\ndef parse_req_from_editable(editable_req: str) -> RequirementParts:\n    name, url, extras_override = parse_editable(editable_req)\n\n    if name is not None:\n        try:\n            req: Optional[Requirement] = Requirement(name)\n        except InvalidRequirement:\n            raise InstallationError(f\"Invalid requirement: '{name}'\")\n    else:\n        req = None\n\n    link = Link(url)\n\n    return RequirementParts(req, link, None, extras_override)\n\n\n# ---- The actual constructors follow ----\n\n\ndef install_req_from_editable(\n    editable_req: str,\n    comes_from: Optional[Union[InstallRequirement, str]] = None,\n    *,\n    use_pep517: Optional[bool] = None,\n    isolated: bool = False,\n    global_options: Optional[List[str]] = None,\n    hash_options: Optional[Dict[str, List[str]]] = None,\n    constraint: bool = False,\n    user_supplied: bool = False,\n    permit_editable_wheels: bool = False,\n    config_settings: Optional[Dict[str, Union[str, List[str]]]] = None,\n) -> InstallRequirement:\n    parts = parse_req_from_editable(editable_req)\n\n    return InstallRequirement(\n        parts.requirement,\n        comes_from=comes_from,\n        user_supplied=user_supplied,\n        editable=True,\n        permit_editable_wheels=permit_editable_wheels,\n        link=parts.link,\n        constraint=constraint,\n        use_pep517=use_pep517,\n        isolated=isolated,\n        global_options=global_options,\n        hash_options=hash_options,\n        config_settings=config_settings,\n        extras=parts.extras,\n    )\n\n\ndef _looks_like_path(name: str) -> bool:\n    \"\"\"Checks whether the string \"looks like\" a path on the filesystem.\n\n    This does not check whether the target actually exists, only judge from the\n    appearance.\n\n    Returns true if any of the following conditions is true:\n    * a path separator is found (either os.path.sep or os.path.altsep);\n    * a dot is found (which represents the current directory).\n    \"\"\"\n    if os.path.sep in name:\n        return True\n    if os.path.altsep is not None and os.path.altsep in name:\n        return True\n    if name.startswith(\".\"):\n        return True\n    return False\n\n\ndef _get_url_from_path(path: str, name: str) -> Optional[str]:\n    \"\"\"\n    First, it checks whether a provided path is an installable directory. If it\n    is, returns the path.\n\n    If false, check if the path is an archive file (such as a .whl).\n    The function checks if the path is a file. If false, if the path has\n    an @, it will treat it as a PEP 440 URL requirement and return the path.\n    \"\"\"\n    if _looks_like_path(name) and os.path.isdir(path):\n        if is_installable_dir(path):\n            return path_to_url(path)\n        # TODO: The is_installable_dir test here might not be necessary\n        #       now that it is done in load_pyproject_toml too.\n        raise InstallationError(\n            f\"Directory {name!r} is not installable. Neither 'setup.py' \"\n            \"nor 'pyproject.toml' found.\"\n        )\n    if not is_archive_file(path):\n        return None\n    if os.path.isfile(path):\n        return path_to_url(path)\n    urlreq_parts = name.split(\"@\", 1)\n    if len(urlreq_parts) >= 2 and not _looks_like_path(urlreq_parts[0]):\n        # If the path contains '@' and the part before it does not look\n        # like a path, try to treat it as a PEP 440 URL req instead.\n        return None\n    logger.warning(\n        \"Requirement %r looks like a filename, but the file does not exist\",\n        name,\n    )\n    return path_to_url(path)\n\n\ndef parse_req_from_line(name: str, line_source: Optional[str]) -> RequirementParts:\n    if is_url(name):\n        marker_sep = \"; \"\n    else:\n        marker_sep = \";\"\n    if marker_sep in name:\n        name, markers_as_string = name.split(marker_sep, 1)\n        markers_as_string = markers_as_string.strip()\n        if not markers_as_string:\n            markers = None\n        else:\n            markers = Marker(markers_as_string)\n    else:\n        markers = None\n    name = name.strip()\n    req_as_string = None\n    path = os.path.normpath(os.path.abspath(name))\n    link = None\n    extras_as_string = None\n\n    if is_url(name):\n        link = Link(name)\n    else:\n        p, extras_as_string = _strip_extras(path)\n        url = _get_url_from_path(p, name)\n        if url is not None:\n            link = Link(url)\n\n    # it's a local file, dir, or url\n    if link:\n        # Handle relative file URLs\n        if link.scheme == \"file\" and re.search(r\"\\.\\./\", link.url):\n            link = Link(path_to_url(os.path.normpath(os.path.abspath(link.path))))\n        # wheel file\n        if link.is_wheel:\n            wheel = Wheel(link.filename)  # can raise InvalidWheelFilename\n            req_as_string = f\"{wheel.name}=={wheel.version}\"\n        else:\n            # set the req to the egg fragment.  when it's not there, this\n            # will become an 'unnamed' requirement\n            req_as_string = link.egg_fragment\n\n    # a requirement specifier\n    else:\n        req_as_string = name\n\n    extras = convert_extras(extras_as_string)\n\n    def with_source(text: str) -> str:\n        if not line_source:\n            return text\n        return f\"{text} (from {line_source})\"\n\n    def _parse_req_string(req_as_string: str) -> Requirement:\n        try:\n            req = get_requirement(req_as_string)\n        except InvalidRequirement:\n            if os.path.sep in req_as_string:\n                add_msg = \"It looks like a path.\"\n                add_msg += deduce_helpful_msg(req_as_string)\n            elif \"=\" in req_as_string and not any(\n                op in req_as_string for op in operators\n            ):\n                add_msg = \"= is not a valid operator. Did you mean == ?\"\n            else:\n                add_msg = \"\"\n            msg = with_source(f\"Invalid requirement: {req_as_string!r}\")\n            if add_msg:\n                msg += f\"\\nHint: {add_msg}\"\n            raise InstallationError(msg)\n        else:\n            # Deprecate extras after specifiers: \"name>=1.0[extras]\"\n            # This currently works by accident because _strip_extras() parses\n            # any extras in the end of the string and those are saved in\n            # RequirementParts\n            for spec in req.specifier:\n                spec_str = str(spec)\n                if spec_str.endswith(\"]\"):\n                    msg = f\"Extras after version '{spec_str}'.\"\n                    raise InstallationError(msg)\n        return req\n\n    if req_as_string is not None:\n        req: Optional[Requirement] = _parse_req_string(req_as_string)\n    else:\n        req = None\n\n    return RequirementParts(req, link, markers, extras)\n\n\ndef install_req_from_line(\n    name: str,\n    comes_from: Optional[Union[str, InstallRequirement]] = None,\n    *,\n    use_pep517: Optional[bool] = None,\n    isolated: bool = False,\n    global_options: Optional[List[str]] = None,\n    hash_options: Optional[Dict[str, List[str]]] = None,\n    constraint: bool = False,\n    line_source: Optional[str] = None,\n    user_supplied: bool = False,\n    config_settings: Optional[Dict[str, Union[str, List[str]]]] = None,\n) -> InstallRequirement:\n    \"\"\"Creates an InstallRequirement from a name, which might be a\n    requirement, directory containing 'setup.py', filename, or URL.\n\n    :param line_source: An optional string describing where the line is from,\n        for logging purposes in case of an error.\n    \"\"\"\n    parts = parse_req_from_line(name, line_source)\n\n    return InstallRequirement(\n        parts.requirement,\n        comes_from,\n        link=parts.link,\n        markers=parts.markers,\n        use_pep517=use_pep517,\n        isolated=isolated,\n        global_options=global_options,\n        hash_options=hash_options,\n        config_settings=config_settings,\n        constraint=constraint,\n        extras=parts.extras,\n        user_supplied=user_supplied,\n    )\n\n\ndef install_req_from_req_string(\n    req_string: str,\n    comes_from: Optional[InstallRequirement] = None,\n    isolated: bool = False,\n    use_pep517: Optional[bool] = None,\n    user_supplied: bool = False,\n) -> InstallRequirement:\n    try:\n        req = get_requirement(req_string)\n    except InvalidRequirement:\n        raise InstallationError(f\"Invalid requirement: '{req_string}'\")\n\n    domains_not_allowed = [\n        PyPI.file_storage_domain,\n        TestPyPI.file_storage_domain,\n    ]\n    if (\n        req.url\n        and comes_from\n        and comes_from.link\n        and comes_from.link.netloc in domains_not_allowed\n    ):\n        # Explicitly disallow pypi packages that depend on external urls\n        raise InstallationError(\n            \"Packages installed from PyPI cannot depend on packages \"\n            \"which are not also hosted on PyPI.\\n\"\n            f\"{comes_from.name} depends on {req} \"\n        )\n\n    return InstallRequirement(\n        req,\n        comes_from,\n        isolated=isolated,\n        use_pep517=use_pep517,\n        user_supplied=user_supplied,\n    )\n\n\ndef install_req_from_parsed_requirement(\n    parsed_req: ParsedRequirement,\n    isolated: bool = False,\n    use_pep517: Optional[bool] = None,\n    user_supplied: bool = False,\n    config_settings: Optional[Dict[str, Union[str, List[str]]]] = None,\n) -> InstallRequirement:\n    if parsed_req.is_editable:\n        req = install_req_from_editable(\n            parsed_req.requirement,\n            comes_from=parsed_req.comes_from,\n            use_pep517=use_pep517,\n            constraint=parsed_req.constraint,\n            isolated=isolated,\n            user_supplied=user_supplied,\n            config_settings=config_settings,\n        )\n\n    else:\n        req = install_req_from_line(\n            parsed_req.requirement,\n            comes_from=parsed_req.comes_from,\n            use_pep517=use_pep517,\n            isolated=isolated,\n            global_options=(\n                parsed_req.options.get(\"global_options\", [])\n                if parsed_req.options\n                else []\n            ),\n            hash_options=(\n                parsed_req.options.get(\"hashes\", {}) if parsed_req.options else {}\n            ),\n            constraint=parsed_req.constraint,\n            line_source=parsed_req.line_source,\n            user_supplied=user_supplied,\n            config_settings=config_settings,\n        )\n    return req\n\n\ndef install_req_from_link_and_ireq(\n    link: Link, ireq: InstallRequirement\n) -> InstallRequirement:\n    return InstallRequirement(\n        req=ireq.req,\n        comes_from=ireq.comes_from,\n        editable=ireq.editable,\n        link=link,\n        markers=ireq.markers,\n        use_pep517=ireq.use_pep517,\n        isolated=ireq.isolated,\n        global_options=ireq.global_options,\n        hash_options=ireq.hash_options,\n        config_settings=ireq.config_settings,\n        user_supplied=ireq.user_supplied,\n    )\n\n\ndef install_req_drop_extras(ireq: InstallRequirement) -> InstallRequirement:\n    \"\"\"\n    Creates a new InstallationRequirement using the given template but without\n    any extras. Sets the original requirement as the new one's parent\n    (comes_from).\n    \"\"\"\n    return InstallRequirement(\n        req=(\n            _set_requirement_extras(ireq.req, set()) if ireq.req is not None else None\n        ),\n        comes_from=ireq,\n        editable=ireq.editable,\n        link=ireq.link,\n        markers=ireq.markers,\n        use_pep517=ireq.use_pep517,\n        isolated=ireq.isolated,\n        global_options=ireq.global_options,\n        hash_options=ireq.hash_options,\n        constraint=ireq.constraint,\n        extras=[],\n        config_settings=ireq.config_settings,\n        user_supplied=ireq.user_supplied,\n        permit_editable_wheels=ireq.permit_editable_wheels,\n    )\n\n\ndef install_req_extend_extras(\n    ireq: InstallRequirement,\n    extras: Collection[str],\n) -> InstallRequirement:\n    \"\"\"\n    Returns a copy of an installation requirement with some additional extras.\n    Makes a shallow copy of the ireq object.\n    \"\"\"\n    result = copy.copy(ireq)\n    result.extras = {*ireq.extras, *extras}\n    result.req = (\n        _set_requirement_extras(ireq.req, result.extras)\n        if ireq.req is not None\n        else None\n    )\n    return result\n"},"hash":"r28Ey2khPV"}