{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:utils:temp_dir.py","body":"import errno\nimport itertools\nimport logging\nimport os.path\nimport tempfile\nimport traceback\nfrom contextlib import ExitStack, contextmanager\nfrom pathlib import Path\nfrom typing import (\n    Any,\n    Callable,\n    Dict,\n    Generator,\n    List,\n    Optional,\n    TypeVar,\n    Union,\n)\n\nfrom pip._internal.utils.misc import enum, rmtree\n\nlogger = logging.getLogger(__name__)\n\n_T = TypeVar(\"_T\", bound=\"TempDirectory\")\n\n\n# Kinds of temporary directories. Only needed for ones that are\n# globally-managed.\ntempdir_kinds = enum(\n    BUILD_ENV=\"build-env\",\n    EPHEM_WHEEL_CACHE=\"ephem-wheel-cache\",\n    REQ_BUILD=\"req-build\",\n)\n\n\n_tempdir_manager: Optional[ExitStack] = None\n\n\n@contextmanager\ndef global_tempdir_manager() -> Generator[None, None, None]:\n    global _tempdir_manager\n    with ExitStack() as stack:\n        old_tempdir_manager, _tempdir_manager = _tempdir_manager, stack\n        try:\n            yield\n        finally:\n            _tempdir_manager = old_tempdir_manager\n\n\nclass TempDirectoryTypeRegistry:\n    \"\"\"Manages temp directory behavior\"\"\"\n\n    def __init__(self) -> None:\n        self._should_delete: Dict[str, bool] = {}\n\n    def set_delete(self, kind: str, value: bool) -> None:\n        \"\"\"Indicate whether a TempDirectory of the given kind should be\n        auto-deleted.\n        \"\"\"\n        self._should_delete[kind] = value\n\n    def get_delete(self, kind: str) -> bool:\n        \"\"\"Get configured auto-delete flag for a given TempDirectory type,\n        default True.\n        \"\"\"\n        return self._should_delete.get(kind, True)\n\n\n_tempdir_registry: Optional[TempDirectoryTypeRegistry] = None\n\n\n@contextmanager\ndef tempdir_registry() -> Generator[TempDirectoryTypeRegistry, None, None]:\n    \"\"\"Provides a scoped global tempdir registry that can be used to dictate\n    whether directories should be deleted.\n    \"\"\"\n    global _tempdir_registry\n    old_tempdir_registry = _tempdir_registry\n    _tempdir_registry = TempDirectoryTypeRegistry()\n    try:\n        yield _tempdir_registry\n    finally:\n        _tempdir_registry = old_tempdir_registry\n\n\nclass _Default:\n    pass\n\n\n_default = _Default()\n\n\nclass TempDirectory:\n    \"\"\"Helper class that owns and cleans up a temporary directory.\n\n    This class can be used as a context manager or as an OO representation of a\n    temporary directory.\n\n    Attributes:\n        path\n            Location to the created temporary directory\n        delete\n            Whether the directory should be deleted when exiting\n            (when used as a contextmanager)\n\n    Methods:\n        cleanup()\n            Deletes the temporary directory\n\n    When used as a context manager, if the delete attribute is True, on\n    exiting the context the temporary directory is deleted.\n    \"\"\"\n\n    def __init__(\n        self,\n        path: Optional[str] = None,\n        delete: Union[bool, None, _Default] = _default,\n        kind: str = \"temp\",\n        globally_managed: bool = False,\n        ignore_cleanup_errors: bool = True,\n    ):\n        super().__init__()\n\n        if delete is _default:\n            if path is not None:\n                # If we were given an explicit directory, resolve delete option\n                # now.\n                delete = False\n            else:\n                # Otherwise, we wait until cleanup and see what\n                # tempdir_registry says.\n                delete = None\n\n        # The only time we specify path is in for editables where it\n        # is the value of the --src option.\n        if path is None:\n            path = self._create(kind)\n\n        self._path = path\n        self._deleted = False\n        self.delete = delete\n        self.kind = kind\n        self.ignore_cleanup_errors = ignore_cleanup_errors\n\n        if globally_managed:\n            assert _tempdir_manager is not None\n            _tempdir_manager.enter_context(self)\n\n    @property\n    def path(self) -> str:\n        assert not self._deleted, f\"Attempted to access deleted path: {self._path}\"\n        return self._path\n\n    def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__} {self.path!r}>\"\n\n    def __enter__(self: _T) -> _T:\n        return self\n\n    def __exit__(self, exc: Any, value: Any, tb: Any) -> None:\n        if self.delete is not None:\n            delete = self.delete\n        elif _tempdir_registry:\n            delete = _tempdir_registry.get_delete(self.kind)\n        else:\n            delete = True\n\n        if delete:\n            self.cleanup()\n\n    def _create(self, kind: str) -> str:\n        \"\"\"Create a temporary directory and store its path in self.path\"\"\"\n        # We realpath here because some systems have their default tmpdir\n        # symlinked to another directory.  This tends to confuse build\n        # scripts, so we canonicalize the path by traversing potential\n        # symlinks here.\n        path = os.path.realpath(tempfile.mkdtemp(prefix=f\"pip-{kind}-\"))\n        logger.debug(\"Created temporary directory: %s\", path)\n        return path\n\n    def cleanup(self) -> None:\n        \"\"\"Remove the temporary directory created and reset state\"\"\"\n        self._deleted = True\n        if not os.path.exists(self._path):\n            return\n\n        errors: List[BaseException] = []\n\n        def onerror(\n            func: Callable[..., Any],\n            path: Path,\n            exc_val: BaseException,\n        ) -> None:\n            \"\"\"Log a warning for a `rmtree` error and continue\"\"\"\n            formatted_exc = \"\\n\".join(\n                traceback.format_exception_only(type(exc_val), exc_val)\n            )\n            formatted_exc = formatted_exc.rstrip()  # remove trailing new line\n            if func in (os.unlink, os.remove, os.rmdir):\n                logger.debug(\n                    \"Failed to remove a temporary file '%s' due to %s.\\n\",\n                    path,\n                    formatted_exc,\n                )\n            else:\n                logger.debug(\"%s failed with %s.\", func.__qualname__, formatted_exc)\n            errors.append(exc_val)\n\n        if self.ignore_cleanup_errors:\n            try:\n                # first try with tenacity; retrying to handle ephemeral errors\n                rmtree(self._path, ignore_errors=False)\n            except OSError:\n                # last pass ignore/log all errors\n                rmtree(self._path, onexc=onerror)\n            if errors:\n                logger.warning(\n                    \"Failed to remove contents in a temporary directory '%s'.\\n\"\n                    \"You can safely remove it manually.\",\n                    self._path,\n                )\n        else:\n            rmtree(self._path)\n\n\nclass AdjacentTempDirectory(TempDirectory):\n    \"\"\"Helper class that creates a temporary directory adjacent to a real one.\n\n    Attributes:\n        original\n            The original directory to create a temp directory for.\n        path\n            After calling create() or entering, contains the full\n            path to the temporary directory.\n        delete\n            Whether the directory should be deleted when exiting\n            (when used as a contextmanager)\n\n    \"\"\"\n\n    # The characters that may be used to name the temp directory\n    # We always prepend a ~ and then rotate through these until\n    # a usable name is found.\n    # pkg_resources raises a different error for .dist-info folder\n    # with leading '-' and invalid metadata\n    LEADING_CHARS = \"-~.=%0123456789\"\n\n    def __init__(self, original: str, delete: Optional[bool] = None) -> None:\n        self.original = original.rstrip(\"/\\\\\")\n        super().__init__(delete=delete)\n\n    @classmethod\n    def _generate_names(cls, name: str) -> Generator[str, None, None]:\n        \"\"\"Generates a series of temporary names.\n\n        The algorithm replaces the leading characters in the name\n        with ones that are valid filesystem characters, but are not\n        valid package names (for both Python and pip definitions of\n        package).\n        \"\"\"\n        for i in range(1, len(name)):\n            for candidate in itertools.combinations_with_replacement(\n                cls.LEADING_CHARS, i - 1\n            ):\n                new_name = \"~\" + \"\".join(candidate) + name[i:]\n                if new_name != name:\n                    yield new_name\n\n        # If we make it this far, we will have to make a longer name\n        for i in range(len(cls.LEADING_CHARS)):\n            for candidate in itertools.combinations_with_replacement(\n                cls.LEADING_CHARS, i\n            ):\n                new_name = \"~\" + \"\".join(candidate) + name\n                if new_name != name:\n                    yield new_name\n\n    def _create(self, kind: str) -> str:\n        root, name = os.path.split(self.original)\n        for candidate in self._generate_names(name):\n            path = os.path.join(root, candidate)\n            try:\n                os.mkdir(path)\n            except OSError as ex:\n                # Continue if the name exists already\n                if ex.errno != errno.EEXIST:\n                    raise\n            else:\n                path = os.path.realpath(path)\n                break\n        else:\n            # Final fallback on the default behavior.\n            path = os.path.realpath(tempfile.mkdtemp(prefix=f\"pip-{kind}-\"))\n\n        logger.debug(\"Created temporary directory: %s\", path)\n        return path\n"},"hash":"thvF9N0abd"}