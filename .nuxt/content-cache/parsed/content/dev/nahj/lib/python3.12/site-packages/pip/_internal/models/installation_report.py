{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:models:installation_report.py","body":"from typing import Any, Dict, Sequence\n\nfrom pip._vendor.packaging.markers import default_environment\n\nfrom pip import __version__\nfrom pip._internal.req.req_install import InstallRequirement\n\n\nclass InstallationReport:\n    def __init__(self, install_requirements: Sequence[InstallRequirement]):\n        self._install_requirements = install_requirements\n\n    @classmethod\n    def _install_req_to_dict(cls, ireq: InstallRequirement) -> Dict[str, Any]:\n        assert ireq.download_info, f\"No download_info for {ireq}\"\n        res = {\n            # PEP 610 json for the download URL. download_info.archive_info.hashes may\n            # be absent when the requirement was installed from the wheel cache\n            # and the cache entry was populated by an older pip version that did not\n            # record origin.json.\n            \"download_info\": ireq.download_info.to_dict(),\n            # is_direct is true if the requirement was a direct URL reference (which\n            # includes editable requirements), and false if the requirement was\n            # downloaded from a PEP 503 index or --find-links.\n            \"is_direct\": ireq.is_direct,\n            # is_yanked is true if the requirement was yanked from the index, but\n            # was still selected by pip to conform to PEP 592.\n            \"is_yanked\": ireq.link.is_yanked if ireq.link else False,\n            # requested is true if the requirement was specified by the user (aka\n            # top level requirement), and false if it was installed as a dependency of a\n            # requirement. https://peps.python.org/pep-0376/#requested\n            \"requested\": ireq.user_supplied,\n            # PEP 566 json encoding for metadata\n            # https://www.python.org/dev/peps/pep-0566/#json-compatible-metadata\n            \"metadata\": ireq.get_dist().metadata_dict,\n        }\n        if ireq.user_supplied and ireq.extras:\n            # For top level requirements, the list of requested extras, if any.\n            res[\"requested_extras\"] = sorted(ireq.extras)\n        return res\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"version\": \"1\",\n            \"pip_version\": __version__,\n            \"install\": [\n                self._install_req_to_dict(ireq) for ireq in self._install_requirements\n            ],\n            # https://peps.python.org/pep-0508/#environment-markers\n            # TODO: currently, the resolver uses the default environment to evaluate\n            # environment markers, so that is what we report here. In the future, it\n            # should also take into account options such as --python-version or\n            # --platform, perhaps under the form of an environment_override field?\n            # https://github.com/pypa/pip/issues/11198\n            \"environment\": default_environment(),\n        }\n"},"hash":"rzbN7JUovt"}