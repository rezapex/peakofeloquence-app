{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:truststore:_windows.py","body":"import contextlib\nimport ssl\nimport typing\nfrom ctypes import WinDLL  # type: ignore\nfrom ctypes import WinError  # type: ignore\nfrom ctypes import (\n    POINTER,\n    Structure,\n    c_char_p,\n    c_ulong,\n    c_void_p,\n    c_wchar_p,\n    cast,\n    create_unicode_buffer,\n    pointer,\n    sizeof,\n)\nfrom ctypes.wintypes import (\n    BOOL,\n    DWORD,\n    HANDLE,\n    LONG,\n    LPCSTR,\n    LPCVOID,\n    LPCWSTR,\n    LPFILETIME,\n    LPSTR,\n    LPWSTR,\n)\nfrom typing import TYPE_CHECKING, Any\n\nfrom ._ssl_constants import _set_ssl_context_verify_mode\n\nHCERTCHAINENGINE = HANDLE\nHCERTSTORE = HANDLE\nHCRYPTPROV_LEGACY = HANDLE\n\n\nclass CERT_CONTEXT(Structure):\n    _fields_ = (\n        (\"dwCertEncodingType\", DWORD),\n        (\"pbCertEncoded\", c_void_p),\n        (\"cbCertEncoded\", DWORD),\n        (\"pCertInfo\", c_void_p),\n        (\"hCertStore\", HCERTSTORE),\n    )\n\n\nPCERT_CONTEXT = POINTER(CERT_CONTEXT)\nPCCERT_CONTEXT = POINTER(PCERT_CONTEXT)\n\n\nclass CERT_ENHKEY_USAGE(Structure):\n    _fields_ = (\n        (\"cUsageIdentifier\", DWORD),\n        (\"rgpszUsageIdentifier\", POINTER(LPSTR)),\n    )\n\n\nPCERT_ENHKEY_USAGE = POINTER(CERT_ENHKEY_USAGE)\n\n\nclass CERT_USAGE_MATCH(Structure):\n    _fields_ = (\n        (\"dwType\", DWORD),\n        (\"Usage\", CERT_ENHKEY_USAGE),\n    )\n\n\nclass CERT_CHAIN_PARA(Structure):\n    _fields_ = (\n        (\"cbSize\", DWORD),\n        (\"RequestedUsage\", CERT_USAGE_MATCH),\n        (\"RequestedIssuancePolicy\", CERT_USAGE_MATCH),\n        (\"dwUrlRetrievalTimeout\", DWORD),\n        (\"fCheckRevocationFreshnessTime\", BOOL),\n        (\"dwRevocationFreshnessTime\", DWORD),\n        (\"pftCacheResync\", LPFILETIME),\n        (\"pStrongSignPara\", c_void_p),\n        (\"dwStrongSignFlags\", DWORD),\n    )\n\n\nif TYPE_CHECKING:\n    PCERT_CHAIN_PARA = pointer[CERT_CHAIN_PARA]  # type: ignore[misc]\nelse:\n    PCERT_CHAIN_PARA = POINTER(CERT_CHAIN_PARA)\n\n\nclass CERT_TRUST_STATUS(Structure):\n    _fields_ = (\n        (\"dwErrorStatus\", DWORD),\n        (\"dwInfoStatus\", DWORD),\n    )\n\n\nclass CERT_CHAIN_ELEMENT(Structure):\n    _fields_ = (\n        (\"cbSize\", DWORD),\n        (\"pCertContext\", PCERT_CONTEXT),\n        (\"TrustStatus\", CERT_TRUST_STATUS),\n        (\"pRevocationInfo\", c_void_p),\n        (\"pIssuanceUsage\", PCERT_ENHKEY_USAGE),\n        (\"pApplicationUsage\", PCERT_ENHKEY_USAGE),\n        (\"pwszExtendedErrorInfo\", LPCWSTR),\n    )\n\n\nPCERT_CHAIN_ELEMENT = POINTER(CERT_CHAIN_ELEMENT)\n\n\nclass CERT_SIMPLE_CHAIN(Structure):\n    _fields_ = (\n        (\"cbSize\", DWORD),\n        (\"TrustStatus\", CERT_TRUST_STATUS),\n        (\"cElement\", DWORD),\n        (\"rgpElement\", POINTER(PCERT_CHAIN_ELEMENT)),\n        (\"pTrustListInfo\", c_void_p),\n        (\"fHasRevocationFreshnessTime\", BOOL),\n        (\"dwRevocationFreshnessTime\", DWORD),\n    )\n\n\nPCERT_SIMPLE_CHAIN = POINTER(CERT_SIMPLE_CHAIN)\n\n\nclass CERT_CHAIN_CONTEXT(Structure):\n    _fields_ = (\n        (\"cbSize\", DWORD),\n        (\"TrustStatus\", CERT_TRUST_STATUS),\n        (\"cChain\", DWORD),\n        (\"rgpChain\", POINTER(PCERT_SIMPLE_CHAIN)),\n        (\"cLowerQualityChainContext\", DWORD),\n        (\"rgpLowerQualityChainContext\", c_void_p),\n        (\"fHasRevocationFreshnessTime\", BOOL),\n        (\"dwRevocationFreshnessTime\", DWORD),\n    )\n\n\nPCERT_CHAIN_CONTEXT = POINTER(CERT_CHAIN_CONTEXT)\nPCCERT_CHAIN_CONTEXT = POINTER(PCERT_CHAIN_CONTEXT)\n\n\nclass SSL_EXTRA_CERT_CHAIN_POLICY_PARA(Structure):\n    _fields_ = (\n        (\"cbSize\", DWORD),\n        (\"dwAuthType\", DWORD),\n        (\"fdwChecks\", DWORD),\n        (\"pwszServerName\", LPCWSTR),\n    )\n\n\nclass CERT_CHAIN_POLICY_PARA(Structure):\n    _fields_ = (\n        (\"cbSize\", DWORD),\n        (\"dwFlags\", DWORD),\n        (\"pvExtraPolicyPara\", c_void_p),\n    )\n\n\nPCERT_CHAIN_POLICY_PARA = POINTER(CERT_CHAIN_POLICY_PARA)\n\n\nclass CERT_CHAIN_POLICY_STATUS(Structure):\n    _fields_ = (\n        (\"cbSize\", DWORD),\n        (\"dwError\", DWORD),\n        (\"lChainIndex\", LONG),\n        (\"lElementIndex\", LONG),\n        (\"pvExtraPolicyStatus\", c_void_p),\n    )\n\n\nPCERT_CHAIN_POLICY_STATUS = POINTER(CERT_CHAIN_POLICY_STATUS)\n\n\nclass CERT_CHAIN_ENGINE_CONFIG(Structure):\n    _fields_ = (\n        (\"cbSize\", DWORD),\n        (\"hRestrictedRoot\", HCERTSTORE),\n        (\"hRestrictedTrust\", HCERTSTORE),\n        (\"hRestrictedOther\", HCERTSTORE),\n        (\"cAdditionalStore\", DWORD),\n        (\"rghAdditionalStore\", c_void_p),\n        (\"dwFlags\", DWORD),\n        (\"dwUrlRetrievalTimeout\", DWORD),\n        (\"MaximumCachedCertificates\", DWORD),\n        (\"CycleDetectionModulus\", DWORD),\n        (\"hExclusiveRoot\", HCERTSTORE),\n        (\"hExclusiveTrustedPeople\", HCERTSTORE),\n        (\"dwExclusiveFlags\", DWORD),\n    )\n\n\nPCERT_CHAIN_ENGINE_CONFIG = POINTER(CERT_CHAIN_ENGINE_CONFIG)\nPHCERTCHAINENGINE = POINTER(HCERTCHAINENGINE)\n\nX509_ASN_ENCODING = 0x00000001\nPKCS_7_ASN_ENCODING = 0x00010000\nCERT_STORE_PROV_MEMORY = b\"Memory\"\nCERT_STORE_ADD_USE_EXISTING = 2\nUSAGE_MATCH_TYPE_OR = 1\nOID_PKIX_KP_SERVER_AUTH = c_char_p(b\"1.3.6.1.5.5.7.3.1\")\nCERT_CHAIN_REVOCATION_CHECK_END_CERT = 0x10000000\nCERT_CHAIN_REVOCATION_CHECK_CHAIN = 0x20000000\nCERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS = 0x00000007\nCERT_CHAIN_POLICY_IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG = 0x00000008\nCERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG = 0x00000010\nCERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG = 0x00000040\nCERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG = 0x00000020\nCERT_CHAIN_POLICY_IGNORE_INVALID_POLICY_FLAG = 0x00000080\nCERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS = 0x00000F00\nCERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG = 0x00008000\nCERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG = 0x00004000\nAUTHTYPE_SERVER = 2\nCERT_CHAIN_POLICY_SSL = 4\nFORMAT_MESSAGE_FROM_SYSTEM = 0x00001000\nFORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200\n\n# Flags to set for SSLContext.verify_mode=CERT_NONE\nCERT_CHAIN_POLICY_VERIFY_MODE_NONE_FLAGS = (\n    CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS\n    | CERT_CHAIN_POLICY_IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG\n    | CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG\n    | CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG\n    | CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG\n    | CERT_CHAIN_POLICY_IGNORE_INVALID_POLICY_FLAG\n    | CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS\n    | CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG\n    | CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG\n)\n\nwincrypt = WinDLL(\"crypt32.dll\")\nkernel32 = WinDLL(\"kernel32.dll\")\n\n\ndef _handle_win_error(result: bool, _: Any, args: Any) -> Any:\n    if not result:\n        # Note, actually raises OSError after calling GetLastError and FormatMessage\n        raise WinError()\n    return args\n\n\nCertCreateCertificateChainEngine = wincrypt.CertCreateCertificateChainEngine\nCertCreateCertificateChainEngine.argtypes = (\n    PCERT_CHAIN_ENGINE_CONFIG,\n    PHCERTCHAINENGINE,\n)\nCertCreateCertificateChainEngine.errcheck = _handle_win_error\n\nCertOpenStore = wincrypt.CertOpenStore\nCertOpenStore.argtypes = (LPCSTR, DWORD, HCRYPTPROV_LEGACY, DWORD, c_void_p)\nCertOpenStore.restype = HCERTSTORE\nCertOpenStore.errcheck = _handle_win_error\n\nCertAddEncodedCertificateToStore = wincrypt.CertAddEncodedCertificateToStore\nCertAddEncodedCertificateToStore.argtypes = (\n    HCERTSTORE,\n    DWORD,\n    c_char_p,\n    DWORD,\n    DWORD,\n    PCCERT_CONTEXT,\n)\nCertAddEncodedCertificateToStore.restype = BOOL\n\nCertCreateCertificateContext = wincrypt.CertCreateCertificateContext\nCertCreateCertificateContext.argtypes = (DWORD, c_char_p, DWORD)\nCertCreateCertificateContext.restype = PCERT_CONTEXT\nCertCreateCertificateContext.errcheck = _handle_win_error\n\nCertGetCertificateChain = wincrypt.CertGetCertificateChain\nCertGetCertificateChain.argtypes = (\n    HCERTCHAINENGINE,\n    PCERT_CONTEXT,\n    LPFILETIME,\n    HCERTSTORE,\n    PCERT_CHAIN_PARA,\n    DWORD,\n    c_void_p,\n    PCCERT_CHAIN_CONTEXT,\n)\nCertGetCertificateChain.restype = BOOL\nCertGetCertificateChain.errcheck = _handle_win_error\n\nCertVerifyCertificateChainPolicy = wincrypt.CertVerifyCertificateChainPolicy\nCertVerifyCertificateChainPolicy.argtypes = (\n    c_ulong,\n    PCERT_CHAIN_CONTEXT,\n    PCERT_CHAIN_POLICY_PARA,\n    PCERT_CHAIN_POLICY_STATUS,\n)\nCertVerifyCertificateChainPolicy.restype = BOOL\n\nCertCloseStore = wincrypt.CertCloseStore\nCertCloseStore.argtypes = (HCERTSTORE, DWORD)\nCertCloseStore.restype = BOOL\nCertCloseStore.errcheck = _handle_win_error\n\nCertFreeCertificateChain = wincrypt.CertFreeCertificateChain\nCertFreeCertificateChain.argtypes = (PCERT_CHAIN_CONTEXT,)\n\nCertFreeCertificateContext = wincrypt.CertFreeCertificateContext\nCertFreeCertificateContext.argtypes = (PCERT_CONTEXT,)\n\nCertFreeCertificateChainEngine = wincrypt.CertFreeCertificateChainEngine\nCertFreeCertificateChainEngine.argtypes = (HCERTCHAINENGINE,)\n\nFormatMessageW = kernel32.FormatMessageW\nFormatMessageW.argtypes = (\n    DWORD,\n    LPCVOID,\n    DWORD,\n    DWORD,\n    LPWSTR,\n    DWORD,\n    c_void_p,\n)\nFormatMessageW.restype = DWORD\n\n\ndef _verify_peercerts_impl(\n    ssl_context: ssl.SSLContext,\n    cert_chain: list[bytes],\n    server_hostname: str | None = None,\n) -> None:\n    \"\"\"Verify the cert_chain from the server using Windows APIs.\"\"\"\n    pCertContext = None\n    hIntermediateCertStore = CertOpenStore(CERT_STORE_PROV_MEMORY, 0, None, 0, None)\n    try:\n        # Add intermediate certs to an in-memory cert store\n        for cert_bytes in cert_chain[1:]:\n            CertAddEncodedCertificateToStore(\n                hIntermediateCertStore,\n                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,\n                cert_bytes,\n                len(cert_bytes),\n                CERT_STORE_ADD_USE_EXISTING,\n                None,\n            )\n\n        # Cert context for leaf cert\n        leaf_cert = cert_chain[0]\n        pCertContext = CertCreateCertificateContext(\n            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, leaf_cert, len(leaf_cert)\n        )\n\n        # Chain params to match certs for serverAuth extended usage\n        cert_enhkey_usage = CERT_ENHKEY_USAGE()\n        cert_enhkey_usage.cUsageIdentifier = 1\n        cert_enhkey_usage.rgpszUsageIdentifier = (c_char_p * 1)(OID_PKIX_KP_SERVER_AUTH)\n        cert_usage_match = CERT_USAGE_MATCH()\n        cert_usage_match.Usage = cert_enhkey_usage\n        chain_params = CERT_CHAIN_PARA()\n        chain_params.RequestedUsage = cert_usage_match\n        chain_params.cbSize = sizeof(chain_params)\n        pChainPara = pointer(chain_params)\n\n        if ssl_context.verify_flags & ssl.VERIFY_CRL_CHECK_CHAIN:\n            chain_flags = CERT_CHAIN_REVOCATION_CHECK_CHAIN\n        elif ssl_context.verify_flags & ssl.VERIFY_CRL_CHECK_LEAF:\n            chain_flags = CERT_CHAIN_REVOCATION_CHECK_END_CERT\n        else:\n            chain_flags = 0\n\n        try:\n            # First attempt to verify using the default Windows system trust roots\n            # (default chain engine).\n            _get_and_verify_cert_chain(\n                ssl_context,\n                None,\n                hIntermediateCertStore,\n                pCertContext,\n                pChainPara,\n                server_hostname,\n                chain_flags=chain_flags,\n            )\n        except ssl.SSLCertVerificationError:\n            # If that fails but custom CA certs have been added\n            # to the SSLContext using load_verify_locations,\n            # try verifying using a custom chain engine\n            # that trusts the custom CA certs.\n            custom_ca_certs: list[bytes] | None = ssl_context.get_ca_certs(\n                binary_form=True\n            )\n            if custom_ca_certs:\n                _verify_using_custom_ca_certs(\n                    ssl_context,\n                    custom_ca_certs,\n                    hIntermediateCertStore,\n                    pCertContext,\n                    pChainPara,\n                    server_hostname,\n                    chain_flags=chain_flags,\n                )\n            else:\n                raise\n    finally:\n        CertCloseStore(hIntermediateCertStore, 0)\n        if pCertContext:\n            CertFreeCertificateContext(pCertContext)\n\n\ndef _get_and_verify_cert_chain(\n    ssl_context: ssl.SSLContext,\n    hChainEngine: HCERTCHAINENGINE | None,\n    hIntermediateCertStore: HCERTSTORE,\n    pPeerCertContext: c_void_p,\n    pChainPara: PCERT_CHAIN_PARA,  # type: ignore[valid-type]\n    server_hostname: str | None,\n    chain_flags: int,\n) -> None:\n    ppChainContext = None\n    try:\n        # Get cert chain\n        ppChainContext = pointer(PCERT_CHAIN_CONTEXT())\n        CertGetCertificateChain(\n            hChainEngine,  # chain engine\n            pPeerCertContext,  # leaf cert context\n            None,  # current system time\n            hIntermediateCertStore,  # additional in-memory cert store\n            pChainPara,  # chain-building parameters\n            chain_flags,\n            None,  # reserved\n            ppChainContext,  # the resulting chain context\n        )\n        pChainContext = ppChainContext.contents\n\n        # Verify cert chain\n        ssl_extra_cert_chain_policy_para = SSL_EXTRA_CERT_CHAIN_POLICY_PARA()\n        ssl_extra_cert_chain_policy_para.cbSize = sizeof(\n            ssl_extra_cert_chain_policy_para\n        )\n        ssl_extra_cert_chain_policy_para.dwAuthType = AUTHTYPE_SERVER\n        ssl_extra_cert_chain_policy_para.fdwChecks = 0\n        if server_hostname:\n            ssl_extra_cert_chain_policy_para.pwszServerName = c_wchar_p(server_hostname)\n\n        chain_policy = CERT_CHAIN_POLICY_PARA()\n        chain_policy.pvExtraPolicyPara = cast(\n            pointer(ssl_extra_cert_chain_policy_para), c_void_p\n        )\n        if ssl_context.verify_mode == ssl.CERT_NONE:\n            chain_policy.dwFlags |= CERT_CHAIN_POLICY_VERIFY_MODE_NONE_FLAGS\n        if not ssl_context.check_hostname:\n            chain_policy.dwFlags |= CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG\n        chain_policy.cbSize = sizeof(chain_policy)\n\n        pPolicyPara = pointer(chain_policy)\n        policy_status = CERT_CHAIN_POLICY_STATUS()\n        policy_status.cbSize = sizeof(policy_status)\n        pPolicyStatus = pointer(policy_status)\n        CertVerifyCertificateChainPolicy(\n            CERT_CHAIN_POLICY_SSL,\n            pChainContext,\n            pPolicyPara,\n            pPolicyStatus,\n        )\n\n        # Check status\n        error_code = policy_status.dwError\n        if error_code:\n            # Try getting a human readable message for an error code.\n            error_message_buf = create_unicode_buffer(1024)\n            error_message_chars = FormatMessageW(\n                FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n                None,\n                error_code,\n                0,\n                error_message_buf,\n                sizeof(error_message_buf),\n                None,\n            )\n\n            # See if we received a message for the error,\n            # otherwise we use a generic error with the\n            # error code and hope that it's search-able.\n            if error_message_chars <= 0:\n                error_message = f\"Certificate chain policy error {error_code:#x} [{policy_status.lElementIndex}]\"\n            else:\n                error_message = error_message_buf.value.strip()\n\n            err = ssl.SSLCertVerificationError(error_message)\n            err.verify_message = error_message\n            err.verify_code = error_code\n            raise err from None\n    finally:\n        if ppChainContext:\n            CertFreeCertificateChain(ppChainContext.contents)\n\n\ndef _verify_using_custom_ca_certs(\n    ssl_context: ssl.SSLContext,\n    custom_ca_certs: list[bytes],\n    hIntermediateCertStore: HCERTSTORE,\n    pPeerCertContext: c_void_p,\n    pChainPara: PCERT_CHAIN_PARA,  # type: ignore[valid-type]\n    server_hostname: str | None,\n    chain_flags: int,\n) -> None:\n    hChainEngine = None\n    hRootCertStore = CertOpenStore(CERT_STORE_PROV_MEMORY, 0, None, 0, None)\n    try:\n        # Add custom CA certs to an in-memory cert store\n        for cert_bytes in custom_ca_certs:\n            CertAddEncodedCertificateToStore(\n                hRootCertStore,\n                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,\n                cert_bytes,\n                len(cert_bytes),\n                CERT_STORE_ADD_USE_EXISTING,\n                None,\n            )\n\n        # Create a custom cert chain engine which exclusively trusts\n        # certs from our hRootCertStore\n        cert_chain_engine_config = CERT_CHAIN_ENGINE_CONFIG()\n        cert_chain_engine_config.cbSize = sizeof(cert_chain_engine_config)\n        cert_chain_engine_config.hExclusiveRoot = hRootCertStore\n        pConfig = pointer(cert_chain_engine_config)\n        phChainEngine = pointer(HCERTCHAINENGINE())\n        CertCreateCertificateChainEngine(\n            pConfig,\n            phChainEngine,\n        )\n        hChainEngine = phChainEngine.contents\n\n        # Get and verify a cert chain using the custom chain engine\n        _get_and_verify_cert_chain(\n            ssl_context,\n            hChainEngine,\n            hIntermediateCertStore,\n            pPeerCertContext,\n            pChainPara,\n            server_hostname,\n            chain_flags,\n        )\n    finally:\n        if hChainEngine:\n            CertFreeCertificateChainEngine(hChainEngine)\n        CertCloseStore(hRootCertStore, 0)\n\n\n@contextlib.contextmanager\ndef _configure_context(ctx: ssl.SSLContext) -> typing.Iterator[None]:\n    check_hostname = ctx.check_hostname\n    verify_mode = ctx.verify_mode\n    ctx.check_hostname = False\n    _set_ssl_context_verify_mode(ctx, ssl.CERT_NONE)\n    try:\n        yield\n    finally:\n        ctx.check_hostname = check_hostname\n        _set_ssl_context_verify_mode(ctx, verify_mode)\n"},"hash":"JOp7p8p5ZO"}