{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:pyparsing:testing.py","body":"# testing.py\n\nfrom contextlib import contextmanager\nimport typing\n\nfrom .core import (\n    ParserElement,\n    ParseException,\n    Keyword,\n    __diag__,\n    __compat__,\n)\n\n\nclass pyparsing_test:\n    \"\"\"\n    namespace class for classes useful in writing unit tests\n    \"\"\"\n\n    class reset_pyparsing_context:\n        \"\"\"\n        Context manager to be used when writing unit tests that modify pyparsing config values:\n        - packrat parsing\n        - bounded recursion parsing\n        - default whitespace characters.\n        - default keyword characters\n        - literal string auto-conversion class\n        - __diag__ settings\n\n        Example::\n\n            with reset_pyparsing_context():\n                # test that literals used to construct a grammar are automatically suppressed\n                ParserElement.inlineLiteralsUsing(Suppress)\n\n                term = Word(alphas) | Word(nums)\n                group = Group('(' + term[...] + ')')\n\n                # assert that the '()' characters are not included in the parsed tokens\n                self.assertParseAndCheckList(group, \"(abc 123 def)\", ['abc', '123', 'def'])\n\n            # after exiting context manager, literals are converted to Literal expressions again\n        \"\"\"\n\n        def __init__(self):\n            self._save_context = {}\n\n        def save(self):\n            self._save_context[\"default_whitespace\"] = ParserElement.DEFAULT_WHITE_CHARS\n            self._save_context[\"default_keyword_chars\"] = Keyword.DEFAULT_KEYWORD_CHARS\n\n            self._save_context[\n                \"literal_string_class\"\n            ] = ParserElement._literalStringClass\n\n            self._save_context[\"verbose_stacktrace\"] = ParserElement.verbose_stacktrace\n\n            self._save_context[\"packrat_enabled\"] = ParserElement._packratEnabled\n            if ParserElement._packratEnabled:\n                self._save_context[\n                    \"packrat_cache_size\"\n                ] = ParserElement.packrat_cache.size\n            else:\n                self._save_context[\"packrat_cache_size\"] = None\n            self._save_context[\"packrat_parse\"] = ParserElement._parse\n            self._save_context[\n                \"recursion_enabled\"\n            ] = ParserElement._left_recursion_enabled\n\n            self._save_context[\"__diag__\"] = {\n                name: getattr(__diag__, name) for name in __diag__._all_names\n            }\n\n            self._save_context[\"__compat__\"] = {\n                \"collect_all_And_tokens\": __compat__.collect_all_And_tokens\n            }\n\n            return self\n\n        def restore(self):\n            # reset pyparsing global state\n            if (\n                ParserElement.DEFAULT_WHITE_CHARS\n                != self._save_context[\"default_whitespace\"]\n            ):\n                ParserElement.set_default_whitespace_chars(\n                    self._save_context[\"default_whitespace\"]\n                )\n\n            ParserElement.verbose_stacktrace = self._save_context[\"verbose_stacktrace\"]\n\n            Keyword.DEFAULT_KEYWORD_CHARS = self._save_context[\"default_keyword_chars\"]\n            ParserElement.inlineLiteralsUsing(\n                self._save_context[\"literal_string_class\"]\n            )\n\n            for name, value in self._save_context[\"__diag__\"].items():\n                (__diag__.enable if value else __diag__.disable)(name)\n\n            ParserElement._packratEnabled = False\n            if self._save_context[\"packrat_enabled\"]:\n                ParserElement.enable_packrat(self._save_context[\"packrat_cache_size\"])\n            else:\n                ParserElement._parse = self._save_context[\"packrat_parse\"]\n            ParserElement._left_recursion_enabled = self._save_context[\n                \"recursion_enabled\"\n            ]\n\n            __compat__.collect_all_And_tokens = self._save_context[\"__compat__\"]\n\n            return self\n\n        def copy(self):\n            ret = type(self)()\n            ret._save_context.update(self._save_context)\n            return ret\n\n        def __enter__(self):\n            return self.save()\n\n        def __exit__(self, *args):\n            self.restore()\n\n    class TestParseResultsAsserts:\n        \"\"\"\n        A mixin class to add parse results assertion methods to normal unittest.TestCase classes.\n        \"\"\"\n\n        def assertParseResultsEquals(\n            self, result, expected_list=None, expected_dict=None, msg=None\n        ):\n            \"\"\"\n            Unit test assertion to compare a :class:`ParseResults` object with an optional ``expected_list``,\n            and compare any defined results names with an optional ``expected_dict``.\n            \"\"\"\n            if expected_list is not None:\n                self.assertEqual(expected_list, result.as_list(), msg=msg)\n            if expected_dict is not None:\n                self.assertEqual(expected_dict, result.as_dict(), msg=msg)\n\n        def assertParseAndCheckList(\n            self, expr, test_string, expected_list, msg=None, verbose=True\n        ):\n            \"\"\"\n            Convenience wrapper assert to test a parser element and input string, and assert that\n            the resulting ``ParseResults.asList()`` is equal to the ``expected_list``.\n            \"\"\"\n            result = expr.parse_string(test_string, parse_all=True)\n            if verbose:\n                print(result.dump())\n            else:\n                print(result.as_list())\n            self.assertParseResultsEquals(result, expected_list=expected_list, msg=msg)\n\n        def assertParseAndCheckDict(\n            self, expr, test_string, expected_dict, msg=None, verbose=True\n        ):\n            \"\"\"\n            Convenience wrapper assert to test a parser element and input string, and assert that\n            the resulting ``ParseResults.asDict()`` is equal to the ``expected_dict``.\n            \"\"\"\n            result = expr.parse_string(test_string, parseAll=True)\n            if verbose:\n                print(result.dump())\n            else:\n                print(result.as_list())\n            self.assertParseResultsEquals(result, expected_dict=expected_dict, msg=msg)\n\n        def assertRunTestResults(\n            self, run_tests_report, expected_parse_results=None, msg=None\n        ):\n            \"\"\"\n            Unit test assertion to evaluate output of ``ParserElement.runTests()``. If a list of\n            list-dict tuples is given as the ``expected_parse_results`` argument, then these are zipped\n            with the report tuples returned by ``runTests`` and evaluated using ``assertParseResultsEquals``.\n            Finally, asserts that the overall ``runTests()`` success value is ``True``.\n\n            :param run_tests_report: tuple(bool, [tuple(str, ParseResults or Exception)]) returned from runTests\n            :param expected_parse_results (optional): [tuple(str, list, dict, Exception)]\n            \"\"\"\n            run_test_success, run_test_results = run_tests_report\n\n            if expected_parse_results is not None:\n                merged = [\n                    (*rpt, expected)\n                    for rpt, expected in zip(run_test_results, expected_parse_results)\n                ]\n                for test_string, result, expected in merged:\n                    # expected should be a tuple containing a list and/or a dict or an exception,\n                    # and optional failure message string\n                    # an empty tuple will skip any result validation\n                    fail_msg = next(\n                        (exp for exp in expected if isinstance(exp, str)), None\n                    )\n                    expected_exception = next(\n                        (\n                            exp\n                            for exp in expected\n                            if isinstance(exp, type) and issubclass(exp, Exception)\n                        ),\n                        None,\n                    )\n                    if expected_exception is not None:\n                        with self.assertRaises(\n                            expected_exception=expected_exception, msg=fail_msg or msg\n                        ):\n                            if isinstance(result, Exception):\n                                raise result\n                    else:\n                        expected_list = next(\n                            (exp for exp in expected if isinstance(exp, list)), None\n                        )\n                        expected_dict = next(\n                            (exp for exp in expected if isinstance(exp, dict)), None\n                        )\n                        if (expected_list, expected_dict) != (None, None):\n                            self.assertParseResultsEquals(\n                                result,\n                                expected_list=expected_list,\n                                expected_dict=expected_dict,\n                                msg=fail_msg or msg,\n                            )\n                        else:\n                            # warning here maybe?\n                            print(f\"no validation for {test_string!r}\")\n\n            # do this last, in case some specific test results can be reported instead\n            self.assertTrue(\n                run_test_success, msg=msg if msg is not None else \"failed runTests\"\n            )\n\n        @contextmanager\n        def assertRaisesParseException(self, exc_type=ParseException, msg=None):\n            with self.assertRaises(exc_type, msg=msg):\n                yield\n\n    @staticmethod\n    def with_line_numbers(\n        s: str,\n        start_line: typing.Optional[int] = None,\n        end_line: typing.Optional[int] = None,\n        expand_tabs: bool = True,\n        eol_mark: str = \"|\",\n        mark_spaces: typing.Optional[str] = None,\n        mark_control: typing.Optional[str] = None,\n    ) -> str:\n        \"\"\"\n        Helpful method for debugging a parser - prints a string with line and column numbers.\n        (Line and column numbers are 1-based.)\n\n        :param s: tuple(bool, str - string to be printed with line and column numbers\n        :param start_line: int - (optional) starting line number in s to print (default=1)\n        :param end_line: int - (optional) ending line number in s to print (default=len(s))\n        :param expand_tabs: bool - (optional) expand tabs to spaces, to match the pyparsing default\n        :param eol_mark: str - (optional) string to mark the end of lines, helps visualize trailing spaces (default=\"|\")\n        :param mark_spaces: str - (optional) special character to display in place of spaces\n        :param mark_control: str - (optional) convert non-printing control characters to a placeholding\n                                 character; valid values:\n                                 - \"unicode\" - replaces control chars with Unicode symbols, such as \"␍\" and \"␊\"\n                                 - any single character string - replace control characters with given string\n                                 - None (default) - string is displayed as-is\n\n        :return: str - input string with leading line numbers and column number headers\n        \"\"\"\n        if expand_tabs:\n            s = s.expandtabs()\n        if mark_control is not None:\n            mark_control = typing.cast(str, mark_control)\n            if mark_control == \"unicode\":\n                transtable_map = {\n                    c: u for c, u in zip(range(0, 33), range(0x2400, 0x2433))\n                }\n                transtable_map[127] = 0x2421\n                tbl = str.maketrans(transtable_map)\n                eol_mark = \"\"\n            else:\n                ord_mark_control = ord(mark_control)\n                tbl = str.maketrans(\n                    {c: ord_mark_control for c in list(range(0, 32)) + [127]}\n                )\n            s = s.translate(tbl)\n        if mark_spaces is not None and mark_spaces != \" \":\n            if mark_spaces == \"unicode\":\n                tbl = str.maketrans({9: 0x2409, 32: 0x2423})\n                s = s.translate(tbl)\n            else:\n                s = s.replace(\" \", mark_spaces)\n        if start_line is None:\n            start_line = 1\n        if end_line is None:\n            end_line = len(s)\n        end_line = min(end_line, len(s))\n        start_line = min(max(1, start_line), end_line)\n\n        if mark_control != \"unicode\":\n            s_lines = s.splitlines()[start_line - 1 : end_line]\n        else:\n            s_lines = [line + \"␊\" for line in s.split(\"␊\")[start_line - 1 : end_line]]\n        if not s_lines:\n            return \"\"\n\n        lineno_width = len(str(end_line))\n        max_line_len = max(len(line) for line in s_lines)\n        lead = \" \" * (lineno_width + 1)\n        if max_line_len >= 99:\n            header0 = (\n                lead\n                + \"\".join(\n                    f\"{' ' * 99}{(i + 1) % 100}\"\n                    for i in range(max(max_line_len // 100, 1))\n                )\n                + \"\\n\"\n            )\n        else:\n            header0 = \"\"\n        header1 = (\n            header0\n            + lead\n            + \"\".join(f\"         {(i + 1) % 10}\" for i in range(-(-max_line_len // 10)))\n            + \"\\n\"\n        )\n        header2 = lead + \"1234567890\" * (-(-max_line_len // 10)) + \"\\n\"\n        return (\n            header1\n            + header2\n            + \"\\n\".join(\n                f\"{i:{lineno_width}d}:{line}{eol_mark}\"\n                for i, line in enumerate(s_lines, start=start_line)\n            )\n            + \"\\n\"\n        )\n"},"hash":"UG8tHM1gqx"}