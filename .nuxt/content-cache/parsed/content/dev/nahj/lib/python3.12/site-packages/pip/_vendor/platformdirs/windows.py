{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:platformdirs:windows.py","body":"\"\"\"Windows.\"\"\"\nfrom __future__ import annotations\n\nimport ctypes\nimport os\nimport sys\nfrom functools import lru_cache\nfrom typing import TYPE_CHECKING\n\nfrom .api import PlatformDirsABC\n\nif TYPE_CHECKING:\n    from collections.abc import Callable\n\n\nclass Windows(PlatformDirsABC):\n    \"\"\"\n    `MSDN on where to store app data files\n    <http://support.microsoft.com/default.aspx?scid=kb;en-us;310294#XSLTH3194121123120121120120>`_.\n    Makes use of the\n    `appname <platformdirs.api.PlatformDirsABC.appname>`,\n    `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`,\n    `version <platformdirs.api.PlatformDirsABC.version>`,\n    `roaming <platformdirs.api.PlatformDirsABC.roaming>`,\n    `opinion <platformdirs.api.PlatformDirsABC.opinion>`,\n    `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    \"\"\"\n\n    @property\n    def user_data_dir(self) -> str:\n        \"\"\"\n        :return: data directory tied to the user, e.g.\n         ``%USERPROFILE%\\\\AppData\\\\Local\\\\$appauthor\\\\$appname`` (not roaming) or\n         ``%USERPROFILE%\\\\AppData\\\\Roaming\\\\$appauthor\\\\$appname`` (roaming)\n        \"\"\"\n        const = \"CSIDL_APPDATA\" if self.roaming else \"CSIDL_LOCAL_APPDATA\"\n        path = os.path.normpath(get_win_folder(const))\n        return self._append_parts(path)\n\n    def _append_parts(self, path: str, *, opinion_value: str | None = None) -> str:\n        params = []\n        if self.appname:\n            if self.appauthor is not False:\n                author = self.appauthor or self.appname\n                params.append(author)\n            params.append(self.appname)\n            if opinion_value is not None and self.opinion:\n                params.append(opinion_value)\n            if self.version:\n                params.append(self.version)\n        path = os.path.join(path, *params)  # noqa: PTH118\n        self._optionally_create_directory(path)\n        return path\n\n    @property\n    def site_data_dir(self) -> str:\n        \"\"\":return: data directory shared by users, e.g. ``C:\\\\ProgramData\\\\$appauthor\\\\$appname``\"\"\"\n        path = os.path.normpath(get_win_folder(\"CSIDL_COMMON_APPDATA\"))\n        return self._append_parts(path)\n\n    @property\n    def user_config_dir(self) -> str:\n        \"\"\":return: config directory tied to the user, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def site_config_dir(self) -> str:\n        \"\"\":return: config directory shared by the users, same as `site_data_dir`\"\"\"\n        return self.site_data_dir\n\n    @property\n    def user_cache_dir(self) -> str:\n        \"\"\"\n        :return: cache directory tied to the user (if opinionated with ``Cache`` folder within ``$appname``) e.g.\n         ``%USERPROFILE%\\\\AppData\\\\Local\\\\$appauthor\\\\$appname\\\\Cache\\\\$version``\n        \"\"\"\n        path = os.path.normpath(get_win_folder(\"CSIDL_LOCAL_APPDATA\"))\n        return self._append_parts(path, opinion_value=\"Cache\")\n\n    @property\n    def site_cache_dir(self) -> str:\n        \"\"\":return: cache directory shared by users, e.g. ``C:\\\\ProgramData\\\\$appauthor\\\\$appname\\\\Cache\\\\$version``\"\"\"\n        path = os.path.normpath(get_win_folder(\"CSIDL_COMMON_APPDATA\"))\n        return self._append_parts(path, opinion_value=\"Cache\")\n\n    @property\n    def user_state_dir(self) -> str:\n        \"\"\":return: state directory tied to the user, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def user_log_dir(self) -> str:\n        \"\"\":return: log directory tied to the user, same as `user_data_dir` if not opinionated else ``Logs`` in it\"\"\"\n        path = self.user_data_dir\n        if self.opinion:\n            path = os.path.join(path, \"Logs\")  # noqa: PTH118\n            self._optionally_create_directory(path)\n        return path\n\n    @property\n    def user_documents_dir(self) -> str:\n        \"\"\":return: documents directory tied to the user e.g. ``%USERPROFILE%\\\\Documents``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_PERSONAL\"))\n\n    @property\n    def user_downloads_dir(self) -> str:\n        \"\"\":return: downloads directory tied to the user e.g. ``%USERPROFILE%\\\\Downloads``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_DOWNLOADS\"))\n\n    @property\n    def user_pictures_dir(self) -> str:\n        \"\"\":return: pictures directory tied to the user e.g. ``%USERPROFILE%\\\\Pictures``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_MYPICTURES\"))\n\n    @property\n    def user_videos_dir(self) -> str:\n        \"\"\":return: videos directory tied to the user e.g. ``%USERPROFILE%\\\\Videos``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_MYVIDEO\"))\n\n    @property\n    def user_music_dir(self) -> str:\n        \"\"\":return: music directory tied to the user e.g. ``%USERPROFILE%\\\\Music``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_MYMUSIC\"))\n\n    @property\n    def user_runtime_dir(self) -> str:\n        \"\"\"\n        :return: runtime directory tied to the user, e.g.\n         ``%USERPROFILE%\\\\AppData\\\\Local\\\\Temp\\\\$appauthor\\\\$appname``\n        \"\"\"\n        path = os.path.normpath(os.path.join(get_win_folder(\"CSIDL_LOCAL_APPDATA\"), \"Temp\"))  # noqa: PTH118\n        return self._append_parts(path)\n\n\ndef get_win_folder_from_env_vars(csidl_name: str) -> str:\n    \"\"\"Get folder from environment variables.\"\"\"\n    result = get_win_folder_if_csidl_name_not_env_var(csidl_name)\n    if result is not None:\n        return result\n\n    env_var_name = {\n        \"CSIDL_APPDATA\": \"APPDATA\",\n        \"CSIDL_COMMON_APPDATA\": \"ALLUSERSPROFILE\",\n        \"CSIDL_LOCAL_APPDATA\": \"LOCALAPPDATA\",\n    }.get(csidl_name)\n    if env_var_name is None:\n        msg = f\"Unknown CSIDL name: {csidl_name}\"\n        raise ValueError(msg)\n    result = os.environ.get(env_var_name)\n    if result is None:\n        msg = f\"Unset environment variable: {env_var_name}\"\n        raise ValueError(msg)\n    return result\n\n\ndef get_win_folder_if_csidl_name_not_env_var(csidl_name: str) -> str | None:\n    \"\"\"Get folder for a CSIDL name that does not exist as an environment variable.\"\"\"\n    if csidl_name == \"CSIDL_PERSONAL\":\n        return os.path.join(os.path.normpath(os.environ[\"USERPROFILE\"]), \"Documents\")  # noqa: PTH118\n\n    if csidl_name == \"CSIDL_DOWNLOADS\":\n        return os.path.join(os.path.normpath(os.environ[\"USERPROFILE\"]), \"Downloads\")  # noqa: PTH118\n\n    if csidl_name == \"CSIDL_MYPICTURES\":\n        return os.path.join(os.path.normpath(os.environ[\"USERPROFILE\"]), \"Pictures\")  # noqa: PTH118\n\n    if csidl_name == \"CSIDL_MYVIDEO\":\n        return os.path.join(os.path.normpath(os.environ[\"USERPROFILE\"]), \"Videos\")  # noqa: PTH118\n\n    if csidl_name == \"CSIDL_MYMUSIC\":\n        return os.path.join(os.path.normpath(os.environ[\"USERPROFILE\"]), \"Music\")  # noqa: PTH118\n    return None\n\n\ndef get_win_folder_from_registry(csidl_name: str) -> str:\n    \"\"\"\n    Get folder from the registry.\n\n    This is a fallback technique at best. I'm not sure if using the registry for these guarantees us the correct answer\n    for all CSIDL_* names.\n    \"\"\"\n    shell_folder_name = {\n        \"CSIDL_APPDATA\": \"AppData\",\n        \"CSIDL_COMMON_APPDATA\": \"Common AppData\",\n        \"CSIDL_LOCAL_APPDATA\": \"Local AppData\",\n        \"CSIDL_PERSONAL\": \"Personal\",\n        \"CSIDL_DOWNLOADS\": \"{374DE290-123F-4565-9164-39C4925E467B}\",\n        \"CSIDL_MYPICTURES\": \"My Pictures\",\n        \"CSIDL_MYVIDEO\": \"My Video\",\n        \"CSIDL_MYMUSIC\": \"My Music\",\n    }.get(csidl_name)\n    if shell_folder_name is None:\n        msg = f\"Unknown CSIDL name: {csidl_name}\"\n        raise ValueError(msg)\n    if sys.platform != \"win32\":  # only needed for mypy type checker to know that this code runs only on Windows\n        raise NotImplementedError\n    import winreg\n\n    key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r\"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\")\n    directory, _ = winreg.QueryValueEx(key, shell_folder_name)\n    return str(directory)\n\n\ndef get_win_folder_via_ctypes(csidl_name: str) -> str:\n    \"\"\"Get folder with ctypes.\"\"\"\n    # There is no 'CSIDL_DOWNLOADS'.\n    # Use 'CSIDL_PROFILE' (40) and append the default folder 'Downloads' instead.\n    # https://learn.microsoft.com/en-us/windows/win32/shell/knownfolderid\n\n    csidl_const = {\n        \"CSIDL_APPDATA\": 26,\n        \"CSIDL_COMMON_APPDATA\": 35,\n        \"CSIDL_LOCAL_APPDATA\": 28,\n        \"CSIDL_PERSONAL\": 5,\n        \"CSIDL_MYPICTURES\": 39,\n        \"CSIDL_MYVIDEO\": 14,\n        \"CSIDL_MYMUSIC\": 13,\n        \"CSIDL_DOWNLOADS\": 40,\n    }.get(csidl_name)\n    if csidl_const is None:\n        msg = f\"Unknown CSIDL name: {csidl_name}\"\n        raise ValueError(msg)\n\n    buf = ctypes.create_unicode_buffer(1024)\n    windll = getattr(ctypes, \"windll\")  # noqa: B009 # using getattr to avoid false positive with mypy type checker\n    windll.shell32.SHGetFolderPathW(None, csidl_const, None, 0, buf)\n\n    # Downgrade to short path name if it has highbit chars.\n    if any(ord(c) > 255 for c in buf):  # noqa: PLR2004\n        buf2 = ctypes.create_unicode_buffer(1024)\n        if windll.kernel32.GetShortPathNameW(buf.value, buf2, 1024):\n            buf = buf2\n\n    if csidl_name == \"CSIDL_DOWNLOADS\":\n        return os.path.join(buf.value, \"Downloads\")  # noqa: PTH118\n\n    return buf.value\n\n\ndef _pick_get_win_folder() -> Callable[[str], str]:\n    if hasattr(ctypes, \"windll\"):\n        return get_win_folder_via_ctypes\n    try:\n        import winreg  # noqa: F401\n    except ImportError:\n        return get_win_folder_from_env_vars\n    else:\n        return get_win_folder_from_registry\n\n\nget_win_folder = lru_cache(maxsize=None)(_pick_get_win_folder())\n\n__all__ = [\n    \"Windows\",\n]\n"},"hash":"We7VJzADY5"}