{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:cli:base_command.py","body":"\"\"\"Base Command class, and related routines\"\"\"\n\nimport functools\nimport logging\nimport logging.config\nimport optparse\nimport os\nimport sys\nimport traceback\nfrom optparse import Values\nfrom typing import Any, Callable, List, Optional, Tuple\n\nfrom pip._vendor.rich import traceback as rich_traceback\n\nfrom pip._internal.cli import cmdoptions\nfrom pip._internal.cli.command_context import CommandContextMixIn\nfrom pip._internal.cli.parser import ConfigOptionParser, UpdatingDefaultsHelpFormatter\nfrom pip._internal.cli.status_codes import (\n    ERROR,\n    PREVIOUS_BUILD_DIR_ERROR,\n    UNKNOWN_ERROR,\n    VIRTUALENV_NOT_FOUND,\n)\nfrom pip._internal.exceptions import (\n    BadCommand,\n    CommandError,\n    DiagnosticPipError,\n    InstallationError,\n    NetworkConnectionError,\n    PreviousBuildDirError,\n    UninstallationError,\n)\nfrom pip._internal.utils.filesystem import check_path_owner\nfrom pip._internal.utils.logging import BrokenStdoutLoggingError, setup_logging\nfrom pip._internal.utils.misc import get_prog, normalize_path\nfrom pip._internal.utils.temp_dir import TempDirectoryTypeRegistry as TempDirRegistry\nfrom pip._internal.utils.temp_dir import global_tempdir_manager, tempdir_registry\nfrom pip._internal.utils.virtualenv import running_under_virtualenv\n\n__all__ = [\"Command\"]\n\nlogger = logging.getLogger(__name__)\n\n\nclass Command(CommandContextMixIn):\n    usage: str = \"\"\n    ignore_require_venv: bool = False\n\n    def __init__(self, name: str, summary: str, isolated: bool = False) -> None:\n        super().__init__()\n\n        self.name = name\n        self.summary = summary\n        self.parser = ConfigOptionParser(\n            usage=self.usage,\n            prog=f\"{get_prog()} {name}\",\n            formatter=UpdatingDefaultsHelpFormatter(),\n            add_help_option=False,\n            name=name,\n            description=self.__doc__,\n            isolated=isolated,\n        )\n\n        self.tempdir_registry: Optional[TempDirRegistry] = None\n\n        # Commands should add options to this option group\n        optgroup_name = f\"{self.name.capitalize()} Options\"\n        self.cmd_opts = optparse.OptionGroup(self.parser, optgroup_name)\n\n        # Add the general options\n        gen_opts = cmdoptions.make_option_group(\n            cmdoptions.general_group,\n            self.parser,\n        )\n        self.parser.add_option_group(gen_opts)\n\n        self.add_options()\n\n    def add_options(self) -> None:\n        pass\n\n    def handle_pip_version_check(self, options: Values) -> None:\n        \"\"\"\n        This is a no-op so that commands by default do not do the pip version\n        check.\n        \"\"\"\n        # Make sure we do the pip version check if the index_group options\n        # are present.\n        assert not hasattr(options, \"no_index\")\n\n    def run(self, options: Values, args: List[str]) -> int:\n        raise NotImplementedError\n\n    def parse_args(self, args: List[str]) -> Tuple[Values, List[str]]:\n        # factored out for testability\n        return self.parser.parse_args(args)\n\n    def main(self, args: List[str]) -> int:\n        try:\n            with self.main_context():\n                return self._main(args)\n        finally:\n            logging.shutdown()\n\n    def _main(self, args: List[str]) -> int:\n        # We must initialize this before the tempdir manager, otherwise the\n        # configuration would not be accessible by the time we clean up the\n        # tempdir manager.\n        self.tempdir_registry = self.enter_context(tempdir_registry())\n        # Intentionally set as early as possible so globally-managed temporary\n        # directories are available to the rest of the code.\n        self.enter_context(global_tempdir_manager())\n\n        options, args = self.parse_args(args)\n\n        # Set verbosity so that it can be used elsewhere.\n        self.verbosity = options.verbose - options.quiet\n\n        level_number = setup_logging(\n            verbosity=self.verbosity,\n            no_color=options.no_color,\n            user_log_file=options.log,\n        )\n\n        always_enabled_features = set(options.features_enabled) & set(\n            cmdoptions.ALWAYS_ENABLED_FEATURES\n        )\n        if always_enabled_features:\n            logger.warning(\n                \"The following features are always enabled: %s. \",\n                \", \".join(sorted(always_enabled_features)),\n            )\n\n        # Make sure that the --python argument isn't specified after the\n        # subcommand. We can tell, because if --python was specified,\n        # we should only reach this point if we're running in the created\n        # subprocess, which has the _PIP_RUNNING_IN_SUBPROCESS environment\n        # variable set.\n        if options.python and \"_PIP_RUNNING_IN_SUBPROCESS\" not in os.environ:\n            logger.critical(\n                \"The --python option must be placed before the pip subcommand name\"\n            )\n            sys.exit(ERROR)\n\n        # TODO: Try to get these passing down from the command?\n        #       without resorting to os.environ to hold these.\n        #       This also affects isolated builds and it should.\n\n        if options.no_input:\n            os.environ[\"PIP_NO_INPUT\"] = \"1\"\n\n        if options.exists_action:\n            os.environ[\"PIP_EXISTS_ACTION\"] = \" \".join(options.exists_action)\n\n        if options.require_venv and not self.ignore_require_venv:\n            # If a venv is required check if it can really be found\n            if not running_under_virtualenv():\n                logger.critical(\"Could not find an activated virtualenv (required).\")\n                sys.exit(VIRTUALENV_NOT_FOUND)\n\n        if options.cache_dir:\n            options.cache_dir = normalize_path(options.cache_dir)\n            if not check_path_owner(options.cache_dir):\n                logger.warning(\n                    \"The directory '%s' or its parent directory is not owned \"\n                    \"or is not writable by the current user. The cache \"\n                    \"has been disabled. Check the permissions and owner of \"\n                    \"that directory. If executing pip with sudo, you should \"\n                    \"use sudo's -H flag.\",\n                    options.cache_dir,\n                )\n                options.cache_dir = None\n\n        def intercepts_unhandled_exc(\n            run_func: Callable[..., int]\n        ) -> Callable[..., int]:\n            @functools.wraps(run_func)\n            def exc_logging_wrapper(*args: Any) -> int:\n                try:\n                    status = run_func(*args)\n                    assert isinstance(status, int)\n                    return status\n                except DiagnosticPipError as exc:\n                    logger.error(\"%s\", exc, extra={\"rich\": True})\n                    logger.debug(\"Exception information:\", exc_info=True)\n\n                    return ERROR\n                except PreviousBuildDirError as exc:\n                    logger.critical(str(exc))\n                    logger.debug(\"Exception information:\", exc_info=True)\n\n                    return PREVIOUS_BUILD_DIR_ERROR\n                except (\n                    InstallationError,\n                    UninstallationError,\n                    BadCommand,\n                    NetworkConnectionError,\n                ) as exc:\n                    logger.critical(str(exc))\n                    logger.debug(\"Exception information:\", exc_info=True)\n\n                    return ERROR\n                except CommandError as exc:\n                    logger.critical(\"%s\", exc)\n                    logger.debug(\"Exception information:\", exc_info=True)\n\n                    return ERROR\n                except BrokenStdoutLoggingError:\n                    # Bypass our logger and write any remaining messages to\n                    # stderr because stdout no longer works.\n                    print(\"ERROR: Pipe to stdout was broken\", file=sys.stderr)\n                    if level_number <= logging.DEBUG:\n                        traceback.print_exc(file=sys.stderr)\n\n                    return ERROR\n                except KeyboardInterrupt:\n                    logger.critical(\"Operation cancelled by user\")\n                    logger.debug(\"Exception information:\", exc_info=True)\n\n                    return ERROR\n                except BaseException:\n                    logger.critical(\"Exception:\", exc_info=True)\n\n                    return UNKNOWN_ERROR\n\n            return exc_logging_wrapper\n\n        try:\n            if not options.debug_mode:\n                run = intercepts_unhandled_exc(self.run)\n            else:\n                run = self.run\n                rich_traceback.install(show_locals=True)\n            return run(options, args)\n        finally:\n            self.handle_pip_version_check(options)\n"},"hash":"LnIQynf1Ek"}