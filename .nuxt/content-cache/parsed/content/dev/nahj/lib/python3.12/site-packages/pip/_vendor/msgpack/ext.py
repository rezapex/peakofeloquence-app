{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:msgpack:ext.py","body":"# coding: utf-8\nfrom collections import namedtuple\nimport datetime\nimport sys\nimport struct\n\n\nPY2 = sys.version_info[0] == 2\n\nif PY2:\n    int_types = (int, long)\n    _utc = None\nelse:\n    int_types = int\n    try:\n        _utc = datetime.timezone.utc\n    except AttributeError:\n        _utc = datetime.timezone(datetime.timedelta(0))\n\n\nclass ExtType(namedtuple(\"ExtType\", \"code data\")):\n    \"\"\"ExtType represents ext type in msgpack.\"\"\"\n\n    def __new__(cls, code, data):\n        if not isinstance(code, int):\n            raise TypeError(\"code must be int\")\n        if not isinstance(data, bytes):\n            raise TypeError(\"data must be bytes\")\n        if not 0 <= code <= 127:\n            raise ValueError(\"code must be 0~127\")\n        return super(ExtType, cls).__new__(cls, code, data)\n\n\nclass Timestamp(object):\n    \"\"\"Timestamp represents the Timestamp extension type in msgpack.\n\n    When built with Cython, msgpack uses C methods to pack and unpack `Timestamp`. When using pure-Python\n    msgpack, :func:`to_bytes` and :func:`from_bytes` are used to pack and unpack `Timestamp`.\n\n    This class is immutable: Do not override seconds and nanoseconds.\n    \"\"\"\n\n    __slots__ = [\"seconds\", \"nanoseconds\"]\n\n    def __init__(self, seconds, nanoseconds=0):\n        \"\"\"Initialize a Timestamp object.\n\n        :param int seconds:\n            Number of seconds since the UNIX epoch (00:00:00 UTC Jan 1 1970, minus leap seconds).\n            May be negative.\n\n        :param int nanoseconds:\n            Number of nanoseconds to add to `seconds` to get fractional time.\n            Maximum is 999_999_999.  Default is 0.\n\n        Note: Negative times (before the UNIX epoch) are represented as negative seconds + positive ns.\n        \"\"\"\n        if not isinstance(seconds, int_types):\n            raise TypeError(\"seconds must be an integer\")\n        if not isinstance(nanoseconds, int_types):\n            raise TypeError(\"nanoseconds must be an integer\")\n        if not (0 <= nanoseconds < 10**9):\n            raise ValueError(\n                \"nanoseconds must be a non-negative integer less than 999999999.\"\n            )\n        self.seconds = seconds\n        self.nanoseconds = nanoseconds\n\n    def __repr__(self):\n        \"\"\"String representation of Timestamp.\"\"\"\n        return \"Timestamp(seconds={0}, nanoseconds={1})\".format(\n            self.seconds, self.nanoseconds\n        )\n\n    def __eq__(self, other):\n        \"\"\"Check for equality with another Timestamp object\"\"\"\n        if type(other) is self.__class__:\n            return (\n                self.seconds == other.seconds and self.nanoseconds == other.nanoseconds\n            )\n        return False\n\n    def __ne__(self, other):\n        \"\"\"not-equals method (see :func:`__eq__()`)\"\"\"\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return hash((self.seconds, self.nanoseconds))\n\n    @staticmethod\n    def from_bytes(b):\n        \"\"\"Unpack bytes into a `Timestamp` object.\n\n        Used for pure-Python msgpack unpacking.\n\n        :param b: Payload from msgpack ext message with code -1\n        :type b: bytes\n\n        :returns: Timestamp object unpacked from msgpack ext payload\n        :rtype: Timestamp\n        \"\"\"\n        if len(b) == 4:\n            seconds = struct.unpack(\"!L\", b)[0]\n            nanoseconds = 0\n        elif len(b) == 8:\n            data64 = struct.unpack(\"!Q\", b)[0]\n            seconds = data64 & 0x00000003FFFFFFFF\n            nanoseconds = data64 >> 34\n        elif len(b) == 12:\n            nanoseconds, seconds = struct.unpack(\"!Iq\", b)\n        else:\n            raise ValueError(\n                \"Timestamp type can only be created from 32, 64, or 96-bit byte objects\"\n            )\n        return Timestamp(seconds, nanoseconds)\n\n    def to_bytes(self):\n        \"\"\"Pack this Timestamp object into bytes.\n\n        Used for pure-Python msgpack packing.\n\n        :returns data: Payload for EXT message with code -1 (timestamp type)\n        :rtype: bytes\n        \"\"\"\n        if (self.seconds >> 34) == 0:  # seconds is non-negative and fits in 34 bits\n            data64 = self.nanoseconds << 34 | self.seconds\n            if data64 & 0xFFFFFFFF00000000 == 0:\n                # nanoseconds is zero and seconds < 2**32, so timestamp 32\n                data = struct.pack(\"!L\", data64)\n            else:\n                # timestamp 64\n                data = struct.pack(\"!Q\", data64)\n        else:\n            # timestamp 96\n            data = struct.pack(\"!Iq\", self.nanoseconds, self.seconds)\n        return data\n\n    @staticmethod\n    def from_unix(unix_sec):\n        \"\"\"Create a Timestamp from posix timestamp in seconds.\n\n        :param unix_float: Posix timestamp in seconds.\n        :type unix_float: int or float.\n        \"\"\"\n        seconds = int(unix_sec // 1)\n        nanoseconds = int((unix_sec % 1) * 10**9)\n        return Timestamp(seconds, nanoseconds)\n\n    def to_unix(self):\n        \"\"\"Get the timestamp as a floating-point value.\n\n        :returns: posix timestamp\n        :rtype: float\n        \"\"\"\n        return self.seconds + self.nanoseconds / 1e9\n\n    @staticmethod\n    def from_unix_nano(unix_ns):\n        \"\"\"Create a Timestamp from posix timestamp in nanoseconds.\n\n        :param int unix_ns: Posix timestamp in nanoseconds.\n        :rtype: Timestamp\n        \"\"\"\n        return Timestamp(*divmod(unix_ns, 10**9))\n\n    def to_unix_nano(self):\n        \"\"\"Get the timestamp as a unixtime in nanoseconds.\n\n        :returns: posix timestamp in nanoseconds\n        :rtype: int\n        \"\"\"\n        return self.seconds * 10**9 + self.nanoseconds\n\n    def to_datetime(self):\n        \"\"\"Get the timestamp as a UTC datetime.\n\n        Python 2 is not supported.\n\n        :rtype: datetime.\n        \"\"\"\n        return datetime.datetime.fromtimestamp(0, _utc) + datetime.timedelta(\n            seconds=self.to_unix()\n        )\n\n    @staticmethod\n    def from_datetime(dt):\n        \"\"\"Create a Timestamp from datetime with tzinfo.\n\n        Python 2 is not supported.\n\n        :rtype: Timestamp\n        \"\"\"\n        return Timestamp.from_unix(dt.timestamp())\n"},"hash":"u5lAkvXjnQ"}