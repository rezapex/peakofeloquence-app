{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:chardet:sjisprober.py","body":"######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is mozilla.org code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 1998\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\nfrom typing import Union\n\nfrom .chardistribution import SJISDistributionAnalysis\nfrom .codingstatemachine import CodingStateMachine\nfrom .enums import MachineState, ProbingState\nfrom .jpcntx import SJISContextAnalysis\nfrom .mbcharsetprober import MultiByteCharSetProber\nfrom .mbcssm import SJIS_SM_MODEL\n\n\nclass SJISProber(MultiByteCharSetProber):\n    def __init__(self) -> None:\n        super().__init__()\n        self.coding_sm = CodingStateMachine(SJIS_SM_MODEL)\n        self.distribution_analyzer = SJISDistributionAnalysis()\n        self.context_analyzer = SJISContextAnalysis()\n        self.reset()\n\n    def reset(self) -> None:\n        super().reset()\n        self.context_analyzer.reset()\n\n    @property\n    def charset_name(self) -> str:\n        return self.context_analyzer.charset_name\n\n    @property\n    def language(self) -> str:\n        return \"Japanese\"\n\n    def feed(self, byte_str: Union[bytes, bytearray]) -> ProbingState:\n        assert self.coding_sm is not None\n        assert self.distribution_analyzer is not None\n\n        for i, byte in enumerate(byte_str):\n            coding_state = self.coding_sm.next_state(byte)\n            if coding_state == MachineState.ERROR:\n                self.logger.debug(\n                    \"%s %s prober hit error at byte %s\",\n                    self.charset_name,\n                    self.language,\n                    i,\n                )\n                self._state = ProbingState.NOT_ME\n                break\n            if coding_state == MachineState.ITS_ME:\n                self._state = ProbingState.FOUND_IT\n                break\n            if coding_state == MachineState.START:\n                char_len = self.coding_sm.get_current_charlen()\n                if i == 0:\n                    self._last_char[1] = byte\n                    self.context_analyzer.feed(\n                        self._last_char[2 - char_len :], char_len\n                    )\n                    self.distribution_analyzer.feed(self._last_char, char_len)\n                else:\n                    self.context_analyzer.feed(\n                        byte_str[i + 1 - char_len : i + 3 - char_len], char_len\n                    )\n                    self.distribution_analyzer.feed(byte_str[i - 1 : i + 1], char_len)\n\n        self._last_char[0] = byte_str[-1]\n\n        if self.state == ProbingState.DETECTING:\n            if self.context_analyzer.got_enough_data() and (\n                self.get_confidence() > self.SHORTCUT_THRESHOLD\n            ):\n                self._state = ProbingState.FOUND_IT\n\n        return self.state\n\n    def get_confidence(self) -> float:\n        assert self.distribution_analyzer is not None\n\n        context_conf = self.context_analyzer.get_confidence()\n        distrib_conf = self.distribution_analyzer.get_confidence()\n        return max(context_conf, distrib_conf)\n"},"hash":"ZADoVfbLXC"}