{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:pyproject_hooks:_impl.py","body":"import json\nimport os\nimport sys\nimport tempfile\nfrom contextlib import contextmanager\nfrom os.path import abspath\nfrom os.path import join as pjoin\nfrom subprocess import STDOUT, check_call, check_output\n\nfrom ._in_process import _in_proc_script_path\n\n\ndef write_json(obj, path, **kwargs):\n    with open(path, 'w', encoding='utf-8') as f:\n        json.dump(obj, f, **kwargs)\n\n\ndef read_json(path):\n    with open(path, encoding='utf-8') as f:\n        return json.load(f)\n\n\nclass BackendUnavailable(Exception):\n    \"\"\"Will be raised if the backend cannot be imported in the hook process.\"\"\"\n    def __init__(self, traceback):\n        self.traceback = traceback\n\n\nclass BackendInvalid(Exception):\n    \"\"\"Will be raised if the backend is invalid.\"\"\"\n    def __init__(self, backend_name, backend_path, message):\n        super().__init__(message)\n        self.backend_name = backend_name\n        self.backend_path = backend_path\n\n\nclass HookMissing(Exception):\n    \"\"\"Will be raised on missing hooks (if a fallback can't be used).\"\"\"\n    def __init__(self, hook_name):\n        super().__init__(hook_name)\n        self.hook_name = hook_name\n\n\nclass UnsupportedOperation(Exception):\n    \"\"\"May be raised by build_sdist if the backend indicates that it can't.\"\"\"\n    def __init__(self, traceback):\n        self.traceback = traceback\n\n\ndef default_subprocess_runner(cmd, cwd=None, extra_environ=None):\n    \"\"\"The default method of calling the wrapper subprocess.\n\n    This uses :func:`subprocess.check_call` under the hood.\n    \"\"\"\n    env = os.environ.copy()\n    if extra_environ:\n        env.update(extra_environ)\n\n    check_call(cmd, cwd=cwd, env=env)\n\n\ndef quiet_subprocess_runner(cmd, cwd=None, extra_environ=None):\n    \"\"\"Call the subprocess while suppressing output.\n\n    This uses :func:`subprocess.check_output` under the hood.\n    \"\"\"\n    env = os.environ.copy()\n    if extra_environ:\n        env.update(extra_environ)\n\n    check_output(cmd, cwd=cwd, env=env, stderr=STDOUT)\n\n\ndef norm_and_check(source_tree, requested):\n    \"\"\"Normalise and check a backend path.\n\n    Ensure that the requested backend path is specified as a relative path,\n    and resolves to a location under the given source tree.\n\n    Return an absolute version of the requested path.\n    \"\"\"\n    if os.path.isabs(requested):\n        raise ValueError(\"paths must be relative\")\n\n    abs_source = os.path.abspath(source_tree)\n    abs_requested = os.path.normpath(os.path.join(abs_source, requested))\n    # We have to use commonprefix for Python 2.7 compatibility. So we\n    # normalise case to avoid problems because commonprefix is a character\n    # based comparison :-(\n    norm_source = os.path.normcase(abs_source)\n    norm_requested = os.path.normcase(abs_requested)\n    if os.path.commonprefix([norm_source, norm_requested]) != norm_source:\n        raise ValueError(\"paths must be inside source tree\")\n\n    return abs_requested\n\n\nclass BuildBackendHookCaller:\n    \"\"\"A wrapper to call the build backend hooks for a source directory.\n    \"\"\"\n\n    def __init__(\n            self,\n            source_dir,\n            build_backend,\n            backend_path=None,\n            runner=None,\n            python_executable=None,\n    ):\n        \"\"\"\n        :param source_dir: The source directory to invoke the build backend for\n        :param build_backend: The build backend spec\n        :param backend_path: Additional path entries for the build backend spec\n        :param runner: The :ref:`subprocess runner <Subprocess Runners>` to use\n        :param python_executable:\n            The Python executable used to invoke the build backend\n        \"\"\"\n        if runner is None:\n            runner = default_subprocess_runner\n\n        self.source_dir = abspath(source_dir)\n        self.build_backend = build_backend\n        if backend_path:\n            backend_path = [\n                norm_and_check(self.source_dir, p) for p in backend_path\n            ]\n        self.backend_path = backend_path\n        self._subprocess_runner = runner\n        if not python_executable:\n            python_executable = sys.executable\n        self.python_executable = python_executable\n\n    @contextmanager\n    def subprocess_runner(self, runner):\n        \"\"\"A context manager for temporarily overriding the default\n        :ref:`subprocess runner <Subprocess Runners>`.\n\n        .. code-block:: python\n\n            hook_caller = BuildBackendHookCaller(...)\n            with hook_caller.subprocess_runner(quiet_subprocess_runner):\n                ...\n        \"\"\"\n        prev = self._subprocess_runner\n        self._subprocess_runner = runner\n        try:\n            yield\n        finally:\n            self._subprocess_runner = prev\n\n    def _supported_features(self):\n        \"\"\"Return the list of optional features supported by the backend.\"\"\"\n        return self._call_hook('_supported_features', {})\n\n    def get_requires_for_build_wheel(self, config_settings=None):\n        \"\"\"Get additional dependencies required for building a wheel.\n\n        :returns: A list of :pep:`dependency specifiers <508>`.\n        :rtype: list[str]\n\n        .. admonition:: Fallback\n\n            If the build backend does not defined a hook with this name, an\n            empty list will be returned.\n        \"\"\"\n        return self._call_hook('get_requires_for_build_wheel', {\n            'config_settings': config_settings\n        })\n\n    def prepare_metadata_for_build_wheel(\n            self, metadata_directory, config_settings=None,\n            _allow_fallback=True):\n        \"\"\"Prepare a ``*.dist-info`` folder with metadata for this project.\n\n        :returns: Name of the newly created subfolder within\n                  ``metadata_directory``, containing the metadata.\n        :rtype: str\n\n        .. admonition:: Fallback\n\n            If the build backend does not define a hook with this name and\n            ``_allow_fallback`` is truthy, the backend will be asked to build a\n            wheel via the ``build_wheel`` hook and the dist-info extracted from\n            that will be returned.\n        \"\"\"\n        return self._call_hook('prepare_metadata_for_build_wheel', {\n            'metadata_directory': abspath(metadata_directory),\n            'config_settings': config_settings,\n            '_allow_fallback': _allow_fallback,\n        })\n\n    def build_wheel(\n            self, wheel_directory, config_settings=None,\n            metadata_directory=None):\n        \"\"\"Build a wheel from this project.\n\n        :returns:\n            The name of the newly created wheel within ``wheel_directory``.\n\n        .. admonition:: Interaction with fallback\n\n            If the ``build_wheel`` hook was called in the fallback for\n            :meth:`prepare_metadata_for_build_wheel`, the build backend would\n            not be invoked. Instead, the previously built wheel will be copied\n            to ``wheel_directory`` and the name of that file will be returned.\n        \"\"\"\n        if metadata_directory is not None:\n            metadata_directory = abspath(metadata_directory)\n        return self._call_hook('build_wheel', {\n            'wheel_directory': abspath(wheel_directory),\n            'config_settings': config_settings,\n            'metadata_directory': metadata_directory,\n        })\n\n    def get_requires_for_build_editable(self, config_settings=None):\n        \"\"\"Get additional dependencies required for building an editable wheel.\n\n        :returns: A list of :pep:`dependency specifiers <508>`.\n        :rtype: list[str]\n\n        .. admonition:: Fallback\n\n            If the build backend does not defined a hook with this name, an\n            empty list will be returned.\n        \"\"\"\n        return self._call_hook('get_requires_for_build_editable', {\n            'config_settings': config_settings\n        })\n\n    def prepare_metadata_for_build_editable(\n            self, metadata_directory, config_settings=None,\n            _allow_fallback=True):\n        \"\"\"Prepare a ``*.dist-info`` folder with metadata for this project.\n\n        :returns: Name of the newly created subfolder within\n                  ``metadata_directory``, containing the metadata.\n        :rtype: str\n\n        .. admonition:: Fallback\n\n            If the build backend does not define a hook with this name and\n            ``_allow_fallback`` is truthy, the backend will be asked to build a\n            wheel via the ``build_editable`` hook and the dist-info\n            extracted from that will be returned.\n        \"\"\"\n        return self._call_hook('prepare_metadata_for_build_editable', {\n            'metadata_directory': abspath(metadata_directory),\n            'config_settings': config_settings,\n            '_allow_fallback': _allow_fallback,\n        })\n\n    def build_editable(\n            self, wheel_directory, config_settings=None,\n            metadata_directory=None):\n        \"\"\"Build an editable wheel from this project.\n\n        :returns:\n            The name of the newly created wheel within ``wheel_directory``.\n\n        .. admonition:: Interaction with fallback\n\n            If the ``build_editable`` hook was called in the fallback for\n            :meth:`prepare_metadata_for_build_editable`, the build backend\n            would not be invoked. Instead, the previously built wheel will be\n            copied to ``wheel_directory`` and the name of that file will be\n            returned.\n        \"\"\"\n        if metadata_directory is not None:\n            metadata_directory = abspath(metadata_directory)\n        return self._call_hook('build_editable', {\n            'wheel_directory': abspath(wheel_directory),\n            'config_settings': config_settings,\n            'metadata_directory': metadata_directory,\n        })\n\n    def get_requires_for_build_sdist(self, config_settings=None):\n        \"\"\"Get additional dependencies required for building an sdist.\n\n        :returns: A list of :pep:`dependency specifiers <508>`.\n        :rtype: list[str]\n        \"\"\"\n        return self._call_hook('get_requires_for_build_sdist', {\n            'config_settings': config_settings\n        })\n\n    def build_sdist(self, sdist_directory, config_settings=None):\n        \"\"\"Build an sdist from this project.\n\n        :returns:\n            The name of the newly created sdist within ``wheel_directory``.\n        \"\"\"\n        return self._call_hook('build_sdist', {\n            'sdist_directory': abspath(sdist_directory),\n            'config_settings': config_settings,\n        })\n\n    def _call_hook(self, hook_name, kwargs):\n        extra_environ = {'PEP517_BUILD_BACKEND': self.build_backend}\n\n        if self.backend_path:\n            backend_path = os.pathsep.join(self.backend_path)\n            extra_environ['PEP517_BACKEND_PATH'] = backend_path\n\n        with tempfile.TemporaryDirectory() as td:\n            hook_input = {'kwargs': kwargs}\n            write_json(hook_input, pjoin(td, 'input.json'), indent=2)\n\n            # Run the hook in a subprocess\n            with _in_proc_script_path() as script:\n                python = self.python_executable\n                self._subprocess_runner(\n                    [python, abspath(str(script)), hook_name, td],\n                    cwd=self.source_dir,\n                    extra_environ=extra_environ\n                )\n\n            data = read_json(pjoin(td, 'output.json'))\n            if data.get('unsupported'):\n                raise UnsupportedOperation(data.get('traceback', ''))\n            if data.get('no_backend'):\n                raise BackendUnavailable(data.get('traceback', ''))\n            if data.get('backend_invalid'):\n                raise BackendInvalid(\n                    backend_name=self.build_backend,\n                    backend_path=self.backend_path,\n                    message=data.get('backend_error', '')\n                )\n            if data.get('hook_missing'):\n                raise HookMissing(data.get('missing_hook_name') or hook_name)\n            return data['return_val']\n"},"hash":"vKEujajDJX"}