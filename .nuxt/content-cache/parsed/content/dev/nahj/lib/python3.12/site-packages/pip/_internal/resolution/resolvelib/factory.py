{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:resolution:resolvelib:factory.py","body":"import contextlib\nimport functools\nimport logging\nfrom typing import (\n    TYPE_CHECKING,\n    Dict,\n    FrozenSet,\n    Iterable,\n    Iterator,\n    List,\n    Mapping,\n    NamedTuple,\n    Optional,\n    Sequence,\n    Set,\n    Tuple,\n    TypeVar,\n    cast,\n)\n\nfrom pip._vendor.packaging.requirements import InvalidRequirement\nfrom pip._vendor.packaging.specifiers import SpecifierSet\nfrom pip._vendor.packaging.utils import NormalizedName, canonicalize_name\nfrom pip._vendor.resolvelib import ResolutionImpossible\n\nfrom pip._internal.cache import CacheEntry, WheelCache\nfrom pip._internal.exceptions import (\n    DistributionNotFound,\n    InstallationError,\n    MetadataInconsistent,\n    UnsupportedPythonVersion,\n    UnsupportedWheel,\n)\nfrom pip._internal.index.package_finder import PackageFinder\nfrom pip._internal.metadata import BaseDistribution, get_default_environment\nfrom pip._internal.models.link import Link\nfrom pip._internal.models.wheel import Wheel\nfrom pip._internal.operations.prepare import RequirementPreparer\nfrom pip._internal.req.constructors import (\n    install_req_drop_extras,\n    install_req_from_link_and_ireq,\n)\nfrom pip._internal.req.req_install import (\n    InstallRequirement,\n    check_invalid_constraint_type,\n)\nfrom pip._internal.resolution.base import InstallRequirementProvider\nfrom pip._internal.utils.compatibility_tags import get_supported\nfrom pip._internal.utils.hashes import Hashes\nfrom pip._internal.utils.packaging import get_requirement\nfrom pip._internal.utils.virtualenv import running_under_virtualenv\n\nfrom .base import Candidate, CandidateVersion, Constraint, Requirement\nfrom .candidates import (\n    AlreadyInstalledCandidate,\n    BaseCandidate,\n    EditableCandidate,\n    ExtrasCandidate,\n    LinkCandidate,\n    RequiresPythonCandidate,\n    as_base_candidate,\n)\nfrom .found_candidates import FoundCandidates, IndexCandidateInfo\nfrom .requirements import (\n    ExplicitRequirement,\n    RequiresPythonRequirement,\n    SpecifierRequirement,\n    SpecifierWithoutExtrasRequirement,\n    UnsatisfiableRequirement,\n)\n\nif TYPE_CHECKING:\n    from typing import Protocol\n\n    class ConflictCause(Protocol):\n        requirement: RequiresPythonRequirement\n        parent: Candidate\n\n\nlogger = logging.getLogger(__name__)\n\nC = TypeVar(\"C\")\nCache = Dict[Link, C]\n\n\nclass CollectedRootRequirements(NamedTuple):\n    requirements: List[Requirement]\n    constraints: Dict[str, Constraint]\n    user_requested: Dict[str, int]\n\n\nclass Factory:\n    def __init__(\n        self,\n        finder: PackageFinder,\n        preparer: RequirementPreparer,\n        make_install_req: InstallRequirementProvider,\n        wheel_cache: Optional[WheelCache],\n        use_user_site: bool,\n        force_reinstall: bool,\n        ignore_installed: bool,\n        ignore_requires_python: bool,\n        py_version_info: Optional[Tuple[int, ...]] = None,\n    ) -> None:\n        self._finder = finder\n        self.preparer = preparer\n        self._wheel_cache = wheel_cache\n        self._python_candidate = RequiresPythonCandidate(py_version_info)\n        self._make_install_req_from_spec = make_install_req\n        self._use_user_site = use_user_site\n        self._force_reinstall = force_reinstall\n        self._ignore_requires_python = ignore_requires_python\n\n        self._build_failures: Cache[InstallationError] = {}\n        self._link_candidate_cache: Cache[LinkCandidate] = {}\n        self._editable_candidate_cache: Cache[EditableCandidate] = {}\n        self._installed_candidate_cache: Dict[str, AlreadyInstalledCandidate] = {}\n        self._extras_candidate_cache: Dict[\n            Tuple[int, FrozenSet[NormalizedName]], ExtrasCandidate\n        ] = {}\n\n        if not ignore_installed:\n            env = get_default_environment()\n            self._installed_dists = {\n                dist.canonical_name: dist\n                for dist in env.iter_installed_distributions(local_only=False)\n            }\n        else:\n            self._installed_dists = {}\n\n    @property\n    def force_reinstall(self) -> bool:\n        return self._force_reinstall\n\n    def _fail_if_link_is_unsupported_wheel(self, link: Link) -> None:\n        if not link.is_wheel:\n            return\n        wheel = Wheel(link.filename)\n        if wheel.supported(self._finder.target_python.get_unsorted_tags()):\n            return\n        msg = f\"{link.filename} is not a supported wheel on this platform.\"\n        raise UnsupportedWheel(msg)\n\n    def _make_extras_candidate(\n        self,\n        base: BaseCandidate,\n        extras: FrozenSet[str],\n        *,\n        comes_from: Optional[InstallRequirement] = None,\n    ) -> ExtrasCandidate:\n        cache_key = (id(base), frozenset(canonicalize_name(e) for e in extras))\n        try:\n            candidate = self._extras_candidate_cache[cache_key]\n        except KeyError:\n            candidate = ExtrasCandidate(base, extras, comes_from=comes_from)\n            self._extras_candidate_cache[cache_key] = candidate\n        return candidate\n\n    def _make_candidate_from_dist(\n        self,\n        dist: BaseDistribution,\n        extras: FrozenSet[str],\n        template: InstallRequirement,\n    ) -> Candidate:\n        try:\n            base = self._installed_candidate_cache[dist.canonical_name]\n        except KeyError:\n            base = AlreadyInstalledCandidate(dist, template, factory=self)\n            self._installed_candidate_cache[dist.canonical_name] = base\n        if not extras:\n            return base\n        return self._make_extras_candidate(base, extras, comes_from=template)\n\n    def _make_candidate_from_link(\n        self,\n        link: Link,\n        extras: FrozenSet[str],\n        template: InstallRequirement,\n        name: Optional[NormalizedName],\n        version: Optional[CandidateVersion],\n    ) -> Optional[Candidate]:\n        base: Optional[BaseCandidate] = self._make_base_candidate_from_link(\n            link, template, name, version\n        )\n        if not extras or base is None:\n            return base\n        return self._make_extras_candidate(base, extras, comes_from=template)\n\n    def _make_base_candidate_from_link(\n        self,\n        link: Link,\n        template: InstallRequirement,\n        name: Optional[NormalizedName],\n        version: Optional[CandidateVersion],\n    ) -> Optional[BaseCandidate]:\n        # TODO: Check already installed candidate, and use it if the link and\n        # editable flag match.\n\n        if link in self._build_failures:\n            # We already tried this candidate before, and it does not build.\n            # Don't bother trying again.\n            return None\n\n        if template.editable:\n            if link not in self._editable_candidate_cache:\n                try:\n                    self._editable_candidate_cache[link] = EditableCandidate(\n                        link,\n                        template,\n                        factory=self,\n                        name=name,\n                        version=version,\n                    )\n                except MetadataInconsistent as e:\n                    logger.info(\n                        \"Discarding [blue underline]%s[/]: [yellow]%s[reset]\",\n                        link,\n                        e,\n                        extra={\"markup\": True},\n                    )\n                    self._build_failures[link] = e\n                    return None\n\n            return self._editable_candidate_cache[link]\n        else:\n            if link not in self._link_candidate_cache:\n                try:\n                    self._link_candidate_cache[link] = LinkCandidate(\n                        link,\n                        template,\n                        factory=self,\n                        name=name,\n                        version=version,\n                    )\n                except MetadataInconsistent as e:\n                    logger.info(\n                        \"Discarding [blue underline]%s[/]: [yellow]%s[reset]\",\n                        link,\n                        e,\n                        extra={\"markup\": True},\n                    )\n                    self._build_failures[link] = e\n                    return None\n            return self._link_candidate_cache[link]\n\n    def _iter_found_candidates(\n        self,\n        ireqs: Sequence[InstallRequirement],\n        specifier: SpecifierSet,\n        hashes: Hashes,\n        prefers_installed: bool,\n        incompatible_ids: Set[int],\n    ) -> Iterable[Candidate]:\n        if not ireqs:\n            return ()\n\n        # The InstallRequirement implementation requires us to give it a\n        # \"template\". Here we just choose the first requirement to represent\n        # all of them.\n        # Hopefully the Project model can correct this mismatch in the future.\n        template = ireqs[0]\n        assert template.req, \"Candidates found on index must be PEP 508\"\n        name = canonicalize_name(template.req.name)\n\n        extras: FrozenSet[str] = frozenset()\n        for ireq in ireqs:\n            assert ireq.req, \"Candidates found on index must be PEP 508\"\n            specifier &= ireq.req.specifier\n            hashes &= ireq.hashes(trust_internet=False)\n            extras |= frozenset(ireq.extras)\n\n        def _get_installed_candidate() -> Optional[Candidate]:\n            \"\"\"Get the candidate for the currently-installed version.\"\"\"\n            # If --force-reinstall is set, we want the version from the index\n            # instead, so we \"pretend\" there is nothing installed.\n            if self._force_reinstall:\n                return None\n            try:\n                installed_dist = self._installed_dists[name]\n            except KeyError:\n                return None\n            # Don't use the installed distribution if its version does not fit\n            # the current dependency graph.\n            if not specifier.contains(installed_dist.version, prereleases=True):\n                return None\n            candidate = self._make_candidate_from_dist(\n                dist=installed_dist,\n                extras=extras,\n                template=template,\n            )\n            # The candidate is a known incompatibility. Don't use it.\n            if id(candidate) in incompatible_ids:\n                return None\n            return candidate\n\n        def iter_index_candidate_infos() -> Iterator[IndexCandidateInfo]:\n            result = self._finder.find_best_candidate(\n                project_name=name,\n                specifier=specifier,\n                hashes=hashes,\n            )\n            icans = list(result.iter_applicable())\n\n            # PEP 592: Yanked releases are ignored unless the specifier\n            # explicitly pins a version (via '==' or '===') that can be\n            # solely satisfied by a yanked release.\n            all_yanked = all(ican.link.is_yanked for ican in icans)\n\n            def is_pinned(specifier: SpecifierSet) -> bool:\n                for sp in specifier:\n                    if sp.operator == \"===\":\n                        return True\n                    if sp.operator != \"==\":\n                        continue\n                    if sp.version.endswith(\".*\"):\n                        continue\n                    return True\n                return False\n\n            pinned = is_pinned(specifier)\n\n            # PackageFinder returns earlier versions first, so we reverse.\n            for ican in reversed(icans):\n                if not (all_yanked and pinned) and ican.link.is_yanked:\n                    continue\n                func = functools.partial(\n                    self._make_candidate_from_link,\n                    link=ican.link,\n                    extras=extras,\n                    template=template,\n                    name=name,\n                    version=ican.version,\n                )\n                yield ican.version, func\n\n        return FoundCandidates(\n            iter_index_candidate_infos,\n            _get_installed_candidate(),\n            prefers_installed,\n            incompatible_ids,\n        )\n\n    def _iter_explicit_candidates_from_base(\n        self,\n        base_requirements: Iterable[Requirement],\n        extras: FrozenSet[str],\n    ) -> Iterator[Candidate]:\n        \"\"\"Produce explicit candidates from the base given an extra-ed package.\n\n        :param base_requirements: Requirements known to the resolver. The\n            requirements are guaranteed to not have extras.\n        :param extras: The extras to inject into the explicit requirements'\n            candidates.\n        \"\"\"\n        for req in base_requirements:\n            lookup_cand, _ = req.get_candidate_lookup()\n            if lookup_cand is None:  # Not explicit.\n                continue\n            # We've stripped extras from the identifier, and should always\n            # get a BaseCandidate here, unless there's a bug elsewhere.\n            base_cand = as_base_candidate(lookup_cand)\n            assert base_cand is not None, \"no extras here\"\n            yield self._make_extras_candidate(base_cand, extras)\n\n    def _iter_candidates_from_constraints(\n        self,\n        identifier: str,\n        constraint: Constraint,\n        template: InstallRequirement,\n    ) -> Iterator[Candidate]:\n        \"\"\"Produce explicit candidates from constraints.\n\n        This creates \"fake\" InstallRequirement objects that are basically clones\n        of what \"should\" be the template, but with original_link set to link.\n        \"\"\"\n        for link in constraint.links:\n            self._fail_if_link_is_unsupported_wheel(link)\n            candidate = self._make_base_candidate_from_link(\n                link,\n                template=install_req_from_link_and_ireq(link, template),\n                name=canonicalize_name(identifier),\n                version=None,\n            )\n            if candidate:\n                yield candidate\n\n    def find_candidates(\n        self,\n        identifier: str,\n        requirements: Mapping[str, Iterable[Requirement]],\n        incompatibilities: Mapping[str, Iterator[Candidate]],\n        constraint: Constraint,\n        prefers_installed: bool,\n    ) -> Iterable[Candidate]:\n        # Collect basic lookup information from the requirements.\n        explicit_candidates: Set[Candidate] = set()\n        ireqs: List[InstallRequirement] = []\n        for req in requirements[identifier]:\n            cand, ireq = req.get_candidate_lookup()\n            if cand is not None:\n                explicit_candidates.add(cand)\n            if ireq is not None:\n                ireqs.append(ireq)\n\n        # If the current identifier contains extras, add requires and explicit\n        # candidates from entries from extra-less identifier.\n        with contextlib.suppress(InvalidRequirement):\n            parsed_requirement = get_requirement(identifier)\n            if parsed_requirement.name != identifier:\n                explicit_candidates.update(\n                    self._iter_explicit_candidates_from_base(\n                        requirements.get(parsed_requirement.name, ()),\n                        frozenset(parsed_requirement.extras),\n                    ),\n                )\n                for req in requirements.get(parsed_requirement.name, []):\n                    _, ireq = req.get_candidate_lookup()\n                    if ireq is not None:\n                        ireqs.append(ireq)\n\n        # Add explicit candidates from constraints. We only do this if there are\n        # known ireqs, which represent requirements not already explicit. If\n        # there are no ireqs, we're constraining already-explicit requirements,\n        # which is handled later when we return the explicit candidates.\n        if ireqs:\n            try:\n                explicit_candidates.update(\n                    self._iter_candidates_from_constraints(\n                        identifier,\n                        constraint,\n                        template=ireqs[0],\n                    ),\n                )\n            except UnsupportedWheel:\n                # If we're constrained to install a wheel incompatible with the\n                # target architecture, no candidates will ever be valid.\n                return ()\n\n        # Since we cache all the candidates, incompatibility identification\n        # can be made quicker by comparing only the id() values.\n        incompat_ids = {id(c) for c in incompatibilities.get(identifier, ())}\n\n        # If none of the requirements want an explicit candidate, we can ask\n        # the finder for candidates.\n        if not explicit_candidates:\n            return self._iter_found_candidates(\n                ireqs,\n                constraint.specifier,\n                constraint.hashes,\n                prefers_installed,\n                incompat_ids,\n            )\n\n        return (\n            c\n            for c in explicit_candidates\n            if id(c) not in incompat_ids\n            and constraint.is_satisfied_by(c)\n            and all(req.is_satisfied_by(c) for req in requirements[identifier])\n        )\n\n    def _make_requirements_from_install_req(\n        self, ireq: InstallRequirement, requested_extras: Iterable[str]\n    ) -> Iterator[Requirement]:\n        \"\"\"\n        Returns requirement objects associated with the given InstallRequirement. In\n        most cases this will be a single object but the following special cases exist:\n            - the InstallRequirement has markers that do not apply -> result is empty\n            - the InstallRequirement has both a constraint (or link) and extras\n                -> result is split in two requirement objects: one with the constraint\n                (or link) and one with the extra. This allows centralized constraint\n                handling for the base, resulting in fewer candidate rejections.\n        \"\"\"\n        if not ireq.match_markers(requested_extras):\n            logger.info(\n                \"Ignoring %s: markers '%s' don't match your environment\",\n                ireq.name,\n                ireq.markers,\n            )\n        elif not ireq.link:\n            if ireq.extras and ireq.req is not None and ireq.req.specifier:\n                yield SpecifierWithoutExtrasRequirement(ireq)\n            yield SpecifierRequirement(ireq)\n        else:\n            self._fail_if_link_is_unsupported_wheel(ireq.link)\n            # Always make the link candidate for the base requirement to make it\n            # available to `find_candidates` for explicit candidate lookup for any\n            # set of extras.\n            # The extras are required separately via a second requirement.\n            cand = self._make_base_candidate_from_link(\n                ireq.link,\n                template=install_req_drop_extras(ireq) if ireq.extras else ireq,\n                name=canonicalize_name(ireq.name) if ireq.name else None,\n                version=None,\n            )\n            if cand is None:\n                # There's no way we can satisfy a URL requirement if the underlying\n                # candidate fails to build. An unnamed URL must be user-supplied, so\n                # we fail eagerly. If the URL is named, an unsatisfiable requirement\n                # can make the resolver do the right thing, either backtrack (and\n                # maybe find some other requirement that's buildable) or raise a\n                # ResolutionImpossible eventually.\n                if not ireq.name:\n                    raise self._build_failures[ireq.link]\n                yield UnsatisfiableRequirement(canonicalize_name(ireq.name))\n            else:\n                # require the base from the link\n                yield self.make_requirement_from_candidate(cand)\n                if ireq.extras:\n                    # require the extras on top of the base candidate\n                    yield self.make_requirement_from_candidate(\n                        self._make_extras_candidate(cand, frozenset(ireq.extras))\n                    )\n\n    def collect_root_requirements(\n        self, root_ireqs: List[InstallRequirement]\n    ) -> CollectedRootRequirements:\n        collected = CollectedRootRequirements([], {}, {})\n        for i, ireq in enumerate(root_ireqs):\n            if ireq.constraint:\n                # Ensure we only accept valid constraints\n                problem = check_invalid_constraint_type(ireq)\n                if problem:\n                    raise InstallationError(problem)\n                if not ireq.match_markers():\n                    continue\n                assert ireq.name, \"Constraint must be named\"\n                name = canonicalize_name(ireq.name)\n                if name in collected.constraints:\n                    collected.constraints[name] &= ireq\n                else:\n                    collected.constraints[name] = Constraint.from_ireq(ireq)\n            else:\n                reqs = list(\n                    self._make_requirements_from_install_req(\n                        ireq,\n                        requested_extras=(),\n                    )\n                )\n                if not reqs:\n                    continue\n                template = reqs[0]\n                if ireq.user_supplied and template.name not in collected.user_requested:\n                    collected.user_requested[template.name] = i\n                collected.requirements.extend(reqs)\n        # Put requirements with extras at the end of the root requires. This does not\n        # affect resolvelib's picking preference but it does affect its initial criteria\n        # population: by putting extras at the end we enable the candidate finder to\n        # present resolvelib with a smaller set of candidates to resolvelib, already\n        # taking into account any non-transient constraints on the associated base. This\n        # means resolvelib will have fewer candidates to visit and reject.\n        # Python's list sort is stable, meaning relative order is kept for objects with\n        # the same key.\n        collected.requirements.sort(key=lambda r: r.name != r.project_name)\n        return collected\n\n    def make_requirement_from_candidate(\n        self, candidate: Candidate\n    ) -> ExplicitRequirement:\n        return ExplicitRequirement(candidate)\n\n    def make_requirements_from_spec(\n        self,\n        specifier: str,\n        comes_from: Optional[InstallRequirement],\n        requested_extras: Iterable[str] = (),\n    ) -> Iterator[Requirement]:\n        \"\"\"\n        Returns requirement objects associated with the given specifier. In most cases\n        this will be a single object but the following special cases exist:\n            - the specifier has markers that do not apply -> result is empty\n            - the specifier has both a constraint and extras -> result is split\n                in two requirement objects: one with the constraint and one with the\n                extra. This allows centralized constraint handling for the base,\n                resulting in fewer candidate rejections.\n        \"\"\"\n        ireq = self._make_install_req_from_spec(specifier, comes_from)\n        return self._make_requirements_from_install_req(ireq, requested_extras)\n\n    def make_requires_python_requirement(\n        self,\n        specifier: SpecifierSet,\n    ) -> Optional[Requirement]:\n        if self._ignore_requires_python:\n            return None\n        # Don't bother creating a dependency for an empty Requires-Python.\n        if not str(specifier):\n            return None\n        return RequiresPythonRequirement(specifier, self._python_candidate)\n\n    def get_wheel_cache_entry(\n        self, link: Link, name: Optional[str]\n    ) -> Optional[CacheEntry]:\n        \"\"\"Look up the link in the wheel cache.\n\n        If ``preparer.require_hashes`` is True, don't use the wheel cache,\n        because cached wheels, always built locally, have different hashes\n        than the files downloaded from the index server and thus throw false\n        hash mismatches. Furthermore, cached wheels at present have\n        nondeterministic contents due to file modification times.\n        \"\"\"\n        if self._wheel_cache is None:\n            return None\n        return self._wheel_cache.get_cache_entry(\n            link=link,\n            package_name=name,\n            supported_tags=get_supported(),\n        )\n\n    def get_dist_to_uninstall(self, candidate: Candidate) -> Optional[BaseDistribution]:\n        # TODO: Are there more cases this needs to return True? Editable?\n        dist = self._installed_dists.get(candidate.project_name)\n        if dist is None:  # Not installed, no uninstallation required.\n            return None\n\n        # We're installing into global site. The current installation must\n        # be uninstalled, no matter it's in global or user site, because the\n        # user site installation has precedence over global.\n        if not self._use_user_site:\n            return dist\n\n        # We're installing into user site. Remove the user site installation.\n        if dist.in_usersite:\n            return dist\n\n        # We're installing into user site, but the installed incompatible\n        # package is in global site. We can't uninstall that, and would let\n        # the new user installation to \"shadow\" it. But shadowing won't work\n        # in virtual environments, so we error out.\n        if running_under_virtualenv() and dist.in_site_packages:\n            message = (\n                f\"Will not install to the user site because it will lack \"\n                f\"sys.path precedence to {dist.raw_name} in {dist.location}\"\n            )\n            raise InstallationError(message)\n        return None\n\n    def _report_requires_python_error(\n        self, causes: Sequence[\"ConflictCause\"]\n    ) -> UnsupportedPythonVersion:\n        assert causes, \"Requires-Python error reported with no cause\"\n\n        version = self._python_candidate.version\n\n        if len(causes) == 1:\n            specifier = str(causes[0].requirement.specifier)\n            message = (\n                f\"Package {causes[0].parent.name!r} requires a different \"\n                f\"Python: {version} not in {specifier!r}\"\n            )\n            return UnsupportedPythonVersion(message)\n\n        message = f\"Packages require a different Python. {version} not in:\"\n        for cause in causes:\n            package = cause.parent.format_for_error()\n            specifier = str(cause.requirement.specifier)\n            message += f\"\\n{specifier!r} (required by {package})\"\n        return UnsupportedPythonVersion(message)\n\n    def _report_single_requirement_conflict(\n        self, req: Requirement, parent: Optional[Candidate]\n    ) -> DistributionNotFound:\n        if parent is None:\n            req_disp = str(req)\n        else:\n            req_disp = f\"{req} (from {parent.name})\"\n\n        cands = self._finder.find_all_candidates(req.project_name)\n        skipped_by_requires_python = self._finder.requires_python_skipped_reasons()\n\n        versions_set: Set[CandidateVersion] = set()\n        yanked_versions_set: Set[CandidateVersion] = set()\n        for c in cands:\n            is_yanked = c.link.is_yanked if c.link else False\n            if is_yanked:\n                yanked_versions_set.add(c.version)\n            else:\n                versions_set.add(c.version)\n\n        versions = [str(v) for v in sorted(versions_set)]\n        yanked_versions = [str(v) for v in sorted(yanked_versions_set)]\n\n        if yanked_versions:\n            # Saying \"version X is yanked\" isn't entirely accurate.\n            # https://github.com/pypa/pip/issues/11745#issuecomment-1402805842\n            logger.critical(\n                \"Ignored the following yanked versions: %s\",\n                \", \".join(yanked_versions) or \"none\",\n            )\n        if skipped_by_requires_python:\n            logger.critical(\n                \"Ignored the following versions that require a different python \"\n                \"version: %s\",\n                \"; \".join(skipped_by_requires_python) or \"none\",\n            )\n        logger.critical(\n            \"Could not find a version that satisfies the requirement %s \"\n            \"(from versions: %s)\",\n            req_disp,\n            \", \".join(versions) or \"none\",\n        )\n        if str(req) == \"requirements.txt\":\n            logger.info(\n                \"HINT: You are attempting to install a package literally \"\n                'named \"requirements.txt\" (which cannot exist). Consider '\n                \"using the '-r' flag to install the packages listed in \"\n                \"requirements.txt\"\n            )\n\n        return DistributionNotFound(f\"No matching distribution found for {req}\")\n\n    def get_installation_error(\n        self,\n        e: \"ResolutionImpossible[Requirement, Candidate]\",\n        constraints: Dict[str, Constraint],\n    ) -> InstallationError:\n        assert e.causes, \"Installation error reported with no cause\"\n\n        # If one of the things we can't solve is \"we need Python X.Y\",\n        # that is what we report.\n        requires_python_causes = [\n            cause\n            for cause in e.causes\n            if isinstance(cause.requirement, RequiresPythonRequirement)\n            and not cause.requirement.is_satisfied_by(self._python_candidate)\n        ]\n        if requires_python_causes:\n            # The comprehension above makes sure all Requirement instances are\n            # RequiresPythonRequirement, so let's cast for convenience.\n            return self._report_requires_python_error(\n                cast(\"Sequence[ConflictCause]\", requires_python_causes),\n            )\n\n        # Otherwise, we have a set of causes which can't all be satisfied\n        # at once.\n\n        # The simplest case is when we have *one* cause that can't be\n        # satisfied. We just report that case.\n        if len(e.causes) == 1:\n            req, parent = e.causes[0]\n            if req.name not in constraints:\n                return self._report_single_requirement_conflict(req, parent)\n\n        # OK, we now have a list of requirements that can't all be\n        # satisfied at once.\n\n        # A couple of formatting helpers\n        def text_join(parts: List[str]) -> str:\n            if len(parts) == 1:\n                return parts[0]\n\n            return \", \".join(parts[:-1]) + \" and \" + parts[-1]\n\n        def describe_trigger(parent: Candidate) -> str:\n            ireq = parent.get_install_requirement()\n            if not ireq or not ireq.comes_from:\n                return f\"{parent.name}=={parent.version}\"\n            if isinstance(ireq.comes_from, InstallRequirement):\n                return str(ireq.comes_from.name)\n            return str(ireq.comes_from)\n\n        triggers = set()\n        for req, parent in e.causes:\n            if parent is None:\n                # This is a root requirement, so we can report it directly\n                trigger = req.format_for_error()\n            else:\n                trigger = describe_trigger(parent)\n            triggers.add(trigger)\n\n        if triggers:\n            info = text_join(sorted(triggers))\n        else:\n            info = \"the requested packages\"\n\n        msg = (\n            f\"Cannot install {info} because these package versions \"\n            \"have conflicting dependencies.\"\n        )\n        logger.critical(msg)\n        msg = \"\\nThe conflict is caused by:\"\n\n        relevant_constraints = set()\n        for req, parent in e.causes:\n            if req.name in constraints:\n                relevant_constraints.add(req.name)\n            msg = msg + \"\\n    \"\n            if parent:\n                msg = msg + f\"{parent.name} {parent.version} depends on \"\n            else:\n                msg = msg + \"The user requested \"\n            msg = msg + req.format_for_error()\n        for key in relevant_constraints:\n            spec = constraints[key].specifier\n            msg += f\"\\n    The user requested (constraint) {key}{spec}\"\n\n        msg = (\n            msg\n            + \"\\n\\n\"\n            + \"To fix this you could try to:\\n\"\n            + \"1. loosen the range of package versions you've specified\\n\"\n            + \"2. remove package versions to allow pip attempt to solve \"\n            + \"the dependency conflict\\n\"\n        )\n\n        logger.info(msg)\n\n        return DistributionNotFound(\n            \"ResolutionImpossible: for help visit \"\n            \"https://pip.pypa.io/en/latest/topics/dependency-resolution/\"\n            \"#dealing-with-dependency-conflicts\"\n        )\n"},"hash":"7hZJRDeb58"}