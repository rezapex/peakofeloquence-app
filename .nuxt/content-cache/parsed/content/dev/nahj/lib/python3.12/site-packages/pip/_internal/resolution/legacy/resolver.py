{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:resolution:legacy:resolver.py","body":"\"\"\"Dependency Resolution\n\nThe dependency resolution in pip is performed as follows:\n\nfor top-level requirements:\n    a. only one spec allowed per project, regardless of conflicts or not.\n       otherwise a \"double requirement\" exception is raised\n    b. they override sub-dependency requirements.\nfor sub-dependencies\n    a. \"first found, wins\" (where the order is breadth first)\n\"\"\"\n\n# The following comment should be removed at some point in the future.\n# mypy: strict-optional=False\n\nimport logging\nimport sys\nfrom collections import defaultdict\nfrom itertools import chain\nfrom typing import DefaultDict, Iterable, List, Optional, Set, Tuple\n\nfrom pip._vendor.packaging import specifiers\nfrom pip._vendor.packaging.requirements import Requirement\n\nfrom pip._internal.cache import WheelCache\nfrom pip._internal.exceptions import (\n    BestVersionAlreadyInstalled,\n    DistributionNotFound,\n    HashError,\n    HashErrors,\n    InstallationError,\n    NoneMetadataError,\n    UnsupportedPythonVersion,\n)\nfrom pip._internal.index.package_finder import PackageFinder\nfrom pip._internal.metadata import BaseDistribution\nfrom pip._internal.models.link import Link\nfrom pip._internal.models.wheel import Wheel\nfrom pip._internal.operations.prepare import RequirementPreparer\nfrom pip._internal.req.req_install import (\n    InstallRequirement,\n    check_invalid_constraint_type,\n)\nfrom pip._internal.req.req_set import RequirementSet\nfrom pip._internal.resolution.base import BaseResolver, InstallRequirementProvider\nfrom pip._internal.utils import compatibility_tags\nfrom pip._internal.utils.compatibility_tags import get_supported\nfrom pip._internal.utils.direct_url_helpers import direct_url_from_link\nfrom pip._internal.utils.logging import indent_log\nfrom pip._internal.utils.misc import normalize_version_info\nfrom pip._internal.utils.packaging import check_requires_python\n\nlogger = logging.getLogger(__name__)\n\nDiscoveredDependencies = DefaultDict[str, List[InstallRequirement]]\n\n\ndef _check_dist_requires_python(\n    dist: BaseDistribution,\n    version_info: Tuple[int, int, int],\n    ignore_requires_python: bool = False,\n) -> None:\n    \"\"\"\n    Check whether the given Python version is compatible with a distribution's\n    \"Requires-Python\" value.\n\n    :param version_info: A 3-tuple of ints representing the Python\n        major-minor-micro version to check.\n    :param ignore_requires_python: Whether to ignore the \"Requires-Python\"\n        value if the given Python version isn't compatible.\n\n    :raises UnsupportedPythonVersion: When the given Python version isn't\n        compatible.\n    \"\"\"\n    # This idiosyncratically converts the SpecifierSet to str and let\n    # check_requires_python then parse it again into SpecifierSet. But this\n    # is the legacy resolver so I'm just not going to bother refactoring.\n    try:\n        requires_python = str(dist.requires_python)\n    except FileNotFoundError as e:\n        raise NoneMetadataError(dist, str(e))\n    try:\n        is_compatible = check_requires_python(\n            requires_python,\n            version_info=version_info,\n        )\n    except specifiers.InvalidSpecifier as exc:\n        logger.warning(\n            \"Package %r has an invalid Requires-Python: %s\", dist.raw_name, exc\n        )\n        return\n\n    if is_compatible:\n        return\n\n    version = \".\".join(map(str, version_info))\n    if ignore_requires_python:\n        logger.debug(\n            \"Ignoring failed Requires-Python check for package %r: %s not in %r\",\n            dist.raw_name,\n            version,\n            requires_python,\n        )\n        return\n\n    raise UnsupportedPythonVersion(\n        \"Package {!r} requires a different Python: {} not in {!r}\".format(\n            dist.raw_name, version, requires_python\n        )\n    )\n\n\nclass Resolver(BaseResolver):\n    \"\"\"Resolves which packages need to be installed/uninstalled to perform \\\n    the requested operation without breaking the requirements of any package.\n    \"\"\"\n\n    _allowed_strategies = {\"eager\", \"only-if-needed\", \"to-satisfy-only\"}\n\n    def __init__(\n        self,\n        preparer: RequirementPreparer,\n        finder: PackageFinder,\n        wheel_cache: Optional[WheelCache],\n        make_install_req: InstallRequirementProvider,\n        use_user_site: bool,\n        ignore_dependencies: bool,\n        ignore_installed: bool,\n        ignore_requires_python: bool,\n        force_reinstall: bool,\n        upgrade_strategy: str,\n        py_version_info: Optional[Tuple[int, ...]] = None,\n    ) -> None:\n        super().__init__()\n        assert upgrade_strategy in self._allowed_strategies\n\n        if py_version_info is None:\n            py_version_info = sys.version_info[:3]\n        else:\n            py_version_info = normalize_version_info(py_version_info)\n\n        self._py_version_info = py_version_info\n\n        self.preparer = preparer\n        self.finder = finder\n        self.wheel_cache = wheel_cache\n\n        self.upgrade_strategy = upgrade_strategy\n        self.force_reinstall = force_reinstall\n        self.ignore_dependencies = ignore_dependencies\n        self.ignore_installed = ignore_installed\n        self.ignore_requires_python = ignore_requires_python\n        self.use_user_site = use_user_site\n        self._make_install_req = make_install_req\n\n        self._discovered_dependencies: DiscoveredDependencies = defaultdict(list)\n\n    def resolve(\n        self, root_reqs: List[InstallRequirement], check_supported_wheels: bool\n    ) -> RequirementSet:\n        \"\"\"Resolve what operations need to be done\n\n        As a side-effect of this method, the packages (and their dependencies)\n        are downloaded, unpacked and prepared for installation. This\n        preparation is done by ``pip.operations.prepare``.\n\n        Once PyPI has static dependency metadata available, it would be\n        possible to move the preparation to become a step separated from\n        dependency resolution.\n        \"\"\"\n        requirement_set = RequirementSet(check_supported_wheels=check_supported_wheels)\n        for req in root_reqs:\n            if req.constraint:\n                check_invalid_constraint_type(req)\n            self._add_requirement_to_set(requirement_set, req)\n\n        # Actually prepare the files, and collect any exceptions. Most hash\n        # exceptions cannot be checked ahead of time, because\n        # _populate_link() needs to be called before we can make decisions\n        # based on link type.\n        discovered_reqs: List[InstallRequirement] = []\n        hash_errors = HashErrors()\n        for req in chain(requirement_set.all_requirements, discovered_reqs):\n            try:\n                discovered_reqs.extend(self._resolve_one(requirement_set, req))\n            except HashError as exc:\n                exc.req = req\n                hash_errors.append(exc)\n\n        if hash_errors:\n            raise hash_errors\n\n        return requirement_set\n\n    def _add_requirement_to_set(\n        self,\n        requirement_set: RequirementSet,\n        install_req: InstallRequirement,\n        parent_req_name: Optional[str] = None,\n        extras_requested: Optional[Iterable[str]] = None,\n    ) -> Tuple[List[InstallRequirement], Optional[InstallRequirement]]:\n        \"\"\"Add install_req as a requirement to install.\n\n        :param parent_req_name: The name of the requirement that needed this\n            added. The name is used because when multiple unnamed requirements\n            resolve to the same name, we could otherwise end up with dependency\n            links that point outside the Requirements set. parent_req must\n            already be added. Note that None implies that this is a user\n            supplied requirement, vs an inferred one.\n        :param extras_requested: an iterable of extras used to evaluate the\n            environment markers.\n        :return: Additional requirements to scan. That is either [] if\n            the requirement is not applicable, or [install_req] if the\n            requirement is applicable and has just been added.\n        \"\"\"\n        # If the markers do not match, ignore this requirement.\n        if not install_req.match_markers(extras_requested):\n            logger.info(\n                \"Ignoring %s: markers '%s' don't match your environment\",\n                install_req.name,\n                install_req.markers,\n            )\n            return [], None\n\n        # If the wheel is not supported, raise an error.\n        # Should check this after filtering out based on environment markers to\n        # allow specifying different wheels based on the environment/OS, in a\n        # single requirements file.\n        if install_req.link and install_req.link.is_wheel:\n            wheel = Wheel(install_req.link.filename)\n            tags = compatibility_tags.get_supported()\n            if requirement_set.check_supported_wheels and not wheel.supported(tags):\n                raise InstallationError(\n                    f\"{wheel.filename} is not a supported wheel on this platform.\"\n                )\n\n        # This next bit is really a sanity check.\n        assert (\n            not install_req.user_supplied or parent_req_name is None\n        ), \"a user supplied req shouldn't have a parent\"\n\n        # Unnamed requirements are scanned again and the requirement won't be\n        # added as a dependency until after scanning.\n        if not install_req.name:\n            requirement_set.add_unnamed_requirement(install_req)\n            return [install_req], None\n\n        try:\n            existing_req: Optional[\n                InstallRequirement\n            ] = requirement_set.get_requirement(install_req.name)\n        except KeyError:\n            existing_req = None\n\n        has_conflicting_requirement = (\n            parent_req_name is None\n            and existing_req\n            and not existing_req.constraint\n            and existing_req.extras == install_req.extras\n            and existing_req.req\n            and install_req.req\n            and existing_req.req.specifier != install_req.req.specifier\n        )\n        if has_conflicting_requirement:\n            raise InstallationError(\n                \"Double requirement given: {} (already in {}, name={!r})\".format(\n                    install_req, existing_req, install_req.name\n                )\n            )\n\n        # When no existing requirement exists, add the requirement as a\n        # dependency and it will be scanned again after.\n        if not existing_req:\n            requirement_set.add_named_requirement(install_req)\n            # We'd want to rescan this requirement later\n            return [install_req], install_req\n\n        # Assume there's no need to scan, and that we've already\n        # encountered this for scanning.\n        if install_req.constraint or not existing_req.constraint:\n            return [], existing_req\n\n        does_not_satisfy_constraint = install_req.link and not (\n            existing_req.link and install_req.link.path == existing_req.link.path\n        )\n        if does_not_satisfy_constraint:\n            raise InstallationError(\n                f\"Could not satisfy constraints for '{install_req.name}': \"\n                \"installation from path or url cannot be \"\n                \"constrained to a version\"\n            )\n        # If we're now installing a constraint, mark the existing\n        # object for real installation.\n        existing_req.constraint = False\n        # If we're now installing a user supplied requirement,\n        # mark the existing object as such.\n        if install_req.user_supplied:\n            existing_req.user_supplied = True\n        existing_req.extras = tuple(\n            sorted(set(existing_req.extras) | set(install_req.extras))\n        )\n        logger.debug(\n            \"Setting %s extras to: %s\",\n            existing_req,\n            existing_req.extras,\n        )\n        # Return the existing requirement for addition to the parent and\n        # scanning again.\n        return [existing_req], existing_req\n\n    def _is_upgrade_allowed(self, req: InstallRequirement) -> bool:\n        if self.upgrade_strategy == \"to-satisfy-only\":\n            return False\n        elif self.upgrade_strategy == \"eager\":\n            return True\n        else:\n            assert self.upgrade_strategy == \"only-if-needed\"\n            return req.user_supplied or req.constraint\n\n    def _set_req_to_reinstall(self, req: InstallRequirement) -> None:\n        \"\"\"\n        Set a requirement to be installed.\n        \"\"\"\n        # Don't uninstall the conflict if doing a user install and the\n        # conflict is not a user install.\n        if not self.use_user_site or req.satisfied_by.in_usersite:\n            req.should_reinstall = True\n        req.satisfied_by = None\n\n    def _check_skip_installed(\n        self, req_to_install: InstallRequirement\n    ) -> Optional[str]:\n        \"\"\"Check if req_to_install should be skipped.\n\n        This will check if the req is installed, and whether we should upgrade\n        or reinstall it, taking into account all the relevant user options.\n\n        After calling this req_to_install will only have satisfied_by set to\n        None if the req_to_install is to be upgraded/reinstalled etc. Any\n        other value will be a dist recording the current thing installed that\n        satisfies the requirement.\n\n        Note that for vcs urls and the like we can't assess skipping in this\n        routine - we simply identify that we need to pull the thing down,\n        then later on it is pulled down and introspected to assess upgrade/\n        reinstalls etc.\n\n        :return: A text reason for why it was skipped, or None.\n        \"\"\"\n        if self.ignore_installed:\n            return None\n\n        req_to_install.check_if_exists(self.use_user_site)\n        if not req_to_install.satisfied_by:\n            return None\n\n        if self.force_reinstall:\n            self._set_req_to_reinstall(req_to_install)\n            return None\n\n        if not self._is_upgrade_allowed(req_to_install):\n            if self.upgrade_strategy == \"only-if-needed\":\n                return \"already satisfied, skipping upgrade\"\n            return \"already satisfied\"\n\n        # Check for the possibility of an upgrade.  For link-based\n        # requirements we have to pull the tree down and inspect to assess\n        # the version #, so it's handled way down.\n        if not req_to_install.link:\n            try:\n                self.finder.find_requirement(req_to_install, upgrade=True)\n            except BestVersionAlreadyInstalled:\n                # Then the best version is installed.\n                return \"already up-to-date\"\n            except DistributionNotFound:\n                # No distribution found, so we squash the error.  It will\n                # be raised later when we re-try later to do the install.\n                # Why don't we just raise here?\n                pass\n\n        self._set_req_to_reinstall(req_to_install)\n        return None\n\n    def _find_requirement_link(self, req: InstallRequirement) -> Optional[Link]:\n        upgrade = self._is_upgrade_allowed(req)\n        best_candidate = self.finder.find_requirement(req, upgrade)\n        if not best_candidate:\n            return None\n\n        # Log a warning per PEP 592 if necessary before returning.\n        link = best_candidate.link\n        if link.is_yanked:\n            reason = link.yanked_reason or \"<none given>\"\n            msg = (\n                # Mark this as a unicode string to prevent\n                # \"UnicodeEncodeError: 'ascii' codec can't encode character\"\n                # in Python 2 when the reason contains non-ascii characters.\n                \"The candidate selected for download or install is a \"\n                f\"yanked version: {best_candidate}\\n\"\n                f\"Reason for being yanked: {reason}\"\n            )\n            logger.warning(msg)\n\n        return link\n\n    def _populate_link(self, req: InstallRequirement) -> None:\n        \"\"\"Ensure that if a link can be found for this, that it is found.\n\n        Note that req.link may still be None - if the requirement is already\n        installed and not needed to be upgraded based on the return value of\n        _is_upgrade_allowed().\n\n        If preparer.require_hashes is True, don't use the wheel cache, because\n        cached wheels, always built locally, have different hashes than the\n        files downloaded from the index server and thus throw false hash\n        mismatches. Furthermore, cached wheels at present have undeterministic\n        contents due to file modification times.\n        \"\"\"\n        if req.link is None:\n            req.link = self._find_requirement_link(req)\n\n        if self.wheel_cache is None or self.preparer.require_hashes:\n            return\n        cache_entry = self.wheel_cache.get_cache_entry(\n            link=req.link,\n            package_name=req.name,\n            supported_tags=get_supported(),\n        )\n        if cache_entry is not None:\n            logger.debug(\"Using cached wheel link: %s\", cache_entry.link)\n            if req.link is req.original_link and cache_entry.persistent:\n                req.cached_wheel_source_link = req.link\n            if cache_entry.origin is not None:\n                req.download_info = cache_entry.origin\n            else:\n                # Legacy cache entry that does not have origin.json.\n                # download_info may miss the archive_info.hashes field.\n                req.download_info = direct_url_from_link(\n                    req.link, link_is_in_wheel_cache=cache_entry.persistent\n                )\n            req.link = cache_entry.link\n\n    def _get_dist_for(self, req: InstallRequirement) -> BaseDistribution:\n        \"\"\"Takes a InstallRequirement and returns a single AbstractDist \\\n        representing a prepared variant of the same.\n        \"\"\"\n        if req.editable:\n            return self.preparer.prepare_editable_requirement(req)\n\n        # satisfied_by is only evaluated by calling _check_skip_installed,\n        # so it must be None here.\n        assert req.satisfied_by is None\n        skip_reason = self._check_skip_installed(req)\n\n        if req.satisfied_by:\n            return self.preparer.prepare_installed_requirement(req, skip_reason)\n\n        # We eagerly populate the link, since that's our \"legacy\" behavior.\n        self._populate_link(req)\n        dist = self.preparer.prepare_linked_requirement(req)\n\n        # NOTE\n        # The following portion is for determining if a certain package is\n        # going to be re-installed/upgraded or not and reporting to the user.\n        # This should probably get cleaned up in a future refactor.\n\n        # req.req is only avail after unpack for URL\n        # pkgs repeat check_if_exists to uninstall-on-upgrade\n        # (#14)\n        if not self.ignore_installed:\n            req.check_if_exists(self.use_user_site)\n\n        if req.satisfied_by:\n            should_modify = (\n                self.upgrade_strategy != \"to-satisfy-only\"\n                or self.force_reinstall\n                or self.ignore_installed\n                or req.link.scheme == \"file\"\n            )\n            if should_modify:\n                self._set_req_to_reinstall(req)\n            else:\n                logger.info(\n                    \"Requirement already satisfied (use --upgrade to upgrade): %s\",\n                    req,\n                )\n        return dist\n\n    def _resolve_one(\n        self,\n        requirement_set: RequirementSet,\n        req_to_install: InstallRequirement,\n    ) -> List[InstallRequirement]:\n        \"\"\"Prepare a single requirements file.\n\n        :return: A list of additional InstallRequirements to also install.\n        \"\"\"\n        # Tell user what we are doing for this requirement:\n        # obtain (editable), skipping, processing (local url), collecting\n        # (remote url or package name)\n        if req_to_install.constraint or req_to_install.prepared:\n            return []\n\n        req_to_install.prepared = True\n\n        # Parse and return dependencies\n        dist = self._get_dist_for(req_to_install)\n        # This will raise UnsupportedPythonVersion if the given Python\n        # version isn't compatible with the distribution's Requires-Python.\n        _check_dist_requires_python(\n            dist,\n            version_info=self._py_version_info,\n            ignore_requires_python=self.ignore_requires_python,\n        )\n\n        more_reqs: List[InstallRequirement] = []\n\n        def add_req(subreq: Requirement, extras_requested: Iterable[str]) -> None:\n            # This idiosyncratically converts the Requirement to str and let\n            # make_install_req then parse it again into Requirement. But this is\n            # the legacy resolver so I'm just not going to bother refactoring.\n            sub_install_req = self._make_install_req(str(subreq), req_to_install)\n            parent_req_name = req_to_install.name\n            to_scan_again, add_to_parent = self._add_requirement_to_set(\n                requirement_set,\n                sub_install_req,\n                parent_req_name=parent_req_name,\n                extras_requested=extras_requested,\n            )\n            if parent_req_name and add_to_parent:\n                self._discovered_dependencies[parent_req_name].append(add_to_parent)\n            more_reqs.extend(to_scan_again)\n\n        with indent_log():\n            # We add req_to_install before its dependencies, so that we\n            # can refer to it when adding dependencies.\n            if not requirement_set.has_requirement(req_to_install.name):\n                # 'unnamed' requirements will get added here\n                # 'unnamed' requirements can only come from being directly\n                # provided by the user.\n                assert req_to_install.user_supplied\n                self._add_requirement_to_set(\n                    requirement_set, req_to_install, parent_req_name=None\n                )\n\n            if not self.ignore_dependencies:\n                if req_to_install.extras:\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        \",\".join(req_to_install.extras),\n                    )\n                missing_requested = sorted(\n                    set(req_to_install.extras) - set(dist.iter_provided_extras())\n                )\n                for missing in missing_requested:\n                    logger.warning(\n                        \"%s %s does not provide the extra '%s'\",\n                        dist.raw_name,\n                        dist.version,\n                        missing,\n                    )\n\n                available_requested = sorted(\n                    set(dist.iter_provided_extras()) & set(req_to_install.extras)\n                )\n                for subreq in dist.iter_dependencies(available_requested):\n                    add_req(subreq, extras_requested=available_requested)\n\n        return more_reqs\n\n    def get_installation_order(\n        self, req_set: RequirementSet\n    ) -> List[InstallRequirement]:\n        \"\"\"Create the installation order.\n\n        The installation order is topological - requirements are installed\n        before the requiring thing. We break cycles at an arbitrary point,\n        and make no other guarantees.\n        \"\"\"\n        # The current implementation, which we may change at any point\n        # installs the user specified things in the order given, except when\n        # dependencies must come earlier to achieve topological order.\n        order = []\n        ordered_reqs: Set[InstallRequirement] = set()\n\n        def schedule(req: InstallRequirement) -> None:\n            if req.satisfied_by or req in ordered_reqs:\n                return\n            if req.constraint:\n                return\n            ordered_reqs.add(req)\n            for dep in self._discovered_dependencies[req.name]:\n                schedule(dep)\n            order.append(req)\n\n        for install_req in req_set.requirements.values():\n            schedule(install_req)\n        return order\n"},"hash":"WpoZG3KmLe"}