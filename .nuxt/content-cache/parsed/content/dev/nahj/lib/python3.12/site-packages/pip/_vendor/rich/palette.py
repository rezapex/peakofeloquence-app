{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:rich:palette.py","body":"from math import sqrt\nfrom functools import lru_cache\nfrom typing import Sequence, Tuple, TYPE_CHECKING\n\nfrom .color_triplet import ColorTriplet\n\nif TYPE_CHECKING:\n    from pip._vendor.rich.table import Table\n\n\nclass Palette:\n    \"\"\"A palette of available colors.\"\"\"\n\n    def __init__(self, colors: Sequence[Tuple[int, int, int]]):\n        self._colors = colors\n\n    def __getitem__(self, number: int) -> ColorTriplet:\n        return ColorTriplet(*self._colors[number])\n\n    def __rich__(self) -> \"Table\":\n        from pip._vendor.rich.color import Color\n        from pip._vendor.rich.style import Style\n        from pip._vendor.rich.text import Text\n        from pip._vendor.rich.table import Table\n\n        table = Table(\n            \"index\",\n            \"RGB\",\n            \"Color\",\n            title=\"Palette\",\n            caption=f\"{len(self._colors)} colors\",\n            highlight=True,\n            caption_justify=\"right\",\n        )\n        for index, color in enumerate(self._colors):\n            table.add_row(\n                str(index),\n                repr(color),\n                Text(\" \" * 16, style=Style(bgcolor=Color.from_rgb(*color))),\n            )\n        return table\n\n    # This is somewhat inefficient and needs caching\n    @lru_cache(maxsize=1024)\n    def match(self, color: Tuple[int, int, int]) -> int:\n        \"\"\"Find a color from a palette that most closely matches a given color.\n\n        Args:\n            color (Tuple[int, int, int]): RGB components in range 0 > 255.\n\n        Returns:\n            int: Index of closes matching color.\n        \"\"\"\n        red1, green1, blue1 = color\n        _sqrt = sqrt\n        get_color = self._colors.__getitem__\n\n        def get_color_distance(index: int) -> float:\n            \"\"\"Get the distance to a color.\"\"\"\n            red2, green2, blue2 = get_color(index)\n            red_mean = (red1 + red2) // 2\n            red = red1 - red2\n            green = green1 - green2\n            blue = blue1 - blue2\n            return _sqrt(\n                (((512 + red_mean) * red * red) >> 8)\n                + 4 * green * green\n                + (((767 - red_mean) * blue * blue) >> 8)\n            )\n\n        min_index = min(range(len(self._colors)), key=get_color_distance)\n        return min_index\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    import colorsys\n    from typing import Iterable\n    from pip._vendor.rich.color import Color\n    from pip._vendor.rich.console import Console, ConsoleOptions\n    from pip._vendor.rich.segment import Segment\n    from pip._vendor.rich.style import Style\n\n    class ColorBox:\n        def __rich_console__(\n            self, console: Console, options: ConsoleOptions\n        ) -> Iterable[Segment]:\n            height = console.size.height - 3\n            for y in range(0, height):\n                for x in range(options.max_width):\n                    h = x / options.max_width\n                    l = y / (height + 1)\n                    r1, g1, b1 = colorsys.hls_to_rgb(h, l, 1.0)\n                    r2, g2, b2 = colorsys.hls_to_rgb(h, l + (1 / height / 2), 1.0)\n                    bgcolor = Color.from_rgb(r1 * 255, g1 * 255, b1 * 255)\n                    color = Color.from_rgb(r2 * 255, g2 * 255, b2 * 255)\n                    yield Segment(\"â–„\", Style(color=color, bgcolor=bgcolor))\n                yield Segment.line()\n\n    console = Console()\n    console.print(ColorBox())\n"},"hash":"3CRiMp92AV"}