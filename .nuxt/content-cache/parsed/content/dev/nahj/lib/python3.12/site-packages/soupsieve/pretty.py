{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:soupsieve:pretty.py","body":"\"\"\"\nFormat a pretty string of a `SoupSieve` object for easy debugging.\n\nThis won't necessarily support all types and such, and definitely\nnot support custom outputs.\n\nIt is mainly geared towards our types as the `SelectorList`\nobject is a beast to look at without some indentation and newlines.\nThe format and various output types is fairly known (though it\nhasn't been tested extensively to make sure we aren't missing corners).\n\nExample:\n-------\n```\n>>> import soupsieve as sv\n>>> sv.compile('this > that.class[name=value]').selectors.pretty()\nSelectorList(\n    selectors=(\n        Selector(\n            tag=SelectorTag(\n                name='that',\n                prefix=None),\n            ids=(),\n            classes=(\n                'class',\n                ),\n            attributes=(\n                SelectorAttribute(\n                    attribute='name',\n                    prefix='',\n                    pattern=re.compile(\n                        '^value$'),\n                    xml_type_pattern=None),\n                ),\n            nth=(),\n            selectors=(),\n            relation=SelectorList(\n                selectors=(\n                    Selector(\n                        tag=SelectorTag(\n                            name='this',\n                            prefix=None),\n                        ids=(),\n                        classes=(),\n                        attributes=(),\n                        nth=(),\n                        selectors=(),\n                        relation=SelectorList(\n                            selectors=(),\n                            is_not=False,\n                            is_html=False),\n                        rel_type='>',\n                        contains=(),\n                        lang=(),\n                        flags=0),\n                    ),\n                is_not=False,\n                is_html=False),\n            rel_type=None,\n            contains=(),\n            lang=(),\n            flags=0),\n        ),\n    is_not=False,\n    is_html=False)\n```\n\n\"\"\"\nfrom __future__ import annotations\nimport re\nfrom typing import Any\n\nRE_CLASS = re.compile(r'(?i)[a-z_][_a-z\\d\\.]+\\(')\nRE_PARAM = re.compile(r'(?i)[_a-z][_a-z\\d]+=')\nRE_EMPTY = re.compile(r'\\(\\)|\\[\\]|\\{\\}')\nRE_LSTRT = re.compile(r'\\[')\nRE_DSTRT = re.compile(r'\\{')\nRE_TSTRT = re.compile(r'\\(')\nRE_LEND = re.compile(r'\\]')\nRE_DEND = re.compile(r'\\}')\nRE_TEND = re.compile(r'\\)')\nRE_INT = re.compile(r'\\d+')\nRE_KWORD = re.compile(r'(?i)[_a-z][_a-z\\d]+')\nRE_DQSTR = re.compile(r'\"(?:\\\\.|[^\"\\\\])*\"')\nRE_SQSTR = re.compile(r\"'(?:\\\\.|[^'\\\\])*'\")\nRE_SEP = re.compile(r'\\s*(,)\\s*')\nRE_DSEP = re.compile(r'\\s*(:)\\s*')\n\nTOKENS = {\n    'class': RE_CLASS,\n    'param': RE_PARAM,\n    'empty': RE_EMPTY,\n    'lstrt': RE_LSTRT,\n    'dstrt': RE_DSTRT,\n    'tstrt': RE_TSTRT,\n    'lend': RE_LEND,\n    'dend': RE_DEND,\n    'tend': RE_TEND,\n    'sqstr': RE_SQSTR,\n    'sep': RE_SEP,\n    'dsep': RE_DSEP,\n    'int': RE_INT,\n    'kword': RE_KWORD,\n    'dqstr': RE_DQSTR\n}\n\n\ndef pretty(obj: Any) -> str:  # pragma: no cover\n    \"\"\"Make the object output string pretty.\"\"\"\n\n    sel = str(obj)\n    index = 0\n    end = len(sel) - 1\n    indent = 0\n    output = []\n\n    while index <= end:\n        m = None\n        for k, v in TOKENS.items():\n            m = v.match(sel, index)\n\n            if m:\n                name = k\n                index = m.end(0)\n                if name in ('class', 'lstrt', 'dstrt', 'tstrt'):\n                    indent += 4\n                    output.append(f'{m.group(0)}\\n{\" \" * indent}')\n                elif name in ('param', 'int', 'kword', 'sqstr', 'dqstr', 'empty'):\n                    output.append(m.group(0))\n                elif name in ('lend', 'dend', 'tend'):\n                    indent -= 4\n                    output.append(m.group(0))\n                elif name in ('sep',):\n                    output.append(f'{m.group(1)}\\n{\" \" * indent}')\n                elif name in ('dsep',):\n                    output.append(f'{m.group(1)} ')\n                break\n\n    return ''.join(output)\n"},"hash":"qFEVG6Uc7e"}