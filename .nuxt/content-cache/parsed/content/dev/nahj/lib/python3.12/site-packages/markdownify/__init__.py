{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:markdownify:__init__.py","body":"from bs4 import BeautifulSoup, NavigableString, Comment, Doctype\nfrom textwrap import fill\nimport re\nimport six\n\n\nconvert_heading_re = re.compile(r'convert_h(\\d+)')\nline_beginning_re = re.compile(r'^', re.MULTILINE)\nwhitespace_re = re.compile(r'[\\t ]+')\nall_whitespace_re = re.compile(r'[\\s]+')\nhtml_heading_re = re.compile(r'h[1-6]')\n\n\n# Heading styles\nATX = 'atx'\nATX_CLOSED = 'atx_closed'\nUNDERLINED = 'underlined'\nSETEXT = UNDERLINED\n\n# Newline style\nSPACES = 'spaces'\nBACKSLASH = 'backslash'\n\n# Strong and emphasis style\nASTERISK = '*'\nUNDERSCORE = '_'\n\n\ndef chomp(text):\n    \"\"\"\n    If the text in an inline tag like b, a, or em contains a leading or trailing\n    space, strip the string and return a space as suffix of prefix, if needed.\n    This function is used to prevent conversions like\n        <b> foo</b> => ** foo**\n    \"\"\"\n    prefix = ' ' if text and text[0] == ' ' else ''\n    suffix = ' ' if text and text[-1] == ' ' else ''\n    text = text.strip()\n    return (prefix, suffix, text)\n\n\ndef abstract_inline_conversion(markup_fn):\n    \"\"\"\n    This abstracts all simple inline tags like b, em, del, ...\n    Returns a function that wraps the chomped text in a pair of the string\n    that is returned by markup_fn. markup_fn is necessary to allow for\n    references to self.strong_em_symbol etc.\n    \"\"\"\n    def implementation(self, el, text, convert_as_inline):\n        markup = markup_fn(self)\n        prefix, suffix, text = chomp(text)\n        if not text:\n            return ''\n        return '%s%s%s%s%s' % (prefix, markup, text, markup, suffix)\n    return implementation\n\n\ndef _todict(obj):\n    return dict((k, getattr(obj, k)) for k in dir(obj) if not k.startswith('_'))\n\n\nclass MarkdownConverter(object):\n    class DefaultOptions:\n        autolinks = True\n        bullets = '*+-'  # An iterable of bullet types.\n        code_language = ''\n        code_language_callback = None\n        convert = None\n        default_title = False\n        escape_asterisks = True\n        escape_underscores = True\n        heading_style = UNDERLINED\n        keep_inline_images_in = []\n        newline_style = SPACES\n        strip = None\n        strong_em_symbol = ASTERISK\n        sub_symbol = ''\n        sup_symbol = ''\n        wrap = False\n        wrap_width = 80\n\n    class Options(DefaultOptions):\n        pass\n\n    def __init__(self, **options):\n        # Create an options dictionary. Use DefaultOptions as a base so that\n        # it doesn't have to be extended.\n        self.options = _todict(self.DefaultOptions)\n        self.options.update(_todict(self.Options))\n        self.options.update(options)\n        if self.options['strip'] is not None and self.options['convert'] is not None:\n            raise ValueError('You may specify either tags to strip or tags to'\n                             ' convert, but not both.')\n\n    def convert(self, html):\n        soup = BeautifulSoup(html, 'html.parser')\n        return self.convert_soup(soup)\n\n    def convert_soup(self, soup):\n        return self.process_tag(soup, convert_as_inline=False, children_only=True)\n\n    def process_tag(self, node, convert_as_inline, children_only=False):\n        text = ''\n\n        # markdown headings or cells can't include\n        # block elements (elements w/newlines)\n        isHeading = html_heading_re.match(node.name) is not None\n        isCell = node.name in ['td', 'th']\n        convert_children_as_inline = convert_as_inline\n\n        if not children_only and (isHeading or isCell):\n            convert_children_as_inline = True\n\n        # Remove whitespace-only textnodes in purely nested nodes\n        def is_nested_node(el):\n            return el and el.name in ['ol', 'ul', 'li',\n                                      'table', 'thead', 'tbody', 'tfoot',\n                                      'tr', 'td', 'th']\n\n        if is_nested_node(node):\n            for el in node.children:\n                # Only extract (remove) whitespace-only text node if any of the\n                # conditions is true:\n                # - el is the first element in its parent\n                # - el is the last element in its parent\n                # - el is adjacent to an nested node\n                can_extract = (not el.previous_sibling\n                               or not el.next_sibling\n                               or is_nested_node(el.previous_sibling)\n                               or is_nested_node(el.next_sibling))\n                if (isinstance(el, NavigableString)\n                        and six.text_type(el).strip() == ''\n                        and can_extract):\n                    el.extract()\n\n        # Convert the children first\n        for el in node.children:\n            if isinstance(el, Comment) or isinstance(el, Doctype):\n                continue\n            elif isinstance(el, NavigableString):\n                text += self.process_text(el)\n            else:\n                text += self.process_tag(el, convert_children_as_inline)\n\n        if not children_only:\n            convert_fn = getattr(self, 'convert_%s' % node.name, None)\n            if convert_fn and self.should_convert_tag(node.name):\n                text = convert_fn(node, text, convert_as_inline)\n\n        return text\n\n    def process_text(self, el):\n        text = six.text_type(el) or ''\n\n        # normalize whitespace if we're not inside a preformatted element\n        if not el.find_parent('pre'):\n            text = whitespace_re.sub(' ', text)\n\n        # escape special characters if we're not inside a preformatted or code element\n        if not el.find_parent(['pre', 'code', 'kbd', 'samp']):\n            text = self.escape(text)\n\n        # remove trailing whitespaces if any of the following condition is true:\n        # - current text node is the last node in li\n        # - current text node is followed by an embedded list\n        if (el.parent.name == 'li'\n                and (not el.next_sibling\n                     or el.next_sibling.name in ['ul', 'ol'])):\n            text = text.rstrip()\n\n        return text\n\n    def __getattr__(self, attr):\n        # Handle headings\n        m = convert_heading_re.match(attr)\n        if m:\n            n = int(m.group(1))\n\n            def convert_tag(el, text, convert_as_inline):\n                return self.convert_hn(n, el, text, convert_as_inline)\n\n            convert_tag.__name__ = 'convert_h%s' % n\n            setattr(self, convert_tag.__name__, convert_tag)\n            return convert_tag\n\n        raise AttributeError(attr)\n\n    def should_convert_tag(self, tag):\n        tag = tag.lower()\n        strip = self.options['strip']\n        convert = self.options['convert']\n        if strip is not None:\n            return tag not in strip\n        elif convert is not None:\n            return tag in convert\n        else:\n            return True\n\n    def escape(self, text):\n        if not text:\n            return ''\n        if self.options['escape_asterisks']:\n            text = text.replace('*', r'\\*')\n        if self.options['escape_underscores']:\n            text = text.replace('_', r'\\_')\n        return text\n\n    def indent(self, text, level):\n        return line_beginning_re.sub('\\t' * level, text) if text else ''\n\n    def underline(self, text, pad_char):\n        text = (text or '').rstrip()\n        return '%s\\n%s\\n\\n' % (text, pad_char * len(text)) if text else ''\n\n    def convert_a(self, el, text, convert_as_inline):\n        prefix, suffix, text = chomp(text)\n        if not text:\n            return ''\n        href = el.get('href')\n        title = el.get('title')\n        # For the replacement see #29: text nodes underscores are escaped\n        if (self.options['autolinks']\n                and text.replace(r'\\_', '_') == href\n                and not title\n                and not self.options['default_title']):\n            # Shortcut syntax\n            return '<%s>' % href\n        if self.options['default_title'] and not title:\n            title = href\n        title_part = ' \"%s\"' % title.replace('\"', r'\\\"') if title else ''\n        return '%s[%s](%s%s)%s' % (prefix, text, href, title_part, suffix) if href else text\n\n    convert_b = abstract_inline_conversion(lambda self: 2 * self.options['strong_em_symbol'])\n\n    def convert_blockquote(self, el, text, convert_as_inline):\n\n        if convert_as_inline:\n            return text\n\n        return '\\n' + (line_beginning_re.sub('> ', text.strip()) + '\\n\\n') if text else ''\n\n    def convert_br(self, el, text, convert_as_inline):\n        if convert_as_inline:\n            return \"\"\n\n        if self.options['newline_style'].lower() == BACKSLASH:\n            return '\\\\\\n'\n        else:\n            return '  \\n'\n\n    def convert_code(self, el, text, convert_as_inline):\n        if el.parent.name == 'pre':\n            return text\n        converter = abstract_inline_conversion(lambda self: '`')\n        return converter(self, el, text, convert_as_inline)\n\n    convert_del = abstract_inline_conversion(lambda self: '~~')\n\n    convert_em = abstract_inline_conversion(lambda self: self.options['strong_em_symbol'])\n\n    convert_kbd = convert_code\n\n    def convert_hn(self, n, el, text, convert_as_inline):\n        if convert_as_inline:\n            return text\n\n        style = self.options['heading_style'].lower()\n        text = text.strip()\n        if style == UNDERLINED and n <= 2:\n            line = '=' if n == 1 else '-'\n            return self.underline(text, line)\n        hashes = '#' * n\n        if style == ATX_CLOSED:\n            return '%s %s %s\\n\\n' % (hashes, text, hashes)\n        return '%s %s\\n\\n' % (hashes, text)\n\n    def convert_hr(self, el, text, convert_as_inline):\n        return '\\n\\n---\\n\\n'\n\n    convert_i = convert_em\n\n    def convert_img(self, el, text, convert_as_inline):\n        alt = el.attrs.get('alt', None) or ''\n        src = el.attrs.get('src', None) or ''\n        title = el.attrs.get('title', None) or ''\n        title_part = ' \"%s\"' % title.replace('\"', r'\\\"') if title else ''\n        if (convert_as_inline\n                and el.parent.name not in self.options['keep_inline_images_in']):\n            return alt\n\n        return '![%s](%s%s)' % (alt, src, title_part)\n\n    def convert_list(self, el, text, convert_as_inline):\n\n        # Converting a list to inline is undefined.\n        # Ignoring convert_to_inline for list.\n\n        nested = False\n        before_paragraph = False\n        if el.next_sibling and el.next_sibling.name not in ['ul', 'ol']:\n            before_paragraph = True\n        while el:\n            if el.name == 'li':\n                nested = True\n                break\n            el = el.parent\n        if nested:\n            # remove trailing newline if nested\n            return '\\n' + self.indent(text, 1).rstrip()\n        return text + ('\\n' if before_paragraph else '')\n\n    convert_ul = convert_list\n    convert_ol = convert_list\n\n    def convert_li(self, el, text, convert_as_inline):\n        parent = el.parent\n        if parent is not None and parent.name == 'ol':\n            if parent.get(\"start\"):\n                start = int(parent.get(\"start\"))\n            else:\n                start = 1\n            bullet = '%s.' % (start + parent.index(el))\n        else:\n            depth = -1\n            while el:\n                if el.name == 'ul':\n                    depth += 1\n                el = el.parent\n            bullets = self.options['bullets']\n            bullet = bullets[depth % len(bullets)]\n        return '%s %s\\n' % (bullet, (text or '').strip())\n\n    def convert_p(self, el, text, convert_as_inline):\n        if convert_as_inline:\n            return text\n        if self.options['wrap']:\n            text = fill(text,\n                        width=self.options['wrap_width'],\n                        break_long_words=False,\n                        break_on_hyphens=False)\n        return '%s\\n\\n' % text if text else ''\n\n    def convert_pre(self, el, text, convert_as_inline):\n        if not text:\n            return ''\n        code_language = self.options['code_language']\n\n        if self.options['code_language_callback']:\n            code_language = self.options['code_language_callback'](el) or code_language\n\n        return '\\n```%s\\n%s\\n```\\n' % (code_language, text)\n\n    def convert_script(self, el, text, convert_as_inline):\n        return ''\n\n    def convert_style(self, el, text, convert_as_inline):\n        return ''\n\n    convert_s = convert_del\n\n    convert_strong = convert_b\n\n    convert_samp = convert_code\n\n    convert_sub = abstract_inline_conversion(lambda self: self.options['sub_symbol'])\n\n    convert_sup = abstract_inline_conversion(lambda self: self.options['sup_symbol'])\n\n    def convert_table(self, el, text, convert_as_inline):\n        return '\\n\\n' + text + '\\n'\n\n    def convert_caption(self, el, text, convert_as_inline):\n        return text + '\\n'\n\n    def convert_figcaption(self, el, text, convert_as_inline):\n        return '\\n\\n' + text + '\\n\\n'\n\n    def convert_td(self, el, text, convert_as_inline):\n        colspan = 1\n        if 'colspan' in el.attrs:\n            colspan = int(el['colspan'])\n        return ' ' + text.strip().replace(\"\\n\", \" \") + ' |' * colspan\n\n    def convert_th(self, el, text, convert_as_inline):\n        colspan = 1\n        if 'colspan' in el.attrs:\n            colspan = int(el['colspan'])\n        return ' ' + text.strip().replace(\"\\n\", \" \") + ' |' * colspan\n\n    def convert_tr(self, el, text, convert_as_inline):\n        cells = el.find_all(['td', 'th'])\n        is_headrow = (\n            all([cell.name == 'th' for cell in cells])\n            or (not el.previous_sibling and not el.parent.name == 'tbody')\n            or (not el.previous_sibling and el.parent.name == 'tbody' and len(el.parent.parent.find_all(['thead'])) < 1)\n        )\n        overline = ''\n        underline = ''\n        if is_headrow and not el.previous_sibling:\n            # first row and is headline: print headline underline\n            full_colspan = 0\n            for cell in cells:\n                if \"colspan\" in cell.attrs:\n                    full_colspan += int(cell[\"colspan\"])\n                else:\n                    full_colspan += 1\n            underline += '| ' + ' | '.join(['---'] * full_colspan) + ' |' + '\\n'\n        elif (not el.previous_sibling\n              and (el.parent.name == 'table'\n                   or (el.parent.name == 'tbody'\n                       and not el.parent.previous_sibling))):\n            # first row, not headline, and:\n            # - the parent is table or\n            # - the parent is tbody at the beginning of a table.\n            # print empty headline above this row\n            overline += '| ' + ' | '.join([''] * len(cells)) + ' |' + '\\n'\n            overline += '| ' + ' | '.join(['---'] * len(cells)) + ' |' + '\\n'\n        return overline + '|' + text + '\\n' + underline\n\n\ndef markdownify(html, **options):\n    return MarkdownConverter(**options).convert(html)\n"},"hash":"U6VEapwizF"}