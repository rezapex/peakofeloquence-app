{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:pygments:formatters:html.py","body":"\"\"\"\n    pygments.formatters.html\n    ~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Formatter for HTML output.\n\n    :copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.\n    :license: BSD, see LICENSE for details.\n\"\"\"\n\nimport functools\nimport os\nimport sys\nimport os.path\nfrom io import StringIO\n\nfrom pip._vendor.pygments.formatter import Formatter\nfrom pip._vendor.pygments.token import Token, Text, STANDARD_TYPES\nfrom pip._vendor.pygments.util import get_bool_opt, get_int_opt, get_list_opt\n\ntry:\n    import ctags\nexcept ImportError:\n    ctags = None\n\n__all__ = ['HtmlFormatter']\n\n\n_escape_html_table = {\n    ord('&'): '&amp;',\n    ord('<'): '&lt;',\n    ord('>'): '&gt;',\n    ord('\"'): '&quot;',\n    ord(\"'\"): '&#39;',\n}\n\n\ndef escape_html(text, table=_escape_html_table):\n    \"\"\"Escape &, <, > as well as single and double quotes for HTML.\"\"\"\n    return text.translate(table)\n\n\ndef webify(color):\n    if color.startswith('calc') or color.startswith('var'):\n        return color\n    else:\n        return '#' + color\n\n\ndef _get_ttype_class(ttype):\n    fname = STANDARD_TYPES.get(ttype)\n    if fname:\n        return fname\n    aname = ''\n    while fname is None:\n        aname = '-' + ttype[-1] + aname\n        ttype = ttype.parent\n        fname = STANDARD_TYPES.get(ttype)\n    return fname + aname\n\n\nCSSFILE_TEMPLATE = '''\\\n/*\ngenerated by Pygments <https://pygments.org/>\nCopyright 2006-2023 by the Pygments team.\nLicensed under the BSD license, see LICENSE for details.\n*/\n%(styledefs)s\n'''\n\nDOC_HEADER = '''\\\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\"\n   \"http://www.w3.org/TR/html4/strict.dtd\">\n<!--\ngenerated by Pygments <https://pygments.org/>\nCopyright 2006-2023 by the Pygments team.\nLicensed under the BSD license, see LICENSE for details.\n-->\n<html>\n<head>\n  <title>%(title)s</title>\n  <meta http-equiv=\"content-type\" content=\"text/html; charset=%(encoding)s\">\n  <style type=\"text/css\">\n''' + CSSFILE_TEMPLATE + '''\n  </style>\n</head>\n<body>\n<h2>%(title)s</h2>\n\n'''\n\nDOC_HEADER_EXTERNALCSS = '''\\\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\"\n   \"http://www.w3.org/TR/html4/strict.dtd\">\n\n<html>\n<head>\n  <title>%(title)s</title>\n  <meta http-equiv=\"content-type\" content=\"text/html; charset=%(encoding)s\">\n  <link rel=\"stylesheet\" href=\"%(cssfile)s\" type=\"text/css\">\n</head>\n<body>\n<h2>%(title)s</h2>\n\n'''\n\nDOC_FOOTER = '''\\\n</body>\n</html>\n'''\n\n\nclass HtmlFormatter(Formatter):\n    r\"\"\"\n    Format tokens as HTML 4 ``<span>`` tags. By default, the content is enclosed\n    in a ``<pre>`` tag, itself wrapped in a ``<div>`` tag (but see the `nowrap` option).\n    The ``<div>``'s CSS class can be set by the `cssclass` option.\n\n    If the `linenos` option is set to ``\"table\"``, the ``<pre>`` is\n    additionally wrapped inside a ``<table>`` which has one row and two\n    cells: one containing the line numbers and one containing the code.\n    Example:\n\n    .. sourcecode:: html\n\n        <div class=\"highlight\" >\n        <table><tr>\n          <td class=\"linenos\" title=\"click to toggle\"\n            onclick=\"with (this.firstChild.style)\n                     { display = (display == '') ? 'none' : '' }\">\n            <pre>1\n            2</pre>\n          </td>\n          <td class=\"code\">\n            <pre><span class=\"Ke\">def </span><span class=\"NaFu\">foo</span>(bar):\n              <span class=\"Ke\">pass</span>\n            </pre>\n          </td>\n        </tr></table></div>\n\n    (whitespace added to improve clarity).\n\n    A list of lines can be specified using the `hl_lines` option to make these\n    lines highlighted (as of Pygments 0.11).\n\n    With the `full` option, a complete HTML 4 document is output, including\n    the style definitions inside a ``<style>`` tag, or in a separate file if\n    the `cssfile` option is given.\n\n    When `tagsfile` is set to the path of a ctags index file, it is used to\n    generate hyperlinks from names to their definition.  You must enable\n    `lineanchors` and run ctags with the `-n` option for this to work.  The\n    `python-ctags` module from PyPI must be installed to use this feature;\n    otherwise a `RuntimeError` will be raised.\n\n    The `get_style_defs(arg='')` method of a `HtmlFormatter` returns a string\n    containing CSS rules for the CSS classes used by the formatter. The\n    argument `arg` can be used to specify additional CSS selectors that\n    are prepended to the classes. A call `fmter.get_style_defs('td .code')`\n    would result in the following CSS classes:\n\n    .. sourcecode:: css\n\n        td .code .kw { font-weight: bold; color: #00FF00 }\n        td .code .cm { color: #999999 }\n        ...\n\n    If you have Pygments 0.6 or higher, you can also pass a list or tuple to the\n    `get_style_defs()` method to request multiple prefixes for the tokens:\n\n    .. sourcecode:: python\n\n        formatter.get_style_defs(['div.syntax pre', 'pre.syntax'])\n\n    The output would then look like this:\n\n    .. sourcecode:: css\n\n        div.syntax pre .kw,\n        pre.syntax .kw { font-weight: bold; color: #00FF00 }\n        div.syntax pre .cm,\n        pre.syntax .cm { color: #999999 }\n        ...\n\n    Additional options accepted:\n\n    `nowrap`\n        If set to ``True``, don't add a ``<pre>`` and a ``<div>`` tag\n        around the tokens. This disables most other options (default: ``False``).\n\n    `full`\n        Tells the formatter to output a \"full\" document, i.e. a complete\n        self-contained document (default: ``False``).\n\n    `title`\n        If `full` is true, the title that should be used to caption the\n        document (default: ``''``).\n\n    `style`\n        The style to use, can be a string or a Style subclass (default:\n        ``'default'``). This option has no effect if the `cssfile`\n        and `noclobber_cssfile` option are given and the file specified in\n        `cssfile` exists.\n\n    `noclasses`\n        If set to true, token ``<span>`` tags (as well as line number elements)\n        will not use CSS classes, but inline styles. This is not recommended\n        for larger pieces of code since it increases output size by quite a bit\n        (default: ``False``).\n\n    `classprefix`\n        Since the token types use relatively short class names, they may clash\n        with some of your own class names. In this case you can use the\n        `classprefix` option to give a string to prepend to all Pygments-generated\n        CSS class names for token types.\n        Note that this option also affects the output of `get_style_defs()`.\n\n    `cssclass`\n        CSS class for the wrapping ``<div>`` tag (default: ``'highlight'``).\n        If you set this option, the default selector for `get_style_defs()`\n        will be this class.\n\n        .. versionadded:: 0.9\n           If you select the ``'table'`` line numbers, the wrapping table will\n           have a CSS class of this string plus ``'table'``, the default is\n           accordingly ``'highlighttable'``.\n\n    `cssstyles`\n        Inline CSS styles for the wrapping ``<div>`` tag (default: ``''``).\n\n    `prestyles`\n        Inline CSS styles for the ``<pre>`` tag (default: ``''``).\n\n        .. versionadded:: 0.11\n\n    `cssfile`\n        If the `full` option is true and this option is given, it must be the\n        name of an external file. If the filename does not include an absolute\n        path, the file's path will be assumed to be relative to the main output\n        file's path, if the latter can be found. The stylesheet is then written\n        to this file instead of the HTML file.\n\n        .. versionadded:: 0.6\n\n    `noclobber_cssfile`\n        If `cssfile` is given and the specified file exists, the css file will\n        not be overwritten. This allows the use of the `full` option in\n        combination with a user specified css file. Default is ``False``.\n\n        .. versionadded:: 1.1\n\n    `linenos`\n        If set to ``'table'``, output line numbers as a table with two cells,\n        one containing the line numbers, the other the whole code.  This is\n        copy-and-paste-friendly, but may cause alignment problems with some\n        browsers or fonts.  If set to ``'inline'``, the line numbers will be\n        integrated in the ``<pre>`` tag that contains the code (that setting\n        is *new in Pygments 0.8*).\n\n        For compatibility with Pygments 0.7 and earlier, every true value\n        except ``'inline'`` means the same as ``'table'`` (in particular, that\n        means also ``True``).\n\n        The default value is ``False``, which means no line numbers at all.\n\n        **Note:** with the default (\"table\") line number mechanism, the line\n        numbers and code can have different line heights in Internet Explorer\n        unless you give the enclosing ``<pre>`` tags an explicit ``line-height``\n        CSS property (you get the default line spacing with ``line-height:\n        125%``).\n\n    `hl_lines`\n        Specify a list of lines to be highlighted. The line numbers are always\n        relative to the input (i.e. the first line is line 1) and are\n        independent of `linenostart`.\n\n        .. versionadded:: 0.11\n\n    `linenostart`\n        The line number for the first line (default: ``1``).\n\n    `linenostep`\n        If set to a number n > 1, only every nth line number is printed.\n\n    `linenospecial`\n        If set to a number n > 0, every nth line number is given the CSS\n        class ``\"special\"`` (default: ``0``).\n\n    `nobackground`\n        If set to ``True``, the formatter won't output the background color\n        for the wrapping element (this automatically defaults to ``False``\n        when there is no wrapping element [eg: no argument for the\n        `get_syntax_defs` method given]) (default: ``False``).\n\n        .. versionadded:: 0.6\n\n    `lineseparator`\n        This string is output between lines of code. It defaults to ``\"\\n\"``,\n        which is enough to break a line inside ``<pre>`` tags, but you can\n        e.g. set it to ``\"<br>\"`` to get HTML line breaks.\n\n        .. versionadded:: 0.7\n\n    `lineanchors`\n        If set to a nonempty string, e.g. ``foo``, the formatter will wrap each\n        output line in an anchor tag with an ``id`` (and `name`) of ``foo-linenumber``.\n        This allows easy linking to certain lines.\n\n        .. versionadded:: 0.9\n\n    `linespans`\n        If set to a nonempty string, e.g. ``foo``, the formatter will wrap each\n        output line in a span tag with an ``id`` of ``foo-linenumber``.\n        This allows easy access to lines via javascript.\n\n        .. versionadded:: 1.6\n\n    `anchorlinenos`\n        If set to `True`, will wrap line numbers in <a> tags. Used in\n        combination with `linenos` and `lineanchors`.\n\n    `tagsfile`\n        If set to the path of a ctags file, wrap names in anchor tags that\n        link to their definitions. `lineanchors` should be used, and the\n        tags file should specify line numbers (see the `-n` option to ctags).\n\n        .. versionadded:: 1.6\n\n    `tagurlformat`\n        A string formatting pattern used to generate links to ctags definitions.\n        Available variables are `%(path)s`, `%(fname)s` and `%(fext)s`.\n        Defaults to an empty string, resulting in just `#prefix-number` links.\n\n        .. versionadded:: 1.6\n\n    `filename`\n        A string used to generate a filename when rendering ``<pre>`` blocks,\n        for example if displaying source code. If `linenos` is set to\n        ``'table'`` then the filename will be rendered in an initial row\n        containing a single `<th>` which spans both columns.\n\n        .. versionadded:: 2.1\n\n    `wrapcode`\n        Wrap the code inside ``<pre>`` blocks using ``<code>``, as recommended\n        by the HTML5 specification.\n\n        .. versionadded:: 2.4\n\n    `debug_token_types`\n        Add ``title`` attributes to all token ``<span>`` tags that show the\n        name of the token.\n\n        .. versionadded:: 2.10\n\n\n    **Subclassing the HTML formatter**\n\n    .. versionadded:: 0.7\n\n    The HTML formatter is now built in a way that allows easy subclassing, thus\n    customizing the output HTML code. The `format()` method calls\n    `self._format_lines()` which returns a generator that yields tuples of ``(1,\n    line)``, where the ``1`` indicates that the ``line`` is a line of the\n    formatted source code.\n\n    If the `nowrap` option is set, the generator is the iterated over and the\n    resulting HTML is output.\n\n    Otherwise, `format()` calls `self.wrap()`, which wraps the generator with\n    other generators. These may add some HTML code to the one generated by\n    `_format_lines()`, either by modifying the lines generated by the latter,\n    then yielding them again with ``(1, line)``, and/or by yielding other HTML\n    code before or after the lines, with ``(0, html)``. The distinction between\n    source lines and other code makes it possible to wrap the generator multiple\n    times.\n\n    The default `wrap()` implementation adds a ``<div>`` and a ``<pre>`` tag.\n\n    A custom `HtmlFormatter` subclass could look like this:\n\n    .. sourcecode:: python\n\n        class CodeHtmlFormatter(HtmlFormatter):\n\n            def wrap(self, source, *, include_div):\n                return self._wrap_code(source)\n\n            def _wrap_code(self, source):\n                yield 0, '<code>'\n                for i, t in source:\n                    if i == 1:\n                        # it's a line of formatted code\n                        t += '<br>'\n                    yield i, t\n                yield 0, '</code>'\n\n    This results in wrapping the formatted lines with a ``<code>`` tag, where the\n    source lines are broken using ``<br>`` tags.\n\n    After calling `wrap()`, the `format()` method also adds the \"line numbers\"\n    and/or \"full document\" wrappers if the respective options are set. Then, all\n    HTML yielded by the wrapped generator is output.\n    \"\"\"\n\n    name = 'HTML'\n    aliases = ['html']\n    filenames = ['*.html', '*.htm']\n\n    def __init__(self, **options):\n        Formatter.__init__(self, **options)\n        self.title = self._decodeifneeded(self.title)\n        self.nowrap = get_bool_opt(options, 'nowrap', False)\n        self.noclasses = get_bool_opt(options, 'noclasses', False)\n        self.classprefix = options.get('classprefix', '')\n        self.cssclass = self._decodeifneeded(options.get('cssclass', 'highlight'))\n        self.cssstyles = self._decodeifneeded(options.get('cssstyles', ''))\n        self.prestyles = self._decodeifneeded(options.get('prestyles', ''))\n        self.cssfile = self._decodeifneeded(options.get('cssfile', ''))\n        self.noclobber_cssfile = get_bool_opt(options, 'noclobber_cssfile', False)\n        self.tagsfile = self._decodeifneeded(options.get('tagsfile', ''))\n        self.tagurlformat = self._decodeifneeded(options.get('tagurlformat', ''))\n        self.filename = self._decodeifneeded(options.get('filename', ''))\n        self.wrapcode = get_bool_opt(options, 'wrapcode', False)\n        self.span_element_openers = {}\n        self.debug_token_types = get_bool_opt(options, 'debug_token_types', False)\n\n        if self.tagsfile:\n            if not ctags:\n                raise RuntimeError('The \"ctags\" package must to be installed '\n                                   'to be able to use the \"tagsfile\" feature.')\n            self._ctags = ctags.CTags(self.tagsfile)\n\n        linenos = options.get('linenos', False)\n        if linenos == 'inline':\n            self.linenos = 2\n        elif linenos:\n            # compatibility with <= 0.7\n            self.linenos = 1\n        else:\n            self.linenos = 0\n        self.linenostart = abs(get_int_opt(options, 'linenostart', 1))\n        self.linenostep = abs(get_int_opt(options, 'linenostep', 1))\n        self.linenospecial = abs(get_int_opt(options, 'linenospecial', 0))\n        self.nobackground = get_bool_opt(options, 'nobackground', False)\n        self.lineseparator = options.get('lineseparator', '\\n')\n        self.lineanchors = options.get('lineanchors', '')\n        self.linespans = options.get('linespans', '')\n        self.anchorlinenos = get_bool_opt(options, 'anchorlinenos', False)\n        self.hl_lines = set()\n        for lineno in get_list_opt(options, 'hl_lines', []):\n            try:\n                self.hl_lines.add(int(lineno))\n            except ValueError:\n                pass\n\n        self._create_stylesheet()\n\n    def _get_css_class(self, ttype):\n        \"\"\"Return the css class of this token type prefixed with\n        the classprefix option.\"\"\"\n        ttypeclass = _get_ttype_class(ttype)\n        if ttypeclass:\n            return self.classprefix + ttypeclass\n        return ''\n\n    def _get_css_classes(self, ttype):\n        \"\"\"Return the CSS classes of this token type prefixed with the classprefix option.\"\"\"\n        cls = self._get_css_class(ttype)\n        while ttype not in STANDARD_TYPES:\n            ttype = ttype.parent\n            cls = self._get_css_class(ttype) + ' ' + cls\n        return cls or ''\n\n    def _get_css_inline_styles(self, ttype):\n        \"\"\"Return the inline CSS styles for this token type.\"\"\"\n        cclass = self.ttype2class.get(ttype)\n        while cclass is None:\n            ttype = ttype.parent\n            cclass = self.ttype2class.get(ttype)\n        return cclass or ''\n\n    def _create_stylesheet(self):\n        t2c = self.ttype2class = {Token: ''}\n        c2s = self.class2style = {}\n        for ttype, ndef in self.style:\n            name = self._get_css_class(ttype)\n            style = ''\n            if ndef['color']:\n                style += 'color: %s; ' % webify(ndef['color'])\n            if ndef['bold']:\n                style += 'font-weight: bold; '\n            if ndef['italic']:\n                style += 'font-style: italic; '\n            if ndef['underline']:\n                style += 'text-decoration: underline; '\n            if ndef['bgcolor']:\n                style += 'background-color: %s; ' % webify(ndef['bgcolor'])\n            if ndef['border']:\n                style += 'border: 1px solid %s; ' % webify(ndef['border'])\n            if style:\n                t2c[ttype] = name\n                # save len(ttype) to enable ordering the styles by\n                # hierarchy (necessary for CSS cascading rules!)\n                c2s[name] = (style[:-2], ttype, len(ttype))\n\n    def get_style_defs(self, arg=None):\n        \"\"\"\n        Return CSS style definitions for the classes produced by the current\n        highlighting style. ``arg`` can be a string or list of selectors to\n        insert before the token type classes.\n        \"\"\"\n        style_lines = []\n\n        style_lines.extend(self.get_linenos_style_defs())\n        style_lines.extend(self.get_background_style_defs(arg))\n        style_lines.extend(self.get_token_style_defs(arg))\n\n        return '\\n'.join(style_lines)\n\n    def get_token_style_defs(self, arg=None):\n        prefix = self.get_css_prefix(arg)\n\n        styles = [\n            (level, ttype, cls, style)\n            for cls, (style, ttype, level) in self.class2style.items()\n            if cls and style\n        ]\n        styles.sort()\n\n        lines = [\n            '%s { %s } /* %s */' % (prefix(cls), style, repr(ttype)[6:])\n            for (level, ttype, cls, style) in styles\n        ]\n\n        return lines\n\n    def get_background_style_defs(self, arg=None):\n        prefix = self.get_css_prefix(arg)\n        bg_color = self.style.background_color\n        hl_color = self.style.highlight_color\n\n        lines = []\n\n        if arg and not self.nobackground and bg_color is not None:\n            text_style = ''\n            if Text in self.ttype2class:\n                text_style = ' ' + self.class2style[self.ttype2class[Text]][0]\n            lines.insert(\n                0, '%s{ background: %s;%s }' % (\n                    prefix(''), bg_color, text_style\n                )\n            )\n        if hl_color is not None:\n            lines.insert(\n                0, '%s { background-color: %s }' % (prefix('hll'), hl_color)\n            )\n\n        return lines\n\n    def get_linenos_style_defs(self):\n        lines = [\n            'pre { %s }' % self._pre_style,\n            'td.linenos .normal { %s }' % self._linenos_style,\n            'span.linenos { %s }' % self._linenos_style,\n            'td.linenos .special { %s }' % self._linenos_special_style,\n            'span.linenos.special { %s }' % self._linenos_special_style,\n        ]\n\n        return lines\n\n    def get_css_prefix(self, arg):\n        if arg is None:\n            arg = ('cssclass' in self.options and '.'+self.cssclass or '')\n        if isinstance(arg, str):\n            args = [arg]\n        else:\n            args = list(arg)\n\n        def prefix(cls):\n            if cls:\n                cls = '.' + cls\n            tmp = []\n            for arg in args:\n                tmp.append((arg and arg + ' ' or '') + cls)\n            return ', '.join(tmp)\n\n        return prefix\n\n    @property\n    def _pre_style(self):\n        return 'line-height: 125%;'\n\n    @property\n    def _linenos_style(self):\n        return 'color: %s; background-color: %s; padding-left: 5px; padding-right: 5px;' % (\n            self.style.line_number_color,\n            self.style.line_number_background_color\n        )\n\n    @property\n    def _linenos_special_style(self):\n        return 'color: %s; background-color: %s; padding-left: 5px; padding-right: 5px;' % (\n            self.style.line_number_special_color,\n            self.style.line_number_special_background_color\n        )\n\n    def _decodeifneeded(self, value):\n        if isinstance(value, bytes):\n            if self.encoding:\n                return value.decode(self.encoding)\n            return value.decode()\n        return value\n\n    def _wrap_full(self, inner, outfile):\n        if self.cssfile:\n            if os.path.isabs(self.cssfile):\n                # it's an absolute filename\n                cssfilename = self.cssfile\n            else:\n                try:\n                    filename = outfile.name\n                    if not filename or filename[0] == '<':\n                        # pseudo files, e.g. name == '<fdopen>'\n                        raise AttributeError\n                    cssfilename = os.path.join(os.path.dirname(filename),\n                                               self.cssfile)\n                except AttributeError:\n                    print('Note: Cannot determine output file name, '\n                          'using current directory as base for the CSS file name',\n                          file=sys.stderr)\n                    cssfilename = self.cssfile\n            # write CSS file only if noclobber_cssfile isn't given as an option.\n            try:\n                if not os.path.exists(cssfilename) or not self.noclobber_cssfile:\n                    with open(cssfilename, \"w\", encoding=\"utf-8\") as cf:\n                        cf.write(CSSFILE_TEMPLATE %\n                                 {'styledefs': self.get_style_defs('body')})\n            except OSError as err:\n                err.strerror = 'Error writing CSS file: ' + err.strerror\n                raise\n\n            yield 0, (DOC_HEADER_EXTERNALCSS %\n                      dict(title=self.title,\n                           cssfile=self.cssfile,\n                           encoding=self.encoding))\n        else:\n            yield 0, (DOC_HEADER %\n                      dict(title=self.title,\n                           styledefs=self.get_style_defs('body'),\n                           encoding=self.encoding))\n\n        yield from inner\n        yield 0, DOC_FOOTER\n\n    def _wrap_tablelinenos(self, inner):\n        dummyoutfile = StringIO()\n        lncount = 0\n        for t, line in inner:\n            if t:\n                lncount += 1\n            dummyoutfile.write(line)\n\n        fl = self.linenostart\n        mw = len(str(lncount + fl - 1))\n        sp = self.linenospecial\n        st = self.linenostep\n        anchor_name = self.lineanchors or self.linespans\n        aln = self.anchorlinenos\n        nocls = self.noclasses\n\n        lines = []\n\n        for i in range(fl, fl+lncount):\n            print_line = i % st == 0\n            special_line = sp and i % sp == 0\n\n            if print_line:\n                line = '%*d' % (mw, i)\n                if aln:\n                    line = '<a href=\"#%s-%d\">%s</a>' % (anchor_name, i, line)\n            else:\n                line = ' ' * mw\n\n            if nocls:\n                if special_line:\n                    style = ' style=\"%s\"' % self._linenos_special_style\n                else:\n                    style = ' style=\"%s\"' % self._linenos_style\n            else:\n                if special_line:\n                    style = ' class=\"special\"'\n                else:\n                    style = ' class=\"normal\"'\n\n            if style:\n                line = '<span%s>%s</span>' % (style, line)\n\n            lines.append(line)\n\n        ls = '\\n'.join(lines)\n\n        # If a filename was specified, we can't put it into the code table as it\n        # would misalign the line numbers. Hence we emit a separate row for it.\n        filename_tr = \"\"\n        if self.filename:\n            filename_tr = (\n                '<tr><th colspan=\"2\" class=\"filename\">'\n                '<span class=\"filename\">' + self.filename + '</span>'\n                '</th></tr>')\n\n        # in case you wonder about the seemingly redundant <div> here: since the\n        # content in the other cell also is wrapped in a div, some browsers in\n        # some configurations seem to mess up the formatting...\n        yield 0, (f'<table class=\"{self.cssclass}table\">' + filename_tr +\n            '<tr><td class=\"linenos\"><div class=\"linenodiv\"><pre>' +\n            ls + '</pre></div></td><td class=\"code\">')\n        yield 0, '<div>'\n        yield 0, dummyoutfile.getvalue()\n        yield 0, '</div>'\n        yield 0, '</td></tr></table>'\n\n\n    def _wrap_inlinelinenos(self, inner):\n        # need a list of lines since we need the width of a single number :(\n        inner_lines = list(inner)\n        sp = self.linenospecial\n        st = self.linenostep\n        num = self.linenostart\n        mw = len(str(len(inner_lines) + num - 1))\n        anchor_name = self.lineanchors or self.linespans\n        aln = self.anchorlinenos\n        nocls = self.noclasses\n\n        for _, inner_line in inner_lines:\n            print_line = num % st == 0\n            special_line = sp and num % sp == 0\n\n            if print_line:\n                line = '%*d' % (mw, num)\n            else:\n                line = ' ' * mw\n\n            if nocls:\n                if special_line:\n                    style = ' style=\"%s\"' % self._linenos_special_style\n                else:\n                    style = ' style=\"%s\"' % self._linenos_style\n            else:\n                if special_line:\n                    style = ' class=\"linenos special\"'\n                else:\n                    style = ' class=\"linenos\"'\n\n            if style:\n                linenos = '<span%s>%s</span>' % (style, line)\n            else:\n                linenos = line\n\n            if aln:\n                yield 1, ('<a href=\"#%s-%d\">%s</a>' % (anchor_name, num, linenos) +\n                          inner_line)\n            else:\n                yield 1, linenos + inner_line\n            num += 1\n\n    def _wrap_lineanchors(self, inner):\n        s = self.lineanchors\n        # subtract 1 since we have to increment i *before* yielding\n        i = self.linenostart - 1\n        for t, line in inner:\n            if t:\n                i += 1\n                href = \"\" if self.linenos else ' href=\"#%s-%d\"' % (s, i)\n                yield 1, '<a id=\"%s-%d\" name=\"%s-%d\"%s></a>' % (s, i, s, i, href) + line\n            else:\n                yield 0, line\n\n    def _wrap_linespans(self, inner):\n        s = self.linespans\n        i = self.linenostart - 1\n        for t, line in inner:\n            if t:\n                i += 1\n                yield 1, '<span id=\"%s-%d\">%s</span>' % (s, i, line)\n            else:\n                yield 0, line\n\n    def _wrap_div(self, inner):\n        style = []\n        if (self.noclasses and not self.nobackground and\n                self.style.background_color is not None):\n            style.append('background: %s' % (self.style.background_color,))\n        if self.cssstyles:\n            style.append(self.cssstyles)\n        style = '; '.join(style)\n\n        yield 0, ('<div' + (self.cssclass and ' class=\"%s\"' % self.cssclass) +\n                  (style and (' style=\"%s\"' % style)) + '>')\n        yield from inner\n        yield 0, '</div>\\n'\n\n    def _wrap_pre(self, inner):\n        style = []\n        if self.prestyles:\n            style.append(self.prestyles)\n        if self.noclasses:\n            style.append(self._pre_style)\n        style = '; '.join(style)\n\n        if self.filename and self.linenos != 1:\n            yield 0, ('<span class=\"filename\">' + self.filename + '</span>')\n\n        # the empty span here is to keep leading empty lines from being\n        # ignored by HTML parsers\n        yield 0, ('<pre' + (style and ' style=\"%s\"' % style) + '><span></span>')\n        yield from inner\n        yield 0, '</pre>'\n\n    def _wrap_code(self, inner):\n        yield 0, '<code>'\n        yield from inner\n        yield 0, '</code>'\n\n    @functools.lru_cache(maxsize=100)\n    def _translate_parts(self, value):\n        \"\"\"HTML-escape a value and split it by newlines.\"\"\"\n        return value.translate(_escape_html_table).split('\\n')\n\n    def _format_lines(self, tokensource):\n        \"\"\"\n        Just format the tokens, without any wrapping tags.\n        Yield individual lines.\n        \"\"\"\n        nocls = self.noclasses\n        lsep = self.lineseparator\n        tagsfile = self.tagsfile\n\n        lspan = ''\n        line = []\n        for ttype, value in tokensource:\n            try:\n                cspan = self.span_element_openers[ttype]\n            except KeyError:\n                title = ' title=\"%s\"' % '.'.join(ttype) if self.debug_token_types else ''\n                if nocls:\n                    css_style = self._get_css_inline_styles(ttype)\n                    if css_style:\n                        css_style = self.class2style[css_style][0]\n                        cspan = '<span style=\"%s\"%s>' % (css_style, title)\n                    else:\n                        cspan = ''\n                else:\n                    css_class = self._get_css_classes(ttype)\n                    if css_class:\n                        cspan = '<span class=\"%s\"%s>' % (css_class, title)\n                    else:\n                        cspan = ''\n                self.span_element_openers[ttype] = cspan\n\n            parts = self._translate_parts(value)\n\n            if tagsfile and ttype in Token.Name:\n                filename, linenumber = self._lookup_ctag(value)\n                if linenumber:\n                    base, filename = os.path.split(filename)\n                    if base:\n                        base += '/'\n                    filename, extension = os.path.splitext(filename)\n                    url = self.tagurlformat % {'path': base, 'fname': filename,\n                                               'fext': extension}\n                    parts[0] = \"<a href=\\\"%s#%s-%d\\\">%s\" % \\\n                        (url, self.lineanchors, linenumber, parts[0])\n                    parts[-1] = parts[-1] + \"</a>\"\n\n            # for all but the last line\n            for part in parts[:-1]:\n                if line:\n                    # Also check for part being non-empty, so we avoid creating\n                    # empty <span> tags\n                    if lspan != cspan and part:\n                        line.extend(((lspan and '</span>'), cspan, part,\n                                     (cspan and '</span>'), lsep))\n                    else:  # both are the same, or the current part was empty\n                        line.extend((part, (lspan and '</span>'), lsep))\n                    yield 1, ''.join(line)\n                    line = []\n                elif part:\n                    yield 1, ''.join((cspan, part, (cspan and '</span>'), lsep))\n                else:\n                    yield 1, lsep\n            # for the last line\n            if line and parts[-1]:\n                if lspan != cspan:\n                    line.extend(((lspan and '</span>'), cspan, parts[-1]))\n                    lspan = cspan\n                else:\n                    line.append(parts[-1])\n            elif parts[-1]:\n                line = [cspan, parts[-1]]\n                lspan = cspan\n            # else we neither have to open a new span nor set lspan\n\n        if line:\n            line.extend(((lspan and '</span>'), lsep))\n            yield 1, ''.join(line)\n\n    def _lookup_ctag(self, token):\n        entry = ctags.TagEntry()\n        if self._ctags.find(entry, token.encode(), 0):\n            return entry['file'], entry['lineNumber']\n        else:\n            return None, None\n\n    def _highlight_lines(self, tokensource):\n        \"\"\"\n        Highlighted the lines specified in the `hl_lines` option by\n        post-processing the token stream coming from `_format_lines`.\n        \"\"\"\n        hls = self.hl_lines\n\n        for i, (t, value) in enumerate(tokensource):\n            if t != 1:\n                yield t, value\n            if i + 1 in hls:  # i + 1 because Python indexes start at 0\n                if self.noclasses:\n                    style = ''\n                    if self.style.highlight_color is not None:\n                        style = (' style=\"background-color: %s\"' %\n                                 (self.style.highlight_color,))\n                    yield 1, '<span%s>%s</span>' % (style, value)\n                else:\n                    yield 1, '<span class=\"hll\">%s</span>' % value\n            else:\n                yield 1, value\n\n    def wrap(self, source):\n        \"\"\"\n        Wrap the ``source``, which is a generator yielding\n        individual lines, in custom generators. See docstring\n        for `format`. Can be overridden.\n        \"\"\"\n\n        output = source\n        if self.wrapcode:\n            output = self._wrap_code(output)\n\n        output = self._wrap_pre(output)\n\n        return output\n\n    def format_unencoded(self, tokensource, outfile):\n        \"\"\"\n        The formatting process uses several nested generators; which of\n        them are used is determined by the user's options.\n\n        Each generator should take at least one argument, ``inner``,\n        and wrap the pieces of text generated by this.\n\n        Always yield 2-tuples: (code, text). If \"code\" is 1, the text\n        is part of the original tokensource being highlighted, if it's\n        0, the text is some piece of wrapping. This makes it possible to\n        use several different wrappers that process the original source\n        linewise, e.g. line number generators.\n        \"\"\"\n        source = self._format_lines(tokensource)\n\n        # As a special case, we wrap line numbers before line highlighting\n        # so the line numbers get wrapped in the highlighting tag.\n        if not self.nowrap and self.linenos == 2:\n            source = self._wrap_inlinelinenos(source)\n\n        if self.hl_lines:\n            source = self._highlight_lines(source)\n\n        if not self.nowrap:\n            if self.lineanchors:\n                source = self._wrap_lineanchors(source)\n            if self.linespans:\n                source = self._wrap_linespans(source)\n            source = self.wrap(source)\n            if self.linenos == 1:\n                source = self._wrap_tablelinenos(source)\n            source = self._wrap_div(source)\n            if self.full:\n                source = self._wrap_full(source, outfile)\n\n        for t, piece in source:\n            outfile.write(piece)\n"},"hash":"Fujgke9Yje"}