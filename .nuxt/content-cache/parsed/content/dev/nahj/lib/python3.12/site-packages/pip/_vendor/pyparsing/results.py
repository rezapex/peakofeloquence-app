{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:pyparsing:results.py","body":"# results.py\nfrom collections.abc import (\n    MutableMapping,\n    Mapping,\n    MutableSequence,\n    Iterator,\n    Sequence,\n    Container,\n)\nimport pprint\nfrom typing import Tuple, Any, Dict, Set, List\n\nstr_type: Tuple[type, ...] = (str, bytes)\n_generator_type = type((_ for _ in ()))\n\n\nclass _ParseResultsWithOffset:\n    tup: Tuple[\"ParseResults\", int]\n    __slots__ = [\"tup\"]\n\n    def __init__(self, p1: \"ParseResults\", p2: int):\n        self.tup: Tuple[ParseResults, int] = (p1, p2)\n\n    def __getitem__(self, i):\n        return self.tup[i]\n\n    def __getstate__(self):\n        return self.tup\n\n    def __setstate__(self, *args):\n        self.tup = args[0]\n\n\nclass ParseResults:\n    \"\"\"Structured parse results, to provide multiple means of access to\n    the parsed data:\n\n    - as a list (``len(results)``)\n    - by list index (``results[0], results[1]``, etc.)\n    - by attribute (``results.<results_name>`` - see :class:`ParserElement.set_results_name`)\n\n    Example::\n\n        integer = Word(nums)\n        date_str = (integer.set_results_name(\"year\") + '/'\n                    + integer.set_results_name(\"month\") + '/'\n                    + integer.set_results_name(\"day\"))\n        # equivalent form:\n        # date_str = (integer(\"year\") + '/'\n        #             + integer(\"month\") + '/'\n        #             + integer(\"day\"))\n\n        # parse_string returns a ParseResults object\n        result = date_str.parse_string(\"1999/12/31\")\n\n        def test(s, fn=repr):\n            print(f\"{s} -> {fn(eval(s))}\")\n        test(\"list(result)\")\n        test(\"result[0]\")\n        test(\"result['month']\")\n        test(\"result.day\")\n        test(\"'month' in result\")\n        test(\"'minutes' in result\")\n        test(\"result.dump()\", str)\n\n    prints::\n\n        list(result) -> ['1999', '/', '12', '/', '31']\n        result[0] -> '1999'\n        result['month'] -> '12'\n        result.day -> '31'\n        'month' in result -> True\n        'minutes' in result -> False\n        result.dump() -> ['1999', '/', '12', '/', '31']\n        - day: '31'\n        - month: '12'\n        - year: '1999'\n    \"\"\"\n\n    _null_values: Tuple[Any, ...] = (None, [], ())\n\n    _name: str\n    _parent: \"ParseResults\"\n    _all_names: Set[str]\n    _modal: bool\n    _toklist: List[Any]\n    _tokdict: Dict[str, Any]\n\n    __slots__ = (\n        \"_name\",\n        \"_parent\",\n        \"_all_names\",\n        \"_modal\",\n        \"_toklist\",\n        \"_tokdict\",\n    )\n\n    class List(list):\n        \"\"\"\n        Simple wrapper class to distinguish parsed list results that should be preserved\n        as actual Python lists, instead of being converted to :class:`ParseResults`::\n\n            LBRACK, RBRACK = map(pp.Suppress, \"[]\")\n            element = pp.Forward()\n            item = ppc.integer\n            element_list = LBRACK + pp.DelimitedList(element) + RBRACK\n\n            # add parse actions to convert from ParseResults to actual Python collection types\n            def as_python_list(t):\n                return pp.ParseResults.List(t.as_list())\n            element_list.add_parse_action(as_python_list)\n\n            element <<= item | element_list\n\n            element.run_tests('''\n                100\n                [2,3,4]\n                [[2, 1],3,4]\n                [(2, 1),3,4]\n                (2,3,4)\n                ''', post_parse=lambda s, r: (r[0], type(r[0])))\n\n        prints::\n\n            100\n            (100, <class 'int'>)\n\n            [2,3,4]\n            ([2, 3, 4], <class 'list'>)\n\n            [[2, 1],3,4]\n            ([[2, 1], 3, 4], <class 'list'>)\n\n        (Used internally by :class:`Group` when `aslist=True`.)\n        \"\"\"\n\n        def __new__(cls, contained=None):\n            if contained is None:\n                contained = []\n\n            if not isinstance(contained, list):\n                raise TypeError(\n                    f\"{cls.__name__} may only be constructed with a list, not {type(contained).__name__}\"\n                )\n\n            return list.__new__(cls)\n\n    def __new__(cls, toklist=None, name=None, **kwargs):\n        if isinstance(toklist, ParseResults):\n            return toklist\n        self = object.__new__(cls)\n        self._name = None\n        self._parent = None\n        self._all_names = set()\n\n        if toklist is None:\n            self._toklist = []\n        elif isinstance(toklist, (list, _generator_type)):\n            self._toklist = (\n                [toklist[:]]\n                if isinstance(toklist, ParseResults.List)\n                else list(toklist)\n            )\n        else:\n            self._toklist = [toklist]\n        self._tokdict = dict()\n        return self\n\n    # Performance tuning: we construct a *lot* of these, so keep this\n    # constructor as small and fast as possible\n    def __init__(\n        self, toklist=None, name=None, asList=True, modal=True, isinstance=isinstance\n    ):\n        self._tokdict: Dict[str, _ParseResultsWithOffset]\n        self._modal = modal\n        if name is not None and name != \"\":\n            if isinstance(name, int):\n                name = str(name)\n            if not modal:\n                self._all_names = {name}\n            self._name = name\n            if toklist not in self._null_values:\n                if isinstance(toklist, (str_type, type)):\n                    toklist = [toklist]\n                if asList:\n                    if isinstance(toklist, ParseResults):\n                        self[name] = _ParseResultsWithOffset(\n                            ParseResults(toklist._toklist), 0\n                        )\n                    else:\n                        self[name] = _ParseResultsWithOffset(\n                            ParseResults(toklist[0]), 0\n                        )\n                    self[name]._name = name\n                else:\n                    try:\n                        self[name] = toklist[0]\n                    except (KeyError, TypeError, IndexError):\n                        if toklist is not self:\n                            self[name] = toklist\n                        else:\n                            self._name = name\n\n    def __getitem__(self, i):\n        if isinstance(i, (int, slice)):\n            return self._toklist[i]\n        else:\n            if i not in self._all_names:\n                return self._tokdict[i][-1][0]\n            else:\n                return ParseResults([v[0] for v in self._tokdict[i]])\n\n    def __setitem__(self, k, v, isinstance=isinstance):\n        if isinstance(v, _ParseResultsWithOffset):\n            self._tokdict[k] = self._tokdict.get(k, list()) + [v]\n            sub = v[0]\n        elif isinstance(k, (int, slice)):\n            self._toklist[k] = v\n            sub = v\n        else:\n            self._tokdict[k] = self._tokdict.get(k, list()) + [\n                _ParseResultsWithOffset(v, 0)\n            ]\n            sub = v\n        if isinstance(sub, ParseResults):\n            sub._parent = self\n\n    def __delitem__(self, i):\n        if isinstance(i, (int, slice)):\n            mylen = len(self._toklist)\n            del self._toklist[i]\n\n            # convert int to slice\n            if isinstance(i, int):\n                if i < 0:\n                    i += mylen\n                i = slice(i, i + 1)\n            # get removed indices\n            removed = list(range(*i.indices(mylen)))\n            removed.reverse()\n            # fixup indices in token dictionary\n            for name, occurrences in self._tokdict.items():\n                for j in removed:\n                    for k, (value, position) in enumerate(occurrences):\n                        occurrences[k] = _ParseResultsWithOffset(\n                            value, position - (position > j)\n                        )\n        else:\n            del self._tokdict[i]\n\n    def __contains__(self, k) -> bool:\n        return k in self._tokdict\n\n    def __len__(self) -> int:\n        return len(self._toklist)\n\n    def __bool__(self) -> bool:\n        return not not (self._toklist or self._tokdict)\n\n    def __iter__(self) -> Iterator:\n        return iter(self._toklist)\n\n    def __reversed__(self) -> Iterator:\n        return iter(self._toklist[::-1])\n\n    def keys(self):\n        return iter(self._tokdict)\n\n    def values(self):\n        return (self[k] for k in self.keys())\n\n    def items(self):\n        return ((k, self[k]) for k in self.keys())\n\n    def haskeys(self) -> bool:\n        \"\"\"\n        Since ``keys()`` returns an iterator, this method is helpful in bypassing\n        code that looks for the existence of any defined results names.\"\"\"\n        return not not self._tokdict\n\n    def pop(self, *args, **kwargs):\n        \"\"\"\n        Removes and returns item at specified index (default= ``last``).\n        Supports both ``list`` and ``dict`` semantics for ``pop()``. If\n        passed no argument or an integer argument, it will use ``list``\n        semantics and pop tokens from the list of parsed tokens. If passed\n        a non-integer argument (most likely a string), it will use ``dict``\n        semantics and pop the corresponding value from any defined results\n        names. A second default return value argument is supported, just as in\n        ``dict.pop()``.\n\n        Example::\n\n            numlist = Word(nums)[...]\n            print(numlist.parse_string(\"0 123 321\")) # -> ['0', '123', '321']\n\n            def remove_first(tokens):\n                tokens.pop(0)\n            numlist.add_parse_action(remove_first)\n            print(numlist.parse_string(\"0 123 321\")) # -> ['123', '321']\n\n            label = Word(alphas)\n            patt = label(\"LABEL\") + Word(nums)[1, ...]\n            print(patt.parse_string(\"AAB 123 321\").dump())\n\n            # Use pop() in a parse action to remove named result (note that corresponding value is not\n            # removed from list form of results)\n            def remove_LABEL(tokens):\n                tokens.pop(\"LABEL\")\n                return tokens\n            patt.add_parse_action(remove_LABEL)\n            print(patt.parse_string(\"AAB 123 321\").dump())\n\n        prints::\n\n            ['AAB', '123', '321']\n            - LABEL: 'AAB'\n\n            ['AAB', '123', '321']\n        \"\"\"\n        if not args:\n            args = [-1]\n        for k, v in kwargs.items():\n            if k == \"default\":\n                args = (args[0], v)\n            else:\n                raise TypeError(f\"pop() got an unexpected keyword argument {k!r}\")\n        if isinstance(args[0], int) or len(args) == 1 or args[0] in self:\n            index = args[0]\n            ret = self[index]\n            del self[index]\n            return ret\n        else:\n            defaultvalue = args[1]\n            return defaultvalue\n\n    def get(self, key, default_value=None):\n        \"\"\"\n        Returns named result matching the given key, or if there is no\n        such name, then returns the given ``default_value`` or ``None`` if no\n        ``default_value`` is specified.\n\n        Similar to ``dict.get()``.\n\n        Example::\n\n            integer = Word(nums)\n            date_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")\n\n            result = date_str.parse_string(\"1999/12/31\")\n            print(result.get(\"year\")) # -> '1999'\n            print(result.get(\"hour\", \"not specified\")) # -> 'not specified'\n            print(result.get(\"hour\")) # -> None\n        \"\"\"\n        if key in self:\n            return self[key]\n        else:\n            return default_value\n\n    def insert(self, index, ins_string):\n        \"\"\"\n        Inserts new element at location index in the list of parsed tokens.\n\n        Similar to ``list.insert()``.\n\n        Example::\n\n            numlist = Word(nums)[...]\n            print(numlist.parse_string(\"0 123 321\")) # -> ['0', '123', '321']\n\n            # use a parse action to insert the parse location in the front of the parsed results\n            def insert_locn(locn, tokens):\n                tokens.insert(0, locn)\n            numlist.add_parse_action(insert_locn)\n            print(numlist.parse_string(\"0 123 321\")) # -> [0, '0', '123', '321']\n        \"\"\"\n        self._toklist.insert(index, ins_string)\n        # fixup indices in token dictionary\n        for name, occurrences in self._tokdict.items():\n            for k, (value, position) in enumerate(occurrences):\n                occurrences[k] = _ParseResultsWithOffset(\n                    value, position + (position > index)\n                )\n\n    def append(self, item):\n        \"\"\"\n        Add single element to end of ``ParseResults`` list of elements.\n\n        Example::\n\n            numlist = Word(nums)[...]\n            print(numlist.parse_string(\"0 123 321\")) # -> ['0', '123', '321']\n\n            # use a parse action to compute the sum of the parsed integers, and add it to the end\n            def append_sum(tokens):\n                tokens.append(sum(map(int, tokens)))\n            numlist.add_parse_action(append_sum)\n            print(numlist.parse_string(\"0 123 321\")) # -> ['0', '123', '321', 444]\n        \"\"\"\n        self._toklist.append(item)\n\n    def extend(self, itemseq):\n        \"\"\"\n        Add sequence of elements to end of ``ParseResults`` list of elements.\n\n        Example::\n\n            patt = Word(alphas)[1, ...]\n\n            # use a parse action to append the reverse of the matched strings, to make a palindrome\n            def make_palindrome(tokens):\n                tokens.extend(reversed([t[::-1] for t in tokens]))\n                return ''.join(tokens)\n            patt.add_parse_action(make_palindrome)\n            print(patt.parse_string(\"lskdj sdlkjf lksd\")) # -> 'lskdjsdlkjflksddsklfjkldsjdksl'\n        \"\"\"\n        if isinstance(itemseq, ParseResults):\n            self.__iadd__(itemseq)\n        else:\n            self._toklist.extend(itemseq)\n\n    def clear(self):\n        \"\"\"\n        Clear all elements and results names.\n        \"\"\"\n        del self._toklist[:]\n        self._tokdict.clear()\n\n    def __getattr__(self, name):\n        try:\n            return self[name]\n        except KeyError:\n            if name.startswith(\"__\"):\n                raise AttributeError(name)\n            return \"\"\n\n    def __add__(self, other: \"ParseResults\") -> \"ParseResults\":\n        ret = self.copy()\n        ret += other\n        return ret\n\n    def __iadd__(self, other: \"ParseResults\") -> \"ParseResults\":\n        if not other:\n            return self\n\n        if other._tokdict:\n            offset = len(self._toklist)\n            addoffset = lambda a: offset if a < 0 else a + offset\n            otheritems = other._tokdict.items()\n            otherdictitems = [\n                (k, _ParseResultsWithOffset(v[0], addoffset(v[1])))\n                for k, vlist in otheritems\n                for v in vlist\n            ]\n            for k, v in otherdictitems:\n                self[k] = v\n                if isinstance(v[0], ParseResults):\n                    v[0]._parent = self\n\n        self._toklist += other._toklist\n        self._all_names |= other._all_names\n        return self\n\n    def __radd__(self, other) -> \"ParseResults\":\n        if isinstance(other, int) and other == 0:\n            # useful for merging many ParseResults using sum() builtin\n            return self.copy()\n        else:\n            # this may raise a TypeError - so be it\n            return other + self\n\n    def __repr__(self) -> str:\n        return f\"{type(self).__name__}({self._toklist!r}, {self.as_dict()})\"\n\n    def __str__(self) -> str:\n        return (\n            \"[\"\n            + \", \".join(\n                [\n                    str(i) if isinstance(i, ParseResults) else repr(i)\n                    for i in self._toklist\n                ]\n            )\n            + \"]\"\n        )\n\n    def _asStringList(self, sep=\"\"):\n        out = []\n        for item in self._toklist:\n            if out and sep:\n                out.append(sep)\n            if isinstance(item, ParseResults):\n                out += item._asStringList()\n            else:\n                out.append(str(item))\n        return out\n\n    def as_list(self) -> list:\n        \"\"\"\n        Returns the parse results as a nested list of matching tokens, all converted to strings.\n\n        Example::\n\n            patt = Word(alphas)[1, ...]\n            result = patt.parse_string(\"sldkj lsdkj sldkj\")\n            # even though the result prints in string-like form, it is actually a pyparsing ParseResults\n            print(type(result), result) # -> <class 'pyparsing.ParseResults'> ['sldkj', 'lsdkj', 'sldkj']\n\n            # Use as_list() to create an actual list\n            result_list = result.as_list()\n            print(type(result_list), result_list) # -> <class 'list'> ['sldkj', 'lsdkj', 'sldkj']\n        \"\"\"\n        return [\n            res.as_list() if isinstance(res, ParseResults) else res\n            for res in self._toklist\n        ]\n\n    def as_dict(self) -> dict:\n        \"\"\"\n        Returns the named parse results as a nested dictionary.\n\n        Example::\n\n            integer = Word(nums)\n            date_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")\n\n            result = date_str.parse_string('12/31/1999')\n            print(type(result), repr(result)) # -> <class 'pyparsing.ParseResults'> (['12', '/', '31', '/', '1999'], {'day': [('1999', 4)], 'year': [('12', 0)], 'month': [('31', 2)]})\n\n            result_dict = result.as_dict()\n            print(type(result_dict), repr(result_dict)) # -> <class 'dict'> {'day': '1999', 'year': '12', 'month': '31'}\n\n            # even though a ParseResults supports dict-like access, sometime you just need to have a dict\n            import json\n            print(json.dumps(result)) # -> Exception: TypeError: ... is not JSON serializable\n            print(json.dumps(result.as_dict())) # -> {\"month\": \"31\", \"day\": \"1999\", \"year\": \"12\"}\n        \"\"\"\n\n        def to_item(obj):\n            if isinstance(obj, ParseResults):\n                return obj.as_dict() if obj.haskeys() else [to_item(v) for v in obj]\n            else:\n                return obj\n\n        return dict((k, to_item(v)) for k, v in self.items())\n\n    def copy(self) -> \"ParseResults\":\n        \"\"\"\n        Returns a new shallow copy of a :class:`ParseResults` object. `ParseResults`\n        items contained within the source are shared with the copy. Use\n        :class:`ParseResults.deepcopy()` to create a copy with its own separate\n        content values.\n        \"\"\"\n        ret = ParseResults(self._toklist)\n        ret._tokdict = self._tokdict.copy()\n        ret._parent = self._parent\n        ret._all_names |= self._all_names\n        ret._name = self._name\n        return ret\n\n    def deepcopy(self) -> \"ParseResults\":\n        \"\"\"\n        Returns a new deep copy of a :class:`ParseResults` object.\n        \"\"\"\n        ret = self.copy()\n        # replace values with copies if they are of known mutable types\n        for i, obj in enumerate(self._toklist):\n            if isinstance(obj, ParseResults):\n                self._toklist[i] = obj.deepcopy()\n            elif isinstance(obj, (str, bytes)):\n                pass\n            elif isinstance(obj, MutableMapping):\n                self._toklist[i] = dest = type(obj)()\n                for k, v in obj.items():\n                    dest[k] = v.deepcopy() if isinstance(v, ParseResults) else v\n            elif isinstance(obj, Container):\n                self._toklist[i] = type(obj)(\n                    v.deepcopy() if isinstance(v, ParseResults) else v for v in obj\n                )\n        return ret\n\n    def get_name(self):\n        r\"\"\"\n        Returns the results name for this token expression. Useful when several\n        different expressions might match at a particular location.\n\n        Example::\n\n            integer = Word(nums)\n            ssn_expr = Regex(r\"\\d\\d\\d-\\d\\d-\\d\\d\\d\\d\")\n            house_number_expr = Suppress('#') + Word(nums, alphanums)\n            user_data = (Group(house_number_expr)(\"house_number\")\n                        | Group(ssn_expr)(\"ssn\")\n                        | Group(integer)(\"age\"))\n            user_info = user_data[1, ...]\n\n            result = user_info.parse_string(\"22 111-22-3333 #221B\")\n            for item in result:\n                print(item.get_name(), ':', item[0])\n\n        prints::\n\n            age : 22\n            ssn : 111-22-3333\n            house_number : 221B\n        \"\"\"\n        if self._name:\n            return self._name\n        elif self._parent:\n            par: \"ParseResults\" = self._parent\n            parent_tokdict_items = par._tokdict.items()\n            return next(\n                (\n                    k\n                    for k, vlist in parent_tokdict_items\n                    for v, loc in vlist\n                    if v is self\n                ),\n                None,\n            )\n        elif (\n            len(self) == 1\n            and len(self._tokdict) == 1\n            and next(iter(self._tokdict.values()))[0][1] in (0, -1)\n        ):\n            return next(iter(self._tokdict.keys()))\n        else:\n            return None\n\n    def dump(self, indent=\"\", full=True, include_list=True, _depth=0) -> str:\n        \"\"\"\n        Diagnostic method for listing out the contents of\n        a :class:`ParseResults`. Accepts an optional ``indent`` argument so\n        that this string can be embedded in a nested display of other data.\n\n        Example::\n\n            integer = Word(nums)\n            date_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")\n\n            result = date_str.parse_string('1999/12/31')\n            print(result.dump())\n\n        prints::\n\n            ['1999', '/', '12', '/', '31']\n            - day: '31'\n            - month: '12'\n            - year: '1999'\n        \"\"\"\n        out = []\n        NL = \"\\n\"\n        out.append(indent + str(self.as_list()) if include_list else \"\")\n\n        if full:\n            if self.haskeys():\n                items = sorted((str(k), v) for k, v in self.items())\n                for k, v in items:\n                    if out:\n                        out.append(NL)\n                    out.append(f\"{indent}{('  ' * _depth)}- {k}: \")\n                    if isinstance(v, ParseResults):\n                        if v:\n                            out.append(\n                                v.dump(\n                                    indent=indent,\n                                    full=full,\n                                    include_list=include_list,\n                                    _depth=_depth + 1,\n                                )\n                            )\n                        else:\n                            out.append(str(v))\n                    else:\n                        out.append(repr(v))\n            if any(isinstance(vv, ParseResults) for vv in self):\n                v = self\n                for i, vv in enumerate(v):\n                    if isinstance(vv, ParseResults):\n                        out.append(\n                            \"\\n{}{}[{}]:\\n{}{}{}\".format(\n                                indent,\n                                (\"  \" * (_depth)),\n                                i,\n                                indent,\n                                (\"  \" * (_depth + 1)),\n                                vv.dump(\n                                    indent=indent,\n                                    full=full,\n                                    include_list=include_list,\n                                    _depth=_depth + 1,\n                                ),\n                            )\n                        )\n                    else:\n                        out.append(\n                            \"\\n%s%s[%d]:\\n%s%s%s\"\n                            % (\n                                indent,\n                                (\"  \" * (_depth)),\n                                i,\n                                indent,\n                                (\"  \" * (_depth + 1)),\n                                str(vv),\n                            )\n                        )\n\n        return \"\".join(out)\n\n    def pprint(self, *args, **kwargs):\n        \"\"\"\n        Pretty-printer for parsed results as a list, using the\n        `pprint <https://docs.python.org/3/library/pprint.html>`_ module.\n        Accepts additional positional or keyword args as defined for\n        `pprint.pprint <https://docs.python.org/3/library/pprint.html#pprint.pprint>`_ .\n\n        Example::\n\n            ident = Word(alphas, alphanums)\n            num = Word(nums)\n            func = Forward()\n            term = ident | num | Group('(' + func + ')')\n            func <<= ident + Group(Optional(DelimitedList(term)))\n            result = func.parse_string(\"fna a,b,(fnb c,d,200),100\")\n            result.pprint(width=40)\n\n        prints::\n\n            ['fna',\n             ['a',\n              'b',\n              ['(', 'fnb', ['c', 'd', '200'], ')'],\n              '100']]\n        \"\"\"\n        pprint.pprint(self.as_list(), *args, **kwargs)\n\n    # add support for pickle protocol\n    def __getstate__(self):\n        return (\n            self._toklist,\n            (\n                self._tokdict.copy(),\n                None,\n                self._all_names,\n                self._name,\n            ),\n        )\n\n    def __setstate__(self, state):\n        self._toklist, (self._tokdict, par, inAccumNames, self._name) = state\n        self._all_names = set(inAccumNames)\n        self._parent = None\n\n    def __getnewargs__(self):\n        return self._toklist, self._name\n\n    def __dir__(self):\n        return dir(type(self)) + list(self.keys())\n\n    @classmethod\n    def from_dict(cls, other, name=None) -> \"ParseResults\":\n        \"\"\"\n        Helper classmethod to construct a ``ParseResults`` from a ``dict``, preserving the\n        name-value relations as results names. If an optional ``name`` argument is\n        given, a nested ``ParseResults`` will be returned.\n        \"\"\"\n\n        def is_iterable(obj):\n            try:\n                iter(obj)\n            except Exception:\n                return False\n            # str's are iterable, but in pyparsing, we don't want to iterate over them\n            else:\n                return not isinstance(obj, str_type)\n\n        ret = cls([])\n        for k, v in other.items():\n            if isinstance(v, Mapping):\n                ret += cls.from_dict(v, name=k)\n            else:\n                ret += cls([v], name=k, asList=is_iterable(v))\n        if name is not None:\n            ret = cls([ret], name=name)\n        return ret\n\n    asList = as_list\n    \"\"\"Deprecated - use :class:`as_list`\"\"\"\n    asDict = as_dict\n    \"\"\"Deprecated - use :class:`as_dict`\"\"\"\n    getName = get_name\n    \"\"\"Deprecated - use :class:`get_name`\"\"\"\n\n\nMutableMapping.register(ParseResults)\nMutableSequence.register(ParseResults)\n"},"hash":"89p0tkfEKr"}