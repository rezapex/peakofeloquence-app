{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:utils:subprocess.py","body":"import logging\nimport os\nimport shlex\nimport subprocess\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    Iterable,\n    List,\n    Mapping,\n    Optional,\n    Union,\n)\n\nfrom pip._vendor.rich.markup import escape\n\nfrom pip._internal.cli.spinners import SpinnerInterface, open_spinner\nfrom pip._internal.exceptions import InstallationSubprocessError\nfrom pip._internal.utils.logging import VERBOSE, subprocess_logger\nfrom pip._internal.utils.misc import HiddenText\n\nif TYPE_CHECKING:\n    # Literal was introduced in Python 3.8.\n    #\n    # TODO: Remove `if TYPE_CHECKING` when dropping support for Python 3.7.\n    from typing import Literal\n\nCommandArgs = List[Union[str, HiddenText]]\n\n\ndef make_command(*args: Union[str, HiddenText, CommandArgs]) -> CommandArgs:\n    \"\"\"\n    Create a CommandArgs object.\n    \"\"\"\n    command_args: CommandArgs = []\n    for arg in args:\n        # Check for list instead of CommandArgs since CommandArgs is\n        # only known during type-checking.\n        if isinstance(arg, list):\n            command_args.extend(arg)\n        else:\n            # Otherwise, arg is str or HiddenText.\n            command_args.append(arg)\n\n    return command_args\n\n\ndef format_command_args(args: Union[List[str], CommandArgs]) -> str:\n    \"\"\"\n    Format command arguments for display.\n    \"\"\"\n    # For HiddenText arguments, display the redacted form by calling str().\n    # Also, we don't apply str() to arguments that aren't HiddenText since\n    # this can trigger a UnicodeDecodeError in Python 2 if the argument\n    # has type unicode and includes a non-ascii character.  (The type\n    # checker doesn't ensure the annotations are correct in all cases.)\n    return \" \".join(\n        shlex.quote(str(arg)) if isinstance(arg, HiddenText) else shlex.quote(arg)\n        for arg in args\n    )\n\n\ndef reveal_command_args(args: Union[List[str], CommandArgs]) -> List[str]:\n    \"\"\"\n    Return the arguments in their raw, unredacted form.\n    \"\"\"\n    return [arg.secret if isinstance(arg, HiddenText) else arg for arg in args]\n\n\ndef call_subprocess(\n    cmd: Union[List[str], CommandArgs],\n    show_stdout: bool = False,\n    cwd: Optional[str] = None,\n    on_returncode: 'Literal[\"raise\", \"warn\", \"ignore\"]' = \"raise\",\n    extra_ok_returncodes: Optional[Iterable[int]] = None,\n    extra_environ: Optional[Mapping[str, Any]] = None,\n    unset_environ: Optional[Iterable[str]] = None,\n    spinner: Optional[SpinnerInterface] = None,\n    log_failed_cmd: Optional[bool] = True,\n    stdout_only: Optional[bool] = False,\n    *,\n    command_desc: str,\n) -> str:\n    \"\"\"\n    Args:\n      show_stdout: if true, use INFO to log the subprocess's stderr and\n        stdout streams.  Otherwise, use DEBUG.  Defaults to False.\n      extra_ok_returncodes: an iterable of integer return codes that are\n        acceptable, in addition to 0. Defaults to None, which means [].\n      unset_environ: an iterable of environment variable names to unset\n        prior to calling subprocess.Popen().\n      log_failed_cmd: if false, failed commands are not logged, only raised.\n      stdout_only: if true, return only stdout, else return both. When true,\n        logging of both stdout and stderr occurs when the subprocess has\n        terminated, else logging occurs as subprocess output is produced.\n    \"\"\"\n    if extra_ok_returncodes is None:\n        extra_ok_returncodes = []\n    if unset_environ is None:\n        unset_environ = []\n    # Most places in pip use show_stdout=False. What this means is--\n    #\n    # - We connect the child's output (combined stderr and stdout) to a\n    #   single pipe, which we read.\n    # - We log this output to stderr at DEBUG level as it is received.\n    # - If DEBUG logging isn't enabled (e.g. if --verbose logging wasn't\n    #   requested), then we show a spinner so the user can still see the\n    #   subprocess is in progress.\n    # - If the subprocess exits with an error, we log the output to stderr\n    #   at ERROR level if it hasn't already been displayed to the console\n    #   (e.g. if --verbose logging wasn't enabled).  This way we don't log\n    #   the output to the console twice.\n    #\n    # If show_stdout=True, then the above is still done, but with DEBUG\n    # replaced by INFO.\n    if show_stdout:\n        # Then log the subprocess output at INFO level.\n        log_subprocess: Callable[..., None] = subprocess_logger.info\n        used_level = logging.INFO\n    else:\n        # Then log the subprocess output using VERBOSE.  This also ensures\n        # it will be logged to the log file (aka user_log), if enabled.\n        log_subprocess = subprocess_logger.verbose\n        used_level = VERBOSE\n\n    # Whether the subprocess will be visible in the console.\n    showing_subprocess = subprocess_logger.getEffectiveLevel() <= used_level\n\n    # Only use the spinner if we're not showing the subprocess output\n    # and we have a spinner.\n    use_spinner = not showing_subprocess and spinner is not None\n\n    log_subprocess(\"Running command %s\", command_desc)\n    env = os.environ.copy()\n    if extra_environ:\n        env.update(extra_environ)\n    for name in unset_environ:\n        env.pop(name, None)\n    try:\n        proc = subprocess.Popen(\n            # Convert HiddenText objects to the underlying str.\n            reveal_command_args(cmd),\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT if not stdout_only else subprocess.PIPE,\n            cwd=cwd,\n            env=env,\n            errors=\"backslashreplace\",\n        )\n    except Exception as exc:\n        if log_failed_cmd:\n            subprocess_logger.critical(\n                \"Error %s while executing command %s\",\n                exc,\n                command_desc,\n            )\n        raise\n    all_output = []\n    if not stdout_only:\n        assert proc.stdout\n        assert proc.stdin\n        proc.stdin.close()\n        # In this mode, stdout and stderr are in the same pipe.\n        while True:\n            line: str = proc.stdout.readline()\n            if not line:\n                break\n            line = line.rstrip()\n            all_output.append(line + \"\\n\")\n\n            # Show the line immediately.\n            log_subprocess(line)\n            # Update the spinner.\n            if use_spinner:\n                assert spinner\n                spinner.spin()\n        try:\n            proc.wait()\n        finally:\n            if proc.stdout:\n                proc.stdout.close()\n        output = \"\".join(all_output)\n    else:\n        # In this mode, stdout and stderr are in different pipes.\n        # We must use communicate() which is the only safe way to read both.\n        out, err = proc.communicate()\n        # log line by line to preserve pip log indenting\n        for out_line in out.splitlines():\n            log_subprocess(out_line)\n        all_output.append(out)\n        for err_line in err.splitlines():\n            log_subprocess(err_line)\n        all_output.append(err)\n        output = out\n\n    proc_had_error = proc.returncode and proc.returncode not in extra_ok_returncodes\n    if use_spinner:\n        assert spinner\n        if proc_had_error:\n            spinner.finish(\"error\")\n        else:\n            spinner.finish(\"done\")\n    if proc_had_error:\n        if on_returncode == \"raise\":\n            error = InstallationSubprocessError(\n                command_description=command_desc,\n                exit_code=proc.returncode,\n                output_lines=all_output if not showing_subprocess else None,\n            )\n            if log_failed_cmd:\n                subprocess_logger.error(\"%s\", error, extra={\"rich\": True})\n                subprocess_logger.verbose(\n                    \"[bold magenta]full command[/]: [blue]%s[/]\",\n                    escape(format_command_args(cmd)),\n                    extra={\"markup\": True},\n                )\n                subprocess_logger.verbose(\n                    \"[bold magenta]cwd[/]: %s\",\n                    escape(cwd or \"[inherit]\"),\n                    extra={\"markup\": True},\n                )\n\n            raise error\n        elif on_returncode == \"warn\":\n            subprocess_logger.warning(\n                'Command \"%s\" had error code %s in %s',\n                command_desc,\n                proc.returncode,\n                cwd,\n            )\n        elif on_returncode == \"ignore\":\n            pass\n        else:\n            raise ValueError(f\"Invalid value: on_returncode={on_returncode!r}\")\n    return output\n\n\ndef runner_with_spinner_message(message: str) -> Callable[..., None]:\n    \"\"\"Provide a subprocess_runner that shows a spinner message.\n\n    Intended for use with for BuildBackendHookCaller. Thus, the runner has\n    an API that matches what's expected by BuildBackendHookCaller.subprocess_runner.\n    \"\"\"\n\n    def runner(\n        cmd: List[str],\n        cwd: Optional[str] = None,\n        extra_environ: Optional[Mapping[str, Any]] = None,\n    ) -> None:\n        with open_spinner(message) as spinner:\n            call_subprocess(\n                cmd,\n                command_desc=message,\n                cwd=cwd,\n                extra_environ=extra_environ,\n                spinner=spinner,\n            )\n\n    return runner\n"},"hash":"sIfqEKd6hg"}