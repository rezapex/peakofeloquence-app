{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:locations:__init__.py","body":"import functools\nimport logging\nimport os\nimport pathlib\nimport sys\nimport sysconfig\nfrom typing import Any, Dict, Generator, Optional, Tuple\n\nfrom pip._internal.models.scheme import SCHEME_KEYS, Scheme\nfrom pip._internal.utils.compat import WINDOWS\nfrom pip._internal.utils.deprecation import deprecated\nfrom pip._internal.utils.virtualenv import running_under_virtualenv\n\nfrom . import _sysconfig\nfrom .base import (\n    USER_CACHE_DIR,\n    get_major_minor_version,\n    get_src_prefix,\n    is_osx_framework,\n    site_packages,\n    user_site,\n)\n\n__all__ = [\n    \"USER_CACHE_DIR\",\n    \"get_bin_prefix\",\n    \"get_bin_user\",\n    \"get_major_minor_version\",\n    \"get_platlib\",\n    \"get_purelib\",\n    \"get_scheme\",\n    \"get_src_prefix\",\n    \"site_packages\",\n    \"user_site\",\n]\n\n\nlogger = logging.getLogger(__name__)\n\n\n_PLATLIBDIR: str = getattr(sys, \"platlibdir\", \"lib\")\n\n_USE_SYSCONFIG_DEFAULT = sys.version_info >= (3, 10)\n\n\ndef _should_use_sysconfig() -> bool:\n    \"\"\"This function determines the value of _USE_SYSCONFIG.\n\n    By default, pip uses sysconfig on Python 3.10+.\n    But Python distributors can override this decision by setting:\n        sysconfig._PIP_USE_SYSCONFIG = True / False\n    Rationale in https://github.com/pypa/pip/issues/10647\n\n    This is a function for testability, but should be constant during any one\n    run.\n    \"\"\"\n    return bool(getattr(sysconfig, \"_PIP_USE_SYSCONFIG\", _USE_SYSCONFIG_DEFAULT))\n\n\n_USE_SYSCONFIG = _should_use_sysconfig()\n\nif not _USE_SYSCONFIG:\n    # Import distutils lazily to avoid deprecation warnings,\n    # but import it soon enough that it is in memory and available during\n    # a pip reinstall.\n    from . import _distutils\n\n# Be noisy about incompatibilities if this platforms \"should\" be using\n# sysconfig, but is explicitly opting out and using distutils instead.\nif _USE_SYSCONFIG_DEFAULT and not _USE_SYSCONFIG:\n    _MISMATCH_LEVEL = logging.WARNING\nelse:\n    _MISMATCH_LEVEL = logging.DEBUG\n\n\ndef _looks_like_bpo_44860() -> bool:\n    \"\"\"The resolution to bpo-44860 will change this incorrect platlib.\n\n    See <https://bugs.python.org/issue44860>.\n    \"\"\"\n    from distutils.command.install import INSTALL_SCHEMES\n\n    try:\n        unix_user_platlib = INSTALL_SCHEMES[\"unix_user\"][\"platlib\"]\n    except KeyError:\n        return False\n    return unix_user_platlib == \"$usersite\"\n\n\ndef _looks_like_red_hat_patched_platlib_purelib(scheme: Dict[str, str]) -> bool:\n    platlib = scheme[\"platlib\"]\n    if \"/$platlibdir/\" in platlib:\n        platlib = platlib.replace(\"/$platlibdir/\", f\"/{_PLATLIBDIR}/\")\n    if \"/lib64/\" not in platlib:\n        return False\n    unpatched = platlib.replace(\"/lib64/\", \"/lib/\")\n    return unpatched.replace(\"$platbase/\", \"$base/\") == scheme[\"purelib\"]\n\n\n@functools.lru_cache(maxsize=None)\ndef _looks_like_red_hat_lib() -> bool:\n    \"\"\"Red Hat patches platlib in unix_prefix and unix_home, but not purelib.\n\n    This is the only way I can see to tell a Red Hat-patched Python.\n    \"\"\"\n    from distutils.command.install import INSTALL_SCHEMES\n\n    return all(\n        k in INSTALL_SCHEMES\n        and _looks_like_red_hat_patched_platlib_purelib(INSTALL_SCHEMES[k])\n        for k in (\"unix_prefix\", \"unix_home\")\n    )\n\n\n@functools.lru_cache(maxsize=None)\ndef _looks_like_debian_scheme() -> bool:\n    \"\"\"Debian adds two additional schemes.\"\"\"\n    from distutils.command.install import INSTALL_SCHEMES\n\n    return \"deb_system\" in INSTALL_SCHEMES and \"unix_local\" in INSTALL_SCHEMES\n\n\n@functools.lru_cache(maxsize=None)\ndef _looks_like_red_hat_scheme() -> bool:\n    \"\"\"Red Hat patches ``sys.prefix`` and ``sys.exec_prefix``.\n\n    Red Hat's ``00251-change-user-install-location.patch`` changes the install\n    command's ``prefix`` and ``exec_prefix`` to append ``\"/local\"``. This is\n    (fortunately?) done quite unconditionally, so we create a default command\n    object without any configuration to detect this.\n    \"\"\"\n    from distutils.command.install import install\n    from distutils.dist import Distribution\n\n    cmd: Any = install(Distribution())\n    cmd.finalize_options()\n    return (\n        cmd.exec_prefix == f\"{os.path.normpath(sys.exec_prefix)}/local\"\n        and cmd.prefix == f\"{os.path.normpath(sys.prefix)}/local\"\n    )\n\n\n@functools.lru_cache(maxsize=None)\ndef _looks_like_slackware_scheme() -> bool:\n    \"\"\"Slackware patches sysconfig but fails to patch distutils and site.\n\n    Slackware changes sysconfig's user scheme to use ``\"lib64\"`` for the lib\n    path, but does not do the same to the site module.\n    \"\"\"\n    if user_site is None:  # User-site not available.\n        return False\n    try:\n        paths = sysconfig.get_paths(scheme=\"posix_user\", expand=False)\n    except KeyError:  # User-site not available.\n        return False\n    return \"/lib64/\" in paths[\"purelib\"] and \"/lib64/\" not in user_site\n\n\n@functools.lru_cache(maxsize=None)\ndef _looks_like_msys2_mingw_scheme() -> bool:\n    \"\"\"MSYS2 patches distutils and sysconfig to use a UNIX-like scheme.\n\n    However, MSYS2 incorrectly patches sysconfig ``nt`` scheme. The fix is\n    likely going to be included in their 3.10 release, so we ignore the warning.\n    See msys2/MINGW-packages#9319.\n\n    MSYS2 MINGW's patch uses lowercase ``\"lib\"`` instead of the usual uppercase,\n    and is missing the final ``\"site-packages\"``.\n    \"\"\"\n    paths = sysconfig.get_paths(\"nt\", expand=False)\n    return all(\n        \"Lib\" not in p and \"lib\" in p and not p.endswith(\"site-packages\")\n        for p in (paths[key] for key in (\"platlib\", \"purelib\"))\n    )\n\n\ndef _fix_abiflags(parts: Tuple[str]) -> Generator[str, None, None]:\n    ldversion = sysconfig.get_config_var(\"LDVERSION\")\n    abiflags = getattr(sys, \"abiflags\", None)\n\n    # LDVERSION does not end with sys.abiflags. Just return the path unchanged.\n    if not ldversion or not abiflags or not ldversion.endswith(abiflags):\n        yield from parts\n        return\n\n    # Strip sys.abiflags from LDVERSION-based path components.\n    for part in parts:\n        if part.endswith(ldversion):\n            part = part[: (0 - len(abiflags))]\n        yield part\n\n\n@functools.lru_cache(maxsize=None)\ndef _warn_mismatched(old: pathlib.Path, new: pathlib.Path, *, key: str) -> None:\n    issue_url = \"https://github.com/pypa/pip/issues/10151\"\n    message = (\n        \"Value for %s does not match. Please report this to <%s>\"\n        \"\\ndistutils: %s\"\n        \"\\nsysconfig: %s\"\n    )\n    logger.log(_MISMATCH_LEVEL, message, key, issue_url, old, new)\n\n\ndef _warn_if_mismatch(old: pathlib.Path, new: pathlib.Path, *, key: str) -> bool:\n    if old == new:\n        return False\n    _warn_mismatched(old, new, key=key)\n    return True\n\n\n@functools.lru_cache(maxsize=None)\ndef _log_context(\n    *,\n    user: bool = False,\n    home: Optional[str] = None,\n    root: Optional[str] = None,\n    prefix: Optional[str] = None,\n) -> None:\n    parts = [\n        \"Additional context:\",\n        \"user = %r\",\n        \"home = %r\",\n        \"root = %r\",\n        \"prefix = %r\",\n    ]\n\n    logger.log(_MISMATCH_LEVEL, \"\\n\".join(parts), user, home, root, prefix)\n\n\ndef get_scheme(\n    dist_name: str,\n    user: bool = False,\n    home: Optional[str] = None,\n    root: Optional[str] = None,\n    isolated: bool = False,\n    prefix: Optional[str] = None,\n) -> Scheme:\n    new = _sysconfig.get_scheme(\n        dist_name,\n        user=user,\n        home=home,\n        root=root,\n        isolated=isolated,\n        prefix=prefix,\n    )\n    if _USE_SYSCONFIG:\n        return new\n\n    old = _distutils.get_scheme(\n        dist_name,\n        user=user,\n        home=home,\n        root=root,\n        isolated=isolated,\n        prefix=prefix,\n    )\n\n    warning_contexts = []\n    for k in SCHEME_KEYS:\n        old_v = pathlib.Path(getattr(old, k))\n        new_v = pathlib.Path(getattr(new, k))\n\n        if old_v == new_v:\n            continue\n\n        # distutils incorrectly put PyPy packages under ``site-packages/python``\n        # in the ``posix_home`` scheme, but PyPy devs said they expect the\n        # directory name to be ``pypy`` instead. So we treat this as a bug fix\n        # and not warn about it. See bpo-43307 and python/cpython#24628.\n        skip_pypy_special_case = (\n            sys.implementation.name == \"pypy\"\n            and home is not None\n            and k in (\"platlib\", \"purelib\")\n            and old_v.parent == new_v.parent\n            and old_v.name.startswith(\"python\")\n            and new_v.name.startswith(\"pypy\")\n        )\n        if skip_pypy_special_case:\n            continue\n\n        # sysconfig's ``osx_framework_user`` does not include ``pythonX.Y`` in\n        # the ``include`` value, but distutils's ``headers`` does. We'll let\n        # CPython decide whether this is a bug or feature. See bpo-43948.\n        skip_osx_framework_user_special_case = (\n            user\n            and is_osx_framework()\n            and k == \"headers\"\n            and old_v.parent.parent == new_v.parent\n            and old_v.parent.name.startswith(\"python\")\n        )\n        if skip_osx_framework_user_special_case:\n            continue\n\n        # On Red Hat and derived Linux distributions, distutils is patched to\n        # use \"lib64\" instead of \"lib\" for platlib.\n        if k == \"platlib\" and _looks_like_red_hat_lib():\n            continue\n\n        # On Python 3.9+, sysconfig's posix_user scheme sets platlib against\n        # sys.platlibdir, but distutils's unix_user incorrectly coninutes\n        # using the same $usersite for both platlib and purelib. This creates a\n        # mismatch when sys.platlibdir is not \"lib\".\n        skip_bpo_44860 = (\n            user\n            and k == \"platlib\"\n            and not WINDOWS\n            and sys.version_info >= (3, 9)\n            and _PLATLIBDIR != \"lib\"\n            and _looks_like_bpo_44860()\n        )\n        if skip_bpo_44860:\n            continue\n\n        # Slackware incorrectly patches posix_user to use lib64 instead of lib,\n        # but not usersite to match the location.\n        skip_slackware_user_scheme = (\n            user\n            and k in (\"platlib\", \"purelib\")\n            and not WINDOWS\n            and _looks_like_slackware_scheme()\n        )\n        if skip_slackware_user_scheme:\n            continue\n\n        # Both Debian and Red Hat patch Python to place the system site under\n        # /usr/local instead of /usr. Debian also places lib in dist-packages\n        # instead of site-packages, but the /usr/local check should cover it.\n        skip_linux_system_special_case = (\n            not (user or home or prefix or running_under_virtualenv())\n            and old_v.parts[1:3] == (\"usr\", \"local\")\n            and len(new_v.parts) > 1\n            and new_v.parts[1] == \"usr\"\n            and (len(new_v.parts) < 3 or new_v.parts[2] != \"local\")\n            and (_looks_like_red_hat_scheme() or _looks_like_debian_scheme())\n        )\n        if skip_linux_system_special_case:\n            continue\n\n        # On Python 3.7 and earlier, sysconfig does not include sys.abiflags in\n        # the \"pythonX.Y\" part of the path, but distutils does.\n        skip_sysconfig_abiflag_bug = (\n            sys.version_info < (3, 8)\n            and not WINDOWS\n            and k in (\"headers\", \"platlib\", \"purelib\")\n            and tuple(_fix_abiflags(old_v.parts)) == new_v.parts\n        )\n        if skip_sysconfig_abiflag_bug:\n            continue\n\n        # MSYS2 MINGW's sysconfig patch does not include the \"site-packages\"\n        # part of the path. This is incorrect and will be fixed in MSYS.\n        skip_msys2_mingw_bug = (\n            WINDOWS and k in (\"platlib\", \"purelib\") and _looks_like_msys2_mingw_scheme()\n        )\n        if skip_msys2_mingw_bug:\n            continue\n\n        # CPython's POSIX install script invokes pip (via ensurepip) against the\n        # interpreter located in the source tree, not the install site. This\n        # triggers special logic in sysconfig that's not present in distutils.\n        # https://github.com/python/cpython/blob/8c21941ddaf/Lib/sysconfig.py#L178-L194\n        skip_cpython_build = (\n            sysconfig.is_python_build(check_home=True)\n            and not WINDOWS\n            and k in (\"headers\", \"include\", \"platinclude\")\n        )\n        if skip_cpython_build:\n            continue\n\n        warning_contexts.append((old_v, new_v, f\"scheme.{k}\"))\n\n    if not warning_contexts:\n        return old\n\n    # Check if this path mismatch is caused by distutils config files. Those\n    # files will no longer work once we switch to sysconfig, so this raises a\n    # deprecation message for them.\n    default_old = _distutils.distutils_scheme(\n        dist_name,\n        user,\n        home,\n        root,\n        isolated,\n        prefix,\n        ignore_config_files=True,\n    )\n    if any(default_old[k] != getattr(old, k) for k in SCHEME_KEYS):\n        deprecated(\n            reason=(\n                \"Configuring installation scheme with distutils config files \"\n                \"is deprecated and will no longer work in the near future. If you \"\n                \"are using a Homebrew or Linuxbrew Python, please see discussion \"\n                \"at https://github.com/Homebrew/homebrew-core/issues/76621\"\n            ),\n            replacement=None,\n            gone_in=None,\n        )\n        return old\n\n    # Post warnings about this mismatch so user can report them back.\n    for old_v, new_v, key in warning_contexts:\n        _warn_mismatched(old_v, new_v, key=key)\n    _log_context(user=user, home=home, root=root, prefix=prefix)\n\n    return old\n\n\ndef get_bin_prefix() -> str:\n    new = _sysconfig.get_bin_prefix()\n    if _USE_SYSCONFIG:\n        return new\n\n    old = _distutils.get_bin_prefix()\n    if _warn_if_mismatch(pathlib.Path(old), pathlib.Path(new), key=\"bin_prefix\"):\n        _log_context()\n    return old\n\n\ndef get_bin_user() -> str:\n    return _sysconfig.get_scheme(\"\", user=True).scripts\n\n\ndef _looks_like_deb_system_dist_packages(value: str) -> bool:\n    \"\"\"Check if the value is Debian's APT-controlled dist-packages.\n\n    Debian's ``distutils.sysconfig.get_python_lib()`` implementation returns the\n    default package path controlled by APT, but does not patch ``sysconfig`` to\n    do the same. This is similar to the bug worked around in ``get_scheme()``,\n    but here the default is ``deb_system`` instead of ``unix_local``. Ultimately\n    we can't do anything about this Debian bug, and this detection allows us to\n    skip the warning when needed.\n    \"\"\"\n    if not _looks_like_debian_scheme():\n        return False\n    if value == \"/usr/lib/python3/dist-packages\":\n        return True\n    return False\n\n\ndef get_purelib() -> str:\n    \"\"\"Return the default pure-Python lib location.\"\"\"\n    new = _sysconfig.get_purelib()\n    if _USE_SYSCONFIG:\n        return new\n\n    old = _distutils.get_purelib()\n    if _looks_like_deb_system_dist_packages(old):\n        return old\n    if _warn_if_mismatch(pathlib.Path(old), pathlib.Path(new), key=\"purelib\"):\n        _log_context()\n    return old\n\n\ndef get_platlib() -> str:\n    \"\"\"Return the default platform-shared lib location.\"\"\"\n    new = _sysconfig.get_platlib()\n    if _USE_SYSCONFIG:\n        return new\n\n    from . import _distutils\n\n    old = _distutils.get_platlib()\n    if _looks_like_deb_system_dist_packages(old):\n        return old\n    if _warn_if_mismatch(pathlib.Path(old), pathlib.Path(new), key=\"platlib\"):\n        _log_context()\n    return old\n"},"hash":"o5Tyq2z3E5"}