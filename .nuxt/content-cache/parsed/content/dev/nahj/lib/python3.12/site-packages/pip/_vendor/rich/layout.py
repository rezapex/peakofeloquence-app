{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:rich:layout.py","body":"from abc import ABC, abstractmethod\nfrom itertools import islice\nfrom operator import itemgetter\nfrom threading import RLock\nfrom typing import (\n    TYPE_CHECKING,\n    Dict,\n    Iterable,\n    List,\n    NamedTuple,\n    Optional,\n    Sequence,\n    Tuple,\n    Union,\n)\n\nfrom ._ratio import ratio_resolve\nfrom .align import Align\nfrom .console import Console, ConsoleOptions, RenderableType, RenderResult\nfrom .highlighter import ReprHighlighter\nfrom .panel import Panel\nfrom .pretty import Pretty\nfrom .region import Region\nfrom .repr import Result, rich_repr\nfrom .segment import Segment\nfrom .style import StyleType\n\nif TYPE_CHECKING:\n    from pip._vendor.rich.tree import Tree\n\n\nclass LayoutRender(NamedTuple):\n    \"\"\"An individual layout render.\"\"\"\n\n    region: Region\n    render: List[List[Segment]]\n\n\nRegionMap = Dict[\"Layout\", Region]\nRenderMap = Dict[\"Layout\", LayoutRender]\n\n\nclass LayoutError(Exception):\n    \"\"\"Layout related error.\"\"\"\n\n\nclass NoSplitter(LayoutError):\n    \"\"\"Requested splitter does not exist.\"\"\"\n\n\nclass _Placeholder:\n    \"\"\"An internal renderable used as a Layout placeholder.\"\"\"\n\n    highlighter = ReprHighlighter()\n\n    def __init__(self, layout: \"Layout\", style: StyleType = \"\") -> None:\n        self.layout = layout\n        self.style = style\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        width = options.max_width\n        height = options.height or options.size.height\n        layout = self.layout\n        title = (\n            f\"{layout.name!r} ({width} x {height})\"\n            if layout.name\n            else f\"({width} x {height})\"\n        )\n        yield Panel(\n            Align.center(Pretty(layout), vertical=\"middle\"),\n            style=self.style,\n            title=self.highlighter(title),\n            border_style=\"blue\",\n            height=height,\n        )\n\n\nclass Splitter(ABC):\n    \"\"\"Base class for a splitter.\"\"\"\n\n    name: str = \"\"\n\n    @abstractmethod\n    def get_tree_icon(self) -> str:\n        \"\"\"Get the icon (emoji) used in layout.tree\"\"\"\n\n    @abstractmethod\n    def divide(\n        self, children: Sequence[\"Layout\"], region: Region\n    ) -> Iterable[Tuple[\"Layout\", Region]]:\n        \"\"\"Divide a region amongst several child layouts.\n\n        Args:\n            children (Sequence(Layout)): A number of child layouts.\n            region (Region): A rectangular region to divide.\n        \"\"\"\n\n\nclass RowSplitter(Splitter):\n    \"\"\"Split a layout region in to rows.\"\"\"\n\n    name = \"row\"\n\n    def get_tree_icon(self) -> str:\n        return \"[layout.tree.row]⬌\"\n\n    def divide(\n        self, children: Sequence[\"Layout\"], region: Region\n    ) -> Iterable[Tuple[\"Layout\", Region]]:\n        x, y, width, height = region\n        render_widths = ratio_resolve(width, children)\n        offset = 0\n        _Region = Region\n        for child, child_width in zip(children, render_widths):\n            yield child, _Region(x + offset, y, child_width, height)\n            offset += child_width\n\n\nclass ColumnSplitter(Splitter):\n    \"\"\"Split a layout region in to columns.\"\"\"\n\n    name = \"column\"\n\n    def get_tree_icon(self) -> str:\n        return \"[layout.tree.column]⬍\"\n\n    def divide(\n        self, children: Sequence[\"Layout\"], region: Region\n    ) -> Iterable[Tuple[\"Layout\", Region]]:\n        x, y, width, height = region\n        render_heights = ratio_resolve(height, children)\n        offset = 0\n        _Region = Region\n        for child, child_height in zip(children, render_heights):\n            yield child, _Region(x, y + offset, width, child_height)\n            offset += child_height\n\n\n@rich_repr\nclass Layout:\n    \"\"\"A renderable to divide a fixed height in to rows or columns.\n\n    Args:\n        renderable (RenderableType, optional): Renderable content, or None for placeholder. Defaults to None.\n        name (str, optional): Optional identifier for Layout. Defaults to None.\n        size (int, optional): Optional fixed size of layout. Defaults to None.\n        minimum_size (int, optional): Minimum size of layout. Defaults to 1.\n        ratio (int, optional): Optional ratio for flexible layout. Defaults to 1.\n        visible (bool, optional): Visibility of layout. Defaults to True.\n    \"\"\"\n\n    splitters = {\"row\": RowSplitter, \"column\": ColumnSplitter}\n\n    def __init__(\n        self,\n        renderable: Optional[RenderableType] = None,\n        *,\n        name: Optional[str] = None,\n        size: Optional[int] = None,\n        minimum_size: int = 1,\n        ratio: int = 1,\n        visible: bool = True,\n    ) -> None:\n        self._renderable = renderable or _Placeholder(self)\n        self.size = size\n        self.minimum_size = minimum_size\n        self.ratio = ratio\n        self.name = name\n        self.visible = visible\n        self.splitter: Splitter = self.splitters[\"column\"]()\n        self._children: List[Layout] = []\n        self._render_map: RenderMap = {}\n        self._lock = RLock()\n\n    def __rich_repr__(self) -> Result:\n        yield \"name\", self.name, None\n        yield \"size\", self.size, None\n        yield \"minimum_size\", self.minimum_size, 1\n        yield \"ratio\", self.ratio, 1\n\n    @property\n    def renderable(self) -> RenderableType:\n        \"\"\"Layout renderable.\"\"\"\n        return self if self._children else self._renderable\n\n    @property\n    def children(self) -> List[\"Layout\"]:\n        \"\"\"Gets (visible) layout children.\"\"\"\n        return [child for child in self._children if child.visible]\n\n    @property\n    def map(self) -> RenderMap:\n        \"\"\"Get a map of the last render.\"\"\"\n        return self._render_map\n\n    def get(self, name: str) -> Optional[\"Layout\"]:\n        \"\"\"Get a named layout, or None if it doesn't exist.\n\n        Args:\n            name (str): Name of layout.\n\n        Returns:\n            Optional[Layout]: Layout instance or None if no layout was found.\n        \"\"\"\n        if self.name == name:\n            return self\n        else:\n            for child in self._children:\n                named_layout = child.get(name)\n                if named_layout is not None:\n                    return named_layout\n        return None\n\n    def __getitem__(self, name: str) -> \"Layout\":\n        layout = self.get(name)\n        if layout is None:\n            raise KeyError(f\"No layout with name {name!r}\")\n        return layout\n\n    @property\n    def tree(self) -> \"Tree\":\n        \"\"\"Get a tree renderable to show layout structure.\"\"\"\n        from pip._vendor.rich.styled import Styled\n        from pip._vendor.rich.table import Table\n        from pip._vendor.rich.tree import Tree\n\n        def summary(layout: \"Layout\") -> Table:\n\n            icon = layout.splitter.get_tree_icon()\n\n            table = Table.grid(padding=(0, 1, 0, 0))\n\n            text: RenderableType = (\n                Pretty(layout) if layout.visible else Styled(Pretty(layout), \"dim\")\n            )\n            table.add_row(icon, text)\n            _summary = table\n            return _summary\n\n        layout = self\n        tree = Tree(\n            summary(layout),\n            guide_style=f\"layout.tree.{layout.splitter.name}\",\n            highlight=True,\n        )\n\n        def recurse(tree: \"Tree\", layout: \"Layout\") -> None:\n            for child in layout._children:\n                recurse(\n                    tree.add(\n                        summary(child),\n                        guide_style=f\"layout.tree.{child.splitter.name}\",\n                    ),\n                    child,\n                )\n\n        recurse(tree, self)\n        return tree\n\n    def split(\n        self,\n        *layouts: Union[\"Layout\", RenderableType],\n        splitter: Union[Splitter, str] = \"column\",\n    ) -> None:\n        \"\"\"Split the layout in to multiple sub-layouts.\n\n        Args:\n            *layouts (Layout): Positional arguments should be (sub) Layout instances.\n            splitter (Union[Splitter, str]): Splitter instance or name of splitter.\n        \"\"\"\n        _layouts = [\n            layout if isinstance(layout, Layout) else Layout(layout)\n            for layout in layouts\n        ]\n        try:\n            self.splitter = (\n                splitter\n                if isinstance(splitter, Splitter)\n                else self.splitters[splitter]()\n            )\n        except KeyError:\n            raise NoSplitter(f\"No splitter called {splitter!r}\")\n        self._children[:] = _layouts\n\n    def add_split(self, *layouts: Union[\"Layout\", RenderableType]) -> None:\n        \"\"\"Add a new layout(s) to existing split.\n\n        Args:\n            *layouts (Union[Layout, RenderableType]): Positional arguments should be renderables or (sub) Layout instances.\n\n        \"\"\"\n        _layouts = (\n            layout if isinstance(layout, Layout) else Layout(layout)\n            for layout in layouts\n        )\n        self._children.extend(_layouts)\n\n    def split_row(self, *layouts: Union[\"Layout\", RenderableType]) -> None:\n        \"\"\"Split the layout in to a row (layouts side by side).\n\n        Args:\n            *layouts (Layout): Positional arguments should be (sub) Layout instances.\n        \"\"\"\n        self.split(*layouts, splitter=\"row\")\n\n    def split_column(self, *layouts: Union[\"Layout\", RenderableType]) -> None:\n        \"\"\"Split the layout in to a column (layouts stacked on top of each other).\n\n        Args:\n            *layouts (Layout): Positional arguments should be (sub) Layout instances.\n        \"\"\"\n        self.split(*layouts, splitter=\"column\")\n\n    def unsplit(self) -> None:\n        \"\"\"Reset splits to initial state.\"\"\"\n        del self._children[:]\n\n    def update(self, renderable: RenderableType) -> None:\n        \"\"\"Update renderable.\n\n        Args:\n            renderable (RenderableType): New renderable object.\n        \"\"\"\n        with self._lock:\n            self._renderable = renderable\n\n    def refresh_screen(self, console: \"Console\", layout_name: str) -> None:\n        \"\"\"Refresh a sub-layout.\n\n        Args:\n            console (Console): Console instance where Layout is to be rendered.\n            layout_name (str): Name of layout.\n        \"\"\"\n        with self._lock:\n            layout = self[layout_name]\n            region, _lines = self._render_map[layout]\n            (x, y, width, height) = region\n            lines = console.render_lines(\n                layout, console.options.update_dimensions(width, height)\n            )\n            self._render_map[layout] = LayoutRender(region, lines)\n            console.update_screen_lines(lines, x, y)\n\n    def _make_region_map(self, width: int, height: int) -> RegionMap:\n        \"\"\"Create a dict that maps layout on to Region.\"\"\"\n        stack: List[Tuple[Layout, Region]] = [(self, Region(0, 0, width, height))]\n        push = stack.append\n        pop = stack.pop\n        layout_regions: List[Tuple[Layout, Region]] = []\n        append_layout_region = layout_regions.append\n        while stack:\n            append_layout_region(pop())\n            layout, region = layout_regions[-1]\n            children = layout.children\n            if children:\n                for child_and_region in layout.splitter.divide(children, region):\n                    push(child_and_region)\n\n        region_map = {\n            layout: region\n            for layout, region in sorted(layout_regions, key=itemgetter(1))\n        }\n        return region_map\n\n    def render(self, console: Console, options: ConsoleOptions) -> RenderMap:\n        \"\"\"Render the sub_layouts.\n\n        Args:\n            console (Console): Console instance.\n            options (ConsoleOptions): Console options.\n\n        Returns:\n            RenderMap: A dict that maps Layout on to a tuple of Region, lines\n        \"\"\"\n        render_width = options.max_width\n        render_height = options.height or console.height\n        region_map = self._make_region_map(render_width, render_height)\n        layout_regions = [\n            (layout, region)\n            for layout, region in region_map.items()\n            if not layout.children\n        ]\n        render_map: Dict[\"Layout\", \"LayoutRender\"] = {}\n        render_lines = console.render_lines\n        update_dimensions = options.update_dimensions\n\n        for layout, region in layout_regions:\n            lines = render_lines(\n                layout.renderable, update_dimensions(region.width, region.height)\n            )\n            render_map[layout] = LayoutRender(region, lines)\n        return render_map\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        with self._lock:\n            width = options.max_width or console.width\n            height = options.height or console.height\n            render_map = self.render(console, options.update_dimensions(width, height))\n            self._render_map = render_map\n            layout_lines: List[List[Segment]] = [[] for _ in range(height)]\n            _islice = islice\n            for (region, lines) in render_map.values():\n                _x, y, _layout_width, layout_height = region\n                for row, line in zip(\n                    _islice(layout_lines, y, y + layout_height), lines\n                ):\n                    row.extend(line)\n\n            new_line = Segment.line()\n            for layout_row in layout_lines:\n                yield from layout_row\n                yield new_line\n\n\nif __name__ == \"__main__\":\n    from pip._vendor.rich.console import Console\n\n    console = Console()\n    layout = Layout()\n\n    layout.split_column(\n        Layout(name=\"header\", size=3),\n        Layout(ratio=1, name=\"main\"),\n        Layout(size=10, name=\"footer\"),\n    )\n\n    layout[\"main\"].split_row(Layout(name=\"side\"), Layout(name=\"body\", ratio=2))\n\n    layout[\"body\"].split_row(Layout(name=\"content\", ratio=2), Layout(name=\"s2\"))\n\n    layout[\"s2\"].split_column(\n        Layout(name=\"top\"), Layout(name=\"middle\"), Layout(name=\"bottom\")\n    )\n\n    layout[\"side\"].split_column(Layout(layout.tree, name=\"left1\"), Layout(name=\"left2\"))\n\n    layout[\"content\"].update(\"foo\")\n\n    console.print(layout)\n"},"hash":"K1U7Lzv7NJ"}