{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:chardet:universaldetector.py","body":"######################## BEGIN LICENSE BLOCK ########################\n# The Original Code is Mozilla Universal charset detector code.\n#\n# The Initial Developer of the Original Code is\n# Netscape Communications Corporation.\n# Portions created by the Initial Developer are Copyright (C) 2001\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Mark Pilgrim - port to Python\n#   Shy Shalom - original C code\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n# 02110-1301  USA\n######################### END LICENSE BLOCK #########################\n\"\"\"\nModule containing the UniversalDetector detector class, which is the primary\nclass a user of ``chardet`` should use.\n\n:author: Mark Pilgrim (initial port to Python)\n:author: Shy Shalom (original C code)\n:author: Dan Blanchard (major refactoring for 3.0)\n:author: Ian Cordasco\n\"\"\"\n\n\nimport codecs\nimport logging\nimport re\nfrom typing import List, Optional, Union\n\nfrom .charsetgroupprober import CharSetGroupProber\nfrom .charsetprober import CharSetProber\nfrom .enums import InputState, LanguageFilter, ProbingState\nfrom .escprober import EscCharSetProber\nfrom .latin1prober import Latin1Prober\nfrom .macromanprober import MacRomanProber\nfrom .mbcsgroupprober import MBCSGroupProber\nfrom .resultdict import ResultDict\nfrom .sbcsgroupprober import SBCSGroupProber\nfrom .utf1632prober import UTF1632Prober\n\n\nclass UniversalDetector:\n    \"\"\"\n    The ``UniversalDetector`` class underlies the ``chardet.detect`` function\n    and coordinates all of the different charset probers.\n\n    To get a ``dict`` containing an encoding and its confidence, you can simply\n    run:\n\n    .. code::\n\n            u = UniversalDetector()\n            u.feed(some_bytes)\n            u.close()\n            detected = u.result\n\n    \"\"\"\n\n    MINIMUM_THRESHOLD = 0.20\n    HIGH_BYTE_DETECTOR = re.compile(b\"[\\x80-\\xFF]\")\n    ESC_DETECTOR = re.compile(b\"(\\033|~{)\")\n    WIN_BYTE_DETECTOR = re.compile(b\"[\\x80-\\x9F]\")\n    ISO_WIN_MAP = {\n        \"iso-8859-1\": \"Windows-1252\",\n        \"iso-8859-2\": \"Windows-1250\",\n        \"iso-8859-5\": \"Windows-1251\",\n        \"iso-8859-6\": \"Windows-1256\",\n        \"iso-8859-7\": \"Windows-1253\",\n        \"iso-8859-8\": \"Windows-1255\",\n        \"iso-8859-9\": \"Windows-1254\",\n        \"iso-8859-13\": \"Windows-1257\",\n    }\n    # Based on https://encoding.spec.whatwg.org/#names-and-labels\n    # but altered to match Python names for encodings and remove mappings\n    # that break tests.\n    LEGACY_MAP = {\n        \"ascii\": \"Windows-1252\",\n        \"iso-8859-1\": \"Windows-1252\",\n        \"tis-620\": \"ISO-8859-11\",\n        \"iso-8859-9\": \"Windows-1254\",\n        \"gb2312\": \"GB18030\",\n        \"euc-kr\": \"CP949\",\n        \"utf-16le\": \"UTF-16\",\n    }\n\n    def __init__(\n        self,\n        lang_filter: LanguageFilter = LanguageFilter.ALL,\n        should_rename_legacy: bool = False,\n    ) -> None:\n        self._esc_charset_prober: Optional[EscCharSetProber] = None\n        self._utf1632_prober: Optional[UTF1632Prober] = None\n        self._charset_probers: List[CharSetProber] = []\n        self.result: ResultDict = {\n            \"encoding\": None,\n            \"confidence\": 0.0,\n            \"language\": None,\n        }\n        self.done = False\n        self._got_data = False\n        self._input_state = InputState.PURE_ASCII\n        self._last_char = b\"\"\n        self.lang_filter = lang_filter\n        self.logger = logging.getLogger(__name__)\n        self._has_win_bytes = False\n        self.should_rename_legacy = should_rename_legacy\n        self.reset()\n\n    @property\n    def input_state(self) -> int:\n        return self._input_state\n\n    @property\n    def has_win_bytes(self) -> bool:\n        return self._has_win_bytes\n\n    @property\n    def charset_probers(self) -> List[CharSetProber]:\n        return self._charset_probers\n\n    def reset(self) -> None:\n        \"\"\"\n        Reset the UniversalDetector and all of its probers back to their\n        initial states.  This is called by ``__init__``, so you only need to\n        call this directly in between analyses of different documents.\n        \"\"\"\n        self.result = {\"encoding\": None, \"confidence\": 0.0, \"language\": None}\n        self.done = False\n        self._got_data = False\n        self._has_win_bytes = False\n        self._input_state = InputState.PURE_ASCII\n        self._last_char = b\"\"\n        if self._esc_charset_prober:\n            self._esc_charset_prober.reset()\n        if self._utf1632_prober:\n            self._utf1632_prober.reset()\n        for prober in self._charset_probers:\n            prober.reset()\n\n    def feed(self, byte_str: Union[bytes, bytearray]) -> None:\n        \"\"\"\n        Takes a chunk of a document and feeds it through all of the relevant\n        charset probers.\n\n        After calling ``feed``, you can check the value of the ``done``\n        attribute to see if you need to continue feeding the\n        ``UniversalDetector`` more data, or if it has made a prediction\n        (in the ``result`` attribute).\n\n        .. note::\n           You should always call ``close`` when you're done feeding in your\n           document if ``done`` is not already ``True``.\n        \"\"\"\n        if self.done:\n            return\n\n        if not byte_str:\n            return\n\n        if not isinstance(byte_str, bytearray):\n            byte_str = bytearray(byte_str)\n\n        # First check for known BOMs, since these are guaranteed to be correct\n        if not self._got_data:\n            # If the data starts with BOM, we know it is UTF\n            if byte_str.startswith(codecs.BOM_UTF8):\n                # EF BB BF  UTF-8 with BOM\n                self.result = {\n                    \"encoding\": \"UTF-8-SIG\",\n                    \"confidence\": 1.0,\n                    \"language\": \"\",\n                }\n            elif byte_str.startswith((codecs.BOM_UTF32_LE, codecs.BOM_UTF32_BE)):\n                # FF FE 00 00  UTF-32, little-endian BOM\n                # 00 00 FE FF  UTF-32, big-endian BOM\n                self.result = {\"encoding\": \"UTF-32\", \"confidence\": 1.0, \"language\": \"\"}\n            elif byte_str.startswith(b\"\\xFE\\xFF\\x00\\x00\"):\n                # FE FF 00 00  UCS-4, unusual octet order BOM (3412)\n                self.result = {\n                    # TODO: This encoding is not supported by Python. Should remove?\n                    \"encoding\": \"X-ISO-10646-UCS-4-3412\",\n                    \"confidence\": 1.0,\n                    \"language\": \"\",\n                }\n            elif byte_str.startswith(b\"\\x00\\x00\\xFF\\xFE\"):\n                # 00 00 FF FE  UCS-4, unusual octet order BOM (2143)\n                self.result = {\n                    # TODO: This encoding is not supported by Python. Should remove?\n                    \"encoding\": \"X-ISO-10646-UCS-4-2143\",\n                    \"confidence\": 1.0,\n                    \"language\": \"\",\n                }\n            elif byte_str.startswith((codecs.BOM_LE, codecs.BOM_BE)):\n                # FF FE  UTF-16, little endian BOM\n                # FE FF  UTF-16, big endian BOM\n                self.result = {\"encoding\": \"UTF-16\", \"confidence\": 1.0, \"language\": \"\"}\n\n            self._got_data = True\n            if self.result[\"encoding\"] is not None:\n                self.done = True\n                return\n\n        # If none of those matched and we've only see ASCII so far, check\n        # for high bytes and escape sequences\n        if self._input_state == InputState.PURE_ASCII:\n            if self.HIGH_BYTE_DETECTOR.search(byte_str):\n                self._input_state = InputState.HIGH_BYTE\n            elif (\n                self._input_state == InputState.PURE_ASCII\n                and self.ESC_DETECTOR.search(self._last_char + byte_str)\n            ):\n                self._input_state = InputState.ESC_ASCII\n\n        self._last_char = byte_str[-1:]\n\n        # next we will look to see if it is appears to be either a UTF-16 or\n        # UTF-32 encoding\n        if not self._utf1632_prober:\n            self._utf1632_prober = UTF1632Prober()\n\n        if self._utf1632_prober.state == ProbingState.DETECTING:\n            if self._utf1632_prober.feed(byte_str) == ProbingState.FOUND_IT:\n                self.result = {\n                    \"encoding\": self._utf1632_prober.charset_name,\n                    \"confidence\": self._utf1632_prober.get_confidence(),\n                    \"language\": \"\",\n                }\n                self.done = True\n                return\n\n        # If we've seen escape sequences, use the EscCharSetProber, which\n        # uses a simple state machine to check for known escape sequences in\n        # HZ and ISO-2022 encodings, since those are the only encodings that\n        # use such sequences.\n        if self._input_state == InputState.ESC_ASCII:\n            if not self._esc_charset_prober:\n                self._esc_charset_prober = EscCharSetProber(self.lang_filter)\n            if self._esc_charset_prober.feed(byte_str) == ProbingState.FOUND_IT:\n                self.result = {\n                    \"encoding\": self._esc_charset_prober.charset_name,\n                    \"confidence\": self._esc_charset_prober.get_confidence(),\n                    \"language\": self._esc_charset_prober.language,\n                }\n                self.done = True\n        # If we've seen high bytes (i.e., those with values greater than 127),\n        # we need to do more complicated checks using all our multi-byte and\n        # single-byte probers that are left.  The single-byte probers\n        # use character bigram distributions to determine the encoding, whereas\n        # the multi-byte probers use a combination of character unigram and\n        # bigram distributions.\n        elif self._input_state == InputState.HIGH_BYTE:\n            if not self._charset_probers:\n                self._charset_probers = [MBCSGroupProber(self.lang_filter)]\n                # If we're checking non-CJK encodings, use single-byte prober\n                if self.lang_filter & LanguageFilter.NON_CJK:\n                    self._charset_probers.append(SBCSGroupProber())\n                self._charset_probers.append(Latin1Prober())\n                self._charset_probers.append(MacRomanProber())\n            for prober in self._charset_probers:\n                if prober.feed(byte_str) == ProbingState.FOUND_IT:\n                    self.result = {\n                        \"encoding\": prober.charset_name,\n                        \"confidence\": prober.get_confidence(),\n                        \"language\": prober.language,\n                    }\n                    self.done = True\n                    break\n            if self.WIN_BYTE_DETECTOR.search(byte_str):\n                self._has_win_bytes = True\n\n    def close(self) -> ResultDict:\n        \"\"\"\n        Stop analyzing the current document and come up with a final\n        prediction.\n\n        :returns:  The ``result`` attribute, a ``dict`` with the keys\n                   `encoding`, `confidence`, and `language`.\n        \"\"\"\n        # Don't bother with checks if we're already done\n        if self.done:\n            return self.result\n        self.done = True\n\n        if not self._got_data:\n            self.logger.debug(\"no data received!\")\n\n        # Default to ASCII if it is all we've seen so far\n        elif self._input_state == InputState.PURE_ASCII:\n            self.result = {\"encoding\": \"ascii\", \"confidence\": 1.0, \"language\": \"\"}\n\n        # If we have seen non-ASCII, return the best that met MINIMUM_THRESHOLD\n        elif self._input_state == InputState.HIGH_BYTE:\n            prober_confidence = None\n            max_prober_confidence = 0.0\n            max_prober = None\n            for prober in self._charset_probers:\n                if not prober:\n                    continue\n                prober_confidence = prober.get_confidence()\n                if prober_confidence > max_prober_confidence:\n                    max_prober_confidence = prober_confidence\n                    max_prober = prober\n            if max_prober and (max_prober_confidence > self.MINIMUM_THRESHOLD):\n                charset_name = max_prober.charset_name\n                assert charset_name is not None\n                lower_charset_name = charset_name.lower()\n                confidence = max_prober.get_confidence()\n                # Use Windows encoding name instead of ISO-8859 if we saw any\n                # extra Windows-specific bytes\n                if lower_charset_name.startswith(\"iso-8859\"):\n                    if self._has_win_bytes:\n                        charset_name = self.ISO_WIN_MAP.get(\n                            lower_charset_name, charset_name\n                        )\n                # Rename legacy encodings with superset encodings if asked\n                if self.should_rename_legacy:\n                    charset_name = self.LEGACY_MAP.get(\n                        (charset_name or \"\").lower(), charset_name\n                    )\n                self.result = {\n                    \"encoding\": charset_name,\n                    \"confidence\": confidence,\n                    \"language\": max_prober.language,\n                }\n\n        # Log all prober confidences if none met MINIMUM_THRESHOLD\n        if self.logger.getEffectiveLevel() <= logging.DEBUG:\n            if self.result[\"encoding\"] is None:\n                self.logger.debug(\"no probers hit minimum threshold\")\n                for group_prober in self._charset_probers:\n                    if not group_prober:\n                        continue\n                    if isinstance(group_prober, CharSetGroupProber):\n                        for prober in group_prober.probers:\n                            self.logger.debug(\n                                \"%s %s confidence = %s\",\n                                prober.charset_name,\n                                prober.language,\n                                prober.get_confidence(),\n                            )\n                    else:\n                        self.logger.debug(\n                            \"%s %s confidence = %s\",\n                            group_prober.charset_name,\n                            group_prober.language,\n                            group_prober.get_confidence(),\n                        )\n        return self.result\n"},"hash":"HH3ZsLskdM"}