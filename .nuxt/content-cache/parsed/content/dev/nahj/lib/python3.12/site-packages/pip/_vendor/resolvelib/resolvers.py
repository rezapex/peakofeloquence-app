{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:resolvelib:resolvers.py","body":"import collections\nimport itertools\nimport operator\n\nfrom .providers import AbstractResolver\nfrom .structs import DirectedGraph, IteratorMapping, build_iter_view\n\nRequirementInformation = collections.namedtuple(\n    \"RequirementInformation\", [\"requirement\", \"parent\"]\n)\n\n\nclass ResolverException(Exception):\n    \"\"\"A base class for all exceptions raised by this module.\n\n    Exceptions derived by this class should all be handled in this module. Any\n    bubbling pass the resolver should be treated as a bug.\n    \"\"\"\n\n\nclass RequirementsConflicted(ResolverException):\n    def __init__(self, criterion):\n        super(RequirementsConflicted, self).__init__(criterion)\n        self.criterion = criterion\n\n    def __str__(self):\n        return \"Requirements conflict: {}\".format(\n            \", \".join(repr(r) for r in self.criterion.iter_requirement()),\n        )\n\n\nclass InconsistentCandidate(ResolverException):\n    def __init__(self, candidate, criterion):\n        super(InconsistentCandidate, self).__init__(candidate, criterion)\n        self.candidate = candidate\n        self.criterion = criterion\n\n    def __str__(self):\n        return \"Provided candidate {!r} does not satisfy {}\".format(\n            self.candidate,\n            \", \".join(repr(r) for r in self.criterion.iter_requirement()),\n        )\n\n\nclass Criterion(object):\n    \"\"\"Representation of possible resolution results of a package.\n\n    This holds three attributes:\n\n    * `information` is a collection of `RequirementInformation` pairs.\n      Each pair is a requirement contributing to this criterion, and the\n      candidate that provides the requirement.\n    * `incompatibilities` is a collection of all known not-to-work candidates\n      to exclude from consideration.\n    * `candidates` is a collection containing all possible candidates deducted\n      from the union of contributing requirements and known incompatibilities.\n      It should never be empty, except when the criterion is an attribute of a\n      raised `RequirementsConflicted` (in which case it is always empty).\n\n    .. note::\n        This class is intended to be externally immutable. **Do not** mutate\n        any of its attribute containers.\n    \"\"\"\n\n    def __init__(self, candidates, information, incompatibilities):\n        self.candidates = candidates\n        self.information = information\n        self.incompatibilities = incompatibilities\n\n    def __repr__(self):\n        requirements = \", \".join(\n            \"({!r}, via={!r})\".format(req, parent)\n            for req, parent in self.information\n        )\n        return \"Criterion({})\".format(requirements)\n\n    def iter_requirement(self):\n        return (i.requirement for i in self.information)\n\n    def iter_parent(self):\n        return (i.parent for i in self.information)\n\n\nclass ResolutionError(ResolverException):\n    pass\n\n\nclass ResolutionImpossible(ResolutionError):\n    def __init__(self, causes):\n        super(ResolutionImpossible, self).__init__(causes)\n        # causes is a list of RequirementInformation objects\n        self.causes = causes\n\n\nclass ResolutionTooDeep(ResolutionError):\n    def __init__(self, round_count):\n        super(ResolutionTooDeep, self).__init__(round_count)\n        self.round_count = round_count\n\n\n# Resolution state in a round.\nState = collections.namedtuple(\"State\", \"mapping criteria backtrack_causes\")\n\n\nclass Resolution(object):\n    \"\"\"Stateful resolution object.\n\n    This is designed as a one-off object that holds information to kick start\n    the resolution process, and holds the results afterwards.\n    \"\"\"\n\n    def __init__(self, provider, reporter):\n        self._p = provider\n        self._r = reporter\n        self._states = []\n\n    @property\n    def state(self):\n        try:\n            return self._states[-1]\n        except IndexError:\n            raise AttributeError(\"state\")\n\n    def _push_new_state(self):\n        \"\"\"Push a new state into history.\n\n        This new state will be used to hold resolution results of the next\n        coming round.\n        \"\"\"\n        base = self._states[-1]\n        state = State(\n            mapping=base.mapping.copy(),\n            criteria=base.criteria.copy(),\n            backtrack_causes=base.backtrack_causes[:],\n        )\n        self._states.append(state)\n\n    def _add_to_criteria(self, criteria, requirement, parent):\n        self._r.adding_requirement(requirement=requirement, parent=parent)\n\n        identifier = self._p.identify(requirement_or_candidate=requirement)\n        criterion = criteria.get(identifier)\n        if criterion:\n            incompatibilities = list(criterion.incompatibilities)\n        else:\n            incompatibilities = []\n\n        matches = self._p.find_matches(\n            identifier=identifier,\n            requirements=IteratorMapping(\n                criteria,\n                operator.methodcaller(\"iter_requirement\"),\n                {identifier: [requirement]},\n            ),\n            incompatibilities=IteratorMapping(\n                criteria,\n                operator.attrgetter(\"incompatibilities\"),\n                {identifier: incompatibilities},\n            ),\n        )\n\n        if criterion:\n            information = list(criterion.information)\n            information.append(RequirementInformation(requirement, parent))\n        else:\n            information = [RequirementInformation(requirement, parent)]\n\n        criterion = Criterion(\n            candidates=build_iter_view(matches),\n            information=information,\n            incompatibilities=incompatibilities,\n        )\n        if not criterion.candidates:\n            raise RequirementsConflicted(criterion)\n        criteria[identifier] = criterion\n\n    def _remove_information_from_criteria(self, criteria, parents):\n        \"\"\"Remove information from parents of criteria.\n\n        Concretely, removes all values from each criterion's ``information``\n        field that have one of ``parents`` as provider of the requirement.\n\n        :param criteria: The criteria to update.\n        :param parents: Identifiers for which to remove information from all criteria.\n        \"\"\"\n        if not parents:\n            return\n        for key, criterion in criteria.items():\n            criteria[key] = Criterion(\n                criterion.candidates,\n                [\n                    information\n                    for information in criterion.information\n                    if (\n                        information.parent is None\n                        or self._p.identify(information.parent) not in parents\n                    )\n                ],\n                criterion.incompatibilities,\n            )\n\n    def _get_preference(self, name):\n        return self._p.get_preference(\n            identifier=name,\n            resolutions=self.state.mapping,\n            candidates=IteratorMapping(\n                self.state.criteria,\n                operator.attrgetter(\"candidates\"),\n            ),\n            information=IteratorMapping(\n                self.state.criteria,\n                operator.attrgetter(\"information\"),\n            ),\n            backtrack_causes=self.state.backtrack_causes,\n        )\n\n    def _is_current_pin_satisfying(self, name, criterion):\n        try:\n            current_pin = self.state.mapping[name]\n        except KeyError:\n            return False\n        return all(\n            self._p.is_satisfied_by(requirement=r, candidate=current_pin)\n            for r in criterion.iter_requirement()\n        )\n\n    def _get_updated_criteria(self, candidate):\n        criteria = self.state.criteria.copy()\n        for requirement in self._p.get_dependencies(candidate=candidate):\n            self._add_to_criteria(criteria, requirement, parent=candidate)\n        return criteria\n\n    def _attempt_to_pin_criterion(self, name):\n        criterion = self.state.criteria[name]\n\n        causes = []\n        for candidate in criterion.candidates:\n            try:\n                criteria = self._get_updated_criteria(candidate)\n            except RequirementsConflicted as e:\n                self._r.rejecting_candidate(e.criterion, candidate)\n                causes.append(e.criterion)\n                continue\n\n            # Check the newly-pinned candidate actually works. This should\n            # always pass under normal circumstances, but in the case of a\n            # faulty provider, we will raise an error to notify the implementer\n            # to fix find_matches() and/or is_satisfied_by().\n            satisfied = all(\n                self._p.is_satisfied_by(requirement=r, candidate=candidate)\n                for r in criterion.iter_requirement()\n            )\n            if not satisfied:\n                raise InconsistentCandidate(candidate, criterion)\n\n            self._r.pinning(candidate=candidate)\n            self.state.criteria.update(criteria)\n\n            # Put newly-pinned candidate at the end. This is essential because\n            # backtracking looks at this mapping to get the last pin.\n            self.state.mapping.pop(name, None)\n            self.state.mapping[name] = candidate\n\n            return []\n\n        # All candidates tried, nothing works. This criterion is a dead\n        # end, signal for backtracking.\n        return causes\n\n    def _backjump(self, causes):\n        \"\"\"Perform backjumping.\n\n        When we enter here, the stack is like this::\n\n            [ state Z ]\n            [ state Y ]\n            [ state X ]\n            .... earlier states are irrelevant.\n\n        1. No pins worked for Z, so it does not have a pin.\n        2. We want to reset state Y to unpinned, and pin another candidate.\n        3. State X holds what state Y was before the pin, but does not\n           have the incompatibility information gathered in state Y.\n\n        Each iteration of the loop will:\n\n        1.  Identify Z. The incompatibility is not always caused by the latest\n            state. For example, given three requirements A, B and C, with\n            dependencies A1, B1 and C1, where A1 and B1 are incompatible: the\n            last state might be related to C, so we want to discard the\n            previous state.\n        2.  Discard Z.\n        3.  Discard Y but remember its incompatibility information gathered\n            previously, and the failure we're dealing with right now.\n        4.  Push a new state Y' based on X, and apply the incompatibility\n            information from Y to Y'.\n        5a. If this causes Y' to conflict, we need to backtrack again. Make Y'\n            the new Z and go back to step 2.\n        5b. If the incompatibilities apply cleanly, end backtracking.\n        \"\"\"\n        incompatible_reqs = itertools.chain(\n            (c.parent for c in causes if c.parent is not None),\n            (c.requirement for c in causes),\n        )\n        incompatible_deps = {self._p.identify(r) for r in incompatible_reqs}\n        while len(self._states) >= 3:\n            # Remove the state that triggered backtracking.\n            del self._states[-1]\n\n            # Ensure to backtrack to a state that caused the incompatibility\n            incompatible_state = False\n            while not incompatible_state:\n                # Retrieve the last candidate pin and known incompatibilities.\n                try:\n                    broken_state = self._states.pop()\n                    name, candidate = broken_state.mapping.popitem()\n                except (IndexError, KeyError):\n                    raise ResolutionImpossible(causes)\n                current_dependencies = {\n                    self._p.identify(d)\n                    for d in self._p.get_dependencies(candidate)\n                }\n                incompatible_state = not current_dependencies.isdisjoint(\n                    incompatible_deps\n                )\n\n            incompatibilities_from_broken = [\n                (k, list(v.incompatibilities))\n                for k, v in broken_state.criteria.items()\n            ]\n\n            # Also mark the newly known incompatibility.\n            incompatibilities_from_broken.append((name, [candidate]))\n\n            # Create a new state from the last known-to-work one, and apply\n            # the previously gathered incompatibility information.\n            def _patch_criteria():\n                for k, incompatibilities in incompatibilities_from_broken:\n                    if not incompatibilities:\n                        continue\n                    try:\n                        criterion = self.state.criteria[k]\n                    except KeyError:\n                        continue\n                    matches = self._p.find_matches(\n                        identifier=k,\n                        requirements=IteratorMapping(\n                            self.state.criteria,\n                            operator.methodcaller(\"iter_requirement\"),\n                        ),\n                        incompatibilities=IteratorMapping(\n                            self.state.criteria,\n                            operator.attrgetter(\"incompatibilities\"),\n                            {k: incompatibilities},\n                        ),\n                    )\n                    candidates = build_iter_view(matches)\n                    if not candidates:\n                        return False\n                    incompatibilities.extend(criterion.incompatibilities)\n                    self.state.criteria[k] = Criterion(\n                        candidates=candidates,\n                        information=list(criterion.information),\n                        incompatibilities=incompatibilities,\n                    )\n                return True\n\n            self._push_new_state()\n            success = _patch_criteria()\n\n            # It works! Let's work on this new state.\n            if success:\n                return True\n\n            # State does not work after applying known incompatibilities.\n            # Try the still previous state.\n\n        # No way to backtrack anymore.\n        return False\n\n    def resolve(self, requirements, max_rounds):\n        if self._states:\n            raise RuntimeError(\"already resolved\")\n\n        self._r.starting()\n\n        # Initialize the root state.\n        self._states = [\n            State(\n                mapping=collections.OrderedDict(),\n                criteria={},\n                backtrack_causes=[],\n            )\n        ]\n        for r in requirements:\n            try:\n                self._add_to_criteria(self.state.criteria, r, parent=None)\n            except RequirementsConflicted as e:\n                raise ResolutionImpossible(e.criterion.information)\n\n        # The root state is saved as a sentinel so the first ever pin can have\n        # something to backtrack to if it fails. The root state is basically\n        # pinning the virtual \"root\" package in the graph.\n        self._push_new_state()\n\n        for round_index in range(max_rounds):\n            self._r.starting_round(index=round_index)\n\n            unsatisfied_names = [\n                key\n                for key, criterion in self.state.criteria.items()\n                if not self._is_current_pin_satisfying(key, criterion)\n            ]\n\n            # All criteria are accounted for. Nothing more to pin, we are done!\n            if not unsatisfied_names:\n                self._r.ending(state=self.state)\n                return self.state\n\n            # keep track of satisfied names to calculate diff after pinning\n            satisfied_names = set(self.state.criteria.keys()) - set(\n                unsatisfied_names\n            )\n\n            # Choose the most preferred unpinned criterion to try.\n            name = min(unsatisfied_names, key=self._get_preference)\n            failure_causes = self._attempt_to_pin_criterion(name)\n\n            if failure_causes:\n                causes = [i for c in failure_causes for i in c.information]\n                # Backjump if pinning fails. The backjump process puts us in\n                # an unpinned state, so we can work on it in the next round.\n                self._r.resolving_conflicts(causes=causes)\n                success = self._backjump(causes)\n                self.state.backtrack_causes[:] = causes\n\n                # Dead ends everywhere. Give up.\n                if not success:\n                    raise ResolutionImpossible(self.state.backtrack_causes)\n            else:\n                # discard as information sources any invalidated names\n                # (unsatisfied names that were previously satisfied)\n                newly_unsatisfied_names = {\n                    key\n                    for key, criterion in self.state.criteria.items()\n                    if key in satisfied_names\n                    and not self._is_current_pin_satisfying(key, criterion)\n                }\n                self._remove_information_from_criteria(\n                    self.state.criteria, newly_unsatisfied_names\n                )\n                # Pinning was successful. Push a new state to do another pin.\n                self._push_new_state()\n\n            self._r.ending_round(index=round_index, state=self.state)\n\n        raise ResolutionTooDeep(max_rounds)\n\n\ndef _has_route_to_root(criteria, key, all_keys, connected):\n    if key in connected:\n        return True\n    if key not in criteria:\n        return False\n    for p in criteria[key].iter_parent():\n        try:\n            pkey = all_keys[id(p)]\n        except KeyError:\n            continue\n        if pkey in connected:\n            connected.add(key)\n            return True\n        if _has_route_to_root(criteria, pkey, all_keys, connected):\n            connected.add(key)\n            return True\n    return False\n\n\nResult = collections.namedtuple(\"Result\", \"mapping graph criteria\")\n\n\ndef _build_result(state):\n    mapping = state.mapping\n    all_keys = {id(v): k for k, v in mapping.items()}\n    all_keys[id(None)] = None\n\n    graph = DirectedGraph()\n    graph.add(None)  # Sentinel as root dependencies' parent.\n\n    connected = {None}\n    for key, criterion in state.criteria.items():\n        if not _has_route_to_root(state.criteria, key, all_keys, connected):\n            continue\n        if key not in graph:\n            graph.add(key)\n        for p in criterion.iter_parent():\n            try:\n                pkey = all_keys[id(p)]\n            except KeyError:\n                continue\n            if pkey not in graph:\n                graph.add(pkey)\n            graph.connect(pkey, key)\n\n    return Result(\n        mapping={k: v for k, v in mapping.items() if k in connected},\n        graph=graph,\n        criteria=state.criteria,\n    )\n\n\nclass Resolver(AbstractResolver):\n    \"\"\"The thing that performs the actual resolution work.\"\"\"\n\n    base_exception = ResolverException\n\n    def resolve(self, requirements, max_rounds=100):\n        \"\"\"Take a collection of constraints, spit out the resolution result.\n\n        The return value is a representation to the final resolution result. It\n        is a tuple subclass with three public members:\n\n        * `mapping`: A dict of resolved candidates. Each key is an identifier\n            of a requirement (as returned by the provider's `identify` method),\n            and the value is the resolved candidate.\n        * `graph`: A `DirectedGraph` instance representing the dependency tree.\n            The vertices are keys of `mapping`, and each edge represents *why*\n            a particular package is included. A special vertex `None` is\n            included to represent parents of user-supplied requirements.\n        * `criteria`: A dict of \"criteria\" that hold detailed information on\n            how edges in the graph are derived. Each key is an identifier of a\n            requirement, and the value is a `Criterion` instance.\n\n        The following exceptions may be raised if a resolution cannot be found:\n\n        * `ResolutionImpossible`: A resolution cannot be found for the given\n            combination of requirements. The `causes` attribute of the\n            exception is a list of (requirement, parent), giving the\n            requirements that could not be satisfied.\n        * `ResolutionTooDeep`: The dependency tree is too deeply nested and\n            the resolver gave up. This is usually caused by a circular\n            dependency, but you can try to resolve this by increasing the\n            `max_rounds` argument.\n        \"\"\"\n        resolution = Resolution(self.provider, self.reporter)\n        state = resolution.resolve(requirements, max_rounds=max_rounds)\n        return _build_result(state)\n"},"hash":"S9ee10Z3f2"}