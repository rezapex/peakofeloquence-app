{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:idna:codec.py","body":"from .core import encode, decode, alabel, ulabel, IDNAError\nimport codecs\nimport re\nfrom typing import Tuple, Optional\n\n_unicode_dots_re = re.compile('[\\u002e\\u3002\\uff0e\\uff61]')\n\nclass Codec(codecs.Codec):\n\n    def encode(self, data: str, errors: str = 'strict') -> Tuple[bytes, int]:\n        if errors != 'strict':\n            raise IDNAError('Unsupported error handling \\\"{}\\\"'.format(errors))\n\n        if not data:\n            return b\"\", 0\n\n        return encode(data), len(data)\n\n    def decode(self, data: bytes, errors: str = 'strict') -> Tuple[str, int]:\n        if errors != 'strict':\n            raise IDNAError('Unsupported error handling \\\"{}\\\"'.format(errors))\n\n        if not data:\n            return '', 0\n\n        return decode(data), len(data)\n\nclass IncrementalEncoder(codecs.BufferedIncrementalEncoder):\n    def _buffer_encode(self, data: str, errors: str, final: bool) -> Tuple[str, int]:  # type: ignore\n        if errors != 'strict':\n            raise IDNAError('Unsupported error handling \\\"{}\\\"'.format(errors))\n\n        if not data:\n            return \"\", 0\n\n        labels = _unicode_dots_re.split(data)\n        trailing_dot = ''\n        if labels:\n            if not labels[-1]:\n                trailing_dot = '.'\n                del labels[-1]\n            elif not final:\n                # Keep potentially unfinished label until the next call\n                del labels[-1]\n                if labels:\n                    trailing_dot = '.'\n\n        result = []\n        size = 0\n        for label in labels:\n            result.append(alabel(label))\n            if size:\n                size += 1\n            size += len(label)\n\n        # Join with U+002E\n        result_str = '.'.join(result) + trailing_dot  # type: ignore\n        size += len(trailing_dot)\n        return result_str, size\n\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    def _buffer_decode(self, data: str, errors: str, final: bool) -> Tuple[str, int]:  # type: ignore\n        if errors != 'strict':\n            raise IDNAError('Unsupported error handling \\\"{}\\\"'.format(errors))\n\n        if not data:\n            return ('', 0)\n\n        labels = _unicode_dots_re.split(data)\n        trailing_dot = ''\n        if labels:\n            if not labels[-1]:\n                trailing_dot = '.'\n                del labels[-1]\n            elif not final:\n                # Keep potentially unfinished label until the next call\n                del labels[-1]\n                if labels:\n                    trailing_dot = '.'\n\n        result = []\n        size = 0\n        for label in labels:\n            result.append(ulabel(label))\n            if size:\n                size += 1\n            size += len(label)\n\n        result_str = '.'.join(result) + trailing_dot\n        size += len(trailing_dot)\n        return (result_str, size)\n\n\nclass StreamWriter(Codec, codecs.StreamWriter):\n    pass\n\n\nclass StreamReader(Codec, codecs.StreamReader):\n    pass\n\n\ndef getregentry() -> codecs.CodecInfo:\n    # Compatibility as a search_function for codecs.register()\n    return codecs.CodecInfo(\n        name='idna',\n        encode=Codec().encode,  # type: ignore\n        decode=Codec().decode,  # type: ignore\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamwriter=StreamWriter,\n        streamreader=StreamReader,\n    )\n"},"hash":"dNOvalaTNG"}