{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:utils:logging.py","body":"import contextlib\nimport errno\nimport logging\nimport logging.handlers\nimport os\nimport sys\nimport threading\nfrom dataclasses import dataclass\nfrom io import TextIOWrapper\nfrom logging import Filter\nfrom typing import Any, ClassVar, Generator, List, Optional, TextIO, Type\n\nfrom pip._vendor.rich.console import (\n    Console,\n    ConsoleOptions,\n    ConsoleRenderable,\n    RenderableType,\n    RenderResult,\n    RichCast,\n)\nfrom pip._vendor.rich.highlighter import NullHighlighter\nfrom pip._vendor.rich.logging import RichHandler\nfrom pip._vendor.rich.segment import Segment\nfrom pip._vendor.rich.style import Style\n\nfrom pip._internal.utils._log import VERBOSE, getLogger\nfrom pip._internal.utils.compat import WINDOWS\nfrom pip._internal.utils.deprecation import DEPRECATION_MSG_PREFIX\nfrom pip._internal.utils.misc import ensure_dir\n\n_log_state = threading.local()\nsubprocess_logger = getLogger(\"pip.subprocessor\")\n\n\nclass BrokenStdoutLoggingError(Exception):\n    \"\"\"\n    Raised if BrokenPipeError occurs for the stdout stream while logging.\n    \"\"\"\n\n\ndef _is_broken_pipe_error(exc_class: Type[BaseException], exc: BaseException) -> bool:\n    if exc_class is BrokenPipeError:\n        return True\n\n    # On Windows, a broken pipe can show up as EINVAL rather than EPIPE:\n    # https://bugs.python.org/issue19612\n    # https://bugs.python.org/issue30418\n    if not WINDOWS:\n        return False\n\n    return isinstance(exc, OSError) and exc.errno in (errno.EINVAL, errno.EPIPE)\n\n\n@contextlib.contextmanager\ndef indent_log(num: int = 2) -> Generator[None, None, None]:\n    \"\"\"\n    A context manager which will cause the log output to be indented for any\n    log messages emitted inside it.\n    \"\"\"\n    # For thread-safety\n    _log_state.indentation = get_indentation()\n    _log_state.indentation += num\n    try:\n        yield\n    finally:\n        _log_state.indentation -= num\n\n\ndef get_indentation() -> int:\n    return getattr(_log_state, \"indentation\", 0)\n\n\nclass IndentingFormatter(logging.Formatter):\n    default_time_format = \"%Y-%m-%dT%H:%M:%S\"\n\n    def __init__(\n        self,\n        *args: Any,\n        add_timestamp: bool = False,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"\n        A logging.Formatter that obeys the indent_log() context manager.\n\n        :param add_timestamp: A bool indicating output lines should be prefixed\n            with their record's timestamp.\n        \"\"\"\n        self.add_timestamp = add_timestamp\n        super().__init__(*args, **kwargs)\n\n    def get_message_start(self, formatted: str, levelno: int) -> str:\n        \"\"\"\n        Return the start of the formatted log message (not counting the\n        prefix to add to each line).\n        \"\"\"\n        if levelno < logging.WARNING:\n            return \"\"\n        if formatted.startswith(DEPRECATION_MSG_PREFIX):\n            # Then the message already has a prefix.  We don't want it to\n            # look like \"WARNING: DEPRECATION: ....\"\n            return \"\"\n        if levelno < logging.ERROR:\n            return \"WARNING: \"\n\n        return \"ERROR: \"\n\n    def format(self, record: logging.LogRecord) -> str:\n        \"\"\"\n        Calls the standard formatter, but will indent all of the log message\n        lines by our current indentation level.\n        \"\"\"\n        formatted = super().format(record)\n        message_start = self.get_message_start(formatted, record.levelno)\n        formatted = message_start + formatted\n\n        prefix = \"\"\n        if self.add_timestamp:\n            prefix = f\"{self.formatTime(record)} \"\n        prefix += \" \" * get_indentation()\n        formatted = \"\".join([prefix + line for line in formatted.splitlines(True)])\n        return formatted\n\n\n@dataclass\nclass IndentedRenderable:\n    renderable: RenderableType\n    indent: int\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        segments = console.render(self.renderable, options)\n        lines = Segment.split_lines(segments)\n        for line in lines:\n            yield Segment(\" \" * self.indent)\n            yield from line\n            yield Segment(\"\\n\")\n\n\nclass RichPipStreamHandler(RichHandler):\n    KEYWORDS: ClassVar[Optional[List[str]]] = []\n\n    def __init__(self, stream: Optional[TextIO], no_color: bool) -> None:\n        super().__init__(\n            console=Console(file=stream, no_color=no_color, soft_wrap=True),\n            show_time=False,\n            show_level=False,\n            show_path=False,\n            highlighter=NullHighlighter(),\n        )\n\n    # Our custom override on Rich's logger, to make things work as we need them to.\n    def emit(self, record: logging.LogRecord) -> None:\n        style: Optional[Style] = None\n\n        # If we are given a diagnostic error to present, present it with indentation.\n        assert isinstance(record.args, tuple)\n        if getattr(record, \"rich\", False):\n            (rich_renderable,) = record.args\n            assert isinstance(\n                rich_renderable, (ConsoleRenderable, RichCast, str)\n            ), f\"{rich_renderable} is not rich-console-renderable\"\n\n            renderable: RenderableType = IndentedRenderable(\n                rich_renderable, indent=get_indentation()\n            )\n        else:\n            message = self.format(record)\n            renderable = self.render_message(record, message)\n            if record.levelno is not None:\n                if record.levelno >= logging.ERROR:\n                    style = Style(color=\"red\")\n                elif record.levelno >= logging.WARNING:\n                    style = Style(color=\"yellow\")\n\n        try:\n            self.console.print(renderable, overflow=\"ignore\", crop=False, style=style)\n        except Exception:\n            self.handleError(record)\n\n    def handleError(self, record: logging.LogRecord) -> None:\n        \"\"\"Called when logging is unable to log some output.\"\"\"\n\n        exc_class, exc = sys.exc_info()[:2]\n        # If a broken pipe occurred while calling write() or flush() on the\n        # stdout stream in logging's Handler.emit(), then raise our special\n        # exception so we can handle it in main() instead of logging the\n        # broken pipe error and continuing.\n        if (\n            exc_class\n            and exc\n            and self.console.file is sys.stdout\n            and _is_broken_pipe_error(exc_class, exc)\n        ):\n            raise BrokenStdoutLoggingError()\n\n        return super().handleError(record)\n\n\nclass BetterRotatingFileHandler(logging.handlers.RotatingFileHandler):\n    def _open(self) -> TextIOWrapper:\n        ensure_dir(os.path.dirname(self.baseFilename))\n        return super()._open()\n\n\nclass MaxLevelFilter(Filter):\n    def __init__(self, level: int) -> None:\n        self.level = level\n\n    def filter(self, record: logging.LogRecord) -> bool:\n        return record.levelno < self.level\n\n\nclass ExcludeLoggerFilter(Filter):\n\n    \"\"\"\n    A logging Filter that excludes records from a logger (or its children).\n    \"\"\"\n\n    def filter(self, record: logging.LogRecord) -> bool:\n        # The base Filter class allows only records from a logger (or its\n        # children).\n        return not super().filter(record)\n\n\ndef setup_logging(verbosity: int, no_color: bool, user_log_file: Optional[str]) -> int:\n    \"\"\"Configures and sets up all of the logging\n\n    Returns the requested logging level, as its integer value.\n    \"\"\"\n\n    # Determine the level to be logging at.\n    if verbosity >= 2:\n        level_number = logging.DEBUG\n    elif verbosity == 1:\n        level_number = VERBOSE\n    elif verbosity == -1:\n        level_number = logging.WARNING\n    elif verbosity == -2:\n        level_number = logging.ERROR\n    elif verbosity <= -3:\n        level_number = logging.CRITICAL\n    else:\n        level_number = logging.INFO\n\n    level = logging.getLevelName(level_number)\n\n    # The \"root\" logger should match the \"console\" level *unless* we also need\n    # to log to a user log file.\n    include_user_log = user_log_file is not None\n    if include_user_log:\n        additional_log_file = user_log_file\n        root_level = \"DEBUG\"\n    else:\n        additional_log_file = \"/dev/null\"\n        root_level = level\n\n    # Disable any logging besides WARNING unless we have DEBUG level logging\n    # enabled for vendored libraries.\n    vendored_log_level = \"WARNING\" if level in [\"INFO\", \"ERROR\"] else \"DEBUG\"\n\n    # Shorthands for clarity\n    log_streams = {\n        \"stdout\": \"ext://sys.stdout\",\n        \"stderr\": \"ext://sys.stderr\",\n    }\n    handler_classes = {\n        \"stream\": \"pip._internal.utils.logging.RichPipStreamHandler\",\n        \"file\": \"pip._internal.utils.logging.BetterRotatingFileHandler\",\n    }\n    handlers = [\"console\", \"console_errors\", \"console_subprocess\"] + (\n        [\"user_log\"] if include_user_log else []\n    )\n\n    logging.config.dictConfig(\n        {\n            \"version\": 1,\n            \"disable_existing_loggers\": False,\n            \"filters\": {\n                \"exclude_warnings\": {\n                    \"()\": \"pip._internal.utils.logging.MaxLevelFilter\",\n                    \"level\": logging.WARNING,\n                },\n                \"restrict_to_subprocess\": {\n                    \"()\": \"logging.Filter\",\n                    \"name\": subprocess_logger.name,\n                },\n                \"exclude_subprocess\": {\n                    \"()\": \"pip._internal.utils.logging.ExcludeLoggerFilter\",\n                    \"name\": subprocess_logger.name,\n                },\n            },\n            \"formatters\": {\n                \"indent\": {\n                    \"()\": IndentingFormatter,\n                    \"format\": \"%(message)s\",\n                },\n                \"indent_with_timestamp\": {\n                    \"()\": IndentingFormatter,\n                    \"format\": \"%(message)s\",\n                    \"add_timestamp\": True,\n                },\n            },\n            \"handlers\": {\n                \"console\": {\n                    \"level\": level,\n                    \"class\": handler_classes[\"stream\"],\n                    \"no_color\": no_color,\n                    \"stream\": log_streams[\"stdout\"],\n                    \"filters\": [\"exclude_subprocess\", \"exclude_warnings\"],\n                    \"formatter\": \"indent\",\n                },\n                \"console_errors\": {\n                    \"level\": \"WARNING\",\n                    \"class\": handler_classes[\"stream\"],\n                    \"no_color\": no_color,\n                    \"stream\": log_streams[\"stderr\"],\n                    \"filters\": [\"exclude_subprocess\"],\n                    \"formatter\": \"indent\",\n                },\n                # A handler responsible for logging to the console messages\n                # from the \"subprocessor\" logger.\n                \"console_subprocess\": {\n                    \"level\": level,\n                    \"class\": handler_classes[\"stream\"],\n                    \"stream\": log_streams[\"stderr\"],\n                    \"no_color\": no_color,\n                    \"filters\": [\"restrict_to_subprocess\"],\n                    \"formatter\": \"indent\",\n                },\n                \"user_log\": {\n                    \"level\": \"DEBUG\",\n                    \"class\": handler_classes[\"file\"],\n                    \"filename\": additional_log_file,\n                    \"encoding\": \"utf-8\",\n                    \"delay\": True,\n                    \"formatter\": \"indent_with_timestamp\",\n                },\n            },\n            \"root\": {\n                \"level\": root_level,\n                \"handlers\": handlers,\n            },\n            \"loggers\": {\"pip._vendor\": {\"level\": vendored_log_level}},\n        }\n    )\n\n    return level_number\n"},"hash":"SfBydiDT6T"}