{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:pyparsing:util.py","body":"# util.py\nimport inspect\nimport warnings\nimport types\nimport collections\nimport itertools\nfrom functools import lru_cache, wraps\nfrom typing import Callable, List, Union, Iterable, TypeVar, cast\n\n_bslash = chr(92)\nC = TypeVar(\"C\", bound=Callable)\n\n\nclass __config_flags:\n    \"\"\"Internal class for defining compatibility and debugging flags\"\"\"\n\n    _all_names: List[str] = []\n    _fixed_names: List[str] = []\n    _type_desc = \"configuration\"\n\n    @classmethod\n    def _set(cls, dname, value):\n        if dname in cls._fixed_names:\n            warnings.warn(\n                f\"{cls.__name__}.{dname} {cls._type_desc} is {str(getattr(cls, dname)).upper()}\"\n                f\" and cannot be overridden\",\n                stacklevel=3,\n            )\n            return\n        if dname in cls._all_names:\n            setattr(cls, dname, value)\n        else:\n            raise ValueError(f\"no such {cls._type_desc} {dname!r}\")\n\n    enable = classmethod(lambda cls, name: cls._set(name, True))\n    disable = classmethod(lambda cls, name: cls._set(name, False))\n\n\n@lru_cache(maxsize=128)\ndef col(loc: int, strg: str) -> int:\n    \"\"\"\n    Returns current column within a string, counting newlines as line separators.\n    The first column is number 1.\n\n    Note: the default parsing behavior is to expand tabs in the input string\n    before starting the parsing process.  See\n    :class:`ParserElement.parse_string` for more\n    information on parsing strings containing ``<TAB>`` s, and suggested\n    methods to maintain a consistent view of the parsed string, the parse\n    location, and line and column positions within the parsed string.\n    \"\"\"\n    s = strg\n    return 1 if 0 < loc < len(s) and s[loc - 1] == \"\\n\" else loc - s.rfind(\"\\n\", 0, loc)\n\n\n@lru_cache(maxsize=128)\ndef lineno(loc: int, strg: str) -> int:\n    \"\"\"Returns current line number within a string, counting newlines as line separators.\n    The first line is number 1.\n\n    Note - the default parsing behavior is to expand tabs in the input string\n    before starting the parsing process.  See :class:`ParserElement.parse_string`\n    for more information on parsing strings containing ``<TAB>`` s, and\n    suggested methods to maintain a consistent view of the parsed string, the\n    parse location, and line and column positions within the parsed string.\n    \"\"\"\n    return strg.count(\"\\n\", 0, loc) + 1\n\n\n@lru_cache(maxsize=128)\ndef line(loc: int, strg: str) -> str:\n    \"\"\"\n    Returns the line of text containing loc within a string, counting newlines as line separators.\n    \"\"\"\n    last_cr = strg.rfind(\"\\n\", 0, loc)\n    next_cr = strg.find(\"\\n\", loc)\n    return strg[last_cr + 1 : next_cr] if next_cr >= 0 else strg[last_cr + 1 :]\n\n\nclass _UnboundedCache:\n    def __init__(self):\n        cache = {}\n        cache_get = cache.get\n        self.not_in_cache = not_in_cache = object()\n\n        def get(_, key):\n            return cache_get(key, not_in_cache)\n\n        def set_(_, key, value):\n            cache[key] = value\n\n        def clear(_):\n            cache.clear()\n\n        self.size = None\n        self.get = types.MethodType(get, self)\n        self.set = types.MethodType(set_, self)\n        self.clear = types.MethodType(clear, self)\n\n\nclass _FifoCache:\n    def __init__(self, size):\n        self.not_in_cache = not_in_cache = object()\n        cache = {}\n        keyring = [object()] * size\n        cache_get = cache.get\n        cache_pop = cache.pop\n        keyiter = itertools.cycle(range(size))\n\n        def get(_, key):\n            return cache_get(key, not_in_cache)\n\n        def set_(_, key, value):\n            cache[key] = value\n            i = next(keyiter)\n            cache_pop(keyring[i], None)\n            keyring[i] = key\n\n        def clear(_):\n            cache.clear()\n            keyring[:] = [object()] * size\n\n        self.size = size\n        self.get = types.MethodType(get, self)\n        self.set = types.MethodType(set_, self)\n        self.clear = types.MethodType(clear, self)\n\n\nclass LRUMemo:\n    \"\"\"\n    A memoizing mapping that retains `capacity` deleted items\n\n    The memo tracks retained items by their access order; once `capacity` items\n    are retained, the least recently used item is discarded.\n    \"\"\"\n\n    def __init__(self, capacity):\n        self._capacity = capacity\n        self._active = {}\n        self._memory = collections.OrderedDict()\n\n    def __getitem__(self, key):\n        try:\n            return self._active[key]\n        except KeyError:\n            self._memory.move_to_end(key)\n            return self._memory[key]\n\n    def __setitem__(self, key, value):\n        self._memory.pop(key, None)\n        self._active[key] = value\n\n    def __delitem__(self, key):\n        try:\n            value = self._active.pop(key)\n        except KeyError:\n            pass\n        else:\n            while len(self._memory) >= self._capacity:\n                self._memory.popitem(last=False)\n            self._memory[key] = value\n\n    def clear(self):\n        self._active.clear()\n        self._memory.clear()\n\n\nclass UnboundedMemo(dict):\n    \"\"\"\n    A memoizing mapping that retains all deleted items\n    \"\"\"\n\n    def __delitem__(self, key):\n        pass\n\n\ndef _escape_regex_range_chars(s: str) -> str:\n    # escape these chars: ^-[]\n    for c in r\"\\^-[]\":\n        s = s.replace(c, _bslash + c)\n    s = s.replace(\"\\n\", r\"\\n\")\n    s = s.replace(\"\\t\", r\"\\t\")\n    return str(s)\n\n\ndef _collapse_string_to_ranges(\n    s: Union[str, Iterable[str]], re_escape: bool = True\n) -> str:\n    def is_consecutive(c):\n        c_int = ord(c)\n        is_consecutive.prev, prev = c_int, is_consecutive.prev\n        if c_int - prev > 1:\n            is_consecutive.value = next(is_consecutive.counter)\n        return is_consecutive.value\n\n    is_consecutive.prev = 0  # type: ignore [attr-defined]\n    is_consecutive.counter = itertools.count()  # type: ignore [attr-defined]\n    is_consecutive.value = -1  # type: ignore [attr-defined]\n\n    def escape_re_range_char(c):\n        return \"\\\\\" + c if c in r\"\\^-][\" else c\n\n    def no_escape_re_range_char(c):\n        return c\n\n    if not re_escape:\n        escape_re_range_char = no_escape_re_range_char\n\n    ret = []\n    s = \"\".join(sorted(set(s)))\n    if len(s) > 3:\n        for _, chars in itertools.groupby(s, key=is_consecutive):\n            first = last = next(chars)\n            last = collections.deque(\n                itertools.chain(iter([last]), chars), maxlen=1\n            ).pop()\n            if first == last:\n                ret.append(escape_re_range_char(first))\n            else:\n                sep = \"\" if ord(last) == ord(first) + 1 else \"-\"\n                ret.append(\n                    f\"{escape_re_range_char(first)}{sep}{escape_re_range_char(last)}\"\n                )\n    else:\n        ret = [escape_re_range_char(c) for c in s]\n\n    return \"\".join(ret)\n\n\ndef _flatten(ll: list) -> list:\n    ret = []\n    for i in ll:\n        if isinstance(i, list):\n            ret.extend(_flatten(i))\n        else:\n            ret.append(i)\n    return ret\n\n\ndef _make_synonym_function(compat_name: str, fn: C) -> C:\n    # In a future version, uncomment the code in the internal _inner() functions\n    # to begin emitting DeprecationWarnings.\n\n    # Unwrap staticmethod/classmethod\n    fn = getattr(fn, \"__func__\", fn)\n\n    # (Presence of 'self' arg in signature is used by explain_exception() methods, so we take\n    # some extra steps to add it if present in decorated function.)\n    if \"self\" == list(inspect.signature(fn).parameters)[0]:\n\n        @wraps(fn)\n        def _inner(self, *args, **kwargs):\n            # warnings.warn(\n            #     f\"Deprecated - use {fn.__name__}\", DeprecationWarning, stacklevel=3\n            # )\n            return fn(self, *args, **kwargs)\n\n    else:\n\n        @wraps(fn)\n        def _inner(*args, **kwargs):\n            # warnings.warn(\n            #     f\"Deprecated - use {fn.__name__}\", DeprecationWarning, stacklevel=3\n            # )\n            return fn(*args, **kwargs)\n\n    _inner.__doc__ = f\"\"\"Deprecated - use :class:`{fn.__name__}`\"\"\"\n    _inner.__name__ = compat_name\n    _inner.__annotations__ = fn.__annotations__\n    if isinstance(fn, types.FunctionType):\n        _inner.__kwdefaults__ = fn.__kwdefaults__\n    elif isinstance(fn, type) and hasattr(fn, \"__init__\"):\n        _inner.__kwdefaults__ = fn.__init__.__kwdefaults__\n    else:\n        _inner.__kwdefaults__ = None\n    _inner.__qualname__ = fn.__qualname__\n    return cast(C, _inner)\n\n\ndef replaced_by_pep8(fn: C) -> Callable[[Callable], C]:\n    \"\"\"\n    Decorator for pre-PEP8 compatibility synonyms, to link them to the new function.\n    \"\"\"\n    return lambda other: _make_synonym_function(other.__name__, fn)\n"},"hash":"gZFME5Lszt"}