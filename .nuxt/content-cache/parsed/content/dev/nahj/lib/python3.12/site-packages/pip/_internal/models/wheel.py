{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:models:wheel.py","body":"\"\"\"Represents a wheel file and provides access to the various parts of the\nname that have meaning.\n\"\"\"\nimport re\nfrom typing import Dict, Iterable, List\n\nfrom pip._vendor.packaging.tags import Tag\n\nfrom pip._internal.exceptions import InvalidWheelFilename\n\n\nclass Wheel:\n    \"\"\"A wheel file\"\"\"\n\n    wheel_file_re = re.compile(\n        r\"\"\"^(?P<namever>(?P<name>[^\\s-]+?)-(?P<ver>[^\\s-]*?))\n        ((-(?P<build>\\d[^-]*?))?-(?P<pyver>[^\\s-]+?)-(?P<abi>[^\\s-]+?)-(?P<plat>[^\\s-]+?)\n        \\.whl|\\.dist-info)$\"\"\",\n        re.VERBOSE,\n    )\n\n    def __init__(self, filename: str) -> None:\n        \"\"\"\n        :raises InvalidWheelFilename: when the filename is invalid for a wheel\n        \"\"\"\n        wheel_info = self.wheel_file_re.match(filename)\n        if not wheel_info:\n            raise InvalidWheelFilename(f\"{filename} is not a valid wheel filename.\")\n        self.filename = filename\n        self.name = wheel_info.group(\"name\").replace(\"_\", \"-\")\n        # we'll assume \"_\" means \"-\" due to wheel naming scheme\n        # (https://github.com/pypa/pip/issues/1150)\n        self.version = wheel_info.group(\"ver\").replace(\"_\", \"-\")\n        self.build_tag = wheel_info.group(\"build\")\n        self.pyversions = wheel_info.group(\"pyver\").split(\".\")\n        self.abis = wheel_info.group(\"abi\").split(\".\")\n        self.plats = wheel_info.group(\"plat\").split(\".\")\n\n        # All the tag combinations from this file\n        self.file_tags = {\n            Tag(x, y, z) for x in self.pyversions for y in self.abis for z in self.plats\n        }\n\n    def get_formatted_file_tags(self) -> List[str]:\n        \"\"\"Return the wheel's tags as a sorted list of strings.\"\"\"\n        return sorted(str(tag) for tag in self.file_tags)\n\n    def support_index_min(self, tags: List[Tag]) -> int:\n        \"\"\"Return the lowest index that one of the wheel's file_tag combinations\n        achieves in the given list of supported tags.\n\n        For example, if there are 8 supported tags and one of the file tags\n        is first in the list, then return 0.\n\n        :param tags: the PEP 425 tags to check the wheel against, in order\n            with most preferred first.\n\n        :raises ValueError: If none of the wheel's file tags match one of\n            the supported tags.\n        \"\"\"\n        try:\n            return next(i for i, t in enumerate(tags) if t in self.file_tags)\n        except StopIteration:\n            raise ValueError()\n\n    def find_most_preferred_tag(\n        self, tags: List[Tag], tag_to_priority: Dict[Tag, int]\n    ) -> int:\n        \"\"\"Return the priority of the most preferred tag that one of the wheel's file\n        tag combinations achieves in the given list of supported tags using the given\n        tag_to_priority mapping, where lower priorities are more-preferred.\n\n        This is used in place of support_index_min in some cases in order to avoid\n        an expensive linear scan of a large list of tags.\n\n        :param tags: the PEP 425 tags to check the wheel against.\n        :param tag_to_priority: a mapping from tag to priority of that tag, where\n            lower is more preferred.\n\n        :raises ValueError: If none of the wheel's file tags match one of\n            the supported tags.\n        \"\"\"\n        return min(\n            tag_to_priority[tag] for tag in self.file_tags if tag in tag_to_priority\n        )\n\n    def supported(self, tags: Iterable[Tag]) -> bool:\n        \"\"\"Return whether the wheel is compatible with one of the given tags.\n\n        :param tags: the PEP 425 tags to check the wheel against.\n        \"\"\"\n        return not self.file_tags.isdisjoint(tags)\n"},"hash":"FEZlbHWreo"}