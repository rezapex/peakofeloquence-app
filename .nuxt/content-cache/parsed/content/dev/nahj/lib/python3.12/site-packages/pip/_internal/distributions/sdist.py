{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:distributions:sdist.py","body":"import logging\nfrom typing import Iterable, Optional, Set, Tuple\n\nfrom pip._internal.build_env import BuildEnvironment\nfrom pip._internal.distributions.base import AbstractDistribution\nfrom pip._internal.exceptions import InstallationError\nfrom pip._internal.index.package_finder import PackageFinder\nfrom pip._internal.metadata import BaseDistribution\nfrom pip._internal.utils.subprocess import runner_with_spinner_message\n\nlogger = logging.getLogger(__name__)\n\n\nclass SourceDistribution(AbstractDistribution):\n    \"\"\"Represents a source distribution.\n\n    The preparation step for these needs metadata for the packages to be\n    generated, either using PEP 517 or using the legacy `setup.py egg_info`.\n    \"\"\"\n\n    @property\n    def build_tracker_id(self) -> Optional[str]:\n        \"\"\"Identify this requirement uniquely by its link.\"\"\"\n        assert self.req.link\n        return self.req.link.url_without_fragment\n\n    def get_metadata_distribution(self) -> BaseDistribution:\n        return self.req.get_dist()\n\n    def prepare_distribution_metadata(\n        self,\n        finder: PackageFinder,\n        build_isolation: bool,\n        check_build_deps: bool,\n    ) -> None:\n        # Load pyproject.toml, to determine whether PEP 517 is to be used\n        self.req.load_pyproject_toml()\n\n        # Set up the build isolation, if this requirement should be isolated\n        should_isolate = self.req.use_pep517 and build_isolation\n        if should_isolate:\n            # Setup an isolated environment and install the build backend static\n            # requirements in it.\n            self._prepare_build_backend(finder)\n            # Check that if the requirement is editable, it either supports PEP 660 or\n            # has a setup.py or a setup.cfg. This cannot be done earlier because we need\n            # to setup the build backend to verify it supports build_editable, nor can\n            # it be done later, because we want to avoid installing build requirements\n            # needlessly. Doing it here also works around setuptools generating\n            # UNKNOWN.egg-info when running get_requires_for_build_wheel on a directory\n            # without setup.py nor setup.cfg.\n            self.req.isolated_editable_sanity_check()\n            # Install the dynamic build requirements.\n            self._install_build_reqs(finder)\n        # Check if the current environment provides build dependencies\n        should_check_deps = self.req.use_pep517 and check_build_deps\n        if should_check_deps:\n            pyproject_requires = self.req.pyproject_requires\n            assert pyproject_requires is not None\n            conflicting, missing = self.req.build_env.check_requirements(\n                pyproject_requires\n            )\n            if conflicting:\n                self._raise_conflicts(\"the backend dependencies\", conflicting)\n            if missing:\n                self._raise_missing_reqs(missing)\n        self.req.prepare_metadata()\n\n    def _prepare_build_backend(self, finder: PackageFinder) -> None:\n        # Isolate in a BuildEnvironment and install the build-time\n        # requirements.\n        pyproject_requires = self.req.pyproject_requires\n        assert pyproject_requires is not None\n\n        self.req.build_env = BuildEnvironment()\n        self.req.build_env.install_requirements(\n            finder, pyproject_requires, \"overlay\", kind=\"build dependencies\"\n        )\n        conflicting, missing = self.req.build_env.check_requirements(\n            self.req.requirements_to_check\n        )\n        if conflicting:\n            self._raise_conflicts(\"PEP 517/518 supported requirements\", conflicting)\n        if missing:\n            logger.warning(\n                \"Missing build requirements in pyproject.toml for %s.\",\n                self.req,\n            )\n            logger.warning(\n                \"The project does not specify a build backend, and \"\n                \"pip cannot fall back to setuptools without %s.\",\n                \" and \".join(map(repr, sorted(missing))),\n            )\n\n    def _get_build_requires_wheel(self) -> Iterable[str]:\n        with self.req.build_env:\n            runner = runner_with_spinner_message(\"Getting requirements to build wheel\")\n            backend = self.req.pep517_backend\n            assert backend is not None\n            with backend.subprocess_runner(runner):\n                return backend.get_requires_for_build_wheel()\n\n    def _get_build_requires_editable(self) -> Iterable[str]:\n        with self.req.build_env:\n            runner = runner_with_spinner_message(\n                \"Getting requirements to build editable\"\n            )\n            backend = self.req.pep517_backend\n            assert backend is not None\n            with backend.subprocess_runner(runner):\n                return backend.get_requires_for_build_editable()\n\n    def _install_build_reqs(self, finder: PackageFinder) -> None:\n        # Install any extra build dependencies that the backend requests.\n        # This must be done in a second pass, as the pyproject.toml\n        # dependencies must be installed before we can call the backend.\n        if (\n            self.req.editable\n            and self.req.permit_editable_wheels\n            and self.req.supports_pyproject_editable()\n        ):\n            build_reqs = self._get_build_requires_editable()\n        else:\n            build_reqs = self._get_build_requires_wheel()\n        conflicting, missing = self.req.build_env.check_requirements(build_reqs)\n        if conflicting:\n            self._raise_conflicts(\"the backend dependencies\", conflicting)\n        self.req.build_env.install_requirements(\n            finder, missing, \"normal\", kind=\"backend dependencies\"\n        )\n\n    def _raise_conflicts(\n        self, conflicting_with: str, conflicting_reqs: Set[Tuple[str, str]]\n    ) -> None:\n        format_string = (\n            \"Some build dependencies for {requirement} \"\n            \"conflict with {conflicting_with}: {description}.\"\n        )\n        error_message = format_string.format(\n            requirement=self.req,\n            conflicting_with=conflicting_with,\n            description=\", \".join(\n                f\"{installed} is incompatible with {wanted}\"\n                for installed, wanted in sorted(conflicting_reqs)\n            ),\n        )\n        raise InstallationError(error_message)\n\n    def _raise_missing_reqs(self, missing: Set[str]) -> None:\n        format_string = (\n            \"Some build dependencies for {requirement} are missing: {missing}.\"\n        )\n        error_message = format_string.format(\n            requirement=self.req, missing=\", \".join(map(repr, sorted(missing)))\n        )\n        raise InstallationError(error_message)\n"},"hash":"l2uUK4ECrW"}