{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:commands:install.py","body":"import errno\nimport json\nimport operator\nimport os\nimport shutil\nimport site\nfrom optparse import SUPPRESS_HELP, Values\nfrom typing import List, Optional\n\nfrom pip._vendor.rich import print_json\n\nfrom pip._internal.cache import WheelCache\nfrom pip._internal.cli import cmdoptions\nfrom pip._internal.cli.cmdoptions import make_target_python\nfrom pip._internal.cli.req_command import (\n    RequirementCommand,\n    warn_if_run_as_root,\n    with_cleanup,\n)\nfrom pip._internal.cli.status_codes import ERROR, SUCCESS\nfrom pip._internal.exceptions import CommandError, InstallationError\nfrom pip._internal.locations import get_scheme\nfrom pip._internal.metadata import get_environment\nfrom pip._internal.models.installation_report import InstallationReport\nfrom pip._internal.operations.build.build_tracker import get_build_tracker\nfrom pip._internal.operations.check import ConflictDetails, check_install_conflicts\nfrom pip._internal.req import install_given_reqs\nfrom pip._internal.req.req_install import (\n    InstallRequirement,\n    check_legacy_setup_py_options,\n)\nfrom pip._internal.utils.compat import WINDOWS\nfrom pip._internal.utils.filesystem import test_writable_dir\nfrom pip._internal.utils.logging import getLogger\nfrom pip._internal.utils.misc import (\n    check_externally_managed,\n    ensure_dir,\n    get_pip_version,\n    protect_pip_from_modification_on_windows,\n    write_output,\n)\nfrom pip._internal.utils.temp_dir import TempDirectory\nfrom pip._internal.utils.virtualenv import (\n    running_under_virtualenv,\n    virtualenv_no_global,\n)\nfrom pip._internal.wheel_builder import build, should_build_for_install_command\n\nlogger = getLogger(__name__)\n\n\nclass InstallCommand(RequirementCommand):\n    \"\"\"\n    Install packages from:\n\n    - PyPI (and other indexes) using requirement specifiers.\n    - VCS project urls.\n    - Local project directories.\n    - Local or remote source archives.\n\n    pip also supports installing from \"requirements files\", which provide\n    an easy way to specify a whole environment to be installed.\n    \"\"\"\n\n    usage = \"\"\"\n      %prog [options] <requirement specifier> [package-index-options] ...\n      %prog [options] -r <requirements file> [package-index-options] ...\n      %prog [options] [-e] <vcs project url> ...\n      %prog [options] [-e] <local project path> ...\n      %prog [options] <archive url/path> ...\"\"\"\n\n    def add_options(self) -> None:\n        self.cmd_opts.add_option(cmdoptions.requirements())\n        self.cmd_opts.add_option(cmdoptions.constraints())\n        self.cmd_opts.add_option(cmdoptions.no_deps())\n        self.cmd_opts.add_option(cmdoptions.pre())\n\n        self.cmd_opts.add_option(cmdoptions.editable())\n        self.cmd_opts.add_option(\n            \"--dry-run\",\n            action=\"store_true\",\n            dest=\"dry_run\",\n            default=False,\n            help=(\n                \"Don't actually install anything, just print what would be. \"\n                \"Can be used in combination with --ignore-installed \"\n                \"to 'resolve' the requirements.\"\n            ),\n        )\n        self.cmd_opts.add_option(\n            \"-t\",\n            \"--target\",\n            dest=\"target_dir\",\n            metavar=\"dir\",\n            default=None,\n            help=(\n                \"Install packages into <dir>. \"\n                \"By default this will not replace existing files/folders in \"\n                \"<dir>. Use --upgrade to replace existing packages in <dir> \"\n                \"with new versions.\"\n            ),\n        )\n        cmdoptions.add_target_python_options(self.cmd_opts)\n\n        self.cmd_opts.add_option(\n            \"--user\",\n            dest=\"use_user_site\",\n            action=\"store_true\",\n            help=(\n                \"Install to the Python user install directory for your \"\n                \"platform. Typically ~/.local/, or %APPDATA%\\\\Python on \"\n                \"Windows. (See the Python documentation for site.USER_BASE \"\n                \"for full details.)\"\n            ),\n        )\n        self.cmd_opts.add_option(\n            \"--no-user\",\n            dest=\"use_user_site\",\n            action=\"store_false\",\n            help=SUPPRESS_HELP,\n        )\n        self.cmd_opts.add_option(\n            \"--root\",\n            dest=\"root_path\",\n            metavar=\"dir\",\n            default=None,\n            help=\"Install everything relative to this alternate root directory.\",\n        )\n        self.cmd_opts.add_option(\n            \"--prefix\",\n            dest=\"prefix_path\",\n            metavar=\"dir\",\n            default=None,\n            help=(\n                \"Installation prefix where lib, bin and other top-level \"\n                \"folders are placed. Note that the resulting installation may \"\n                \"contain scripts and other resources which reference the \"\n                \"Python interpreter of pip, and not that of ``--prefix``. \"\n                \"See also the ``--python`` option if the intention is to \"\n                \"install packages into another (possibly pip-free) \"\n                \"environment.\"\n            ),\n        )\n\n        self.cmd_opts.add_option(cmdoptions.src())\n\n        self.cmd_opts.add_option(\n            \"-U\",\n            \"--upgrade\",\n            dest=\"upgrade\",\n            action=\"store_true\",\n            help=(\n                \"Upgrade all specified packages to the newest available \"\n                \"version. The handling of dependencies depends on the \"\n                \"upgrade-strategy used.\"\n            ),\n        )\n\n        self.cmd_opts.add_option(\n            \"--upgrade-strategy\",\n            dest=\"upgrade_strategy\",\n            default=\"only-if-needed\",\n            choices=[\"only-if-needed\", \"eager\"],\n            help=(\n                \"Determines how dependency upgrading should be handled \"\n                \"[default: %default]. \"\n                '\"eager\" - dependencies are upgraded regardless of '\n                \"whether the currently installed version satisfies the \"\n                \"requirements of the upgraded package(s). \"\n                '\"only-if-needed\" -  are upgraded only when they do not '\n                \"satisfy the requirements of the upgraded package(s).\"\n            ),\n        )\n\n        self.cmd_opts.add_option(\n            \"--force-reinstall\",\n            dest=\"force_reinstall\",\n            action=\"store_true\",\n            help=\"Reinstall all packages even if they are already up-to-date.\",\n        )\n\n        self.cmd_opts.add_option(\n            \"-I\",\n            \"--ignore-installed\",\n            dest=\"ignore_installed\",\n            action=\"store_true\",\n            help=(\n                \"Ignore the installed packages, overwriting them. \"\n                \"This can break your system if the existing package \"\n                \"is of a different version or was installed \"\n                \"with a different package manager!\"\n            ),\n        )\n\n        self.cmd_opts.add_option(cmdoptions.ignore_requires_python())\n        self.cmd_opts.add_option(cmdoptions.no_build_isolation())\n        self.cmd_opts.add_option(cmdoptions.use_pep517())\n        self.cmd_opts.add_option(cmdoptions.no_use_pep517())\n        self.cmd_opts.add_option(cmdoptions.check_build_deps())\n        self.cmd_opts.add_option(cmdoptions.override_externally_managed())\n\n        self.cmd_opts.add_option(cmdoptions.config_settings())\n        self.cmd_opts.add_option(cmdoptions.global_options())\n\n        self.cmd_opts.add_option(\n            \"--compile\",\n            action=\"store_true\",\n            dest=\"compile\",\n            default=True,\n            help=\"Compile Python source files to bytecode\",\n        )\n\n        self.cmd_opts.add_option(\n            \"--no-compile\",\n            action=\"store_false\",\n            dest=\"compile\",\n            help=\"Do not compile Python source files to bytecode\",\n        )\n\n        self.cmd_opts.add_option(\n            \"--no-warn-script-location\",\n            action=\"store_false\",\n            dest=\"warn_script_location\",\n            default=True,\n            help=\"Do not warn when installing scripts outside PATH\",\n        )\n        self.cmd_opts.add_option(\n            \"--no-warn-conflicts\",\n            action=\"store_false\",\n            dest=\"warn_about_conflicts\",\n            default=True,\n            help=\"Do not warn about broken dependencies\",\n        )\n        self.cmd_opts.add_option(cmdoptions.no_binary())\n        self.cmd_opts.add_option(cmdoptions.only_binary())\n        self.cmd_opts.add_option(cmdoptions.prefer_binary())\n        self.cmd_opts.add_option(cmdoptions.require_hashes())\n        self.cmd_opts.add_option(cmdoptions.progress_bar())\n        self.cmd_opts.add_option(cmdoptions.root_user_action())\n\n        index_opts = cmdoptions.make_option_group(\n            cmdoptions.index_group,\n            self.parser,\n        )\n\n        self.parser.insert_option_group(0, index_opts)\n        self.parser.insert_option_group(0, self.cmd_opts)\n\n        self.cmd_opts.add_option(\n            \"--report\",\n            dest=\"json_report_file\",\n            metavar=\"file\",\n            default=None,\n            help=(\n                \"Generate a JSON file describing what pip did to install \"\n                \"the provided requirements. \"\n                \"Can be used in combination with --dry-run and --ignore-installed \"\n                \"to 'resolve' the requirements. \"\n                \"When - is used as file name it writes to stdout. \"\n                \"When writing to stdout, please combine with the --quiet option \"\n                \"to avoid mixing pip logging output with JSON output.\"\n            ),\n        )\n\n    @with_cleanup\n    def run(self, options: Values, args: List[str]) -> int:\n        if options.use_user_site and options.target_dir is not None:\n            raise CommandError(\"Can not combine '--user' and '--target'\")\n\n        # Check whether the environment we're installing into is externally\n        # managed, as specified in PEP 668. Specifying --root, --target, or\n        # --prefix disables the check, since there's no reliable way to locate\n        # the EXTERNALLY-MANAGED file for those cases. An exception is also\n        # made specifically for \"--dry-run --report\" for convenience.\n        installing_into_current_environment = (\n            not (options.dry_run and options.json_report_file)\n            and options.root_path is None\n            and options.target_dir is None\n            and options.prefix_path is None\n        )\n        if (\n            installing_into_current_environment\n            and not options.override_externally_managed\n        ):\n            check_externally_managed()\n\n        upgrade_strategy = \"to-satisfy-only\"\n        if options.upgrade:\n            upgrade_strategy = options.upgrade_strategy\n\n        cmdoptions.check_dist_restriction(options, check_target=True)\n\n        logger.verbose(\"Using %s\", get_pip_version())\n        options.use_user_site = decide_user_install(\n            options.use_user_site,\n            prefix_path=options.prefix_path,\n            target_dir=options.target_dir,\n            root_path=options.root_path,\n            isolated_mode=options.isolated_mode,\n        )\n\n        target_temp_dir: Optional[TempDirectory] = None\n        target_temp_dir_path: Optional[str] = None\n        if options.target_dir:\n            options.ignore_installed = True\n            options.target_dir = os.path.abspath(options.target_dir)\n            if (\n                # fmt: off\n                os.path.exists(options.target_dir) and\n                not os.path.isdir(options.target_dir)\n                # fmt: on\n            ):\n                raise CommandError(\n                    \"Target path exists but is not a directory, will not continue.\"\n                )\n\n            # Create a target directory for using with the target option\n            target_temp_dir = TempDirectory(kind=\"target\")\n            target_temp_dir_path = target_temp_dir.path\n            self.enter_context(target_temp_dir)\n\n        global_options = options.global_options or []\n\n        session = self.get_default_session(options)\n\n        target_python = make_target_python(options)\n        finder = self._build_package_finder(\n            options=options,\n            session=session,\n            target_python=target_python,\n            ignore_requires_python=options.ignore_requires_python,\n        )\n        build_tracker = self.enter_context(get_build_tracker())\n\n        directory = TempDirectory(\n            delete=not options.no_clean,\n            kind=\"install\",\n            globally_managed=True,\n        )\n\n        try:\n            reqs = self.get_requirements(args, options, finder, session)\n            check_legacy_setup_py_options(options, reqs)\n\n            wheel_cache = WheelCache(options.cache_dir)\n\n            # Only when installing is it permitted to use PEP 660.\n            # In other circumstances (pip wheel, pip download) we generate\n            # regular (i.e. non editable) metadata and wheels.\n            for req in reqs:\n                req.permit_editable_wheels = True\n\n            preparer = self.make_requirement_preparer(\n                temp_build_dir=directory,\n                options=options,\n                build_tracker=build_tracker,\n                session=session,\n                finder=finder,\n                use_user_site=options.use_user_site,\n                verbosity=self.verbosity,\n            )\n            resolver = self.make_resolver(\n                preparer=preparer,\n                finder=finder,\n                options=options,\n                wheel_cache=wheel_cache,\n                use_user_site=options.use_user_site,\n                ignore_installed=options.ignore_installed,\n                ignore_requires_python=options.ignore_requires_python,\n                force_reinstall=options.force_reinstall,\n                upgrade_strategy=upgrade_strategy,\n                use_pep517=options.use_pep517,\n            )\n\n            self.trace_basic_info(finder)\n\n            requirement_set = resolver.resolve(\n                reqs, check_supported_wheels=not options.target_dir\n            )\n\n            if options.json_report_file:\n                report = InstallationReport(requirement_set.requirements_to_install)\n                if options.json_report_file == \"-\":\n                    print_json(data=report.to_dict())\n                else:\n                    with open(options.json_report_file, \"w\", encoding=\"utf-8\") as f:\n                        json.dump(report.to_dict(), f, indent=2, ensure_ascii=False)\n\n            if options.dry_run:\n                # In non dry-run mode, the legacy versions and specifiers check\n                # will be done as part of conflict detection.\n                requirement_set.warn_legacy_versions_and_specifiers()\n                would_install_items = sorted(\n                    (r.metadata[\"name\"], r.metadata[\"version\"])\n                    for r in requirement_set.requirements_to_install\n                )\n                if would_install_items:\n                    write_output(\n                        \"Would install %s\",\n                        \" \".join(\"-\".join(item) for item in would_install_items),\n                    )\n                return SUCCESS\n\n            try:\n                pip_req = requirement_set.get_requirement(\"pip\")\n            except KeyError:\n                modifying_pip = False\n            else:\n                # If we're not replacing an already installed pip,\n                # we're not modifying it.\n                modifying_pip = pip_req.satisfied_by is None\n            protect_pip_from_modification_on_windows(modifying_pip=modifying_pip)\n\n            reqs_to_build = [\n                r\n                for r in requirement_set.requirements.values()\n                if should_build_for_install_command(r)\n            ]\n\n            _, build_failures = build(\n                reqs_to_build,\n                wheel_cache=wheel_cache,\n                verify=True,\n                build_options=[],\n                global_options=global_options,\n            )\n\n            if build_failures:\n                raise InstallationError(\n                    \"Could not build wheels for {}, which is required to \"\n                    \"install pyproject.toml-based projects\".format(\n                        \", \".join(r.name for r in build_failures)  # type: ignore\n                    )\n                )\n\n            to_install = resolver.get_installation_order(requirement_set)\n\n            # Check for conflicts in the package set we're installing.\n            conflicts: Optional[ConflictDetails] = None\n            should_warn_about_conflicts = (\n                not options.ignore_dependencies and options.warn_about_conflicts\n            )\n            if should_warn_about_conflicts:\n                conflicts = self._determine_conflicts(to_install)\n\n            # Don't warn about script install locations if\n            # --target or --prefix has been specified\n            warn_script_location = options.warn_script_location\n            if options.target_dir or options.prefix_path:\n                warn_script_location = False\n\n            installed = install_given_reqs(\n                to_install,\n                global_options,\n                root=options.root_path,\n                home=target_temp_dir_path,\n                prefix=options.prefix_path,\n                warn_script_location=warn_script_location,\n                use_user_site=options.use_user_site,\n                pycompile=options.compile,\n            )\n\n            lib_locations = get_lib_location_guesses(\n                user=options.use_user_site,\n                home=target_temp_dir_path,\n                root=options.root_path,\n                prefix=options.prefix_path,\n                isolated=options.isolated_mode,\n            )\n            env = get_environment(lib_locations)\n\n            installed.sort(key=operator.attrgetter(\"name\"))\n            items = []\n            for result in installed:\n                item = result.name\n                try:\n                    installed_dist = env.get_distribution(item)\n                    if installed_dist is not None:\n                        item = f\"{item}-{installed_dist.version}\"\n                except Exception:\n                    pass\n                items.append(item)\n\n            if conflicts is not None:\n                self._warn_about_conflicts(\n                    conflicts,\n                    resolver_variant=self.determine_resolver_variant(options),\n                )\n\n            installed_desc = \" \".join(items)\n            if installed_desc:\n                write_output(\n                    \"Successfully installed %s\",\n                    installed_desc,\n                )\n        except OSError as error:\n            show_traceback = self.verbosity >= 1\n\n            message = create_os_error_message(\n                error,\n                show_traceback,\n                options.use_user_site,\n            )\n            logger.error(message, exc_info=show_traceback)\n\n            return ERROR\n\n        if options.target_dir:\n            assert target_temp_dir\n            self._handle_target_dir(\n                options.target_dir, target_temp_dir, options.upgrade\n            )\n        if options.root_user_action == \"warn\":\n            warn_if_run_as_root()\n        return SUCCESS\n\n    def _handle_target_dir(\n        self, target_dir: str, target_temp_dir: TempDirectory, upgrade: bool\n    ) -> None:\n        ensure_dir(target_dir)\n\n        # Checking both purelib and platlib directories for installed\n        # packages to be moved to target directory\n        lib_dir_list = []\n\n        # Checking both purelib and platlib directories for installed\n        # packages to be moved to target directory\n        scheme = get_scheme(\"\", home=target_temp_dir.path)\n        purelib_dir = scheme.purelib\n        platlib_dir = scheme.platlib\n        data_dir = scheme.data\n\n        if os.path.exists(purelib_dir):\n            lib_dir_list.append(purelib_dir)\n        if os.path.exists(platlib_dir) and platlib_dir != purelib_dir:\n            lib_dir_list.append(platlib_dir)\n        if os.path.exists(data_dir):\n            lib_dir_list.append(data_dir)\n\n        for lib_dir in lib_dir_list:\n            for item in os.listdir(lib_dir):\n                if lib_dir == data_dir:\n                    ddir = os.path.join(data_dir, item)\n                    if any(s.startswith(ddir) for s in lib_dir_list[:-1]):\n                        continue\n                target_item_dir = os.path.join(target_dir, item)\n                if os.path.exists(target_item_dir):\n                    if not upgrade:\n                        logger.warning(\n                            \"Target directory %s already exists. Specify \"\n                            \"--upgrade to force replacement.\",\n                            target_item_dir,\n                        )\n                        continue\n                    if os.path.islink(target_item_dir):\n                        logger.warning(\n                            \"Target directory %s already exists and is \"\n                            \"a link. pip will not automatically replace \"\n                            \"links, please remove if replacement is \"\n                            \"desired.\",\n                            target_item_dir,\n                        )\n                        continue\n                    if os.path.isdir(target_item_dir):\n                        shutil.rmtree(target_item_dir)\n                    else:\n                        os.remove(target_item_dir)\n\n                shutil.move(os.path.join(lib_dir, item), target_item_dir)\n\n    def _determine_conflicts(\n        self, to_install: List[InstallRequirement]\n    ) -> Optional[ConflictDetails]:\n        try:\n            return check_install_conflicts(to_install)\n        except Exception:\n            logger.exception(\n                \"Error while checking for conflicts. Please file an issue on \"\n                \"pip's issue tracker: https://github.com/pypa/pip/issues/new\"\n            )\n            return None\n\n    def _warn_about_conflicts(\n        self, conflict_details: ConflictDetails, resolver_variant: str\n    ) -> None:\n        package_set, (missing, conflicting) = conflict_details\n        if not missing and not conflicting:\n            return\n\n        parts: List[str] = []\n        if resolver_variant == \"legacy\":\n            parts.append(\n                \"pip's legacy dependency resolver does not consider dependency \"\n                \"conflicts when selecting packages. This behaviour is the \"\n                \"source of the following dependency conflicts.\"\n            )\n        else:\n            assert resolver_variant == \"resolvelib\"\n            parts.append(\n                \"pip's dependency resolver does not currently take into account \"\n                \"all the packages that are installed. This behaviour is the \"\n                \"source of the following dependency conflicts.\"\n            )\n\n        # NOTE: There is some duplication here, with commands/check.py\n        for project_name in missing:\n            version = package_set[project_name][0]\n            for dependency in missing[project_name]:\n                message = (\n                    f\"{project_name} {version} requires {dependency[1]}, \"\n                    \"which is not installed.\"\n                )\n                parts.append(message)\n\n        for project_name in conflicting:\n            version = package_set[project_name][0]\n            for dep_name, dep_version, req in conflicting[project_name]:\n                message = (\n                    \"{name} {version} requires {requirement}, but {you} have \"\n                    \"{dep_name} {dep_version} which is incompatible.\"\n                ).format(\n                    name=project_name,\n                    version=version,\n                    requirement=req,\n                    dep_name=dep_name,\n                    dep_version=dep_version,\n                    you=(\"you\" if resolver_variant == \"resolvelib\" else \"you'll\"),\n                )\n                parts.append(message)\n\n        logger.critical(\"\\n\".join(parts))\n\n\ndef get_lib_location_guesses(\n    user: bool = False,\n    home: Optional[str] = None,\n    root: Optional[str] = None,\n    isolated: bool = False,\n    prefix: Optional[str] = None,\n) -> List[str]:\n    scheme = get_scheme(\n        \"\",\n        user=user,\n        home=home,\n        root=root,\n        isolated=isolated,\n        prefix=prefix,\n    )\n    return [scheme.purelib, scheme.platlib]\n\n\ndef site_packages_writable(root: Optional[str], isolated: bool) -> bool:\n    return all(\n        test_writable_dir(d)\n        for d in set(get_lib_location_guesses(root=root, isolated=isolated))\n    )\n\n\ndef decide_user_install(\n    use_user_site: Optional[bool],\n    prefix_path: Optional[str] = None,\n    target_dir: Optional[str] = None,\n    root_path: Optional[str] = None,\n    isolated_mode: bool = False,\n) -> bool:\n    \"\"\"Determine whether to do a user install based on the input options.\n\n    If use_user_site is False, no additional checks are done.\n    If use_user_site is True, it is checked for compatibility with other\n    options.\n    If use_user_site is None, the default behaviour depends on the environment,\n    which is provided by the other arguments.\n    \"\"\"\n    # In some cases (config from tox), use_user_site can be set to an integer\n    # rather than a bool, which 'use_user_site is False' wouldn't catch.\n    if (use_user_site is not None) and (not use_user_site):\n        logger.debug(\"Non-user install by explicit request\")\n        return False\n\n    if use_user_site:\n        if prefix_path:\n            raise CommandError(\n                \"Can not combine '--user' and '--prefix' as they imply \"\n                \"different installation locations\"\n            )\n        if virtualenv_no_global():\n            raise InstallationError(\n                \"Can not perform a '--user' install. User site-packages \"\n                \"are not visible in this virtualenv.\"\n            )\n        logger.debug(\"User install by explicit request\")\n        return True\n\n    # If we are here, user installs have not been explicitly requested/avoided\n    assert use_user_site is None\n\n    # user install incompatible with --prefix/--target\n    if prefix_path or target_dir:\n        logger.debug(\"Non-user install due to --prefix or --target option\")\n        return False\n\n    # If user installs are not enabled, choose a non-user install\n    if not site.ENABLE_USER_SITE:\n        logger.debug(\"Non-user install because user site-packages disabled\")\n        return False\n\n    # If we have permission for a non-user install, do that,\n    # otherwise do a user install.\n    if site_packages_writable(root=root_path, isolated=isolated_mode):\n        logger.debug(\"Non-user install because site-packages writeable\")\n        return False\n\n    logger.info(\n        \"Defaulting to user installation because normal site-packages \"\n        \"is not writeable\"\n    )\n    return True\n\n\ndef create_os_error_message(\n    error: OSError, show_traceback: bool, using_user_site: bool\n) -> str:\n    \"\"\"Format an error message for an OSError\n\n    It may occur anytime during the execution of the install command.\n    \"\"\"\n    parts = []\n\n    # Mention the error if we are not going to show a traceback\n    parts.append(\"Could not install packages due to an OSError\")\n    if not show_traceback:\n        parts.append(\": \")\n        parts.append(str(error))\n    else:\n        parts.append(\".\")\n\n    # Spilt the error indication from a helper message (if any)\n    parts[-1] += \"\\n\"\n\n    # Suggest useful actions to the user:\n    #  (1) using user site-packages or (2) verifying the permissions\n    if error.errno == errno.EACCES:\n        user_option_part = \"Consider using the `--user` option\"\n        permissions_part = \"Check the permissions\"\n\n        if not running_under_virtualenv() and not using_user_site:\n            parts.extend(\n                [\n                    user_option_part,\n                    \" or \",\n                    permissions_part.lower(),\n                ]\n            )\n        else:\n            parts.append(permissions_part)\n        parts.append(\".\\n\")\n\n    # Suggest the user to enable Long Paths if path length is\n    # more than 260\n    if (\n        WINDOWS\n        and error.errno == errno.ENOENT\n        and error.filename\n        and len(error.filename) > 260\n    ):\n        parts.append(\n            \"HINT: This error might have occurred since \"\n            \"this system does not have Windows Long Path \"\n            \"support enabled. You can find information on \"\n            \"how to enable this at \"\n            \"https://pip.pypa.io/warnings/enable-long-paths\\n\"\n        )\n\n    return \"\".join(parts).strip() + \"\\n\"\n"},"hash":"JQ5AwgzUoZ"}