{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:pyproject.py","body":"import importlib.util\nimport os\nfrom collections import namedtuple\nfrom typing import Any, List, Optional\n\nfrom pip._vendor import tomli\nfrom pip._vendor.packaging.requirements import InvalidRequirement, Requirement\n\nfrom pip._internal.exceptions import (\n    InstallationError,\n    InvalidPyProjectBuildRequires,\n    MissingPyProjectBuildRequires,\n)\n\n\ndef _is_list_of_str(obj: Any) -> bool:\n    return isinstance(obj, list) and all(isinstance(item, str) for item in obj)\n\n\ndef make_pyproject_path(unpacked_source_directory: str) -> str:\n    return os.path.join(unpacked_source_directory, \"pyproject.toml\")\n\n\nBuildSystemDetails = namedtuple(\n    \"BuildSystemDetails\", [\"requires\", \"backend\", \"check\", \"backend_path\"]\n)\n\n\ndef load_pyproject_toml(\n    use_pep517: Optional[bool], pyproject_toml: str, setup_py: str, req_name: str\n) -> Optional[BuildSystemDetails]:\n    \"\"\"Load the pyproject.toml file.\n\n    Parameters:\n        use_pep517 - Has the user requested PEP 517 processing? None\n                     means the user hasn't explicitly specified.\n        pyproject_toml - Location of the project's pyproject.toml file\n        setup_py - Location of the project's setup.py file\n        req_name - The name of the requirement we're processing (for\n                   error reporting)\n\n    Returns:\n        None if we should use the legacy code path, otherwise a tuple\n        (\n            requirements from pyproject.toml,\n            name of PEP 517 backend,\n            requirements we should check are installed after setting\n                up the build environment\n            directory paths to import the backend from (backend-path),\n                relative to the project root.\n        )\n    \"\"\"\n    has_pyproject = os.path.isfile(pyproject_toml)\n    has_setup = os.path.isfile(setup_py)\n\n    if not has_pyproject and not has_setup:\n        raise InstallationError(\n            f\"{req_name} does not appear to be a Python project: \"\n            f\"neither 'setup.py' nor 'pyproject.toml' found.\"\n        )\n\n    if has_pyproject:\n        with open(pyproject_toml, encoding=\"utf-8\") as f:\n            pp_toml = tomli.loads(f.read())\n        build_system = pp_toml.get(\"build-system\")\n    else:\n        build_system = None\n\n    # The following cases must use PEP 517\n    # We check for use_pep517 being non-None and falsey because that means\n    # the user explicitly requested --no-use-pep517.  The value 0 as\n    # opposed to False can occur when the value is provided via an\n    # environment variable or config file option (due to the quirk of\n    # strtobool() returning an integer in pip's configuration code).\n    if has_pyproject and not has_setup:\n        if use_pep517 is not None and not use_pep517:\n            raise InstallationError(\n                \"Disabling PEP 517 processing is invalid: \"\n                \"project does not have a setup.py\"\n            )\n        use_pep517 = True\n    elif build_system and \"build-backend\" in build_system:\n        if use_pep517 is not None and not use_pep517:\n            raise InstallationError(\n                \"Disabling PEP 517 processing is invalid: \"\n                \"project specifies a build backend of {} \"\n                \"in pyproject.toml\".format(build_system[\"build-backend\"])\n            )\n        use_pep517 = True\n\n    # If we haven't worked out whether to use PEP 517 yet,\n    # and the user hasn't explicitly stated a preference,\n    # we do so if the project has a pyproject.toml file\n    # or if we cannot import setuptools or wheels.\n\n    # We fallback to PEP 517 when without setuptools or without the wheel package,\n    # so setuptools can be installed as a default build backend.\n    # For more info see:\n    # https://discuss.python.org/t/pip-without-setuptools-could-the-experience-be-improved/11810/9\n    # https://github.com/pypa/pip/issues/8559\n    elif use_pep517 is None:\n        use_pep517 = (\n            has_pyproject\n            or not importlib.util.find_spec(\"setuptools\")\n            or not importlib.util.find_spec(\"wheel\")\n        )\n\n    # At this point, we know whether we're going to use PEP 517.\n    assert use_pep517 is not None\n\n    # If we're using the legacy code path, there is nothing further\n    # for us to do here.\n    if not use_pep517:\n        return None\n\n    if build_system is None:\n        # Either the user has a pyproject.toml with no build-system\n        # section, or the user has no pyproject.toml, but has opted in\n        # explicitly via --use-pep517.\n        # In the absence of any explicit backend specification, we\n        # assume the setuptools backend that most closely emulates the\n        # traditional direct setup.py execution, and require wheel and\n        # a version of setuptools that supports that backend.\n\n        build_system = {\n            \"requires\": [\"setuptools>=40.8.0\"],\n            \"build-backend\": \"setuptools.build_meta:__legacy__\",\n        }\n\n    # If we're using PEP 517, we have build system information (either\n    # from pyproject.toml, or defaulted by the code above).\n    # Note that at this point, we do not know if the user has actually\n    # specified a backend, though.\n    assert build_system is not None\n\n    # Ensure that the build-system section in pyproject.toml conforms\n    # to PEP 518.\n\n    # Specifying the build-system table but not the requires key is invalid\n    if \"requires\" not in build_system:\n        raise MissingPyProjectBuildRequires(package=req_name)\n\n    # Error out if requires is not a list of strings\n    requires = build_system[\"requires\"]\n    if not _is_list_of_str(requires):\n        raise InvalidPyProjectBuildRequires(\n            package=req_name,\n            reason=\"It is not a list of strings.\",\n        )\n\n    # Each requirement must be valid as per PEP 508\n    for requirement in requires:\n        try:\n            Requirement(requirement)\n        except InvalidRequirement as error:\n            raise InvalidPyProjectBuildRequires(\n                package=req_name,\n                reason=f\"It contains an invalid requirement: {requirement!r}\",\n            ) from error\n\n    backend = build_system.get(\"build-backend\")\n    backend_path = build_system.get(\"backend-path\", [])\n    check: List[str] = []\n    if backend is None:\n        # If the user didn't specify a backend, we assume they want to use\n        # the setuptools backend. But we can't be sure they have included\n        # a version of setuptools which supplies the backend. So we\n        # make a note to check that this requirement is present once\n        # we have set up the environment.\n        # This is quite a lot of work to check for a very specific case. But\n        # the problem is, that case is potentially quite common - projects that\n        # adopted PEP 518 early for the ability to specify requirements to\n        # execute setup.py, but never considered needing to mention the build\n        # tools themselves. The original PEP 518 code had a similar check (but\n        # implemented in a different way).\n        backend = \"setuptools.build_meta:__legacy__\"\n        check = [\"setuptools>=40.8.0\"]\n\n    return BuildSystemDetails(requires, backend, check, backend_path)\n"},"hash":"PxuCDCOtZS"}