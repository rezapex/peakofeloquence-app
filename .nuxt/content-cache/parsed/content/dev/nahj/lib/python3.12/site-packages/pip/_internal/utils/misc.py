{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:utils:misc.py","body":"import contextlib\nimport errno\nimport getpass\nimport hashlib\nimport io\nimport logging\nimport os\nimport posixpath\nimport shutil\nimport stat\nimport sys\nimport sysconfig\nimport urllib.parse\nfrom functools import partial\nfrom io import StringIO\nfrom itertools import filterfalse, tee, zip_longest\nfrom pathlib import Path\nfrom types import FunctionType, TracebackType\nfrom typing import (\n    Any,\n    BinaryIO,\n    Callable,\n    ContextManager,\n    Dict,\n    Generator,\n    Iterable,\n    Iterator,\n    List,\n    Optional,\n    TextIO,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    cast,\n)\n\nfrom pip._vendor.packaging.requirements import Requirement\nfrom pip._vendor.pyproject_hooks import BuildBackendHookCaller\nfrom pip._vendor.tenacity import retry, stop_after_delay, wait_fixed\n\nfrom pip import __version__\nfrom pip._internal.exceptions import CommandError, ExternallyManagedEnvironment\nfrom pip._internal.locations import get_major_minor_version\nfrom pip._internal.utils.compat import WINDOWS\nfrom pip._internal.utils.virtualenv import running_under_virtualenv\n\n__all__ = [\n    \"rmtree\",\n    \"display_path\",\n    \"backup_dir\",\n    \"ask\",\n    \"splitext\",\n    \"format_size\",\n    \"is_installable_dir\",\n    \"normalize_path\",\n    \"renames\",\n    \"get_prog\",\n    \"captured_stdout\",\n    \"ensure_dir\",\n    \"remove_auth_from_url\",\n    \"check_externally_managed\",\n    \"ConfiguredBuildBackendHookCaller\",\n]\n\nlogger = logging.getLogger(__name__)\n\nT = TypeVar(\"T\")\nExcInfo = Tuple[Type[BaseException], BaseException, TracebackType]\nVersionInfo = Tuple[int, int, int]\nNetlocTuple = Tuple[str, Tuple[Optional[str], Optional[str]]]\nOnExc = Callable[[FunctionType, Path, BaseException], Any]\nOnErr = Callable[[FunctionType, Path, ExcInfo], Any]\n\n\ndef get_pip_version() -> str:\n    pip_pkg_dir = os.path.join(os.path.dirname(__file__), \"..\", \"..\")\n    pip_pkg_dir = os.path.abspath(pip_pkg_dir)\n\n    return f\"pip {__version__} from {pip_pkg_dir} (python {get_major_minor_version()})\"\n\n\ndef normalize_version_info(py_version_info: Tuple[int, ...]) -> Tuple[int, int, int]:\n    \"\"\"\n    Convert a tuple of ints representing a Python version to one of length\n    three.\n\n    :param py_version_info: a tuple of ints representing a Python version,\n        or None to specify no version. The tuple can have any length.\n\n    :return: a tuple of length three if `py_version_info` is non-None.\n        Otherwise, return `py_version_info` unchanged (i.e. None).\n    \"\"\"\n    if len(py_version_info) < 3:\n        py_version_info += (3 - len(py_version_info)) * (0,)\n    elif len(py_version_info) > 3:\n        py_version_info = py_version_info[:3]\n\n    return cast(\"VersionInfo\", py_version_info)\n\n\ndef ensure_dir(path: str) -> None:\n    \"\"\"os.path.makedirs without EEXIST.\"\"\"\n    try:\n        os.makedirs(path)\n    except OSError as e:\n        # Windows can raise spurious ENOTEMPTY errors. See #6426.\n        if e.errno != errno.EEXIST and e.errno != errno.ENOTEMPTY:\n            raise\n\n\ndef get_prog() -> str:\n    try:\n        prog = os.path.basename(sys.argv[0])\n        if prog in (\"__main__.py\", \"-c\"):\n            return f\"{sys.executable} -m pip\"\n        else:\n            return prog\n    except (AttributeError, TypeError, IndexError):\n        pass\n    return \"pip\"\n\n\n# Retry every half second for up to 3 seconds\n# Tenacity raises RetryError by default, explicitly raise the original exception\n@retry(reraise=True, stop=stop_after_delay(3), wait=wait_fixed(0.5))\ndef rmtree(\n    dir: str,\n    ignore_errors: bool = False,\n    onexc: Optional[OnExc] = None,\n) -> None:\n    if ignore_errors:\n        onexc = _onerror_ignore\n    if onexc is None:\n        onexc = _onerror_reraise\n    handler: OnErr = partial(\n        # `[func, path, Union[ExcInfo, BaseException]] -> Any` is equivalent to\n        # `Union[([func, path, ExcInfo] -> Any), ([func, path, BaseException] -> Any)]`.\n        cast(Union[OnExc, OnErr], rmtree_errorhandler),\n        onexc=onexc,\n    )\n    if sys.version_info >= (3, 12):\n        # See https://docs.python.org/3.12/whatsnew/3.12.html#shutil.\n        shutil.rmtree(dir, onexc=handler)  # type: ignore\n    else:\n        shutil.rmtree(dir, onerror=handler)  # type: ignore\n\n\ndef _onerror_ignore(*_args: Any) -> None:\n    pass\n\n\ndef _onerror_reraise(*_args: Any) -> None:\n    raise\n\n\ndef rmtree_errorhandler(\n    func: FunctionType,\n    path: Path,\n    exc_info: Union[ExcInfo, BaseException],\n    *,\n    onexc: OnExc = _onerror_reraise,\n) -> None:\n    \"\"\"\n    `rmtree` error handler to 'force' a file remove (i.e. like `rm -f`).\n\n    * If a file is readonly then it's write flag is set and operation is\n      retried.\n\n    * `onerror` is the original callback from `rmtree(... onerror=onerror)`\n      that is chained at the end if the \"rm -f\" still fails.\n    \"\"\"\n    try:\n        st_mode = os.stat(path).st_mode\n    except OSError:\n        # it's equivalent to os.path.exists\n        return\n\n    if not st_mode & stat.S_IWRITE:\n        # convert to read/write\n        try:\n            os.chmod(path, st_mode | stat.S_IWRITE)\n        except OSError:\n            pass\n        else:\n            # use the original function to repeat the operation\n            try:\n                func(path)\n                return\n            except OSError:\n                pass\n\n    if not isinstance(exc_info, BaseException):\n        _, exc_info, _ = exc_info\n    onexc(func, path, exc_info)\n\n\ndef display_path(path: str) -> str:\n    \"\"\"Gives the display value for a given path, making it relative to cwd\n    if possible.\"\"\"\n    path = os.path.normcase(os.path.abspath(path))\n    if path.startswith(os.getcwd() + os.path.sep):\n        path = \".\" + path[len(os.getcwd()) :]\n    return path\n\n\ndef backup_dir(dir: str, ext: str = \".bak\") -> str:\n    \"\"\"Figure out the name of a directory to back up the given dir to\n    (adding .bak, .bak2, etc)\"\"\"\n    n = 1\n    extension = ext\n    while os.path.exists(dir + extension):\n        n += 1\n        extension = ext + str(n)\n    return dir + extension\n\n\ndef ask_path_exists(message: str, options: Iterable[str]) -> str:\n    for action in os.environ.get(\"PIP_EXISTS_ACTION\", \"\").split():\n        if action in options:\n            return action\n    return ask(message, options)\n\n\ndef _check_no_input(message: str) -> None:\n    \"\"\"Raise an error if no input is allowed.\"\"\"\n    if os.environ.get(\"PIP_NO_INPUT\"):\n        raise Exception(\n            f\"No input was expected ($PIP_NO_INPUT set); question: {message}\"\n        )\n\n\ndef ask(message: str, options: Iterable[str]) -> str:\n    \"\"\"Ask the message interactively, with the given possible responses\"\"\"\n    while 1:\n        _check_no_input(message)\n        response = input(message)\n        response = response.strip().lower()\n        if response not in options:\n            print(\n                \"Your response ({!r}) was not one of the expected responses: \"\n                \"{}\".format(response, \", \".join(options))\n            )\n        else:\n            return response\n\n\ndef ask_input(message: str) -> str:\n    \"\"\"Ask for input interactively.\"\"\"\n    _check_no_input(message)\n    return input(message)\n\n\ndef ask_password(message: str) -> str:\n    \"\"\"Ask for a password interactively.\"\"\"\n    _check_no_input(message)\n    return getpass.getpass(message)\n\n\ndef strtobool(val: str) -> int:\n    \"\"\"Convert a string representation of truth to true (1) or false (0).\n\n    True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values\n    are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if\n    'val' is anything else.\n    \"\"\"\n    val = val.lower()\n    if val in (\"y\", \"yes\", \"t\", \"true\", \"on\", \"1\"):\n        return 1\n    elif val in (\"n\", \"no\", \"f\", \"false\", \"off\", \"0\"):\n        return 0\n    else:\n        raise ValueError(f\"invalid truth value {val!r}\")\n\n\ndef format_size(bytes: float) -> str:\n    if bytes > 1000 * 1000:\n        return f\"{bytes / 1000.0 / 1000:.1f} MB\"\n    elif bytes > 10 * 1000:\n        return f\"{int(bytes / 1000)} kB\"\n    elif bytes > 1000:\n        return f\"{bytes / 1000.0:.1f} kB\"\n    else:\n        return f\"{int(bytes)} bytes\"\n\n\ndef tabulate(rows: Iterable[Iterable[Any]]) -> Tuple[List[str], List[int]]:\n    \"\"\"Return a list of formatted rows and a list of column sizes.\n\n    For example::\n\n    >>> tabulate([['foobar', 2000], [0xdeadbeef]])\n    (['foobar     2000', '3735928559'], [10, 4])\n    \"\"\"\n    rows = [tuple(map(str, row)) for row in rows]\n    sizes = [max(map(len, col)) for col in zip_longest(*rows, fillvalue=\"\")]\n    table = [\" \".join(map(str.ljust, row, sizes)).rstrip() for row in rows]\n    return table, sizes\n\n\ndef is_installable_dir(path: str) -> bool:\n    \"\"\"Is path is a directory containing pyproject.toml or setup.py?\n\n    If pyproject.toml exists, this is a PEP 517 project. Otherwise we look for\n    a legacy setuptools layout by identifying setup.py. We don't check for the\n    setup.cfg because using it without setup.py is only available for PEP 517\n    projects, which are already covered by the pyproject.toml check.\n    \"\"\"\n    if not os.path.isdir(path):\n        return False\n    if os.path.isfile(os.path.join(path, \"pyproject.toml\")):\n        return True\n    if os.path.isfile(os.path.join(path, \"setup.py\")):\n        return True\n    return False\n\n\ndef read_chunks(\n    file: BinaryIO, size: int = io.DEFAULT_BUFFER_SIZE\n) -> Generator[bytes, None, None]:\n    \"\"\"Yield pieces of data from a file-like object until EOF.\"\"\"\n    while True:\n        chunk = file.read(size)\n        if not chunk:\n            break\n        yield chunk\n\n\ndef normalize_path(path: str, resolve_symlinks: bool = True) -> str:\n    \"\"\"\n    Convert a path to its canonical, case-normalized, absolute version.\n\n    \"\"\"\n    path = os.path.expanduser(path)\n    if resolve_symlinks:\n        path = os.path.realpath(path)\n    else:\n        path = os.path.abspath(path)\n    return os.path.normcase(path)\n\n\ndef splitext(path: str) -> Tuple[str, str]:\n    \"\"\"Like os.path.splitext, but take off .tar too\"\"\"\n    base, ext = posixpath.splitext(path)\n    if base.lower().endswith(\".tar\"):\n        ext = base[-4:] + ext\n        base = base[:-4]\n    return base, ext\n\n\ndef renames(old: str, new: str) -> None:\n    \"\"\"Like os.renames(), but handles renaming across devices.\"\"\"\n    # Implementation borrowed from os.renames().\n    head, tail = os.path.split(new)\n    if head and tail and not os.path.exists(head):\n        os.makedirs(head)\n\n    shutil.move(old, new)\n\n    head, tail = os.path.split(old)\n    if head and tail:\n        try:\n            os.removedirs(head)\n        except OSError:\n            pass\n\n\ndef is_local(path: str) -> bool:\n    \"\"\"\n    Return True if path is within sys.prefix, if we're running in a virtualenv.\n\n    If we're not in a virtualenv, all paths are considered \"local.\"\n\n    Caution: this function assumes the head of path has been normalized\n    with normalize_path.\n    \"\"\"\n    if not running_under_virtualenv():\n        return True\n    return path.startswith(normalize_path(sys.prefix))\n\n\ndef write_output(msg: Any, *args: Any) -> None:\n    logger.info(msg, *args)\n\n\nclass StreamWrapper(StringIO):\n    orig_stream: TextIO\n\n    @classmethod\n    def from_stream(cls, orig_stream: TextIO) -> \"StreamWrapper\":\n        ret = cls()\n        ret.orig_stream = orig_stream\n        return ret\n\n    # compileall.compile_dir() needs stdout.encoding to print to stdout\n    # type ignore is because TextIOBase.encoding is writeable\n    @property\n    def encoding(self) -> str:  # type: ignore\n        return self.orig_stream.encoding\n\n\n@contextlib.contextmanager\ndef captured_output(stream_name: str) -> Generator[StreamWrapper, None, None]:\n    \"\"\"Return a context manager used by captured_stdout/stdin/stderr\n    that temporarily replaces the sys stream *stream_name* with a StringIO.\n\n    Taken from Lib/support/__init__.py in the CPython repo.\n    \"\"\"\n    orig_stdout = getattr(sys, stream_name)\n    setattr(sys, stream_name, StreamWrapper.from_stream(orig_stdout))\n    try:\n        yield getattr(sys, stream_name)\n    finally:\n        setattr(sys, stream_name, orig_stdout)\n\n\ndef captured_stdout() -> ContextManager[StreamWrapper]:\n    \"\"\"Capture the output of sys.stdout:\n\n       with captured_stdout() as stdout:\n           print('hello')\n       self.assertEqual(stdout.getvalue(), 'hello\\n')\n\n    Taken from Lib/support/__init__.py in the CPython repo.\n    \"\"\"\n    return captured_output(\"stdout\")\n\n\ndef captured_stderr() -> ContextManager[StreamWrapper]:\n    \"\"\"\n    See captured_stdout().\n    \"\"\"\n    return captured_output(\"stderr\")\n\n\n# Simulates an enum\ndef enum(*sequential: Any, **named: Any) -> Type[Any]:\n    enums = dict(zip(sequential, range(len(sequential))), **named)\n    reverse = {value: key for key, value in enums.items()}\n    enums[\"reverse_mapping\"] = reverse\n    return type(\"Enum\", (), enums)\n\n\ndef build_netloc(host: str, port: Optional[int]) -> str:\n    \"\"\"\n    Build a netloc from a host-port pair\n    \"\"\"\n    if port is None:\n        return host\n    if \":\" in host:\n        # Only wrap host with square brackets when it is IPv6\n        host = f\"[{host}]\"\n    return f\"{host}:{port}\"\n\n\ndef build_url_from_netloc(netloc: str, scheme: str = \"https\") -> str:\n    \"\"\"\n    Build a full URL from a netloc.\n    \"\"\"\n    if netloc.count(\":\") >= 2 and \"@\" not in netloc and \"[\" not in netloc:\n        # It must be a bare IPv6 address, so wrap it with brackets.\n        netloc = f\"[{netloc}]\"\n    return f\"{scheme}://{netloc}\"\n\n\ndef parse_netloc(netloc: str) -> Tuple[Optional[str], Optional[int]]:\n    \"\"\"\n    Return the host-port pair from a netloc.\n    \"\"\"\n    url = build_url_from_netloc(netloc)\n    parsed = urllib.parse.urlparse(url)\n    return parsed.hostname, parsed.port\n\n\ndef split_auth_from_netloc(netloc: str) -> NetlocTuple:\n    \"\"\"\n    Parse out and remove the auth information from a netloc.\n\n    Returns: (netloc, (username, password)).\n    \"\"\"\n    if \"@\" not in netloc:\n        return netloc, (None, None)\n\n    # Split from the right because that's how urllib.parse.urlsplit()\n    # behaves if more than one @ is present (which can be checked using\n    # the password attribute of urlsplit()'s return value).\n    auth, netloc = netloc.rsplit(\"@\", 1)\n    pw: Optional[str] = None\n    if \":\" in auth:\n        # Split from the left because that's how urllib.parse.urlsplit()\n        # behaves if more than one : is present (which again can be checked\n        # using the password attribute of the return value)\n        user, pw = auth.split(\":\", 1)\n    else:\n        user, pw = auth, None\n\n    user = urllib.parse.unquote(user)\n    if pw is not None:\n        pw = urllib.parse.unquote(pw)\n\n    return netloc, (user, pw)\n\n\ndef redact_netloc(netloc: str) -> str:\n    \"\"\"\n    Replace the sensitive data in a netloc with \"****\", if it exists.\n\n    For example:\n        - \"user:pass@example.com\" returns \"user:****@example.com\"\n        - \"accesstoken@example.com\" returns \"****@example.com\"\n    \"\"\"\n    netloc, (user, password) = split_auth_from_netloc(netloc)\n    if user is None:\n        return netloc\n    if password is None:\n        user = \"****\"\n        password = \"\"\n    else:\n        user = urllib.parse.quote(user)\n        password = \":****\"\n    return f\"{user}{password}@{netloc}\"\n\n\ndef _transform_url(\n    url: str, transform_netloc: Callable[[str], Tuple[Any, ...]]\n) -> Tuple[str, NetlocTuple]:\n    \"\"\"Transform and replace netloc in a url.\n\n    transform_netloc is a function taking the netloc and returning a\n    tuple. The first element of this tuple is the new netloc. The\n    entire tuple is returned.\n\n    Returns a tuple containing the transformed url as item 0 and the\n    original tuple returned by transform_netloc as item 1.\n    \"\"\"\n    purl = urllib.parse.urlsplit(url)\n    netloc_tuple = transform_netloc(purl.netloc)\n    # stripped url\n    url_pieces = (purl.scheme, netloc_tuple[0], purl.path, purl.query, purl.fragment)\n    surl = urllib.parse.urlunsplit(url_pieces)\n    return surl, cast(\"NetlocTuple\", netloc_tuple)\n\n\ndef _get_netloc(netloc: str) -> NetlocTuple:\n    return split_auth_from_netloc(netloc)\n\n\ndef _redact_netloc(netloc: str) -> Tuple[str]:\n    return (redact_netloc(netloc),)\n\n\ndef split_auth_netloc_from_url(\n    url: str,\n) -> Tuple[str, str, Tuple[Optional[str], Optional[str]]]:\n    \"\"\"\n    Parse a url into separate netloc, auth, and url with no auth.\n\n    Returns: (url_without_auth, netloc, (username, password))\n    \"\"\"\n    url_without_auth, (netloc, auth) = _transform_url(url, _get_netloc)\n    return url_without_auth, netloc, auth\n\n\ndef remove_auth_from_url(url: str) -> str:\n    \"\"\"Return a copy of url with 'username:password@' removed.\"\"\"\n    # username/pass params are passed to subversion through flags\n    # and are not recognized in the url.\n    return _transform_url(url, _get_netloc)[0]\n\n\ndef redact_auth_from_url(url: str) -> str:\n    \"\"\"Replace the password in a given url with ****.\"\"\"\n    return _transform_url(url, _redact_netloc)[0]\n\n\ndef redact_auth_from_requirement(req: Requirement) -> str:\n    \"\"\"Replace the password in a given requirement url with ****.\"\"\"\n    if not req.url:\n        return str(req)\n    return str(req).replace(req.url, redact_auth_from_url(req.url))\n\n\nclass HiddenText:\n    def __init__(self, secret: str, redacted: str) -> None:\n        self.secret = secret\n        self.redacted = redacted\n\n    def __repr__(self) -> str:\n        return f\"<HiddenText {str(self)!r}>\"\n\n    def __str__(self) -> str:\n        return self.redacted\n\n    # This is useful for testing.\n    def __eq__(self, other: Any) -> bool:\n        if type(self) != type(other):\n            return False\n\n        # The string being used for redaction doesn't also have to match,\n        # just the raw, original string.\n        return self.secret == other.secret\n\n\ndef hide_value(value: str) -> HiddenText:\n    return HiddenText(value, redacted=\"****\")\n\n\ndef hide_url(url: str) -> HiddenText:\n    redacted = redact_auth_from_url(url)\n    return HiddenText(url, redacted=redacted)\n\n\ndef protect_pip_from_modification_on_windows(modifying_pip: bool) -> None:\n    \"\"\"Protection of pip.exe from modification on Windows\n\n    On Windows, any operation modifying pip should be run as:\n        python -m pip ...\n    \"\"\"\n    pip_names = [\n        \"pip\",\n        f\"pip{sys.version_info.major}\",\n        f\"pip{sys.version_info.major}.{sys.version_info.minor}\",\n    ]\n\n    # See https://github.com/pypa/pip/issues/1299 for more discussion\n    should_show_use_python_msg = (\n        modifying_pip and WINDOWS and os.path.basename(sys.argv[0]) in pip_names\n    )\n\n    if should_show_use_python_msg:\n        new_command = [sys.executable, \"-m\", \"pip\"] + sys.argv[1:]\n        raise CommandError(\n            \"To modify pip, please run the following command:\\n{}\".format(\n                \" \".join(new_command)\n            )\n        )\n\n\ndef check_externally_managed() -> None:\n    \"\"\"Check whether the current environment is externally managed.\n\n    If the ``EXTERNALLY-MANAGED`` config file is found, the current environment\n    is considered externally managed, and an ExternallyManagedEnvironment is\n    raised.\n    \"\"\"\n    if running_under_virtualenv():\n        return\n    marker = os.path.join(sysconfig.get_path(\"stdlib\"), \"EXTERNALLY-MANAGED\")\n    if not os.path.isfile(marker):\n        return\n    raise ExternallyManagedEnvironment.from_config(marker)\n\n\ndef is_console_interactive() -> bool:\n    \"\"\"Is this console interactive?\"\"\"\n    return sys.stdin is not None and sys.stdin.isatty()\n\n\ndef hash_file(path: str, blocksize: int = 1 << 20) -> Tuple[Any, int]:\n    \"\"\"Return (hash, length) for path using hashlib.sha256()\"\"\"\n\n    h = hashlib.sha256()\n    length = 0\n    with open(path, \"rb\") as f:\n        for block in read_chunks(f, size=blocksize):\n            length += len(block)\n            h.update(block)\n    return h, length\n\n\ndef pairwise(iterable: Iterable[Any]) -> Iterator[Tuple[Any, Any]]:\n    \"\"\"\n    Return paired elements.\n\n    For example:\n        s -> (s0, s1), (s2, s3), (s4, s5), ...\n    \"\"\"\n    iterable = iter(iterable)\n    return zip_longest(iterable, iterable)\n\n\ndef partition(\n    pred: Callable[[T], bool],\n    iterable: Iterable[T],\n) -> Tuple[Iterable[T], Iterable[T]]:\n    \"\"\"\n    Use a predicate to partition entries into false entries and true entries,\n    like\n\n        partition(is_odd, range(10)) --> 0 2 4 6 8   and  1 3 5 7 9\n    \"\"\"\n    t1, t2 = tee(iterable)\n    return filterfalse(pred, t1), filter(pred, t2)\n\n\nclass ConfiguredBuildBackendHookCaller(BuildBackendHookCaller):\n    def __init__(\n        self,\n        config_holder: Any,\n        source_dir: str,\n        build_backend: str,\n        backend_path: Optional[str] = None,\n        runner: Optional[Callable[..., None]] = None,\n        python_executable: Optional[str] = None,\n    ):\n        super().__init__(\n            source_dir, build_backend, backend_path, runner, python_executable\n        )\n        self.config_holder = config_holder\n\n    def build_wheel(\n        self,\n        wheel_directory: str,\n        config_settings: Optional[Dict[str, Union[str, List[str]]]] = None,\n        metadata_directory: Optional[str] = None,\n    ) -> str:\n        cs = self.config_holder.config_settings\n        return super().build_wheel(\n            wheel_directory, config_settings=cs, metadata_directory=metadata_directory\n        )\n\n    def build_sdist(\n        self,\n        sdist_directory: str,\n        config_settings: Optional[Dict[str, Union[str, List[str]]]] = None,\n    ) -> str:\n        cs = self.config_holder.config_settings\n        return super().build_sdist(sdist_directory, config_settings=cs)\n\n    def build_editable(\n        self,\n        wheel_directory: str,\n        config_settings: Optional[Dict[str, Union[str, List[str]]]] = None,\n        metadata_directory: Optional[str] = None,\n    ) -> str:\n        cs = self.config_holder.config_settings\n        return super().build_editable(\n            wheel_directory, config_settings=cs, metadata_directory=metadata_directory\n        )\n\n    def get_requires_for_build_wheel(\n        self, config_settings: Optional[Dict[str, Union[str, List[str]]]] = None\n    ) -> List[str]:\n        cs = self.config_holder.config_settings\n        return super().get_requires_for_build_wheel(config_settings=cs)\n\n    def get_requires_for_build_sdist(\n        self, config_settings: Optional[Dict[str, Union[str, List[str]]]] = None\n    ) -> List[str]:\n        cs = self.config_holder.config_settings\n        return super().get_requires_for_build_sdist(config_settings=cs)\n\n    def get_requires_for_build_editable(\n        self, config_settings: Optional[Dict[str, Union[str, List[str]]]] = None\n    ) -> List[str]:\n        cs = self.config_holder.config_settings\n        return super().get_requires_for_build_editable(config_settings=cs)\n\n    def prepare_metadata_for_build_wheel(\n        self,\n        metadata_directory: str,\n        config_settings: Optional[Dict[str, Union[str, List[str]]]] = None,\n        _allow_fallback: bool = True,\n    ) -> str:\n        cs = self.config_holder.config_settings\n        return super().prepare_metadata_for_build_wheel(\n            metadata_directory=metadata_directory,\n            config_settings=cs,\n            _allow_fallback=_allow_fallback,\n        )\n\n    def prepare_metadata_for_build_editable(\n        self,\n        metadata_directory: str,\n        config_settings: Optional[Dict[str, Union[str, List[str]]]] = None,\n        _allow_fallback: bool = True,\n    ) -> str:\n        cs = self.config_holder.config_settings\n        return super().prepare_metadata_for_build_editable(\n            metadata_directory=metadata_directory,\n            config_settings=cs,\n            _allow_fallback=_allow_fallback,\n        )\n"},"hash":"QOntm0022d"}