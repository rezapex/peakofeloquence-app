{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_internal:vcs:git.py","body":"import logging\nimport os.path\nimport pathlib\nimport re\nimport urllib.parse\nimport urllib.request\nfrom typing import List, Optional, Tuple\n\nfrom pip._internal.exceptions import BadCommand, InstallationError\nfrom pip._internal.utils.misc import HiddenText, display_path, hide_url\nfrom pip._internal.utils.subprocess import make_command\nfrom pip._internal.vcs.versioncontrol import (\n    AuthInfo,\n    RemoteNotFoundError,\n    RemoteNotValidError,\n    RevOptions,\n    VersionControl,\n    find_path_to_project_root_from_repo_root,\n    vcs,\n)\n\nurlsplit = urllib.parse.urlsplit\nurlunsplit = urllib.parse.urlunsplit\n\n\nlogger = logging.getLogger(__name__)\n\n\nGIT_VERSION_REGEX = re.compile(\n    r\"^git version \"  # Prefix.\n    r\"(\\d+)\"  # Major.\n    r\"\\.(\\d+)\"  # Dot, minor.\n    r\"(?:\\.(\\d+))?\"  # Optional dot, patch.\n    r\".*$\"  # Suffix, including any pre- and post-release segments we don't care about.\n)\n\nHASH_REGEX = re.compile(\"^[a-fA-F0-9]{40}$\")\n\n# SCP (Secure copy protocol) shorthand. e.g. 'git@example.com:foo/bar.git'\nSCP_REGEX = re.compile(\n    r\"\"\"^\n    # Optional user, e.g. 'git@'\n    (\\w+@)?\n    # Server, e.g. 'github.com'.\n    ([^/:]+):\n    # The server-side path. e.g. 'user/project.git'. Must start with an\n    # alphanumeric character so as not to be confusable with a Windows paths\n    # like 'C:/foo/bar' or 'C:\\foo\\bar'.\n    (\\w[^:]*)\n    $\"\"\",\n    re.VERBOSE,\n)\n\n\ndef looks_like_hash(sha: str) -> bool:\n    return bool(HASH_REGEX.match(sha))\n\n\nclass Git(VersionControl):\n    name = \"git\"\n    dirname = \".git\"\n    repo_name = \"clone\"\n    schemes = (\n        \"git+http\",\n        \"git+https\",\n        \"git+ssh\",\n        \"git+git\",\n        \"git+file\",\n    )\n    # Prevent the user's environment variables from interfering with pip:\n    # https://github.com/pypa/pip/issues/1130\n    unset_environ = (\"GIT_DIR\", \"GIT_WORK_TREE\")\n    default_arg_rev = \"HEAD\"\n\n    @staticmethod\n    def get_base_rev_args(rev: str) -> List[str]:\n        return [rev]\n\n    def is_immutable_rev_checkout(self, url: str, dest: str) -> bool:\n        _, rev_options = self.get_url_rev_options(hide_url(url))\n        if not rev_options.rev:\n            return False\n        if not self.is_commit_id_equal(dest, rev_options.rev):\n            # the current commit is different from rev,\n            # which means rev was something else than a commit hash\n            return False\n        # return False in the rare case rev is both a commit hash\n        # and a tag or a branch; we don't want to cache in that case\n        # because that branch/tag could point to something else in the future\n        is_tag_or_branch = bool(self.get_revision_sha(dest, rev_options.rev)[0])\n        return not is_tag_or_branch\n\n    def get_git_version(self) -> Tuple[int, ...]:\n        version = self.run_command(\n            [\"version\"],\n            command_desc=\"git version\",\n            show_stdout=False,\n            stdout_only=True,\n        )\n        match = GIT_VERSION_REGEX.match(version)\n        if not match:\n            logger.warning(\"Can't parse git version: %s\", version)\n            return ()\n        return (int(match.group(1)), int(match.group(2)))\n\n    @classmethod\n    def get_current_branch(cls, location: str) -> Optional[str]:\n        \"\"\"\n        Return the current branch, or None if HEAD isn't at a branch\n        (e.g. detached HEAD).\n        \"\"\"\n        # git-symbolic-ref exits with empty stdout if \"HEAD\" is a detached\n        # HEAD rather than a symbolic ref.  In addition, the -q causes the\n        # command to exit with status code 1 instead of 128 in this case\n        # and to suppress the message to stderr.\n        args = [\"symbolic-ref\", \"-q\", \"HEAD\"]\n        output = cls.run_command(\n            args,\n            extra_ok_returncodes=(1,),\n            show_stdout=False,\n            stdout_only=True,\n            cwd=location,\n        )\n        ref = output.strip()\n\n        if ref.startswith(\"refs/heads/\"):\n            return ref[len(\"refs/heads/\") :]\n\n        return None\n\n    @classmethod\n    def get_revision_sha(cls, dest: str, rev: str) -> Tuple[Optional[str], bool]:\n        \"\"\"\n        Return (sha_or_none, is_branch), where sha_or_none is a commit hash\n        if the revision names a remote branch or tag, otherwise None.\n\n        Args:\n          dest: the repository directory.\n          rev: the revision name.\n        \"\"\"\n        # Pass rev to pre-filter the list.\n        output = cls.run_command(\n            [\"show-ref\", rev],\n            cwd=dest,\n            show_stdout=False,\n            stdout_only=True,\n            on_returncode=\"ignore\",\n        )\n        refs = {}\n        # NOTE: We do not use splitlines here since that would split on other\n        #       unicode separators, which can be maliciously used to install a\n        #       different revision.\n        for line in output.strip().split(\"\\n\"):\n            line = line.rstrip(\"\\r\")\n            if not line:\n                continue\n            try:\n                ref_sha, ref_name = line.split(\" \", maxsplit=2)\n            except ValueError:\n                # Include the offending line to simplify troubleshooting if\n                # this error ever occurs.\n                raise ValueError(f\"unexpected show-ref line: {line!r}\")\n\n            refs[ref_name] = ref_sha\n\n        branch_ref = f\"refs/remotes/origin/{rev}\"\n        tag_ref = f\"refs/tags/{rev}\"\n\n        sha = refs.get(branch_ref)\n        if sha is not None:\n            return (sha, True)\n\n        sha = refs.get(tag_ref)\n\n        return (sha, False)\n\n    @classmethod\n    def _should_fetch(cls, dest: str, rev: str) -> bool:\n        \"\"\"\n        Return true if rev is a ref or is a commit that we don't have locally.\n\n        Branches and tags are not considered in this method because they are\n        assumed to be always available locally (which is a normal outcome of\n        ``git clone`` and ``git fetch --tags``).\n        \"\"\"\n        if rev.startswith(\"refs/\"):\n            # Always fetch remote refs.\n            return True\n\n        if not looks_like_hash(rev):\n            # Git fetch would fail with abbreviated commits.\n            return False\n\n        if cls.has_commit(dest, rev):\n            # Don't fetch if we have the commit locally.\n            return False\n\n        return True\n\n    @classmethod\n    def resolve_revision(\n        cls, dest: str, url: HiddenText, rev_options: RevOptions\n    ) -> RevOptions:\n        \"\"\"\n        Resolve a revision to a new RevOptions object with the SHA1 of the\n        branch, tag, or ref if found.\n\n        Args:\n          rev_options: a RevOptions object.\n        \"\"\"\n        rev = rev_options.arg_rev\n        # The arg_rev property's implementation for Git ensures that the\n        # rev return value is always non-None.\n        assert rev is not None\n\n        sha, is_branch = cls.get_revision_sha(dest, rev)\n\n        if sha is not None:\n            rev_options = rev_options.make_new(sha)\n            rev_options.branch_name = rev if is_branch else None\n\n            return rev_options\n\n        # Do not show a warning for the common case of something that has\n        # the form of a Git commit hash.\n        if not looks_like_hash(rev):\n            logger.warning(\n                \"Did not find branch or tag '%s', assuming revision or ref.\",\n                rev,\n            )\n\n        if not cls._should_fetch(dest, rev):\n            return rev_options\n\n        # fetch the requested revision\n        cls.run_command(\n            make_command(\"fetch\", \"-q\", url, rev_options.to_args()),\n            cwd=dest,\n        )\n        # Change the revision to the SHA of the ref we fetched\n        sha = cls.get_revision(dest, rev=\"FETCH_HEAD\")\n        rev_options = rev_options.make_new(sha)\n\n        return rev_options\n\n    @classmethod\n    def is_commit_id_equal(cls, dest: str, name: Optional[str]) -> bool:\n        \"\"\"\n        Return whether the current commit hash equals the given name.\n\n        Args:\n          dest: the repository directory.\n          name: a string name.\n        \"\"\"\n        if not name:\n            # Then avoid an unnecessary subprocess call.\n            return False\n\n        return cls.get_revision(dest) == name\n\n    def fetch_new(\n        self, dest: str, url: HiddenText, rev_options: RevOptions, verbosity: int\n    ) -> None:\n        rev_display = rev_options.to_display()\n        logger.info(\"Cloning %s%s to %s\", url, rev_display, display_path(dest))\n        if verbosity <= 0:\n            flags: Tuple[str, ...] = (\"--quiet\",)\n        elif verbosity == 1:\n            flags = ()\n        else:\n            flags = (\"--verbose\", \"--progress\")\n        if self.get_git_version() >= (2, 17):\n            # Git added support for partial clone in 2.17\n            # https://git-scm.com/docs/partial-clone\n            # Speeds up cloning by functioning without a complete copy of repository\n            self.run_command(\n                make_command(\n                    \"clone\",\n                    \"--filter=blob:none\",\n                    *flags,\n                    url,\n                    dest,\n                )\n            )\n        else:\n            self.run_command(make_command(\"clone\", *flags, url, dest))\n\n        if rev_options.rev:\n            # Then a specific revision was requested.\n            rev_options = self.resolve_revision(dest, url, rev_options)\n            branch_name = getattr(rev_options, \"branch_name\", None)\n            logger.debug(\"Rev options %s, branch_name %s\", rev_options, branch_name)\n            if branch_name is None:\n                # Only do a checkout if the current commit id doesn't match\n                # the requested revision.\n                if not self.is_commit_id_equal(dest, rev_options.rev):\n                    cmd_args = make_command(\n                        \"checkout\",\n                        \"-q\",\n                        rev_options.to_args(),\n                    )\n                    self.run_command(cmd_args, cwd=dest)\n            elif self.get_current_branch(dest) != branch_name:\n                # Then a specific branch was requested, and that branch\n                # is not yet checked out.\n                track_branch = f\"origin/{branch_name}\"\n                cmd_args = [\n                    \"checkout\",\n                    \"-b\",\n                    branch_name,\n                    \"--track\",\n                    track_branch,\n                ]\n                self.run_command(cmd_args, cwd=dest)\n        else:\n            sha = self.get_revision(dest)\n            rev_options = rev_options.make_new(sha)\n\n        logger.info(\"Resolved %s to commit %s\", url, rev_options.rev)\n\n        #: repo may contain submodules\n        self.update_submodules(dest)\n\n    def switch(self, dest: str, url: HiddenText, rev_options: RevOptions) -> None:\n        self.run_command(\n            make_command(\"config\", \"remote.origin.url\", url),\n            cwd=dest,\n        )\n        cmd_args = make_command(\"checkout\", \"-q\", rev_options.to_args())\n        self.run_command(cmd_args, cwd=dest)\n\n        self.update_submodules(dest)\n\n    def update(self, dest: str, url: HiddenText, rev_options: RevOptions) -> None:\n        # First fetch changes from the default remote\n        if self.get_git_version() >= (1, 9):\n            # fetch tags in addition to everything else\n            self.run_command([\"fetch\", \"-q\", \"--tags\"], cwd=dest)\n        else:\n            self.run_command([\"fetch\", \"-q\"], cwd=dest)\n        # Then reset to wanted revision (maybe even origin/master)\n        rev_options = self.resolve_revision(dest, url, rev_options)\n        cmd_args = make_command(\"reset\", \"--hard\", \"-q\", rev_options.to_args())\n        self.run_command(cmd_args, cwd=dest)\n        #: update submodules\n        self.update_submodules(dest)\n\n    @classmethod\n    def get_remote_url(cls, location: str) -> str:\n        \"\"\"\n        Return URL of the first remote encountered.\n\n        Raises RemoteNotFoundError if the repository does not have a remote\n        url configured.\n        \"\"\"\n        # We need to pass 1 for extra_ok_returncodes since the command\n        # exits with return code 1 if there are no matching lines.\n        stdout = cls.run_command(\n            [\"config\", \"--get-regexp\", r\"remote\\..*\\.url\"],\n            extra_ok_returncodes=(1,),\n            show_stdout=False,\n            stdout_only=True,\n            cwd=location,\n        )\n        remotes = stdout.splitlines()\n        try:\n            found_remote = remotes[0]\n        except IndexError:\n            raise RemoteNotFoundError\n\n        for remote in remotes:\n            if remote.startswith(\"remote.origin.url \"):\n                found_remote = remote\n                break\n        url = found_remote.split(\" \")[1]\n        return cls._git_remote_to_pip_url(url.strip())\n\n    @staticmethod\n    def _git_remote_to_pip_url(url: str) -> str:\n        \"\"\"\n        Convert a remote url from what git uses to what pip accepts.\n\n        There are 3 legal forms **url** may take:\n\n            1. A fully qualified url: ssh://git@example.com/foo/bar.git\n            2. A local project.git folder: /path/to/bare/repository.git\n            3. SCP shorthand for form 1: git@example.com:foo/bar.git\n\n        Form 1 is output as-is. Form 2 must be converted to URI and form 3 must\n        be converted to form 1.\n\n        See the corresponding test test_git_remote_url_to_pip() for examples of\n        sample inputs/outputs.\n        \"\"\"\n        if re.match(r\"\\w+://\", url):\n            # This is already valid. Pass it though as-is.\n            return url\n        if os.path.exists(url):\n            # A local bare remote (git clone --mirror).\n            # Needs a file:// prefix.\n            return pathlib.PurePath(url).as_uri()\n        scp_match = SCP_REGEX.match(url)\n        if scp_match:\n            # Add an ssh:// prefix and replace the ':' with a '/'.\n            return scp_match.expand(r\"ssh://\\1\\2/\\3\")\n        # Otherwise, bail out.\n        raise RemoteNotValidError(url)\n\n    @classmethod\n    def has_commit(cls, location: str, rev: str) -> bool:\n        \"\"\"\n        Check if rev is a commit that is available in the local repository.\n        \"\"\"\n        try:\n            cls.run_command(\n                [\"rev-parse\", \"-q\", \"--verify\", \"sha^\" + rev],\n                cwd=location,\n                log_failed_cmd=False,\n            )\n        except InstallationError:\n            return False\n        else:\n            return True\n\n    @classmethod\n    def get_revision(cls, location: str, rev: Optional[str] = None) -> str:\n        if rev is None:\n            rev = \"HEAD\"\n        current_rev = cls.run_command(\n            [\"rev-parse\", rev],\n            show_stdout=False,\n            stdout_only=True,\n            cwd=location,\n        )\n        return current_rev.strip()\n\n    @classmethod\n    def get_subdirectory(cls, location: str) -> Optional[str]:\n        \"\"\"\n        Return the path to Python project root, relative to the repo root.\n        Return None if the project root is in the repo root.\n        \"\"\"\n        # find the repo root\n        git_dir = cls.run_command(\n            [\"rev-parse\", \"--git-dir\"],\n            show_stdout=False,\n            stdout_only=True,\n            cwd=location,\n        ).strip()\n        if not os.path.isabs(git_dir):\n            git_dir = os.path.join(location, git_dir)\n        repo_root = os.path.abspath(os.path.join(git_dir, \"..\"))\n        return find_path_to_project_root_from_repo_root(location, repo_root)\n\n    @classmethod\n    def get_url_rev_and_auth(cls, url: str) -> Tuple[str, Optional[str], AuthInfo]:\n        \"\"\"\n        Prefixes stub URLs like 'user@hostname:user/repo.git' with 'ssh://'.\n        That's required because although they use SSH they sometimes don't\n        work with a ssh:// scheme (e.g. GitHub). But we need a scheme for\n        parsing. Hence we remove it again afterwards and return it as a stub.\n        \"\"\"\n        # Works around an apparent Git bug\n        # (see https://article.gmane.org/gmane.comp.version-control.git/146500)\n        scheme, netloc, path, query, fragment = urlsplit(url)\n        if scheme.endswith(\"file\"):\n            initial_slashes = path[: -len(path.lstrip(\"/\"))]\n            newpath = initial_slashes + urllib.request.url2pathname(path).replace(\n                \"\\\\\", \"/\"\n            ).lstrip(\"/\")\n            after_plus = scheme.find(\"+\") + 1\n            url = scheme[:after_plus] + urlunsplit(\n                (scheme[after_plus:], netloc, newpath, query, fragment),\n            )\n\n        if \"://\" not in url:\n            assert \"file:\" not in url\n            url = url.replace(\"git+\", \"git+ssh://\")\n            url, rev, user_pass = super().get_url_rev_and_auth(url)\n            url = url.replace(\"ssh://\", \"\")\n        else:\n            url, rev, user_pass = super().get_url_rev_and_auth(url)\n\n        return url, rev, user_pass\n\n    @classmethod\n    def update_submodules(cls, location: str) -> None:\n        if not os.path.exists(os.path.join(location, \".gitmodules\")):\n            return\n        cls.run_command(\n            [\"submodule\", \"update\", \"--init\", \"--recursive\", \"-q\"],\n            cwd=location,\n        )\n\n    @classmethod\n    def get_repository_root(cls, location: str) -> Optional[str]:\n        loc = super().get_repository_root(location)\n        if loc:\n            return loc\n        try:\n            r = cls.run_command(\n                [\"rev-parse\", \"--show-toplevel\"],\n                cwd=location,\n                show_stdout=False,\n                stdout_only=True,\n                on_returncode=\"raise\",\n                log_failed_cmd=False,\n            )\n        except BadCommand:\n            logger.debug(\n                \"could not determine if %s is under git control \"\n                \"because git is not available\",\n                location,\n            )\n            return None\n        except InstallationError:\n            return None\n        return os.path.normpath(r.rstrip(\"\\r\\n\"))\n\n    @staticmethod\n    def should_add_vcs_url_prefix(repo_url: str) -> bool:\n        \"\"\"In either https or ssh form, requirements must be prefixed with git+.\"\"\"\n        return True\n\n\nvcs.register(Git)\n"},"hash":"1Cclv930Ms"}