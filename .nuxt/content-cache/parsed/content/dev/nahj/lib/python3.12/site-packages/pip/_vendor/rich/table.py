{"parsed":{"_id":"content:dev:nahj:lib:python3.12:site-packages:pip:_vendor:rich:table.py","body":"from dataclasses import dataclass, field, replace\nfrom typing import (\n    TYPE_CHECKING,\n    Dict,\n    Iterable,\n    List,\n    NamedTuple,\n    Optional,\n    Sequence,\n    Tuple,\n    Union,\n)\n\nfrom . import box, errors\nfrom ._loop import loop_first_last, loop_last\nfrom ._pick import pick_bool\nfrom ._ratio import ratio_distribute, ratio_reduce\nfrom .align import VerticalAlignMethod\nfrom .jupyter import JupyterMixin\nfrom .measure import Measurement\nfrom .padding import Padding, PaddingDimensions\nfrom .protocol import is_renderable\nfrom .segment import Segment\nfrom .style import Style, StyleType\nfrom .text import Text, TextType\n\nif TYPE_CHECKING:\n    from .console import (\n        Console,\n        ConsoleOptions,\n        JustifyMethod,\n        OverflowMethod,\n        RenderableType,\n        RenderResult,\n    )\n\n\n@dataclass\nclass Column:\n    \"\"\"Defines a column within a ~Table.\n\n    Args:\n        title (Union[str, Text], optional): The title of the table rendered at the top. Defaults to None.\n        caption (Union[str, Text], optional): The table caption rendered below. Defaults to None.\n        width (int, optional): The width in characters of the table, or ``None`` to automatically fit. Defaults to None.\n        min_width (Optional[int], optional): The minimum width of the table, or ``None`` for no minimum. Defaults to None.\n        box (box.Box, optional): One of the constants in box.py used to draw the edges (see :ref:`appendix_box`), or ``None`` for no box lines. Defaults to box.HEAVY_HEAD.\n        safe_box (Optional[bool], optional): Disable box characters that don't display on windows legacy terminal with *raster* fonts. Defaults to True.\n        padding (PaddingDimensions, optional): Padding for cells (top, right, bottom, left). Defaults to (0, 1).\n        collapse_padding (bool, optional): Enable collapsing of padding around cells. Defaults to False.\n        pad_edge (bool, optional): Enable padding of edge cells. Defaults to True.\n        expand (bool, optional): Expand the table to fit the available space if ``True``, otherwise the table width will be auto-calculated. Defaults to False.\n        show_header (bool, optional): Show a header row. Defaults to True.\n        show_footer (bool, optional): Show a footer row. Defaults to False.\n        show_edge (bool, optional): Draw a box around the outside of the table. Defaults to True.\n        show_lines (bool, optional): Draw lines between every row. Defaults to False.\n        leading (bool, optional): Number of blank lines between rows (precludes ``show_lines``). Defaults to 0.\n        style (Union[str, Style], optional): Default style for the table. Defaults to \"none\".\n        row_styles (List[Union, str], optional): Optional list of row styles, if more than one style is given then the styles will alternate. Defaults to None.\n        header_style (Union[str, Style], optional): Style of the header. Defaults to \"table.header\".\n        footer_style (Union[str, Style], optional): Style of the footer. Defaults to \"table.footer\".\n        border_style (Union[str, Style], optional): Style of the border. Defaults to None.\n        title_style (Union[str, Style], optional): Style of the title. Defaults to None.\n        caption_style (Union[str, Style], optional): Style of the caption. Defaults to None.\n        title_justify (str, optional): Justify method for title. Defaults to \"center\".\n        caption_justify (str, optional): Justify method for caption. Defaults to \"center\".\n        highlight (bool, optional): Highlight cell contents (if str). Defaults to False.\n    \"\"\"\n\n    header: \"RenderableType\" = \"\"\n    \"\"\"RenderableType: Renderable for the header (typically a string)\"\"\"\n\n    footer: \"RenderableType\" = \"\"\n    \"\"\"RenderableType: Renderable for the footer (typically a string)\"\"\"\n\n    header_style: StyleType = \"\"\n    \"\"\"StyleType: The style of the header.\"\"\"\n\n    footer_style: StyleType = \"\"\n    \"\"\"StyleType: The style of the footer.\"\"\"\n\n    style: StyleType = \"\"\n    \"\"\"StyleType: The style of the column.\"\"\"\n\n    justify: \"JustifyMethod\" = \"left\"\n    \"\"\"str: How to justify text within the column (\"left\", \"center\", \"right\", or \"full\")\"\"\"\n\n    vertical: \"VerticalAlignMethod\" = \"top\"\n    \"\"\"str: How to vertically align content (\"top\", \"middle\", or \"bottom\")\"\"\"\n\n    overflow: \"OverflowMethod\" = \"ellipsis\"\n    \"\"\"str: Overflow method.\"\"\"\n\n    width: Optional[int] = None\n    \"\"\"Optional[int]: Width of the column, or ``None`` (default) to auto calculate width.\"\"\"\n\n    min_width: Optional[int] = None\n    \"\"\"Optional[int]: Minimum width of column, or ``None`` for no minimum. Defaults to None.\"\"\"\n\n    max_width: Optional[int] = None\n    \"\"\"Optional[int]: Maximum width of column, or ``None`` for no maximum. Defaults to None.\"\"\"\n\n    ratio: Optional[int] = None\n    \"\"\"Optional[int]: Ratio to use when calculating column width, or ``None`` (default) to adapt to column contents.\"\"\"\n\n    no_wrap: bool = False\n    \"\"\"bool: Prevent wrapping of text within the column. Defaults to ``False``.\"\"\"\n\n    _index: int = 0\n    \"\"\"Index of column.\"\"\"\n\n    _cells: List[\"RenderableType\"] = field(default_factory=list)\n\n    def copy(self) -> \"Column\":\n        \"\"\"Return a copy of this Column.\"\"\"\n        return replace(self, _cells=[])\n\n    @property\n    def cells(self) -> Iterable[\"RenderableType\"]:\n        \"\"\"Get all cells in the column, not including header.\"\"\"\n        yield from self._cells\n\n    @property\n    def flexible(self) -> bool:\n        \"\"\"Check if this column is flexible.\"\"\"\n        return self.ratio is not None\n\n\n@dataclass\nclass Row:\n    \"\"\"Information regarding a row.\"\"\"\n\n    style: Optional[StyleType] = None\n    \"\"\"Style to apply to row.\"\"\"\n\n    end_section: bool = False\n    \"\"\"Indicated end of section, which will force a line beneath the row.\"\"\"\n\n\nclass _Cell(NamedTuple):\n    \"\"\"A single cell in a table.\"\"\"\n\n    style: StyleType\n    \"\"\"Style to apply to cell.\"\"\"\n    renderable: \"RenderableType\"\n    \"\"\"Cell renderable.\"\"\"\n    vertical: VerticalAlignMethod\n    \"\"\"Cell vertical alignment.\"\"\"\n\n\nclass Table(JupyterMixin):\n    \"\"\"A console renderable to draw a table.\n\n    Args:\n        *headers (Union[Column, str]): Column headers, either as a string, or :class:`~rich.table.Column` instance.\n        title (Union[str, Text], optional): The title of the table rendered at the top. Defaults to None.\n        caption (Union[str, Text], optional): The table caption rendered below. Defaults to None.\n        width (int, optional): The width in characters of the table, or ``None`` to automatically fit. Defaults to None.\n        min_width (Optional[int], optional): The minimum width of the table, or ``None`` for no minimum. Defaults to None.\n        box (box.Box, optional): One of the constants in box.py used to draw the edges (see :ref:`appendix_box`), or ``None`` for no box lines. Defaults to box.HEAVY_HEAD.\n        safe_box (Optional[bool], optional): Disable box characters that don't display on windows legacy terminal with *raster* fonts. Defaults to True.\n        padding (PaddingDimensions, optional): Padding for cells (top, right, bottom, left). Defaults to (0, 1).\n        collapse_padding (bool, optional): Enable collapsing of padding around cells. Defaults to False.\n        pad_edge (bool, optional): Enable padding of edge cells. Defaults to True.\n        expand (bool, optional): Expand the table to fit the available space if ``True``, otherwise the table width will be auto-calculated. Defaults to False.\n        show_header (bool, optional): Show a header row. Defaults to True.\n        show_footer (bool, optional): Show a footer row. Defaults to False.\n        show_edge (bool, optional): Draw a box around the outside of the table. Defaults to True.\n        show_lines (bool, optional): Draw lines between every row. Defaults to False.\n        leading (bool, optional): Number of blank lines between rows (precludes ``show_lines``). Defaults to 0.\n        style (Union[str, Style], optional): Default style for the table. Defaults to \"none\".\n        row_styles (List[Union, str], optional): Optional list of row styles, if more than one style is given then the styles will alternate. Defaults to None.\n        header_style (Union[str, Style], optional): Style of the header. Defaults to \"table.header\".\n        footer_style (Union[str, Style], optional): Style of the footer. Defaults to \"table.footer\".\n        border_style (Union[str, Style], optional): Style of the border. Defaults to None.\n        title_style (Union[str, Style], optional): Style of the title. Defaults to None.\n        caption_style (Union[str, Style], optional): Style of the caption. Defaults to None.\n        title_justify (str, optional): Justify method for title. Defaults to \"center\".\n        caption_justify (str, optional): Justify method for caption. Defaults to \"center\".\n        highlight (bool, optional): Highlight cell contents (if str). Defaults to False.\n    \"\"\"\n\n    columns: List[Column]\n    rows: List[Row]\n\n    def __init__(\n        self,\n        *headers: Union[Column, str],\n        title: Optional[TextType] = None,\n        caption: Optional[TextType] = None,\n        width: Optional[int] = None,\n        min_width: Optional[int] = None,\n        box: Optional[box.Box] = box.HEAVY_HEAD,\n        safe_box: Optional[bool] = None,\n        padding: PaddingDimensions = (0, 1),\n        collapse_padding: bool = False,\n        pad_edge: bool = True,\n        expand: bool = False,\n        show_header: bool = True,\n        show_footer: bool = False,\n        show_edge: bool = True,\n        show_lines: bool = False,\n        leading: int = 0,\n        style: StyleType = \"none\",\n        row_styles: Optional[Iterable[StyleType]] = None,\n        header_style: Optional[StyleType] = \"table.header\",\n        footer_style: Optional[StyleType] = \"table.footer\",\n        border_style: Optional[StyleType] = None,\n        title_style: Optional[StyleType] = None,\n        caption_style: Optional[StyleType] = None,\n        title_justify: \"JustifyMethod\" = \"center\",\n        caption_justify: \"JustifyMethod\" = \"center\",\n        highlight: bool = False,\n    ) -> None:\n\n        self.columns: List[Column] = []\n        self.rows: List[Row] = []\n        self.title = title\n        self.caption = caption\n        self.width = width\n        self.min_width = min_width\n        self.box = box\n        self.safe_box = safe_box\n        self._padding = Padding.unpack(padding)\n        self.pad_edge = pad_edge\n        self._expand = expand\n        self.show_header = show_header\n        self.show_footer = show_footer\n        self.show_edge = show_edge\n        self.show_lines = show_lines\n        self.leading = leading\n        self.collapse_padding = collapse_padding\n        self.style = style\n        self.header_style = header_style or \"\"\n        self.footer_style = footer_style or \"\"\n        self.border_style = border_style\n        self.title_style = title_style\n        self.caption_style = caption_style\n        self.title_justify: \"JustifyMethod\" = title_justify\n        self.caption_justify: \"JustifyMethod\" = caption_justify\n        self.highlight = highlight\n        self.row_styles: Sequence[StyleType] = list(row_styles or [])\n        append_column = self.columns.append\n        for header in headers:\n            if isinstance(header, str):\n                self.add_column(header=header)\n            else:\n                header._index = len(self.columns)\n                append_column(header)\n\n    @classmethod\n    def grid(\n        cls,\n        *headers: Union[Column, str],\n        padding: PaddingDimensions = 0,\n        collapse_padding: bool = True,\n        pad_edge: bool = False,\n        expand: bool = False,\n    ) -> \"Table\":\n        \"\"\"Get a table with no lines, headers, or footer.\n\n        Args:\n            *headers (Union[Column, str]): Column headers, either as a string, or :class:`~rich.table.Column` instance.\n            padding (PaddingDimensions, optional): Get padding around cells. Defaults to 0.\n            collapse_padding (bool, optional): Enable collapsing of padding around cells. Defaults to True.\n            pad_edge (bool, optional): Enable padding around edges of table. Defaults to False.\n            expand (bool, optional): Expand the table to fit the available space if ``True``, otherwise the table width will be auto-calculated. Defaults to False.\n\n        Returns:\n            Table: A table instance.\n        \"\"\"\n        return cls(\n            *headers,\n            box=None,\n            padding=padding,\n            collapse_padding=collapse_padding,\n            show_header=False,\n            show_footer=False,\n            show_edge=False,\n            pad_edge=pad_edge,\n            expand=expand,\n        )\n\n    @property\n    def expand(self) -> bool:\n        \"\"\"Setting a non-None self.width implies expand.\"\"\"\n        return self._expand or self.width is not None\n\n    @expand.setter\n    def expand(self, expand: bool) -> None:\n        \"\"\"Set expand.\"\"\"\n        self._expand = expand\n\n    @property\n    def _extra_width(self) -> int:\n        \"\"\"Get extra width to add to cell content.\"\"\"\n        width = 0\n        if self.box and self.show_edge:\n            width += 2\n        if self.box:\n            width += len(self.columns) - 1\n        return width\n\n    @property\n    def row_count(self) -> int:\n        \"\"\"Get the current number of rows.\"\"\"\n        return len(self.rows)\n\n    def get_row_style(self, console: \"Console\", index: int) -> StyleType:\n        \"\"\"Get the current row style.\"\"\"\n        style = Style.null()\n        if self.row_styles:\n            style += console.get_style(self.row_styles[index % len(self.row_styles)])\n        row_style = self.rows[index].style\n        if row_style is not None:\n            style += console.get_style(row_style)\n        return style\n\n    def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> Measurement:\n        max_width = options.max_width\n        if self.width is not None:\n            max_width = self.width\n        if max_width < 0:\n            return Measurement(0, 0)\n\n        extra_width = self._extra_width\n        max_width = sum(\n            self._calculate_column_widths(\n                console, options.update_width(max_width - extra_width)\n            )\n        )\n        _measure_column = self._measure_column\n\n        measurements = [\n            _measure_column(console, options.update_width(max_width), column)\n            for column in self.columns\n        ]\n        minimum_width = (\n            sum(measurement.minimum for measurement in measurements) + extra_width\n        )\n        maximum_width = (\n            sum(measurement.maximum for measurement in measurements) + extra_width\n            if (self.width is None)\n            else self.width\n        )\n        measurement = Measurement(minimum_width, maximum_width)\n        measurement = measurement.clamp(self.min_width)\n        return measurement\n\n    @property\n    def padding(self) -> Tuple[int, int, int, int]:\n        \"\"\"Get cell padding.\"\"\"\n        return self._padding\n\n    @padding.setter\n    def padding(self, padding: PaddingDimensions) -> \"Table\":\n        \"\"\"Set cell padding.\"\"\"\n        self._padding = Padding.unpack(padding)\n        return self\n\n    def add_column(\n        self,\n        header: \"RenderableType\" = \"\",\n        footer: \"RenderableType\" = \"\",\n        *,\n        header_style: Optional[StyleType] = None,\n        footer_style: Optional[StyleType] = None,\n        style: Optional[StyleType] = None,\n        justify: \"JustifyMethod\" = \"left\",\n        vertical: \"VerticalAlignMethod\" = \"top\",\n        overflow: \"OverflowMethod\" = \"ellipsis\",\n        width: Optional[int] = None,\n        min_width: Optional[int] = None,\n        max_width: Optional[int] = None,\n        ratio: Optional[int] = None,\n        no_wrap: bool = False,\n    ) -> None:\n        \"\"\"Add a column to the table.\n\n        Args:\n            header (RenderableType, optional): Text or renderable for the header.\n                Defaults to \"\".\n            footer (RenderableType, optional): Text or renderable for the footer.\n                Defaults to \"\".\n            header_style (Union[str, Style], optional): Style for the header, or None for default. Defaults to None.\n            footer_style (Union[str, Style], optional): Style for the footer, or None for default. Defaults to None.\n            style (Union[str, Style], optional): Style for the column cells, or None for default. Defaults to None.\n            justify (JustifyMethod, optional): Alignment for cells. Defaults to \"left\".\n            vertical (VerticalAlignMethod, optional): Vertical alignment, one of \"top\", \"middle\", or \"bottom\". Defaults to \"top\".\n            overflow (OverflowMethod): Overflow method: \"crop\", \"fold\", \"ellipsis\". Defaults to \"ellipsis\".\n            width (int, optional): Desired width of column in characters, or None to fit to contents. Defaults to None.\n            min_width (Optional[int], optional): Minimum width of column, or ``None`` for no minimum. Defaults to None.\n            max_width (Optional[int], optional): Maximum width of column, or ``None`` for no maximum. Defaults to None.\n            ratio (int, optional): Flexible ratio for the column (requires ``Table.expand`` or ``Table.width``). Defaults to None.\n            no_wrap (bool, optional): Set to ``True`` to disable wrapping of this column.\n        \"\"\"\n\n        column = Column(\n            _index=len(self.columns),\n            header=header,\n            footer=footer,\n            header_style=header_style or \"\",\n            footer_style=footer_style or \"\",\n            style=style or \"\",\n            justify=justify,\n            vertical=vertical,\n            overflow=overflow,\n            width=width,\n            min_width=min_width,\n            max_width=max_width,\n            ratio=ratio,\n            no_wrap=no_wrap,\n        )\n        self.columns.append(column)\n\n    def add_row(\n        self,\n        *renderables: Optional[\"RenderableType\"],\n        style: Optional[StyleType] = None,\n        end_section: bool = False,\n    ) -> None:\n        \"\"\"Add a row of renderables.\n\n        Args:\n            *renderables (None or renderable): Each cell in a row must be a renderable object (including str),\n                or ``None`` for a blank cell.\n            style (StyleType, optional): An optional style to apply to the entire row. Defaults to None.\n            end_section (bool, optional): End a section and draw a line. Defaults to False.\n\n        Raises:\n            errors.NotRenderableError: If you add something that can't be rendered.\n        \"\"\"\n\n        def add_cell(column: Column, renderable: \"RenderableType\") -> None:\n            column._cells.append(renderable)\n\n        cell_renderables: List[Optional[\"RenderableType\"]] = list(renderables)\n\n        columns = self.columns\n        if len(cell_renderables) < len(columns):\n            cell_renderables = [\n                *cell_renderables,\n                *[None] * (len(columns) - len(cell_renderables)),\n            ]\n        for index, renderable in enumerate(cell_renderables):\n            if index == len(columns):\n                column = Column(_index=index)\n                for _ in self.rows:\n                    add_cell(column, Text(\"\"))\n                self.columns.append(column)\n            else:\n                column = columns[index]\n            if renderable is None:\n                add_cell(column, \"\")\n            elif is_renderable(renderable):\n                add_cell(column, renderable)\n            else:\n                raise errors.NotRenderableError(\n                    f\"unable to render {type(renderable).__name__}; a string or other renderable object is required\"\n                )\n        self.rows.append(Row(style=style, end_section=end_section))\n\n    def add_section(self) -> None:\n        \"\"\"Add a new section (draw a line after current row).\"\"\"\n\n        if self.rows:\n            self.rows[-1].end_section = True\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n\n        if not self.columns:\n            yield Segment(\"\\n\")\n            return\n\n        max_width = options.max_width\n        if self.width is not None:\n            max_width = self.width\n\n        extra_width = self._extra_width\n        widths = self._calculate_column_widths(\n            console, options.update_width(max_width - extra_width)\n        )\n        table_width = sum(widths) + extra_width\n\n        render_options = options.update(\n            width=table_width, highlight=self.highlight, height=None\n        )\n\n        def render_annotation(\n            text: TextType, style: StyleType, justify: \"JustifyMethod\" = \"center\"\n        ) -> \"RenderResult\":\n            render_text = (\n                console.render_str(text, style=style, highlight=False)\n                if isinstance(text, str)\n                else text\n            )\n            return console.render(\n                render_text, options=render_options.update(justify=justify)\n            )\n\n        if self.title:\n            yield from render_annotation(\n                self.title,\n                style=Style.pick_first(self.title_style, \"table.title\"),\n                justify=self.title_justify,\n            )\n        yield from self._render(console, render_options, widths)\n        if self.caption:\n            yield from render_annotation(\n                self.caption,\n                style=Style.pick_first(self.caption_style, \"table.caption\"),\n                justify=self.caption_justify,\n            )\n\n    def _calculate_column_widths(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> List[int]:\n        \"\"\"Calculate the widths of each column, including padding, not including borders.\"\"\"\n        max_width = options.max_width\n        columns = self.columns\n        width_ranges = [\n            self._measure_column(console, options, column) for column in columns\n        ]\n        widths = [_range.maximum or 1 for _range in width_ranges]\n        get_padding_width = self._get_padding_width\n        extra_width = self._extra_width\n        if self.expand:\n            ratios = [col.ratio or 0 for col in columns if col.flexible]\n            if any(ratios):\n                fixed_widths = [\n                    0 if column.flexible else _range.maximum\n                    for _range, column in zip(width_ranges, columns)\n                ]\n                flex_minimum = [\n                    (column.width or 1) + get_padding_width(column._index)\n                    for column in columns\n                    if column.flexible\n                ]\n                flexible_width = max_width - sum(fixed_widths)\n                flex_widths = ratio_distribute(flexible_width, ratios, flex_minimum)\n                iter_flex_widths = iter(flex_widths)\n                for index, column in enumerate(columns):\n                    if column.flexible:\n                        widths[index] = fixed_widths[index] + next(iter_flex_widths)\n        table_width = sum(widths)\n\n        if table_width > max_width:\n            widths = self._collapse_widths(\n                widths,\n                [(column.width is None and not column.no_wrap) for column in columns],\n                max_width,\n            )\n            table_width = sum(widths)\n            # last resort, reduce columns evenly\n            if table_width > max_width:\n                excess_width = table_width - max_width\n                widths = ratio_reduce(excess_width, [1] * len(widths), widths, widths)\n                table_width = sum(widths)\n\n            width_ranges = [\n                self._measure_column(console, options.update_width(width), column)\n                for width, column in zip(widths, columns)\n            ]\n            widths = [_range.maximum or 0 for _range in width_ranges]\n\n        if (table_width < max_width and self.expand) or (\n            self.min_width is not None and table_width < (self.min_width - extra_width)\n        ):\n            _max_width = (\n                max_width\n                if self.min_width is None\n                else min(self.min_width - extra_width, max_width)\n            )\n            pad_widths = ratio_distribute(_max_width - table_width, widths)\n            widths = [_width + pad for _width, pad in zip(widths, pad_widths)]\n\n        return widths\n\n    @classmethod\n    def _collapse_widths(\n        cls, widths: List[int], wrapable: List[bool], max_width: int\n    ) -> List[int]:\n        \"\"\"Reduce widths so that the total is under max_width.\n\n        Args:\n            widths (List[int]): List of widths.\n            wrapable (List[bool]): List of booleans that indicate if a column may shrink.\n            max_width (int): Maximum width to reduce to.\n\n        Returns:\n            List[int]: A new list of widths.\n        \"\"\"\n        total_width = sum(widths)\n        excess_width = total_width - max_width\n        if any(wrapable):\n            while total_width and excess_width > 0:\n                max_column = max(\n                    width for width, allow_wrap in zip(widths, wrapable) if allow_wrap\n                )\n                second_max_column = max(\n                    width if allow_wrap and width != max_column else 0\n                    for width, allow_wrap in zip(widths, wrapable)\n                )\n                column_difference = max_column - second_max_column\n                ratios = [\n                    (1 if (width == max_column and allow_wrap) else 0)\n                    for width, allow_wrap in zip(widths, wrapable)\n                ]\n                if not any(ratios) or not column_difference:\n                    break\n                max_reduce = [min(excess_width, column_difference)] * len(widths)\n                widths = ratio_reduce(excess_width, ratios, max_reduce, widths)\n\n                total_width = sum(widths)\n                excess_width = total_width - max_width\n        return widths\n\n    def _get_cells(\n        self, console: \"Console\", column_index: int, column: Column\n    ) -> Iterable[_Cell]:\n        \"\"\"Get all the cells with padding and optional header.\"\"\"\n\n        collapse_padding = self.collapse_padding\n        pad_edge = self.pad_edge\n        padding = self.padding\n        any_padding = any(padding)\n\n        first_column = column_index == 0\n        last_column = column_index == len(self.columns) - 1\n\n        _padding_cache: Dict[Tuple[bool, bool], Tuple[int, int, int, int]] = {}\n\n        def get_padding(first_row: bool, last_row: bool) -> Tuple[int, int, int, int]:\n            cached = _padding_cache.get((first_row, last_row))\n            if cached:\n                return cached\n            top, right, bottom, left = padding\n\n            if collapse_padding:\n                if not first_column:\n                    left = max(0, left - right)\n                if not last_row:\n                    bottom = max(0, top - bottom)\n\n            if not pad_edge:\n                if first_column:\n                    left = 0\n                if last_column:\n                    right = 0\n                if first_row:\n                    top = 0\n                if last_row:\n                    bottom = 0\n            _padding = (top, right, bottom, left)\n            _padding_cache[(first_row, last_row)] = _padding\n            return _padding\n\n        raw_cells: List[Tuple[StyleType, \"RenderableType\"]] = []\n        _append = raw_cells.append\n        get_style = console.get_style\n        if self.show_header:\n            header_style = get_style(self.header_style or \"\") + get_style(\n                column.header_style\n            )\n            _append((header_style, column.header))\n        cell_style = get_style(column.style or \"\")\n        for cell in column.cells:\n            _append((cell_style, cell))\n        if self.show_footer:\n            footer_style = get_style(self.footer_style or \"\") + get_style(\n                column.footer_style\n            )\n            _append((footer_style, column.footer))\n\n        if any_padding:\n            _Padding = Padding\n            for first, last, (style, renderable) in loop_first_last(raw_cells):\n                yield _Cell(\n                    style,\n                    _Padding(renderable, get_padding(first, last)),\n                    getattr(renderable, \"vertical\", None) or column.vertical,\n                )\n        else:\n            for (style, renderable) in raw_cells:\n                yield _Cell(\n                    style,\n                    renderable,\n                    getattr(renderable, \"vertical\", None) or column.vertical,\n                )\n\n    def _get_padding_width(self, column_index: int) -> int:\n        \"\"\"Get extra width from padding.\"\"\"\n        _, pad_right, _, pad_left = self.padding\n        if self.collapse_padding:\n            if column_index > 0:\n                pad_left = max(0, pad_left - pad_right)\n        return pad_left + pad_right\n\n    def _measure_column(\n        self,\n        console: \"Console\",\n        options: \"ConsoleOptions\",\n        column: Column,\n    ) -> Measurement:\n        \"\"\"Get the minimum and maximum width of the column.\"\"\"\n\n        max_width = options.max_width\n        if max_width < 1:\n            return Measurement(0, 0)\n\n        padding_width = self._get_padding_width(column._index)\n\n        if column.width is not None:\n            # Fixed width column\n            return Measurement(\n                column.width + padding_width, column.width + padding_width\n            ).with_maximum(max_width)\n        # Flexible column, we need to measure contents\n        min_widths: List[int] = []\n        max_widths: List[int] = []\n        append_min = min_widths.append\n        append_max = max_widths.append\n        get_render_width = Measurement.get\n        for cell in self._get_cells(console, column._index, column):\n            _min, _max = get_render_width(console, options, cell.renderable)\n            append_min(_min)\n            append_max(_max)\n\n        measurement = Measurement(\n            max(min_widths) if min_widths else 1,\n            max(max_widths) if max_widths else max_width,\n        ).with_maximum(max_width)\n        measurement = measurement.clamp(\n            None if column.min_width is None else column.min_width + padding_width,\n            None if column.max_width is None else column.max_width + padding_width,\n        )\n        return measurement\n\n    def _render(\n        self, console: \"Console\", options: \"ConsoleOptions\", widths: List[int]\n    ) -> \"RenderResult\":\n        table_style = console.get_style(self.style or \"\")\n\n        border_style = table_style + console.get_style(self.border_style or \"\")\n        _column_cells = (\n            self._get_cells(console, column_index, column)\n            for column_index, column in enumerate(self.columns)\n        )\n        row_cells: List[Tuple[_Cell, ...]] = list(zip(*_column_cells))\n        _box = (\n            self.box.substitute(\n                options, safe=pick_bool(self.safe_box, console.safe_box)\n            )\n            if self.box\n            else None\n        )\n        _box = _box.get_plain_headed_box() if _box and not self.show_header else _box\n\n        new_line = Segment.line()\n\n        columns = self.columns\n        show_header = self.show_header\n        show_footer = self.show_footer\n        show_edge = self.show_edge\n        show_lines = self.show_lines\n        leading = self.leading\n\n        _Segment = Segment\n        if _box:\n            box_segments = [\n                (\n                    _Segment(_box.head_left, border_style),\n                    _Segment(_box.head_right, border_style),\n                    _Segment(_box.head_vertical, border_style),\n                ),\n                (\n                    _Segment(_box.foot_left, border_style),\n                    _Segment(_box.foot_right, border_style),\n                    _Segment(_box.foot_vertical, border_style),\n                ),\n                (\n                    _Segment(_box.mid_left, border_style),\n                    _Segment(_box.mid_right, border_style),\n                    _Segment(_box.mid_vertical, border_style),\n                ),\n            ]\n            if show_edge:\n                yield _Segment(_box.get_top(widths), border_style)\n                yield new_line\n        else:\n            box_segments = []\n\n        get_row_style = self.get_row_style\n        get_style = console.get_style\n\n        for index, (first, last, row_cell) in enumerate(loop_first_last(row_cells)):\n            header_row = first and show_header\n            footer_row = last and show_footer\n            row = (\n                self.rows[index - show_header]\n                if (not header_row and not footer_row)\n                else None\n            )\n            max_height = 1\n            cells: List[List[List[Segment]]] = []\n            if header_row or footer_row:\n                row_style = Style.null()\n            else:\n                row_style = get_style(\n                    get_row_style(console, index - 1 if show_header else index)\n                )\n            for width, cell, column in zip(widths, row_cell, columns):\n                render_options = options.update(\n                    width=width,\n                    justify=column.justify,\n                    no_wrap=column.no_wrap,\n                    overflow=column.overflow,\n                    height=None,\n                )\n                lines = console.render_lines(\n                    cell.renderable,\n                    render_options,\n                    style=get_style(cell.style) + row_style,\n                )\n                max_height = max(max_height, len(lines))\n                cells.append(lines)\n\n            row_height = max(len(cell) for cell in cells)\n\n            def align_cell(\n                cell: List[List[Segment]],\n                vertical: \"VerticalAlignMethod\",\n                width: int,\n                style: Style,\n            ) -> List[List[Segment]]:\n                if header_row:\n                    vertical = \"bottom\"\n                elif footer_row:\n                    vertical = \"top\"\n\n                if vertical == \"top\":\n                    return _Segment.align_top(cell, width, row_height, style)\n                elif vertical == \"middle\":\n                    return _Segment.align_middle(cell, width, row_height, style)\n                return _Segment.align_bottom(cell, width, row_height, style)\n\n            cells[:] = [\n                _Segment.set_shape(\n                    align_cell(\n                        cell,\n                        _cell.vertical,\n                        width,\n                        get_style(_cell.style) + row_style,\n                    ),\n                    width,\n                    max_height,\n                )\n                for width, _cell, cell, column in zip(widths, row_cell, cells, columns)\n            ]\n\n            if _box:\n                if last and show_footer:\n                    yield _Segment(\n                        _box.get_row(widths, \"foot\", edge=show_edge), border_style\n                    )\n                    yield new_line\n                left, right, _divider = box_segments[0 if first else (2 if last else 1)]\n\n                # If the column divider is whitespace also style it with the row background\n                divider = (\n                    _divider\n                    if _divider.text.strip()\n                    else _Segment(\n                        _divider.text, row_style.background_style + _divider.style\n                    )\n                )\n                for line_no in range(max_height):\n                    if show_edge:\n                        yield left\n                    for last_cell, rendered_cell in loop_last(cells):\n                        yield from rendered_cell[line_no]\n                        if not last_cell:\n                            yield divider\n                    if show_edge:\n                        yield right\n                    yield new_line\n            else:\n                for line_no in range(max_height):\n                    for rendered_cell in cells:\n                        yield from rendered_cell[line_no]\n                    yield new_line\n            if _box and first and show_header:\n                yield _Segment(\n                    _box.get_row(widths, \"head\", edge=show_edge), border_style\n                )\n                yield new_line\n            end_section = row and row.end_section\n            if _box and (show_lines or leading or end_section):\n                if (\n                    not last\n                    and not (show_footer and index >= len(row_cells) - 2)\n                    and not (show_header and header_row)\n                ):\n                    if leading:\n                        yield _Segment(\n                            _box.get_row(widths, \"mid\", edge=show_edge) * leading,\n                            border_style,\n                        )\n                    else:\n                        yield _Segment(\n                            _box.get_row(widths, \"row\", edge=show_edge), border_style\n                        )\n                    yield new_line\n\n        if _box and show_edge:\n            yield _Segment(_box.get_bottom(widths), border_style)\n            yield new_line\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    from pip._vendor.rich.console import Console\n    from pip._vendor.rich.highlighter import ReprHighlighter\n    from pip._vendor.rich.table import Table as Table\n\n    from ._timer import timer\n\n    with timer(\"Table render\"):\n        table = Table(\n            title=\"Star Wars Movies\",\n            caption=\"Rich example table\",\n            caption_justify=\"right\",\n        )\n\n        table.add_column(\n            \"Released\", header_style=\"bright_cyan\", style=\"cyan\", no_wrap=True\n        )\n        table.add_column(\"Title\", style=\"magenta\")\n        table.add_column(\"Box Office\", justify=\"right\", style=\"green\")\n\n        table.add_row(\n            \"Dec 20, 2019\",\n            \"Star Wars: The Rise of Skywalker\",\n            \"$952,110,690\",\n        )\n        table.add_row(\"May 25, 2018\", \"Solo: A Star Wars Story\", \"$393,151,347\")\n        table.add_row(\n            \"Dec 15, 2017\",\n            \"Star Wars Ep. V111: The Last Jedi\",\n            \"$1,332,539,889\",\n            style=\"on black\",\n            end_section=True,\n        )\n        table.add_row(\n            \"Dec 16, 2016\",\n            \"Rogue One: A Star Wars Story\",\n            \"$1,332,439,889\",\n        )\n\n        def header(text: str) -> None:\n            console.print()\n            console.rule(highlight(text))\n            console.print()\n\n        console = Console()\n        highlight = ReprHighlighter()\n        header(\"Example Table\")\n        console.print(table, justify=\"center\")\n\n        table.expand = True\n        header(\"expand=True\")\n        console.print(table)\n\n        table.width = 50\n        header(\"width=50\")\n\n        console.print(table, justify=\"center\")\n\n        table.width = None\n        table.expand = False\n        table.row_styles = [\"dim\", \"none\"]\n        header(\"row_styles=['dim', 'none']\")\n\n        console.print(table, justify=\"center\")\n\n        table.width = None\n        table.expand = False\n        table.row_styles = [\"dim\", \"none\"]\n        table.leading = 1\n        header(\"leading=1, row_styles=['dim', 'none']\")\n        console.print(table, justify=\"center\")\n\n        table.width = None\n        table.expand = False\n        table.row_styles = [\"dim\", \"none\"]\n        table.show_lines = True\n        table.leading = 0\n        header(\"show_lines=True, row_styles=['dim', 'none']\")\n        console.print(table, justify=\"center\")\n"},"hash":"p15etlicC0"}